/* Generated code for Python source for module 'codegen.Contexts'
 * created by Nuitka version 0.5.31
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_codegen$Contexts is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_codegen$Contexts;
PyDictObject *moduledict_codegen$Contexts;

/* The module constants used, if any. */
static PyObject *const_str_digest_9e9622c7c86655267970050134c8b362;
static PyObject *const_str_digest_948f61cf32e45d9aca768fd3a5bfde91;
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain___del__;
extern PyObject *const_str_plain___name__;
extern PyObject *const_tuple_str_plain_self_str_plain_key_tuple;
extern PyObject *const_str_plain_getIntResName;
extern PyObject *const_str_plain_sorted;
extern PyObject *const_str_plain_constants;
extern PyObject *const_dict_empty;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_object;
static PyObject *const_str_plain_constant_use_count;
static PyObject *const_str_plain_setFrameGuardMode;
static PyObject *const_str_digest_3b43b7bb5d11bed0890d96709e396529;
extern PyObject *const_str_plain_bool;
static PyObject *const_str_plain_TempMixin;
static PyObject *const_str_digest_13bac17eda8963a56732e7b8e7f99340;
extern PyObject *const_str_angle_listcontraction;
extern PyObject *const_str_plain_encode;
static PyObject *const_str_digest_7557da68ac75e5b5557ba5ebbd1a40b4;
static PyObject *const_tuple_str_plain_result_str_plain_bool_tuple;
extern PyObject *const_str_plain_getPythonFlags;
static PyObject *const_str_digest_a0fb262c13dfb27f8fb32ef7135876e8;
static PyObject *const_tuple_str_plain_ReturnValueNameMixin_tuple_type_object_tuple_tuple;
static PyObject *const_str_digest_4ad35e0f2a19fb140fd91ad3f29da348;
extern PyObject *const_str_plain_getFrameVariableTypeDescriptionName;
extern PyObject *const_str_plain_None;
extern PyObject *const_str_plain_end;
static PyObject *const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_base_name_tuple;
static PyObject *const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple;
static PyObject *const_str_digest_6d071d3109a8060fb2a971391a41d604;
extern PyObject *const_str_plain_Options;
extern PyObject *const_str_plain_PythonFunctionDirectContext;
extern PyObject *const_str_plain_const_;
static PyObject *const_str_digest_520108655c15407c4a5f87230dc28f7c;
static PyObject *const_str_digest_4d4ad1d66c590948f14a486c230c1682;
extern PyObject *const_str_plain_addCleanupTempName;
static PyObject *const_str_digest_a4094bb766fe1066b2a681c4d9db5b2b;
extern PyObject *const_str_plain_repr;
extern PyObject *const_str_plain_isLocalVariable;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_digest_30c918915243af4a313afc42bd3579fb;
static PyObject *const_str_digest_c61cd5e57bbff781c7524c02fd1b3960;
static PyObject *const_str_digest_19b9cf24c12d3558fddc95d1485a0f2e;
static PyObject *const_str_digest_a84eb8c4cf19a2079f3a5e6014ab3c4d;
extern PyObject *const_str_plain_false_target;
static PyObject *const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain_str;
extern PyObject *const_tuple_none_none_none_none_tuple;
extern PyObject *const_str_plain_getOwner;
static PyObject *const_str_digest_d3171e1be7daa27a0a9a18c82d0cadf6;
extern PyObject *const_str_plain_PythonCoroutineObjectContext;
extern PyObject *const_str_plain_hexdigest;
extern PyObject *const_str_plain_throw;
extern PyObject *const_str_plain___setattr__;
extern PyObject *const_str_plain_getReturnValueName;
extern PyObject *const_str_plain_hashlib;
static PyObject *const_str_digest_22dcf374b1775b5a2a7cb67abb10c1a8;
static PyObject *const_str_digest_b05f079ee69fdf65b9326bf63aac023f;
static PyObject *const_str_plain__calcHash;
extern PyObject *const_str_plain_bytearray;
static PyObject *const_str_digest_c82c62837868c10d2b20ff2c8d4c12cc;
static PyObject *const_str_digest_54e9e6535450bc1ab4b1290b4ca34a3d;
extern PyObject *const_str_plain_hasTempName;
static PyObject *const_str_digest_1fdbba2cfe613b198992c1895f52f6fb;
extern PyObject *const_str_digest_0bee88bea05a6d16838bce17fe2050b5;
static PyObject *const_str_digest_ee5d8bbbb96421bce0814b04537f4e5e;
static PyObject *const_str_digest_23fe9b1819b59de888106e5ab17356ef;
static PyObject *const_str_digest_87af14270b7513eece71f3edf77cf5ff;
static PyObject *const_tuple_str_plain_ReturnReleaseModeMixin_tuple_type_object_tuple_tuple;
static PyObject *const_str_digest_407dc23619580f584d7efe59a675c107;
extern PyObject *const_str_plain_setLoopContinueTarget;
extern PyObject *const_tuple_str_dot_tuple;
extern PyObject *const_str_plain_PythonFunctionCreatedContext;
extern PyObject *const_str_plain_getExceptionKeeperVariables;
static PyObject *const_str_digest_e9b6d0895f57833457cbf9ab51367bb8;
extern PyObject *const_str_plain___loader__;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_6ad77fd10d0c3b52171d2c1538e49ff8;
extern PyObject *const_str_plain_getReturnReleaseMode;
extern PyObject *const_str_plain_getArgumentCount;
static PyObject *const_str_digest_bceddc19e3682969185c76cf95bc10d9;
static PyObject *const_str_plain_hash_value;
static PyObject *const_str_digest_a49b3c30821d06d66b6b814c5228652e;
static PyObject *const_str_digest_9600a801bc9b6cd2b42e5aa9695c1a43;
static PyObject *const_str_plain_Py_Ellipsis;
static PyObject *const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
extern PyObject *const_str_plain_isForCreatedFunction;
static PyObject *const_str_digest_5b977a8a3b26c127088d2ea95bff3dea;
extern PyObject *const_int_pos_270;
static PyObject *const_str_plain_last_source_ref;
static PyObject *const_str_digest_8d018b496b63fe3ca6c82d304f622d94;
static PyObject *const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple;
static PyObject *const_tuple_str_plain_throw_str_plain_close_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_count_tuple;
extern PyObject *const_str_plain_False;
extern PyObject *const_str_plain_getLineNumber;
extern PyObject *const_str_plain_frozenset;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
static PyObject *const_str_plain_forgotten_names;
extern PyObject *const_str_plain_code_object;
extern PyObject *const_str_plain_popCleanupScope;
static PyObject *const_str_plain_frame_variables_stack;
static PyObject *const_tuple_str_plain_self_str_plain_keeper_vars_tuple;
static PyObject *const_str_digest_c70c81be0ee8686f88d0465dd01790d6;
extern PyObject *const_str_plain_PythonAsyncgenObjectContext;
extern PyObject *const_str_plain_mayRecurse;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_code;
static PyObject *const_str_digest_3be2622e090e0211db0e458055823ae8;
static PyObject *const_str_plain_ContextMetaClass;
extern PyObject *const_int_pos_340;
static PyObject *const_str_digest_30b0a365467fd86233ade42cedd7d4ef;
static PyObject *const_str_digest_64d2764f4789876e822950a3b60de617;
static PyObject *const_str_digest_885c88d4b9dcdc5ab5abe136b5e59ae4;
extern PyObject *const_list_str_empty_list;
static PyObject *const_str_digest_540034c844a611d69b7ba61d2b242481;
extern PyObject *const_tuple_str_plain_long_tuple;
extern PyObject *const_str_plain_isExpressionClassBody;
static PyObject *const_str_digest_e1ef4009c46be20ee12b49bd6fda02bf;
static PyObject *const_str_digest_ea30090a2dc6215e4003e6d4e0471dd2;
extern PyObject *const_str_plain_needsExceptionVariables;
extern PyObject *const_str_plain_shallMakeModule;
static PyObject *const_str_plain_ReturnValueNameMixin;
static PyObject *const_str_digest_2f4dfc429de3c23f0195ef78ce774a4d;
extern PyObject *const_str_plain_type;
extern PyObject *const_str_plain_getLoopContinueTarget;
static PyObject *const_str_digest_802fc6c27e355cb87c4659dfc7643939;
extern PyObject *const_str_plain_getTrueBranchTarget;
extern PyObject *const_str_plain_isForDirectCall;
static PyObject *const_str_digest_45513e6ef9428f471b9854b48b23e391;
static PyObject *const_str_digest_ff09dec21711a14ba972c5c09dc0b08d;
extern PyObject *const_str_plain_class;
static PyObject *const_str_digest_52f1ee247aa393ed2fd9ff32d9fe5948;
extern PyObject *const_str_plain___cached__;
static PyObject *const_str_digest_7ac96968a40e4b5f6dac1f4c9846a3ae;
static PyObject *const_str_plain__getConstantDefaultPopulation;
static PyObject *const_str_digest_6227df33b96fb24225f8e850bc7d5c6c;
extern PyObject *const_str_plain_basestring;
static PyObject *const_str_digest_e03d67f5a64017c14f12c063df2c2f06;
static PyObject *const_str_digest_391e3f0d62b69d6a83d92e9ff1a571c6;
static PyObject *const_tuple_str_plain_self_str_plain_locals_dict_name_tuple;
static PyObject *const_str_digest_15890cf826b7d30c52521be71e7a7eb9;
extern PyObject *const_str_plain_source_ref;
static PyObject *const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple;
extern PyObject *const_str_plain_iterItems;
extern PyObject *const_str_plain_PythonGlobalContext;
static PyObject *const_str_plain_Py_True;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_getName;
extern PyObject *const_str_plain_module_name;
static PyObject *const_str_plain_variable_code_type;
static PyObject *const_str_digest_31d729e30f99251b4a1e18bea892374b;
static PyObject *const_str_digest_527ad68d726ffc2da2a6cfbd7aa23f42;
static PyObject *const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple;
static PyObject *const_str_digest_f3486d138092511205b103bca2ec7e88;
extern PyObject *const_str_plain_exc_value;
static PyObject *const_str_plain_return_release_mode;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_str_digest_a7fb2ee40d1e8754e1b199d0a66ddbc5;
extern PyObject *const_str_plain_markAsNeedsExceptionVariables;
static PyObject *const_str_digest_c22317b266ff5904776f5a58e1b9d77d;
extern PyObject *const_str_plain_getLabelCount;
static PyObject *const_str_digest_83dbc6b4579376d5626364525918dafb;
extern PyObject *const_str_plain___repr__;
static PyObject *const_str_digest_b682238f4a2007d1b13f98b0fdc5e1e3;
extern PyObject *const_str_plain_getHelperCodes;
extern PyObject *const_str_plain_getConstants;
extern PyObject *const_str_plain_getTempNameInfos;
static PyObject *const_str_digest_8543c958c8b71f8e133f9a2beb608bc0;
extern PyObject *const_str_plain_module;
extern PyObject *const_str_plain_getCurrentSourceCodeReference;
extern PyObject *const_str_plain_pushFrameVariables;
static PyObject *const_str_digest_089ed70ff710455be48c44c3e522dd31;
extern PyObject *const_str_plain_format;
static PyObject *const_str_digest_7f0e64884a17d062eb6c8fc5669b4e09;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_digest_8b43f078b192122dc45357ec9f7330da;
extern PyObject *const_str_digest_534defdde7328da4dd3495117f2acbaf;
static PyObject *const_str_digest_ca2d7dd6ed477bea25e0137f135c1964;
static PyObject *const_str_digest_529a8ebf30aa338f0b011c2f8d4aab0b;
static PyObject *const_str_digest_125f5277815f5b7d7e6feb17e062156d;
static PyObject *const_str_digest_ed69aa0bd5f577c19c3d0949f3e75d39;
extern PyObject *const_str_plain_Builtins;
static PyObject *const_tuple_str_plain_xrange_tuple;
static PyObject *const_str_digest_e2fbdb696fac361cce9168658dbd2fc0;
extern PyObject *const_str_plain_allocateExceptionKeeperVariables;
static PyObject *const_str_plain_function_exception_exit;
static PyObject *const_str_digest_579f388010d12808b3eae0ac3161d269;
static PyObject *const_str_digest_1756d814b178aaae17abac3163d1a7e0;
static PyObject *const_str_digest_c9f53fea3b1b946fc6f9ff2a3b44affd;
extern PyObject *const_tuple_str_plain_result_tuple;
static PyObject *const_str_digest_ef8f2e417acf45e2ce4f92f1b6f7c606;
extern PyObject *const_str_plain_string;
extern PyObject *const_str_plain_getBody;
extern PyObject *const_str_plain___file__;
static PyObject *const_tuple_str_plain_CodeObjectsMixin_tuple_type_object_tuple_tuple;
static PyObject *const_str_digest_9f94c79a242f7988d834ffc98aa9eeb0;
static PyObject *const_str_digest_4294787ad1c872e007fe67a2ec41f784;
static PyObject *const_str_digest_1a6a0e81cf296c4b8867d45a8b58b1d3;
static PyObject *const_str_digest_0a9b4312244332263552dac3b72c914a;
extern PyObject *const_str_plain_site;
static PyObject *const_str_digest_2fed9bd860ef22890aae00273ef8b1e9;
static PyObject *const_tuple_str_plain_tmp_unused__tuple;
extern PyObject *const_str_plain_getExceptionPreserverCounts;
static PyObject *const_str_plain_exception_escape;
extern PyObject *const_str_plain_getContextObjectName;
extern PyObject *const_str_digest_fd57353dc0a31a7daca8fb2ea030dee2;
static PyObject *const_str_digest_e7002c0ee8e5bbb559c41cccff652c68;
static PyObject *const_tuple_str_plain_namifyConstant_tuple;
extern PyObject *const_str_plain_counted_del;
static PyObject *const_str_digest_7092502eed67780baa4aed0d913d2d89;
static PyObject *const_str_digest_3b82b1dd4c55cea38706e783ea34e248;
static PyObject *const_str_plain_PythonFunctionContext;
static PyObject *const_tuple_str_plain_self_str_plain_guard_mode_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_code_object_tuple;
static PyObject *const_str_digest_2b3e70ac3e1ab3c1f0f382782169dcd9;
static PyObject *const_str_digest_bb940c7f0f9217bc32eb90e6a338a738;
extern PyObject *const_str_plain_Py_None;
static PyObject *const_str_digest_f970dec118dd032743ada440a4958864;
static PyObject *const_str_digest_b1b67715452f238441f19f172aeedfdd;
extern PyObject *const_str_plain_close;
static PyObject *const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple;
extern PyObject *const_int_pos_300;
static PyObject *const_str_plain_frame_variables;
static PyObject *const_str_digest_003e4a56d94b5e8606e65634d347a2ac;
static PyObject *const_str_digest_77d01c4e03e31b15053cbf356c56c5d3;
static PyObject *const_str_digest_747061db3f940444cb7e968024b55240;
extern PyObject *const_str_plain___qualname__;
extern PyObject *const_str_plain_long;
static PyObject *const_str_digest_94d8409ce4a107d22339dc4807c738ed;
extern PyObject *const_str_plain_getKwOnlyParameterCount;
static PyObject *const_str_digest_aa8ecf91a23ffc01605bd0dbabd23bf4;
static PyObject *const_str_digest_8b7296b8019bbdff3203b98f7065cc32;
static PyObject *const_str_digest_10f90d9735fc507eae60ede4611ac1d5;
extern PyObject *const_str_plain_value;
static PyObject *const_str_digest_aeff4a5a9b47578a597233dc0f53d668;
static PyObject *const_str_plain_isForCrossModuleUsage;
extern PyObject *const_str_plain_popFrameHandle;
static PyObject *const_str_plain_PythonChildContextBase;
extern PyObject *const_str_plain_addFrameDeclaration;
static PyObject *const_str_digest_1bc5a106f93df28e7cb280601af927e9;
static PyObject *const_tuple_str_plain_function_return_exit_tuple;
static PyObject *const_str_digest_ab07390ab07a9b5d7f2fc01935b20975;
extern PyObject *const_str_plain_exc_type;
static PyObject *const_str_digest_e50eac13be8c283248b1730bf779a98d;
extern PyObject *const_str_plain_generator;
extern PyObject *const_str_plain_enumerate;
static PyObject *const_tuple_str_plain_NULL_str_plain_N_tuple;
static PyObject *const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple;
static PyObject *const_str_digest_cfe6611d3194e04523d0733e7593071e;
extern PyObject *const_str_plain_getBoolResName;
extern PyObject *const_str_plain_setReturnTarget;
extern PyObject *const_str_plain_once;
extern PyObject *const_str_plain_addDeclaration;
static PyObject *const_str_digest_fb9fc685100d5e403d5f70d0b394c80c;
extern PyObject *const_str_plain_labels;
extern PyObject *const_str_plain_getFilename;
static PyObject *const_tuple_str_plain_self_str_plain_frame_decl_tuple;
static PyObject *const_str_digest_294c218899092afd28db1da9d9795129;
static PyObject *const_str_plain_frame_stack;
static PyObject *const_str_plain_Py_False;
static PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple;
static PyObject *const_str_digest_312280c60bdc0537d21c15fc13a6ee1b;
static PyObject *const_str_digest_694c746215c69a034048b506a36cf7bf;
extern PyObject *const_str_plain_getCleanupTempnames;
static PyObject *const_str_digest_32fd3375c92eca260cdd6ad686088f06;
extern PyObject *const_tuple_str_plain_ABCMeta_str_plain_abstractmethod_tuple;
extern PyObject *const_str_plain_iter;
static PyObject *const_str_digest_7f297503a366843318e0255757663358;
extern PyObject *const_str_plain_isUsed;
extern PyObject *const_str_plain_memoryview;
extern PyObject *const_str_plain_frame_handle;
extern PyObject *const_str_plain___delattr__;
extern PyObject *const_str_plain_getCodeObjectName;
static PyObject *const_str_digest_cfe69f84a1d3c34e08be1062e3949702;
static PyObject *const_str_digest_b8f914007454fc95cbbaf34232adac0a;
extern PyObject *const_str_plain_hasHelperCode;
extern PyObject *const_str_plain_ABCMeta;
static PyObject *const_str_digest_fb36bd46add94916696032032156928f;
static PyObject *const_str_plain_frame_variable_types;
static PyObject *const_str_plain_tmp_types;
static PyObject *const_str_digest_2cdb9fd17a48e31dd84ef597bf3b2f00;
static PyObject *const_str_plain_loop_continue;
static PyObject *const_str_digest_f69f05a54a53082c0c4af4066da595fb;
static PyObject *const_str_digest_4f1b43ee1083d2d091afaee9410359a2;
extern PyObject *const_str_plain_getFrameHandle;
static PyObject *const_str_digest_5bc885749965f660b02bd91c96e09784;
static PyObject *const_str_digest_1aaf40f2b11d352f255716a514436f34;
static PyObject *const_str_digest_86e31d797d4f791dbea48e73dc686425;
static PyObject *const_str_digest_ed3da1d877103f471e67483c8b8f3267;
static PyObject *const_str_digest_ebe63b9b9d5ee0fb95a863e8a24bec5d;
static PyObject *const_str_digest_e8661d65ca161cb98d2f99c4e6dd1cf2;
extern PyObject *const_str_plain___main__;
extern PyObject *const_str_plain_addHelperCode;
extern PyObject *const_str_plain_getLocalsDictNames;
static PyObject *const_str_plain_exception_keepers;
static PyObject *const_str_digest_a0e70fff63384bf33577c66143d20c55;
static PyObject *const_str_digest_36a950e7e63a9795ac03e8984bd01677;
static PyObject *const_str_plain_current_source_ref;
static PyObject *const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple;
static PyObject *const_str_plain_keeper_variable_count;
extern PyObject *const_str_plain_return_value;
extern PyObject *const_str_plain_popFrameVariables;
extern PyObject *const_str_plain_sys;
extern PyObject *const_str_plain_counted_init;
static PyObject *const_str_digest_de6b1851ed9396300170bea9bd415e26;
extern PyObject *const_str_plain_PythonGeneratorObjectContext;
static PyObject *const_str_plain_frames_used;
extern PyObject *const_str_plain_range;
static PyObject *const_str_digest_a2b1038979e363452b40a33002fa30b8;
static PyObject *const_str_plain_frame_decl;
static PyObject *const_str_digest_26f09ed9652d19fa65c7c2f38edc645f;
static PyObject *const_str_digest_ad2f34e8e6f884bf5dc463a64a2860ac;
extern PyObject *const_int_pos_350;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain_getConstantCode;
static PyObject *const_str_digest_fc7b837d9b6460c92a7a6b96b8c0c67d;
extern PyObject *const_str_plain_setVariableType;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_types;
static PyObject *const_str_digest_912b4b1c7307c539a82a691f606660f5;
extern PyObject *const_str_plain_countConstantUse;
extern PyObject *const_str_plain_setFalseBranchTarget;
extern PyObject *const_str_plain_md5;
static PyObject *const_str_digest_bfa5790306fd6f4a7e7d764daae9c3d5;
static PyObject *const_str_digest_bbc23540b36b5266f6535cbbe7b3e01d;
extern PyObject *const_str_plain_generator_return;
extern PyObject *const_str_plain_getFlagHasClosureValue;
extern PyObject *const_str_plain_pushCleanupScope;
extern PyObject *const_str_plain_constant;
extern PyObject *const_str_empty;
static PyObject *const_str_digest_b64dbcae04a9beb7ea31b9fc66d1944e;
extern PyObject *const_str_plain_python_version;
static PyObject *const_tuple_60536d512e7395e2cfe11459ddd28893_tuple;
extern PyObject *const_tuple_str_plain_i_tuple;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_result_tuple;
extern PyObject *const_str_plain_result;
static PyObject *const_str_digest_40aee10a90964f455d9ea1ff7aac6117;
static PyObject *const_str_digest_b15c2d9cc14aa119965733d8bffb6657;
extern PyObject *const_str_plain_mayRaiseException;
static PyObject *const_str_digest_da55172e86e697e30db1acc837d8ae44;
extern PyObject *const_tuple_str_plain___main___tuple;
static PyObject *const_list_6f2f6b405ec0ec1cb9c5e98a4eadddb0_list;
extern PyObject *const_str_plain_abc;
static PyObject *const_str_digest_8f6d1ed1333c2b8e5ed75ae3469272bc;
static PyObject *const_str_digest_6377357bbc333a753ef615877cb70488;
extern PyObject *const_str_plain_bytes;
static PyObject *const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple;
static PyObject *const_str_digest_1fa86cd2988d8c8a3034058c84b34c7c;
static PyObject *const_str_digest_f93c4804b3e85fff716e142bad8c063f;
static PyObject *const_str_digest_a200173c4121e0bca2f471f7b42614e9;
static PyObject *const_str_digest_36e53050e5752dd8dad8ca08da219dfc;
static PyObject *const_str_digest_b1e60ea9ee7c3a8a50cd2755a17a5fe8;
static PyObject *const_str_digest_ab9b65d9f70dba202462db8cbd2bd3c4;
static PyObject *const_tuple_str_plain_send_tuple;
extern PyObject *const_str_plain_locals_dict_name;
extern PyObject *const_str_plain_removeCleanupTempName;
extern PyObject *const_int_neg_1;
extern PyObject *const_str_plain_N;
extern PyObject *const_str_plain_ignore;
extern PyObject *const_str_plain_setExceptionEscape;
extern PyObject *const_str_plain_getFlagNewLocalsValue;
extern PyObject *const_str_plain_classmethod;
static PyObject *const_str_digest_9cf7759ec6f1caec3caa9daa738b0034;
static PyObject *const_str_plain_FrameDeclarationsMixin;
extern PyObject *const_str_plain_getCodeObjectKind;
extern PyObject *const_tuple_str_plain_iterItems_tuple;
static PyObject *const_str_digest_e886a7a5e26861ea3ac04b2519d56551;
static PyObject *const_str_digest_a775b336d71093bdc5cf5048acfcec01;
extern PyObject *const_str_plain_body;
static PyObject *const_str_digest_d034c43e11db00db602a81ced8fe964c;
static PyObject *const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_620eee19046de9c28a5f5941004f50e0;
static PyObject *const_str_digest_ab158c26012931f78fcf5dac53834cf2;
static PyObject *const_str_digest_f20acdafb2f595d6a6bd02e1596c02db;
static PyObject *const_str_digest_da77da2d11ac0ddda33bbdac37d07f77;
extern PyObject *const_str_plain_add;
static PyObject *const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple;
extern PyObject *const_str_plain_label;
static PyObject *const_str_digest_56356746a65eb210965718c6e0bad637;
static PyObject *const_str_digest_e8bf5486242e02fb6a0ece379cdbc2eb;
static PyObject *const_str_digest_451683d32f1c59cad00789bc67c1d0fb;
static PyObject *const_str_digest_96845c9d961382c5fbf5500a9e7469c3;
extern PyObject *const_str_plain_code_name;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_tuple_str_plain_FrameDeclarationsMixin_tuple_type_object_tuple_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_label_tuple;
static PyObject *const_str_digest_a9231837b104419978dcb04752802324;
static PyObject *const_str_digest_ab65be9aa3f9b0f8dac90010b8f2b7b1;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain_getExceptionEscape;
static PyObject *const_str_digest_cd5c4b50f1feb6b43661c8d06b8ea3b6;
static PyObject *const_str_digest_28e7af115baddb2a003debb0f477c4f1;
extern PyObject *const_str_plain_parent;
static PyObject *const_str_digest_b0d0a5ae888b485232848ed0dd46de83;
static PyObject *const_str_plain_getFramesCount;
extern PyObject *const_str_plain_getFrameVariableTypeDescriptions;
static PyObject *const_str_digest_a391e36881e14d55ceef68adbed6ce5c;
static PyObject *const_str_plain_ContextMetaClassBase;
extern PyObject *const_str_plain_builtin_anon_codes;
extern PyObject *const_str_plain_setCurrentSourceCodeReference;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_3a1700848fb92ee1dbb4cd16d7485b08;
extern PyObject *const_str_plain___getattr__;
extern PyObject *const_str_plain_getKeeperVariableCount;
extern PyObject *const_str_plain_append;
extern PyObject *const_str_plain_unique;
extern PyObject *const_str_plain_Py_NotImplemented;
extern PyObject *const_str_plain_setReturnValueName;
static PyObject *const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple;
extern PyObject *const_str_plain_getGeneratorReturnValueName;
static PyObject *const_tuple_str_plain_PythonGlobalContext_tuple_type_object_tuple_tuple;
extern PyObject *const_tuple_type_BaseException_tuple;
extern PyObject *const_str_plain_setExceptionKeeperVariables;
static PyObject *const_str_digest_5d74e5cd1518c783fc6a69f3668478fe;
static PyObject *const_str_digest_a2cb47e4aa86836d571e4f1abc9bd3ea;
extern PyObject *const_str_plain_b;
static PyObject *const_tuple_str_plain_types_tuple;
extern PyObject *const_str_plain_remove;
static PyObject *const_tuple_str_plain_function_exception_exit_tuple;
static PyObject *const_str_plain_ReturnReleaseModeMixin;
static PyObject *const_str_plain_locals_dict_names;
extern PyObject *const_str_plain_xrange;
extern PyObject *const_str_plain_addExceptionPreserverVariables;
static PyObject *const_str_digest_7dd74e6bd6d631103aa06d4fc73f4f11;
static PyObject *const_str_digest_d28c48e582387c3f5676f31b2d75ff04;
extern PyObject *const_str_plain___past__;
extern PyObject *const_str_plain_getModuleCodeName;
extern PyObject *const_tuple_str_plain_generator_return_str_plain_bool_tuple;
static PyObject *const_list_ac54667c64cc9a45e24ec255bd4d57dc_list;
static PyObject *const_str_digest_46e207833d58a5607dcef01b6e0394ce;
static PyObject *const_str_digest_997a826f536e490ccc2a8614e5b3f2a2;
static PyObject *const_str_plain_declaration_codes;
static PyObject *const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple;
static PyObject *const_str_plain_getLastSourceCodeReference;
static PyObject *const_str_digest_f6d30af9f62732609e854dc2c3e57bc8;
extern PyObject *const_str_plain_true_target;
static PyObject *const_str_plain_formatTempName;
static PyObject *const_str_digest_651cc9fe74c654590f332f38cd72ffbe;
static PyObject *const_list_tuple_empty_list;
static PyObject *const_str_digest_b847234509504f20fb53d89e47f5b400;
extern PyObject *const_dict_628013539fe17b0c3c196c9e449729d6;
static PyObject *const_str_digest_20c727c82e5d28322108adc97821509b;
static PyObject *const_str_digest_b0277cdeccf88c8943f1f7d6f7793f34;
extern PyObject *const_str_plain_isCrossModuleUsed;
static PyObject *const_str_plain_frame_type_descriptions;
extern PyObject *const_tuple_str_plain_counted_del_str_plain_counted_init_tuple;
extern PyObject *const_str_plain_return_exit;
extern PyObject *const_str_plain_global_context;
extern PyObject *const_str_plain_variable_c_type;
static PyObject *const_str_digest_bf3bf38031c4163919d18c1364869e43;
static PyObject *const_str_digest_ce62965fd8eb5174bb4ca85b681bd0fc;
extern PyObject *const_list_none_list;
extern PyObject *const_str_plain_asFlags;
extern PyObject *const_str_plain___class__;
static PyObject *const_str_digest_0c7a220bd34fb9c8798f0f2fec1cb0da;
static PyObject *const_str_digest_24cc62b22dd7e61b68f92530a4a782fb;
extern PyObject *const_str_plain_markAsNeedsModuleFilenameObject;
static PyObject *const_str_digest_d8623eadc62eefd98b6505073e32fa96;
extern PyObject *const_str_plain_asyncgen;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_plain_CodeObjectsMixin;
static PyObject *const_str_digest_29b780647c5454d52d6cc5ed97d4403c;
extern PyObject *const_str_plain_setReturnReleaseMode;
static PyObject *const_str_digest_78cb172fc37668311c09cddf0accd2d3;
extern PyObject *const_str_plain_getCodeObjects;
extern PyObject *const_str_plain_getEntryPoint;
static PyObject *const_str_digest_8b84bac5d679cc4833da523c95bcdd7d;
static PyObject *const_str_plain_needs_exception_variables;
static PyObject *const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple;
static PyObject *const_str_digest_bd567e3b650e5693f901e634d214b47b;
static PyObject *const_str_digest_9bb97bbdbc9682270fbd685cae14532d;
extern PyObject *const_str_plain_print;
static PyObject *const_str_digest_a3518bcf72de4035e2f10a911a38232c;
static PyObject *const_str_plain_PythonContextBase;
extern PyObject *const_str_plain_exc_traceback;
static PyObject *const_str_digest_432e03233e910c077a0c0791042b8b37;
static PyObject *const_str_digest_54303a084c426f43301b7773090a790e;
extern PyObject *const_str_plain_function;
extern PyObject *const_str_plain_PythonVersions;
static PyObject *const_str_digest_c253fc25926306e22a98281af8f9629a;
static PyObject *const_str_digest_c3d9479ee0697667cc53d6362864ca27;
extern PyObject *const_str_plain_get;
extern PyObject *const_str_plain_PythonFunctionOutlineContext;
static PyObject *const_str_digest_fdf085b4aa3db2edcb0ac6ec965d812f;
static PyObject *const_str_digest_0847e49017f7c0928080d95a06596ea9;
static PyObject *const_str_digest_1f833ba5473a81e2daec7c57c48cde0b;
extern PyObject *const_tuple_str_plain_ignore_tuple;
extern PyObject *const_str_plain_getFlagIsOptimizedValue;
static PyObject *const_str_digest_de692aaf1a39dcc9add5cafcc90e7d3a;
extern PyObject *const_str_plain_coroutine;
extern PyObject *const_str_plain_executable;
extern PyObject *const_tuple_str_plain_return_value_tuple;
static PyObject *const_str_digest_43f4366fb3942122b01fe9566b3de6f4;
extern PyObject *const_str_plain_number;
static PyObject *const_str_digest_9c42ff6703757defdbe30715d3ba3dc6;
static PyObject *const_str_digest_5e3b8e7b3051f5b55143cd8a3ff855dc;
extern PyObject *const_str_plain_metaclass;
extern PyObject *const_str_plain_pushFrameHandle;
static PyObject *const_str_digest_bd42d502b75375b7743b4f0e7e57275a;
extern PyObject *const_tuple_str_plain___class___tuple;
static PyObject *const_str_digest_fdc08637b74d20da15803737e5e9a07c;
extern PyObject *const_str_plain_tmp_name;
extern PyObject *const_str_plain_variable_code_name;
static PyObject *const_str_digest_b0f2c883e4b2f3dc22cf5e95533a896c;
extern PyObject *const_tuple_str_plain___loader___tuple;
static PyObject *const_str_digest_ef3595b39cc1b9509c09d092b025a8ee;
static PyObject *const_tuple_a446bcf39958ef92ff15a8277e4ac2b0_tuple;
static PyObject *const_str_digest_c4ea70fe255da0d8650740590bc33b6f;
static PyObject *const_str_digest_af3a2b1de0c6a92dacaae4dab7ac3804;
static PyObject *const_tuple_str_plain_res_str_plain_int_tuple;
static PyObject *const_str_digest_d992b89f73bdb30671cdd8edd12f6005;
extern PyObject *const_str_plain_abstractmethod;
extern PyObject *const_str_plain_staticmethod;
extern PyObject *const_str_plain_getFrameVariableTypeDescription;
static PyObject *const_str_digest_7d80a44ec359229267da8928be763699;
static PyObject *const_str_digest_a88fe8d1a8117948a3a9b364ecd8a9bc;
extern PyObject *const_str_plain_builtin_exception_values_list;
static PyObject *const_str_digest_b9654f9fe4b2af41c0086d216c9b3f57;
extern PyObject *const_str_plain_namifyConstant;
extern PyObject *const_str_plain_getLoopBreakTarget;
static PyObject *const_str_digest_64923e0a83c0602664a31786d52a3e9d;
extern PyObject *const_str_plain_join;
static PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple;
static PyObject *const_str_digest_382755dd9d7429a7072e416d429886f5;
static PyObject *const_str_digest_9b3d45c97ffe4b9a67c136fb1c0d39c4;
static PyObject *const_str_digest_037d332b1d32c0d5c23a1d56e4194dea;
static PyObject *const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple;
static PyObject *const_str_digest_90b2ac0e44b346ffb88bff778c792d92;
extern PyObject *const_str_dot;
static PyObject *const_str_digest_300347c1384be8a8687478ff007256b9;
extern PyObject *const_str_plain_allocateTempName;
extern PyObject *const_str_plain_getDeclarations;
extern PyObject *const_str_plain_res;
static PyObject *const_str_plain_tmp_unused_;
extern PyObject *const_str_plain_len;
static PyObject *const_str_plain_cleanup_names;
extern PyObject *const_str_plain_code_objects;
static PyObject *const_str_digest_afa6a7161e70a3534bb104f497fa36d9;
static PyObject *const_tuple_3b992cae161038cd22ae814b4c32d389_tuple;
extern PyObject *const_str_plain_type_name;
static PyObject *const_tuple_str_plain_self_str_plain_constant_tuple;
static PyObject *const_str_plain_return_name;
static PyObject *const_tuple_str_plain___cached___str_plain___loader___tuple;
extern PyObject *const_str_plain_int;
static PyObject *const_str_digest_57e1f5941d8ec27afcae5a2d53fc2ebf;
static PyObject *const_str_digest_77c7b66f03bbae96a3d7f48c86745c88;
static PyObject *const_str_digest_65ffc191fed0548aa882952f5e9c79f9;
extern PyObject *const_str_plain_base_name;
static PyObject *const_str_digest_a27dd0d7d26682190808a83e68f41a2f;
static PyObject *const_str_digest_cd5b021261404c37b8f61a632d02a733;
static PyObject *const_str_digest_3665173bc809a481f388f61ffa1b1bc1;
extern PyObject *const_str_plain_unicode;
extern PyObject *const_str_plain_variable;
static PyObject *const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple;
extern PyObject *const_str_plain_no_warnings;
static PyObject *const_str_digest_6c01341e24783701776f89abd8684492;
static PyObject *const_str_plain_Namify;
extern PyObject *const_tuple_str_plain_python_version_tuple;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_needsCleanup;
static PyObject *const_str_digest_edbae93d98459ae7c9eb8af7b7193e46;
static PyObject *const_str_digest_c0705a6cb9a01b5867fb8ce51e6e5e3b;
static PyObject *const_str_plain_tmp_names;
extern PyObject *const_str_plain_addLocalsDictName;
extern PyObject *const_str_plain_title;
extern PyObject *const_str_plain_allocateLabel;
extern PyObject *const_str_plain_guard_mode;
extern PyObject *const_str_plain_getModuleName;
static PyObject *const_str_digest_62a779267620479a42cca70c1212f7e4;
extern PyObject *const_str_plain_send;
static PyObject *const_tuple_str_plain_self_str_plain_tmp_name_tuple;
extern PyObject *const_str_plain_builtin_anon_values;
static PyObject *const_str_digest_2968b90b27535ed2b21f551de0759d50;
static PyObject *const_str_digest_b1a8cbbad04e282a28abd95e9224b578;
extern PyObject *const_tuple_bad5e3d4cc3e0b6c8c4fc2c004e19a74_tuple;
static PyObject *const_str_digest_c0326b9017891a796a85e065305d0ced;
extern PyObject *const_tuple_str_plain___spec___tuple;
static PyObject *const_str_digest_f0f79a5f9bfcf0fbb0c0effa9839520d;
extern PyObject *const_str_plain_getVarNames;
extern PyObject *const_tuple_str_plain_self_str_plain_parent_tuple;
extern PyObject *const_str_plain_count;
static PyObject *const_str_digest_344fd1ad98611e569be84794445a3e7d;
static PyObject *const_tuple_str_plain_TempMixin_tuple_type_object_tuple_tuple;
extern PyObject *const_str_plain_getReturnTarget;
extern PyObject *const_str_plain_setLoopBreakTarget;
static PyObject *const_tuple_str_plain_self_str_plain_frame_handle_tuple;
static PyObject *const_str_plain_frame_declarations;
static PyObject *const_str_digest_4cdb9bc00ce62e3ec47dc004a74507f3;
extern PyObject *const_str_plain_hasStarDictArg;
static PyObject *const_str_digest_d7fd14742817cb89f9e613bc0578cd73;
static PyObject *const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple;
extern PyObject *const_str_plain_getFrameDeclarations;
static PyObject *const_str_digest_ce77b93bf9baebf6bd099f4ee0e9423a;
static PyObject *const_str_digest_8afd3baaf3244cbcd3753c62c0705e40;
static PyObject *const_str_plain_preserver_variable_counts;
static PyObject *const_str_digest_67ca7d3d1f9da51471c81acdf3cc1989;
static PyObject *const_str_digest_700c551f886c1e8bdb659afa747b8b81;
static PyObject *const_str_plain_function_return_exit;
static PyObject *const_str_digest_356c04499a5502c401c8fb4a5ef9e7f5;
extern PyObject *const_str_plain_outline;
extern PyObject *const_str_plain_needsModuleFilenameObject;
extern PyObject *const_str_plain_getFrameVariableCodeNames;
static PyObject *const_str_digest_2bfea02cce6dbb334c2151f2711d23f4;
static PyObject *const_str_digest_a17c2210ab6063e2443b17d15f0b7260;
static PyObject *const_str_digest_e6d81c4ac5540cfd7927cbc32a7fec8e;
extern PyObject *const_tuple_type_object_tuple;
extern PyObject *const_str_plain_getTypeIndicator;
static PyObject *const_str_digest_cb11a3d64d8c17af6ecf3ea5918cd8cf;
extern PyObject *const_int_pos_330;
extern PyObject *const_str_plain_keeper_vars;
static PyObject *const_str_plain_needs_module_filename_object;
extern PyObject *const_str_plain_filename;
extern PyObject *const_str_plain_getCodeObjectHandle;
static PyObject *const_tuple_str_plain_bytes_tuple;
static PyObject *const_str_digest_3785c5b02b975eee6bd504145377678f;
extern PyObject *const_str_plain_getConstantUseCount;
extern PyObject *const_str_plain_setTrueBranchTarget;
static PyObject *const_str_digest_dc2f9ff63062bab5d561c96bac21dc35;
extern PyObject *const_str_plain_getFutureSpec;
static PyObject *const_str_digest_8687966f175199d40968e4bfcf00bb4c;
static PyObject *const_str_digest_e36decde46776641c89c99776519f544;
extern PyObject *const_tuple_str_plain_b_tuple;
static PyObject *const_str_digest_e8a76356f3b9c8af74157ada4361c7e5;
static PyObject *const_str_digest_f09cea3c42a5b06c37300a17fc8cc6c9;
extern PyObject *const_str_plain_getFalseBranchTarget;
static PyObject *const_str_digest_23422f93eb40a66425e75e64a3122a5e;
static PyObject *const_tuple_str_plain_self_str_plain_body_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_str_plain_loop_break;
static PyObject *const_str_digest_c679c48f65d794c255401ec1bd4db6f2;
static PyObject *const_str_plain_helper_codes;
static PyObject *const_str_digest_3d722941febc13409bb9dd17980dd7b2;
extern PyObject *const_str_plain_isCompiledPythonModule;
static PyObject *const_str_digest_56d6f8d6f93635fba2f1d030ee12aad5;
static PyObject *const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple;
static PyObject *const_str_digest_008caa6a1952819819f4e87b68280429;
extern PyObject *const_str_plain_hasStarListArg;
static PyObject *const_tuple_str_plain_self_str_plain_frame_variables_tuple;
extern PyObject *const_str_plain_PythonModuleContext;
extern PyObject *const_str_plain_forgetTempName;
extern PyObject *const_str_plain_file;
static PyObject *const_tuple_str_plain_site_tuple;
extern PyObject *const_str_plain_getFunction;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_digest_9e9622c7c86655267970050134c8b362 = UNSTREAM_STRING( &constant_bin[ 276671 ], 28, 0 );
    const_str_digest_948f61cf32e45d9aca768fd3a5bfde91 = UNSTREAM_STRING( &constant_bin[ 276699 ], 29, 0 );
    const_str_plain_constant_use_count = UNSTREAM_STRING( &constant_bin[ 276728 ], 18, 1 );
    const_str_plain_setFrameGuardMode = UNSTREAM_STRING( &constant_bin[ 276746 ], 17, 1 );
    const_str_digest_3b43b7bb5d11bed0890d96709e396529 = UNSTREAM_STRING( &constant_bin[ 276763 ], 32, 0 );
    const_str_plain_TempMixin = UNSTREAM_STRING( &constant_bin[ 276699 ], 9, 1 );
    const_str_digest_13bac17eda8963a56732e7b8e7f99340 = UNSTREAM_STRING( &constant_bin[ 276795 ], 38, 0 );
    const_str_digest_7557da68ac75e5b5557ba5ebbd1a40b4 = UNSTREAM_STRING( &constant_bin[ 276833 ], 41, 0 );
    const_tuple_str_plain_result_str_plain_bool_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_result_str_plain_bool_tuple, 0, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_str_plain_result_str_plain_bool_tuple, 1, const_str_plain_bool ); Py_INCREF( const_str_plain_bool );
    const_str_digest_a0fb262c13dfb27f8fb32ef7135876e8 = UNSTREAM_STRING( &constant_bin[ 276874 ], 44, 0 );
    const_tuple_str_plain_ReturnValueNameMixin_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    const_str_plain_ReturnValueNameMixin = UNSTREAM_STRING( &constant_bin[ 276918 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ReturnValueNameMixin_tuple_type_object_tuple_tuple, 0, const_str_plain_ReturnValueNameMixin ); Py_INCREF( const_str_plain_ReturnValueNameMixin );
    PyTuple_SET_ITEM( const_tuple_str_plain_ReturnValueNameMixin_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_str_digest_4ad35e0f2a19fb140fd91ad3f29da348 = UNSTREAM_STRING( &constant_bin[ 276938 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_str_plain_self_str_plain_base_name_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_base_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_base_name_tuple, 1, const_str_plain_base_name ); Py_INCREF( const_str_plain_base_name );
    const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 1, const_str_plain_variable ); Py_INCREF( const_str_plain_variable );
    PyTuple_SET_ITEM( const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 2, const_str_plain_variable_code_name ); Py_INCREF( const_str_plain_variable_code_name );
    PyTuple_SET_ITEM( const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 3, const_str_plain_variable_c_type ); Py_INCREF( const_str_plain_variable_c_type );
    const_str_digest_6d071d3109a8060fb2a971391a41d604 = UNSTREAM_STRING( &constant_bin[ 276987 ], 36, 0 );
    const_str_digest_520108655c15407c4a5f87230dc28f7c = UNSTREAM_STRING( &constant_bin[ 277023 ], 28, 0 );
    const_str_digest_4d4ad1d66c590948f14a486c230c1682 = UNSTREAM_STRING( &constant_bin[ 277051 ], 31, 0 );
    const_str_digest_a4094bb766fe1066b2a681c4d9db5b2b = UNSTREAM_STRING( &constant_bin[ 277082 ], 35, 0 );
    const_str_digest_30c918915243af4a313afc42bd3579fb = UNSTREAM_STRING( &constant_bin[ 277117 ], 39, 0 );
    const_str_digest_c61cd5e57bbff781c7524c02fd1b3960 = UNSTREAM_STRING( &constant_bin[ 277156 ], 36, 0 );
    const_str_digest_19b9cf24c12d3558fddc95d1485a0f2e = UNSTREAM_STRING( &constant_bin[ 277192 ], 31, 0 );
    const_str_digest_a84eb8c4cf19a2079f3a5e6014ab3c4d = UNSTREAM_STRING( &constant_bin[ 277223 ], 34, 0 );
    const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple, 0, const_str_plain_exc_type ); Py_INCREF( const_str_plain_exc_type );
    PyTuple_SET_ITEM( const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple, 1, const_str_plain_exc_value ); Py_INCREF( const_str_plain_exc_value );
    PyTuple_SET_ITEM( const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple, 2, const_str_plain_exc_traceback ); Py_INCREF( const_str_plain_exc_traceback );
    const_str_digest_d3171e1be7daa27a0a9a18c82d0cadf6 = UNSTREAM_STRING( &constant_bin[ 277257 ], 31, 0 );
    const_str_digest_22dcf374b1775b5a2a7cb67abb10c1a8 = UNSTREAM_STRING( &constant_bin[ 277288 ], 19, 0 );
    const_str_digest_b05f079ee69fdf65b9326bf63aac023f = UNSTREAM_STRING( &constant_bin[ 277307 ], 54, 0 );
    const_str_plain__calcHash = UNSTREAM_STRING( &constant_bin[ 277361 ], 9, 1 );
    const_str_digest_c82c62837868c10d2b20ff2c8d4c12cc = UNSTREAM_STRING( &constant_bin[ 277370 ], 55, 0 );
    const_str_digest_54e9e6535450bc1ab4b1290b4ca34a3d = UNSTREAM_STRING( &constant_bin[ 277425 ], 35, 0 );
    const_str_digest_1fdbba2cfe613b198992c1895f52f6fb = UNSTREAM_STRING( &constant_bin[ 277460 ], 40, 0 );
    const_str_digest_ee5d8bbbb96421bce0814b04537f4e5e = UNSTREAM_STRING( &constant_bin[ 277500 ], 33, 0 );
    const_str_digest_23fe9b1819b59de888106e5ab17356ef = UNSTREAM_STRING( &constant_bin[ 277533 ], 38, 0 );
    const_str_digest_87af14270b7513eece71f3edf77cf5ff = UNSTREAM_STRING( &constant_bin[ 277571 ], 48, 0 );
    const_tuple_str_plain_ReturnReleaseModeMixin_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    const_str_plain_ReturnReleaseModeMixin = UNSTREAM_STRING( &constant_bin[ 277533 ], 22, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ReturnReleaseModeMixin_tuple_type_object_tuple_tuple, 0, const_str_plain_ReturnReleaseModeMixin ); Py_INCREF( const_str_plain_ReturnReleaseModeMixin );
    PyTuple_SET_ITEM( const_tuple_str_plain_ReturnReleaseModeMixin_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_str_digest_407dc23619580f584d7efe59a675c107 = UNSTREAM_STRING( &constant_bin[ 277619 ], 32, 0 );
    const_str_digest_e9b6d0895f57833457cbf9ab51367bb8 = UNSTREAM_STRING( &constant_bin[ 277651 ], 50, 0 );
    const_str_digest_6ad77fd10d0c3b52171d2c1538e49ff8 = UNSTREAM_STRING( &constant_bin[ 277701 ], 23, 0 );
    const_str_digest_bceddc19e3682969185c76cf95bc10d9 = UNSTREAM_STRING( &constant_bin[ 277724 ], 40, 0 );
    const_str_plain_hash_value = UNSTREAM_STRING( &constant_bin[ 277764 ], 10, 1 );
    const_str_digest_a49b3c30821d06d66b6b814c5228652e = UNSTREAM_STRING( &constant_bin[ 277774 ], 30, 0 );
    const_str_digest_9600a801bc9b6cd2b42e5aa9695c1a43 = UNSTREAM_STRING( &constant_bin[ 277804 ], 58, 0 );
    const_str_plain_Py_Ellipsis = UNSTREAM_STRING( &constant_bin[ 275122 ], 11, 1 );
    const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2 = UNSTREAM_STRING( &constant_bin[ 277862 ], 16, 0 );
    const_str_digest_5b977a8a3b26c127088d2ea95bff3dea = UNSTREAM_STRING( &constant_bin[ 277878 ], 50, 0 );
    const_str_plain_last_source_ref = UNSTREAM_STRING( &constant_bin[ 277928 ], 15, 1 );
    const_str_digest_8d018b496b63fe3ca6c82d304f622d94 = UNSTREAM_STRING( &constant_bin[ 277943 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple, 1, const_str_plain_constant ); Py_INCREF( const_str_plain_constant );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple, 2, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    const_tuple_str_plain_throw_str_plain_close_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_throw_str_plain_close_tuple, 0, const_str_plain_throw ); Py_INCREF( const_str_plain_throw );
    PyTuple_SET_ITEM( const_tuple_str_plain_throw_str_plain_close_tuple, 1, const_str_plain_close ); Py_INCREF( const_str_plain_close );
    const_str_plain_forgotten_names = UNSTREAM_STRING( &constant_bin[ 277992 ], 15, 1 );
    const_str_plain_frame_variables_stack = UNSTREAM_STRING( &constant_bin[ 278007 ], 21, 1 );
    const_tuple_str_plain_self_str_plain_keeper_vars_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_keeper_vars_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_keeper_vars_tuple, 1, const_str_plain_keeper_vars ); Py_INCREF( const_str_plain_keeper_vars );
    const_str_digest_c70c81be0ee8686f88d0465dd01790d6 = UNSTREAM_STRING( &constant_bin[ 278028 ], 34, 0 );
    const_str_digest_3be2622e090e0211db0e458055823ae8 = UNSTREAM_STRING( &constant_bin[ 278062 ], 55, 0 );
    const_str_plain_ContextMetaClass = UNSTREAM_STRING( &constant_bin[ 278117 ], 16, 1 );
    const_str_digest_30b0a365467fd86233ade42cedd7d4ef = UNSTREAM_STRING( &constant_bin[ 278133 ], 36, 0 );
    const_str_digest_64d2764f4789876e822950a3b60de617 = UNSTREAM_STRING( &constant_bin[ 278169 ], 44, 0 );
    const_str_digest_885c88d4b9dcdc5ab5abe136b5e59ae4 = UNSTREAM_STRING( &constant_bin[ 278213 ], 40, 0 );
    const_str_digest_540034c844a611d69b7ba61d2b242481 = UNSTREAM_STRING( &constant_bin[ 278253 ], 25, 0 );
    const_str_digest_e1ef4009c46be20ee12b49bd6fda02bf = UNSTREAM_STRING( &constant_bin[ 278278 ], 51, 0 );
    const_str_digest_ea30090a2dc6215e4003e6d4e0471dd2 = UNSTREAM_STRING( &constant_bin[ 278329 ], 31, 0 );
    const_str_digest_2f4dfc429de3c23f0195ef78ce774a4d = UNSTREAM_STRING( &constant_bin[ 278360 ], 34, 0 );
    const_str_digest_802fc6c27e355cb87c4659dfc7643939 = UNSTREAM_STRING( &constant_bin[ 278394 ], 48, 0 );
    const_str_digest_45513e6ef9428f471b9854b48b23e391 = UNSTREAM_STRING( &constant_bin[ 278442 ], 44, 0 );
    const_str_digest_ff09dec21711a14ba972c5c09dc0b08d = UNSTREAM_STRING( &constant_bin[ 278486 ], 47, 0 );
    const_str_digest_52f1ee247aa393ed2fd9ff32d9fe5948 = UNSTREAM_STRING( &constant_bin[ 278533 ], 37, 0 );
    const_str_digest_7ac96968a40e4b5f6dac1f4c9846a3ae = UNSTREAM_STRING( &constant_bin[ 278570 ], 53, 0 );
    const_str_plain__getConstantDefaultPopulation = UNSTREAM_STRING( &constant_bin[ 278623 ], 29, 1 );
    const_str_digest_6227df33b96fb24225f8e850bc7d5c6c = UNSTREAM_STRING( &constant_bin[ 278652 ], 47, 0 );
    const_str_digest_e03d67f5a64017c14f12c063df2c2f06 = UNSTREAM_STRING( &constant_bin[ 278699 ], 42, 0 );
    const_str_digest_391e3f0d62b69d6a83d92e9ff1a571c6 = UNSTREAM_STRING( &constant_bin[ 278741 ], 31, 0 );
    const_tuple_str_plain_self_str_plain_locals_dict_name_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_locals_dict_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_locals_dict_name_tuple, 1, const_str_plain_locals_dict_name ); Py_INCREF( const_str_plain_locals_dict_name );
    const_str_digest_15890cf826b7d30c52521be71e7a7eb9 = UNSTREAM_STRING( &constant_bin[ 278772 ], 37, 0 );
    const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 1, const_str_plain_base_name ); Py_INCREF( const_str_plain_base_name );
    PyTuple_SET_ITEM( const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 2, const_str_plain_type_name ); Py_INCREF( const_str_plain_type_name );
    PyTuple_SET_ITEM( const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 3, const_str_plain_unique ); Py_INCREF( const_str_plain_unique );
    const_str_plain_Py_True = UNSTREAM_STRING( &constant_bin[ 274642 ], 7, 1 );
    const_str_plain_variable_code_type = UNSTREAM_STRING( &constant_bin[ 278809 ], 18, 1 );
    const_str_digest_31d729e30f99251b4a1e18bea892374b = UNSTREAM_STRING( &constant_bin[ 278827 ], 28, 0 );
    const_str_digest_527ad68d726ffc2da2a6cfbd7aa23f42 = UNSTREAM_STRING( &constant_bin[ 278855 ], 30, 0 );
    const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple, 0, const_str_plain_print ); Py_INCREF( const_str_plain_print );
    PyTuple_SET_ITEM( const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple, 1, const_str_plain_end ); Py_INCREF( const_str_plain_end );
    PyTuple_SET_ITEM( const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple, 2, const_str_plain_file ); Py_INCREF( const_str_plain_file );
    const_str_digest_f3486d138092511205b103bca2ec7e88 = UNSTREAM_STRING( &constant_bin[ 278885 ], 40, 0 );
    const_str_plain_return_release_mode = UNSTREAM_STRING( &constant_bin[ 278925 ], 19, 1 );
    const_str_digest_a7fb2ee40d1e8754e1b199d0a66ddbc5 = UNSTREAM_STRING( &constant_bin[ 278944 ], 42, 0 );
    const_str_digest_c22317b266ff5904776f5a58e1b9d77d = UNSTREAM_STRING( &constant_bin[ 278986 ], 35, 0 );
    const_str_digest_83dbc6b4579376d5626364525918dafb = UNSTREAM_STRING( &constant_bin[ 279021 ], 30, 0 );
    const_str_digest_b682238f4a2007d1b13f98b0fdc5e1e3 = UNSTREAM_STRING( &constant_bin[ 279051 ], 22, 0 );
    const_str_digest_8543c958c8b71f8e133f9a2beb608bc0 = UNSTREAM_STRING( &constant_bin[ 279073 ], 31, 0 );
    const_str_digest_089ed70ff710455be48c44c3e522dd31 = UNSTREAM_STRING( &constant_bin[ 279104 ], 35, 0 );
    const_str_digest_7f0e64884a17d062eb6c8fc5669b4e09 = UNSTREAM_STRING( &constant_bin[ 279139 ], 37, 0 );
    const_str_digest_8b43f078b192122dc45357ec9f7330da = UNSTREAM_STRING( &constant_bin[ 279176 ], 20, 0 );
    const_str_digest_ca2d7dd6ed477bea25e0137f135c1964 = UNSTREAM_STRING( &constant_bin[ 279196 ], 49, 0 );
    const_str_digest_529a8ebf30aa338f0b011c2f8d4aab0b = UNSTREAM_STRING( &constant_bin[ 279245 ], 48, 0 );
    const_str_digest_125f5277815f5b7d7e6feb17e062156d = UNSTREAM_STRING( &constant_bin[ 279293 ], 101, 0 );
    const_str_digest_ed69aa0bd5f577c19c3d0949f3e75d39 = UNSTREAM_STRING( &constant_bin[ 279394 ], 40, 0 );
    const_tuple_str_plain_xrange_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_xrange_tuple, 0, const_str_plain_xrange ); Py_INCREF( const_str_plain_xrange );
    const_str_digest_e2fbdb696fac361cce9168658dbd2fc0 = UNSTREAM_STRING( &constant_bin[ 279434 ], 24, 0 );
    const_str_plain_function_exception_exit = UNSTREAM_STRING( &constant_bin[ 279458 ], 23, 1 );
    const_str_digest_579f388010d12808b3eae0ac3161d269 = UNSTREAM_STRING( &constant_bin[ 279481 ], 32, 0 );
    const_str_digest_1756d814b178aaae17abac3163d1a7e0 = UNSTREAM_STRING( &constant_bin[ 279513 ], 38, 0 );
    const_str_digest_c9f53fea3b1b946fc6f9ff2a3b44affd = UNSTREAM_STRING( &constant_bin[ 279551 ], 39, 0 );
    const_str_digest_ef8f2e417acf45e2ce4f92f1b6f7c606 = UNSTREAM_STRING( &constant_bin[ 279590 ], 36, 0 );
    const_tuple_str_plain_CodeObjectsMixin_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    const_str_plain_CodeObjectsMixin = UNSTREAM_STRING( &constant_bin[ 279626 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CodeObjectsMixin_tuple_type_object_tuple_tuple, 0, const_str_plain_CodeObjectsMixin ); Py_INCREF( const_str_plain_CodeObjectsMixin );
    PyTuple_SET_ITEM( const_tuple_str_plain_CodeObjectsMixin_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_str_digest_9f94c79a242f7988d834ffc98aa9eeb0 = UNSTREAM_STRING( &constant_bin[ 279642 ], 26, 0 );
    const_str_digest_4294787ad1c872e007fe67a2ec41f784 = UNSTREAM_STRING( &constant_bin[ 279668 ], 48, 0 );
    const_str_digest_1a6a0e81cf296c4b8867d45a8b58b1d3 = UNSTREAM_STRING( &constant_bin[ 279716 ], 30, 0 );
    const_str_digest_0a9b4312244332263552dac3b72c914a = UNSTREAM_STRING( &constant_bin[ 279746 ], 37, 0 );
    const_str_digest_2fed9bd860ef22890aae00273ef8b1e9 = UNSTREAM_STRING( &constant_bin[ 279783 ], 5, 0 );
    const_tuple_str_plain_tmp_unused__tuple = PyTuple_New( 1 );
    const_str_plain_tmp_unused_ = UNSTREAM_STRING( &constant_bin[ 279788 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_tmp_unused__tuple, 0, const_str_plain_tmp_unused_ ); Py_INCREF( const_str_plain_tmp_unused_ );
    const_str_plain_exception_escape = UNSTREAM_STRING( &constant_bin[ 279799 ], 16, 1 );
    const_str_digest_e7002c0ee8e5bbb559c41cccff652c68 = UNSTREAM_STRING( &constant_bin[ 279815 ], 21, 0 );
    const_tuple_str_plain_namifyConstant_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_namifyConstant_tuple, 0, const_str_plain_namifyConstant ); Py_INCREF( const_str_plain_namifyConstant );
    const_str_digest_7092502eed67780baa4aed0d913d2d89 = UNSTREAM_STRING( &constant_bin[ 279836 ], 56, 0 );
    const_str_digest_3b82b1dd4c55cea38706e783ea34e248 = UNSTREAM_STRING( &constant_bin[ 279892 ], 46, 0 );
    const_str_plain_PythonFunctionContext = UNSTREAM_STRING( &constant_bin[ 277426 ], 21, 1 );
    const_tuple_str_plain_self_str_plain_guard_mode_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_guard_mode_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_guard_mode_tuple, 1, const_str_plain_guard_mode ); Py_INCREF( const_str_plain_guard_mode );
    const_tuple_str_plain_self_str_plain_code_object_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_code_object_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_code_object_tuple, 1, const_str_plain_code_object ); Py_INCREF( const_str_plain_code_object );
    const_str_digest_2b3e70ac3e1ab3c1f0f382782169dcd9 = UNSTREAM_STRING( &constant_bin[ 279938 ], 73, 0 );
    const_str_digest_bb940c7f0f9217bc32eb90e6a338a738 = UNSTREAM_STRING( &constant_bin[ 280011 ], 30, 0 );
    const_str_digest_f970dec118dd032743ada440a4958864 = UNSTREAM_STRING( &constant_bin[ 280041 ], 33, 0 );
    const_str_digest_b1b67715452f238441f19f172aeedfdd = UNSTREAM_STRING( &constant_bin[ 280074 ], 42, 0 );
    const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple, 1, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple, 2, const_str_plain_function ); Py_INCREF( const_str_plain_function );
    const_str_plain_frame_variables = UNSTREAM_STRING( &constant_bin[ 278007 ], 15, 1 );
    const_str_digest_003e4a56d94b5e8606e65634d347a2ac = UNSTREAM_STRING( &constant_bin[ 280116 ], 31, 0 );
    const_str_digest_77d01c4e03e31b15053cbf356c56c5d3 = UNSTREAM_STRING( &constant_bin[ 280147 ], 27, 0 );
    const_str_digest_747061db3f940444cb7e968024b55240 = UNSTREAM_STRING( &constant_bin[ 280174 ], 48, 0 );
    const_str_digest_94d8409ce4a107d22339dc4807c738ed = UNSTREAM_STRING( &constant_bin[ 280222 ], 50, 0 );
    const_str_digest_aa8ecf91a23ffc01605bd0dbabd23bf4 = UNSTREAM_STRING( &constant_bin[ 280272 ], 36, 0 );
    const_str_digest_8b7296b8019bbdff3203b98f7065cc32 = UNSTREAM_STRING( &constant_bin[ 280308 ], 37, 0 );
    const_str_digest_10f90d9735fc507eae60ede4611ac1d5 = UNSTREAM_STRING( &constant_bin[ 280345 ], 36, 0 );
    const_str_digest_aeff4a5a9b47578a597233dc0f53d668 = UNSTREAM_STRING( &constant_bin[ 280381 ], 25, 0 );
    const_str_plain_isForCrossModuleUsage = UNSTREAM_STRING( &constant_bin[ 277907 ], 21, 1 );
    const_str_plain_PythonChildContextBase = UNSTREAM_STRING( &constant_bin[ 277307 ], 22, 1 );
    const_str_digest_1bc5a106f93df28e7cb280601af927e9 = UNSTREAM_STRING( &constant_bin[ 280406 ], 32, 0 );
    const_tuple_str_plain_function_return_exit_tuple = PyTuple_New( 1 );
    const_str_plain_function_return_exit = UNSTREAM_STRING( &constant_bin[ 280438 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_function_return_exit_tuple, 0, const_str_plain_function_return_exit ); Py_INCREF( const_str_plain_function_return_exit );
    const_str_digest_ab07390ab07a9b5d7f2fc01935b20975 = UNSTREAM_STRING( &constant_bin[ 280458 ], 26, 0 );
    const_str_digest_e50eac13be8c283248b1730bf779a98d = UNSTREAM_STRING( &constant_bin[ 280484 ], 43, 0 );
    const_tuple_str_plain_NULL_str_plain_N_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_NULL_str_plain_N_tuple, 0, const_str_plain_NULL ); Py_INCREF( const_str_plain_NULL );
    PyTuple_SET_ITEM( const_tuple_str_plain_NULL_str_plain_N_tuple, 1, const_str_plain_N ); Py_INCREF( const_str_plain_N );
    const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 1, const_str_plain_base_name ); Py_INCREF( const_str_plain_base_name );
    PyTuple_SET_ITEM( const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 2, const_str_plain_type_name ); Py_INCREF( const_str_plain_type_name );
    PyTuple_SET_ITEM( const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 3, const_str_plain_unique ); Py_INCREF( const_str_plain_unique );
    PyTuple_SET_ITEM( const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 4, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    const_str_digest_cfe6611d3194e04523d0733e7593071e = UNSTREAM_STRING( &constant_bin[ 280527 ], 37, 0 );
    const_str_digest_fb9fc685100d5e403d5f70d0b394c80c = UNSTREAM_STRING( &constant_bin[ 280564 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_frame_decl_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_decl_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_frame_decl = UNSTREAM_STRING( &constant_bin[ 280613 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_decl_tuple, 1, const_str_plain_frame_decl ); Py_INCREF( const_str_plain_frame_decl );
    const_str_digest_294c218899092afd28db1da9d9795129 = UNSTREAM_STRING( &constant_bin[ 280623 ], 42, 0 );
    const_str_plain_frame_stack = UNSTREAM_STRING( &constant_bin[ 280665 ], 11, 1 );
    const_str_plain_Py_False = UNSTREAM_STRING( &constant_bin[ 275449 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple, 1, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple, 2, const_str_plain_hash_value ); Py_INCREF( const_str_plain_hash_value );
    const_str_digest_312280c60bdc0537d21c15fc13a6ee1b = UNSTREAM_STRING( &constant_bin[ 280676 ], 44, 0 );
    const_str_digest_694c746215c69a034048b506a36cf7bf = UNSTREAM_STRING( &constant_bin[ 280720 ], 36, 0 );
    const_str_digest_32fd3375c92eca260cdd6ad686088f06 = UNSTREAM_STRING( &constant_bin[ 280756 ], 31, 0 );
    const_str_digest_7f297503a366843318e0255757663358 = UNSTREAM_STRING( &constant_bin[ 280787 ], 37, 0 );
    const_str_digest_cfe69f84a1d3c34e08be1062e3949702 = UNSTREAM_STRING( &constant_bin[ 280824 ], 37, 0 );
    const_str_digest_b8f914007454fc95cbbaf34232adac0a = UNSTREAM_STRING( &constant_bin[ 280861 ], 33, 0 );
    const_str_digest_fb36bd46add94916696032032156928f = UNSTREAM_STRING( &constant_bin[ 280894 ], 43, 0 );
    const_str_plain_frame_variable_types = UNSTREAM_STRING( &constant_bin[ 280937 ], 20, 1 );
    const_str_plain_tmp_types = UNSTREAM_STRING( &constant_bin[ 280957 ], 9, 1 );
    const_str_digest_2cdb9fd17a48e31dd84ef597bf3b2f00 = UNSTREAM_STRING( &constant_bin[ 280966 ], 56, 0 );
    const_str_plain_loop_continue = UNSTREAM_STRING( &constant_bin[ 281022 ], 13, 1 );
    const_str_digest_f69f05a54a53082c0c4af4066da595fb = UNSTREAM_STRING( &constant_bin[ 277370 ], 54, 0 );
    const_str_digest_4f1b43ee1083d2d091afaee9410359a2 = UNSTREAM_STRING( &constant_bin[ 281035 ], 39, 0 );
    const_str_digest_5bc885749965f660b02bd91c96e09784 = UNSTREAM_STRING( &constant_bin[ 281074 ], 22, 0 );
    const_str_digest_1aaf40f2b11d352f255716a514436f34 = UNSTREAM_STRING( &constant_bin[ 281096 ], 39, 0 );
    const_str_digest_86e31d797d4f791dbea48e73dc686425 = UNSTREAM_STRING( &constant_bin[ 281135 ], 34, 0 );
    const_str_digest_ed3da1d877103f471e67483c8b8f3267 = UNSTREAM_STRING( &constant_bin[ 281169 ], 41, 0 );
    const_str_digest_ebe63b9b9d5ee0fb95a863e8a24bec5d = UNSTREAM_STRING( &constant_bin[ 281210 ], 31, 0 );
    const_str_digest_e8661d65ca161cb98d2f99c4e6dd1cf2 = UNSTREAM_STRING( &constant_bin[ 281241 ], 37, 0 );
    const_str_plain_exception_keepers = UNSTREAM_STRING( &constant_bin[ 281278 ], 17, 1 );
    const_str_digest_a0e70fff63384bf33577c66143d20c55 = UNSTREAM_STRING( &constant_bin[ 281295 ], 26, 0 );
    const_str_digest_36a950e7e63a9795ac03e8984bd01677 = UNSTREAM_STRING( &constant_bin[ 281321 ], 58, 0 );
    const_str_plain_current_source_ref = UNSTREAM_STRING( &constant_bin[ 281379 ], 18, 1 );
    const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 1, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 2, const_str_plain_variable ); Py_INCREF( const_str_plain_variable );
    PyTuple_SET_ITEM( const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 3, const_str_plain_variable_code_name ); Py_INCREF( const_str_plain_variable_code_name );
    PyTuple_SET_ITEM( const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 4, const_str_plain_variable_code_type ); Py_INCREF( const_str_plain_variable_code_type );
    const_str_plain_keeper_variable_count = UNSTREAM_STRING( &constant_bin[ 281397 ], 21, 1 );
    const_str_digest_de6b1851ed9396300170bea9bd415e26 = UNSTREAM_STRING( &constant_bin[ 281418 ], 32, 0 );
    const_str_plain_frames_used = UNSTREAM_STRING( &constant_bin[ 281450 ], 11, 1 );
    const_str_digest_a2b1038979e363452b40a33002fa30b8 = UNSTREAM_STRING( &constant_bin[ 281461 ], 39, 0 );
    const_str_digest_26f09ed9652d19fa65c7c2f38edc645f = UNSTREAM_STRING( &constant_bin[ 281500 ], 29, 0 );
    const_str_digest_ad2f34e8e6f884bf5dc463a64a2860ac = UNSTREAM_STRING( &constant_bin[ 281529 ], 48, 0 );
    const_str_digest_fc7b837d9b6460c92a7a6b96b8c0c67d = UNSTREAM_STRING( &constant_bin[ 281577 ], 42, 0 );
    const_str_digest_912b4b1c7307c539a82a691f606660f5 = UNSTREAM_STRING( &constant_bin[ 281619 ], 35, 0 );
    const_str_digest_bfa5790306fd6f4a7e7d764daae9c3d5 = UNSTREAM_STRING( &constant_bin[ 281654 ], 31, 0 );
    const_str_digest_bbc23540b36b5266f6535cbbe7b3e01d = UNSTREAM_STRING( &constant_bin[ 281685 ], 31, 0 );
    const_str_digest_b64dbcae04a9beb7ea31b9fc66d1944e = UNSTREAM_STRING( &constant_bin[ 281716 ], 48, 0 );
    const_tuple_60536d512e7395e2cfe11459ddd28893_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 1, const_str_plain_module ); Py_INCREF( const_str_plain_module );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 2, const_str_plain_module_name ); Py_INCREF( const_str_plain_module_name );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 3, const_str_plain_code_name ); Py_INCREF( const_str_plain_code_name );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 4, const_str_plain_filename ); Py_INCREF( const_str_plain_filename );
    PyTuple_SET_ITEM( const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 5, const_str_plain_global_context ); Py_INCREF( const_str_plain_global_context );
    const_str_digest_40aee10a90964f455d9ea1ff7aac6117 = UNSTREAM_STRING( &constant_bin[ 281764 ], 29, 0 );
    const_str_digest_b15c2d9cc14aa119965733d8bffb6657 = UNSTREAM_STRING( &constant_bin[ 279819 ], 17, 0 );
    const_str_digest_da55172e86e697e30db1acc837d8ae44 = UNSTREAM_STRING( &constant_bin[ 281793 ], 30, 0 );
    const_list_6f2f6b405ec0ec1cb9c5e98a4eadddb0_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 281823 ], 335 );
    const_str_digest_8f6d1ed1333c2b8e5ed75ae3469272bc = UNSTREAM_STRING( &constant_bin[ 282158 ], 37, 0 );
    const_str_digest_6377357bbc333a753ef615877cb70488 = UNSTREAM_STRING( &constant_bin[ 282195 ], 24, 0 );
    const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple, 1, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple, 2, const_str_plain_outline ); Py_INCREF( const_str_plain_outline );
    const_str_digest_1fa86cd2988d8c8a3034058c84b34c7c = UNSTREAM_STRING( &constant_bin[ 282219 ], 24, 0 );
    const_str_digest_f93c4804b3e85fff716e142bad8c063f = UNSTREAM_STRING( &constant_bin[ 282243 ], 28, 0 );
    const_str_digest_a200173c4121e0bca2f471f7b42614e9 = UNSTREAM_STRING( &constant_bin[ 282271 ], 61, 0 );
    const_str_digest_36e53050e5752dd8dad8ca08da219dfc = UNSTREAM_STRING( &constant_bin[ 282332 ], 31, 0 );
    const_str_digest_b1e60ea9ee7c3a8a50cd2755a17a5fe8 = UNSTREAM_STRING( &constant_bin[ 282363 ], 38, 0 );
    const_str_digest_ab9b65d9f70dba202462db8cbd2bd3c4 = UNSTREAM_STRING( &constant_bin[ 282401 ], 18, 0 );
    const_tuple_str_plain_send_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_send_tuple, 0, const_str_plain_send ); Py_INCREF( const_str_plain_send );
    const_str_digest_9cf7759ec6f1caec3caa9daa738b0034 = UNSTREAM_STRING( &constant_bin[ 282419 ], 44, 0 );
    const_str_plain_FrameDeclarationsMixin = UNSTREAM_STRING( &constant_bin[ 276795 ], 22, 1 );
    const_str_digest_e886a7a5e26861ea3ac04b2519d56551 = UNSTREAM_STRING( &constant_bin[ 282463 ], 56, 0 );
    const_str_digest_a775b336d71093bdc5cf5048acfcec01 = UNSTREAM_STRING( &constant_bin[ 282519 ], 28, 0 );
    const_str_digest_d034c43e11db00db602a81ced8fe964c = UNSTREAM_STRING( &constant_bin[ 282547 ], 43, 0 );
    const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple, 0, const_str_plain_builtin_anon_codes ); Py_INCREF( const_str_plain_builtin_anon_codes );
    PyTuple_SET_ITEM( const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple, 1, const_str_plain_builtin_anon_values ); Py_INCREF( const_str_plain_builtin_anon_values );
    PyTuple_SET_ITEM( const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple, 2, const_str_plain_builtin_exception_values_list ); Py_INCREF( const_str_plain_builtin_exception_values_list );
    const_str_digest_620eee19046de9c28a5f5941004f50e0 = UNSTREAM_STRING( &constant_bin[ 282590 ], 30, 0 );
    const_str_digest_ab158c26012931f78fcf5dac53834cf2 = UNSTREAM_STRING( &constant_bin[ 282620 ], 47, 0 );
    const_str_digest_f20acdafb2f595d6a6bd02e1596c02db = UNSTREAM_STRING( &constant_bin[ 282667 ], 24, 0 );
    const_str_digest_da77da2d11ac0ddda33bbdac37d07f77 = UNSTREAM_STRING( &constant_bin[ 282691 ], 28, 0 );
    const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple, 1, const_str_plain_keeper_vars ); Py_INCREF( const_str_plain_keeper_vars );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_56356746a65eb210965718c6e0bad637 = UNSTREAM_STRING( &constant_bin[ 282719 ], 43, 0 );
    const_str_digest_e8bf5486242e02fb6a0ece379cdbc2eb = UNSTREAM_STRING( &constant_bin[ 282762 ], 49, 0 );
    const_str_digest_451683d32f1c59cad00789bc67c1d0fb = UNSTREAM_STRING( &constant_bin[ 282811 ], 34, 0 );
    const_str_digest_96845c9d961382c5fbf5500a9e7469c3 = UNSTREAM_STRING( &constant_bin[ 282845 ], 32, 0 );
    const_tuple_str_plain_FrameDeclarationsMixin_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_FrameDeclarationsMixin_tuple_type_object_tuple_tuple, 0, const_str_plain_FrameDeclarationsMixin ); Py_INCREF( const_str_plain_FrameDeclarationsMixin );
    PyTuple_SET_ITEM( const_tuple_str_plain_FrameDeclarationsMixin_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_tuple_str_plain_self_str_plain_label_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_label_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_label_tuple, 1, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    const_str_digest_a9231837b104419978dcb04752802324 = UNSTREAM_STRING( &constant_bin[ 282877 ], 58, 0 );
    const_str_digest_ab65be9aa3f9b0f8dac90010b8f2b7b1 = UNSTREAM_STRING( &constant_bin[ 282935 ], 43, 0 );
    const_str_digest_cd5c4b50f1feb6b43661c8d06b8ea3b6 = UNSTREAM_STRING( &constant_bin[ 282978 ], 60, 0 );
    const_str_digest_28e7af115baddb2a003debb0f477c4f1 = UNSTREAM_STRING( &constant_bin[ 283038 ], 45, 0 );
    const_str_digest_b0d0a5ae888b485232848ed0dd46de83 = UNSTREAM_STRING( &constant_bin[ 283083 ], 21, 0 );
    const_str_plain_getFramesCount = UNSTREAM_STRING( &constant_bin[ 283104 ], 14, 1 );
    const_str_digest_a391e36881e14d55ceef68adbed6ce5c = UNSTREAM_STRING( &constant_bin[ 283118 ], 42, 0 );
    const_str_plain_ContextMetaClassBase = UNSTREAM_STRING( &constant_bin[ 283160 ], 20, 1 );
    const_str_digest_3a1700848fb92ee1dbb4cd16d7485b08 = UNSTREAM_STRING( &constant_bin[ 283180 ], 37, 0 );
    const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple, 1, const_str_plain_constant ); Py_INCREF( const_str_plain_constant );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_str_plain_PythonGlobalContext_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_PythonGlobalContext_tuple_type_object_tuple_tuple, 0, const_str_plain_PythonGlobalContext ); Py_INCREF( const_str_plain_PythonGlobalContext );
    PyTuple_SET_ITEM( const_tuple_str_plain_PythonGlobalContext_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_str_digest_5d74e5cd1518c783fc6a69f3668478fe = UNSTREAM_STRING( &constant_bin[ 283217 ], 10, 0 );
    const_str_digest_a2cb47e4aa86836d571e4f1abc9bd3ea = UNSTREAM_STRING( &constant_bin[ 283227 ], 36, 0 );
    const_tuple_str_plain_types_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_types_tuple, 0, const_str_plain_types ); Py_INCREF( const_str_plain_types );
    const_tuple_str_plain_function_exception_exit_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_function_exception_exit_tuple, 0, const_str_plain_function_exception_exit ); Py_INCREF( const_str_plain_function_exception_exit );
    const_str_plain_locals_dict_names = UNSTREAM_STRING( &constant_bin[ 283263 ], 17, 1 );
    const_str_digest_7dd74e6bd6d631103aa06d4fc73f4f11 = UNSTREAM_STRING( &constant_bin[ 283280 ], 47, 0 );
    const_str_digest_d28c48e582387c3f5676f31b2d75ff04 = UNSTREAM_STRING( &constant_bin[ 283327 ], 41, 0 );
    const_list_ac54667c64cc9a45e24ec255bd4d57dc_list = PyList_New( 6 );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 1, const_str_plain_len ); Py_INCREF( const_str_plain_len );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 2, const_str_plain_range ); Py_INCREF( const_str_plain_range );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 3, const_str_plain_repr ); Py_INCREF( const_str_plain_repr );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 4, const_str_plain_int ); Py_INCREF( const_str_plain_int );
    PyList_SET_ITEM( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list, 5, const_str_plain_iter ); Py_INCREF( const_str_plain_iter );
    const_str_digest_46e207833d58a5607dcef01b6e0394ce = UNSTREAM_STRING( &constant_bin[ 283368 ], 38, 0 );
    const_str_digest_997a826f536e490ccc2a8614e5b3f2a2 = UNSTREAM_STRING( &constant_bin[ 283406 ], 48, 0 );
    const_str_plain_declaration_codes = UNSTREAM_STRING( &constant_bin[ 283454 ], 17, 1 );
    const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple, 0, const_str_digest_fd57353dc0a31a7daca8fb2ea030dee2 ); Py_INCREF( const_str_digest_fd57353dc0a31a7daca8fb2ea030dee2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple, 1, Py_False ); Py_INCREF( Py_False );
    const_str_plain_getLastSourceCodeReference = UNSTREAM_STRING( &constant_bin[ 283471 ], 26, 1 );
    const_str_digest_f6d30af9f62732609e854dc2c3e57bc8 = UNSTREAM_STRING( &constant_bin[ 279815 ], 10, 0 );
    const_str_plain_formatTempName = UNSTREAM_STRING( &constant_bin[ 282205 ], 14, 1 );
    const_str_digest_651cc9fe74c654590f332f38cd72ffbe = UNSTREAM_STRING( &constant_bin[ 283497 ], 45, 0 );
    const_list_tuple_empty_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_tuple_empty_list, 0, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_digest_b847234509504f20fb53d89e47f5b400 = UNSTREAM_STRING( &constant_bin[ 283542 ], 33, 0 );
    const_str_digest_20c727c82e5d28322108adc97821509b = UNSTREAM_STRING( &constant_bin[ 283575 ], 45, 0 );
    const_str_digest_b0277cdeccf88c8943f1f7d6f7793f34 = UNSTREAM_STRING( &constant_bin[ 283620 ], 48, 0 );
    const_str_plain_frame_type_descriptions = UNSTREAM_STRING( &constant_bin[ 283668 ], 23, 1 );
    const_str_digest_bf3bf38031c4163919d18c1364869e43 = UNSTREAM_STRING( &constant_bin[ 283691 ], 40, 0 );
    const_str_digest_ce62965fd8eb5174bb4ca85b681bd0fc = UNSTREAM_STRING( &constant_bin[ 283731 ], 45, 0 );
    const_str_digest_0c7a220bd34fb9c8798f0f2fec1cb0da = UNSTREAM_STRING( &constant_bin[ 283776 ], 28, 0 );
    const_str_digest_24cc62b22dd7e61b68f92530a4a782fb = UNSTREAM_STRING( &constant_bin[ 283804 ], 28, 0 );
    const_str_digest_d8623eadc62eefd98b6505073e32fa96 = UNSTREAM_STRING( &constant_bin[ 283832 ], 49, 0 );
    const_str_digest_29b780647c5454d52d6cc5ed97d4403c = UNSTREAM_STRING( &constant_bin[ 283881 ], 26, 0 );
    const_str_digest_78cb172fc37668311c09cddf0accd2d3 = UNSTREAM_STRING( &constant_bin[ 283907 ], 29, 0 );
    const_str_digest_8b84bac5d679cc4833da523c95bcdd7d = UNSTREAM_STRING( &constant_bin[ 265309 ], 12, 0 );
    const_str_plain_needs_exception_variables = UNSTREAM_STRING( &constant_bin[ 283936 ], 25, 1 );
    const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 1, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_bd567e3b650e5693f901e634d214b47b = UNSTREAM_STRING( &constant_bin[ 283961 ], 37, 0 );
    const_str_digest_9bb97bbdbc9682270fbd685cae14532d = UNSTREAM_STRING( &constant_bin[ 283998 ], 28, 0 );
    const_str_digest_a3518bcf72de4035e2f10a911a38232c = UNSTREAM_STRING( &constant_bin[ 284026 ], 50, 0 );
    const_str_plain_PythonContextBase = UNSTREAM_STRING( &constant_bin[ 277082 ], 17, 1 );
    const_str_digest_432e03233e910c077a0c0791042b8b37 = UNSTREAM_STRING( &constant_bin[ 284076 ], 25, 0 );
    const_str_digest_54303a084c426f43301b7773090a790e = UNSTREAM_STRING( &constant_bin[ 284101 ], 37, 0 );
    const_str_digest_c253fc25926306e22a98281af8f9629a = UNSTREAM_STRING( &constant_bin[ 284138 ], 31, 0 );
    const_str_digest_c3d9479ee0697667cc53d6362864ca27 = UNSTREAM_STRING( &constant_bin[ 284169 ], 50, 0 );
    const_str_digest_fdf085b4aa3db2edcb0ac6ec965d812f = UNSTREAM_STRING( &constant_bin[ 284219 ], 35, 0 );
    const_str_digest_0847e49017f7c0928080d95a06596ea9 = UNSTREAM_STRING( &constant_bin[ 284254 ], 47, 0 );
    const_str_digest_1f833ba5473a81e2daec7c57c48cde0b = UNSTREAM_STRING( &constant_bin[ 284301 ], 59, 0 );
    const_str_digest_de692aaf1a39dcc9add5cafcc90e7d3a = UNSTREAM_STRING( &constant_bin[ 284360 ], 33, 0 );
    const_str_digest_43f4366fb3942122b01fe9566b3de6f4 = UNSTREAM_STRING( &constant_bin[ 278570 ], 49, 0 );
    const_str_digest_9c42ff6703757defdbe30715d3ba3dc6 = UNSTREAM_STRING( &constant_bin[ 284393 ], 25, 0 );
    const_str_digest_5e3b8e7b3051f5b55143cd8a3ff855dc = UNSTREAM_STRING( &constant_bin[ 284418 ], 24, 0 );
    const_str_digest_bd42d502b75375b7743b4f0e7e57275a = UNSTREAM_STRING( &constant_bin[ 284442 ], 48, 0 );
    const_str_digest_fdc08637b74d20da15803737e5e9a07c = UNSTREAM_STRING( &constant_bin[ 284490 ], 47, 0 );
    const_str_digest_b0f2c883e4b2f3dc22cf5e95533a896c = UNSTREAM_STRING( &constant_bin[ 284537 ], 39, 0 );
    const_str_digest_ef3595b39cc1b9509c09d092b025a8ee = UNSTREAM_STRING( &constant_bin[ 284576 ], 33, 0 );
    const_tuple_a446bcf39958ef92ff15a8277e4ac2b0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_a446bcf39958ef92ff15a8277e4ac2b0_tuple, 0, const_str_plain_return_value ); Py_INCREF( const_str_plain_return_value );
    PyTuple_SET_ITEM( const_tuple_a446bcf39958ef92ff15a8277e4ac2b0_tuple, 1, const_str_digest_fd57353dc0a31a7daca8fb2ea030dee2 ); Py_INCREF( const_str_digest_fd57353dc0a31a7daca8fb2ea030dee2 );
    const_str_digest_c4ea70fe255da0d8650740590bc33b6f = UNSTREAM_STRING( &constant_bin[ 284609 ], 26, 0 );
    const_str_digest_af3a2b1de0c6a92dacaae4dab7ac3804 = UNSTREAM_STRING( &constant_bin[ 284635 ], 43, 0 );
    const_tuple_str_plain_res_str_plain_int_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_res_str_plain_int_tuple, 0, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    PyTuple_SET_ITEM( const_tuple_str_plain_res_str_plain_int_tuple, 1, const_str_plain_int ); Py_INCREF( const_str_plain_int );
    const_str_digest_d992b89f73bdb30671cdd8edd12f6005 = UNSTREAM_STRING( &constant_bin[ 284678 ], 32, 0 );
    const_str_digest_7d80a44ec359229267da8928be763699 = UNSTREAM_STRING( &constant_bin[ 284710 ], 41, 0 );
    const_str_digest_a88fe8d1a8117948a3a9b364ecd8a9bc = UNSTREAM_STRING( &constant_bin[ 284751 ], 45, 0 );
    const_str_digest_b9654f9fe4b2af41c0086d216c9b3f57 = UNSTREAM_STRING( &constant_bin[ 284796 ], 44, 0 );
    const_str_digest_64923e0a83c0602664a31786d52a3e9d = UNSTREAM_STRING( &constant_bin[ 284840 ], 36, 0 );
    const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 1, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 2, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    const_str_digest_382755dd9d7429a7072e416d429886f5 = UNSTREAM_STRING( &constant_bin[ 284876 ], 44, 0 );
    const_str_digest_9b3d45c97ffe4b9a67c136fb1c0d39c4 = UNSTREAM_STRING( &constant_bin[ 284920 ], 36, 0 );
    const_str_digest_037d332b1d32c0d5c23a1d56e4194dea = UNSTREAM_STRING( &constant_bin[ 284956 ], 23, 0 );
    const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple, 1, const_str_plain_constant ); Py_INCREF( const_str_plain_constant );
    PyTuple_SET_ITEM( const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple, 2, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple, 3, const_str_plain_type_name ); Py_INCREF( const_str_plain_type_name );
    const_str_digest_90b2ac0e44b346ffb88bff778c792d92 = UNSTREAM_STRING( &constant_bin[ 284979 ], 30, 0 );
    const_str_digest_300347c1384be8a8687478ff007256b9 = UNSTREAM_STRING( &constant_bin[ 285009 ], 32, 0 );
    const_str_plain_cleanup_names = UNSTREAM_STRING( &constant_bin[ 285041 ], 13, 1 );
    const_str_digest_afa6a7161e70a3534bb104f497fa36d9 = UNSTREAM_STRING( &constant_bin[ 285054 ], 45, 0 );
    const_tuple_3b992cae161038cd22ae814b4c32d389_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_3b992cae161038cd22ae814b4c32d389_tuple, 0, const_str_plain___getattr__ ); Py_INCREF( const_str_plain___getattr__ );
    PyTuple_SET_ITEM( const_tuple_3b992cae161038cd22ae814b4c32d389_tuple, 1, const_str_plain___setattr__ ); Py_INCREF( const_str_plain___setattr__ );
    PyTuple_SET_ITEM( const_tuple_3b992cae161038cd22ae814b4c32d389_tuple, 2, const_str_plain___delattr__ ); Py_INCREF( const_str_plain___delattr__ );
    const_tuple_str_plain_self_str_plain_constant_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_constant_tuple, 1, const_str_plain_constant ); Py_INCREF( const_str_plain_constant );
    const_str_plain_return_name = UNSTREAM_STRING( &constant_bin[ 285099 ], 11, 1 );
    const_tuple_str_plain___cached___str_plain___loader___tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain___cached___str_plain___loader___tuple, 0, const_str_plain___cached__ ); Py_INCREF( const_str_plain___cached__ );
    PyTuple_SET_ITEM( const_tuple_str_plain___cached___str_plain___loader___tuple, 1, const_str_plain___loader__ ); Py_INCREF( const_str_plain___loader__ );
    const_str_digest_57e1f5941d8ec27afcae5a2d53fc2ebf = UNSTREAM_STRING( &constant_bin[ 285110 ], 30, 0 );
    const_str_digest_77c7b66f03bbae96a3d7f48c86745c88 = UNSTREAM_STRING( &constant_bin[ 285140 ], 29, 0 );
    const_str_digest_65ffc191fed0548aa882952f5e9c79f9 = UNSTREAM_STRING( &constant_bin[ 285169 ], 43, 0 );
    const_str_digest_a27dd0d7d26682190808a83e68f41a2f = UNSTREAM_STRING( &constant_bin[ 285212 ], 38, 0 );
    const_str_digest_cd5b021261404c37b8f61a632d02a733 = UNSTREAM_STRING( &constant_bin[ 285250 ], 47, 0 );
    const_str_digest_3665173bc809a481f388f61ffa1b1bc1 = UNSTREAM_STRING( &constant_bin[ 285297 ], 39, 0 );
    const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple, 1, const_str_plain_base_name ); Py_INCREF( const_str_plain_base_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple, 2, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    const_str_digest_6c01341e24783701776f89abd8684492 = UNSTREAM_STRING( &constant_bin[ 285336 ], 30, 0 );
    const_str_plain_Namify = UNSTREAM_STRING( &constant_bin[ 285366 ], 6, 1 );
    const_str_digest_edbae93d98459ae7c9eb8af7b7193e46 = UNSTREAM_STRING( &constant_bin[ 285372 ], 29, 0 );
    const_str_digest_c0705a6cb9a01b5867fb8ce51e6e5e3b = UNSTREAM_STRING( &constant_bin[ 285401 ], 47, 0 );
    const_str_plain_tmp_names = UNSTREAM_STRING( &constant_bin[ 285448 ], 9, 1 );
    const_str_digest_62a779267620479a42cca70c1212f7e4 = UNSTREAM_STRING( &constant_bin[ 285457 ], 28, 0 );
    const_tuple_str_plain_self_str_plain_tmp_name_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tmp_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tmp_name_tuple, 1, const_str_plain_tmp_name ); Py_INCREF( const_str_plain_tmp_name );
    const_str_digest_2968b90b27535ed2b21f551de0759d50 = UNSTREAM_STRING( &constant_bin[ 285485 ], 44, 0 );
    const_str_digest_b1a8cbbad04e282a28abd95e9224b578 = UNSTREAM_STRING( &constant_bin[ 285529 ], 34, 0 );
    const_str_digest_c0326b9017891a796a85e065305d0ced = UNSTREAM_STRING( &constant_bin[ 285563 ], 38, 0 );
    const_str_digest_f0f79a5f9bfcf0fbb0c0effa9839520d = UNSTREAM_STRING( &constant_bin[ 285601 ], 22, 0 );
    const_str_digest_344fd1ad98611e569be84794445a3e7d = UNSTREAM_STRING( &constant_bin[ 285623 ], 43, 0 );
    const_tuple_str_plain_TempMixin_tuple_type_object_tuple_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_TempMixin_tuple_type_object_tuple_tuple, 0, const_str_plain_TempMixin ); Py_INCREF( const_str_plain_TempMixin );
    PyTuple_SET_ITEM( const_tuple_str_plain_TempMixin_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple ); Py_INCREF( const_tuple_type_object_tuple );
    const_tuple_str_plain_self_str_plain_frame_handle_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_handle_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_handle_tuple, 1, const_str_plain_frame_handle ); Py_INCREF( const_str_plain_frame_handle );
    const_str_plain_frame_declarations = UNSTREAM_STRING( &constant_bin[ 285666 ], 18, 1 );
    const_str_digest_4cdb9bc00ce62e3ec47dc004a74507f3 = UNSTREAM_STRING( &constant_bin[ 285684 ], 52, 0 );
    const_str_digest_d7fd14742817cb89f9e613bc0578cd73 = UNSTREAM_STRING( &constant_bin[ 285736 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple, 1, const_str_plain_code_object ); Py_INCREF( const_str_plain_code_object );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple, 2, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    const_str_digest_ce77b93bf9baebf6bd099f4ee0e9423a = UNSTREAM_STRING( &constant_bin[ 285785 ], 26, 0 );
    const_str_digest_8afd3baaf3244cbcd3753c62c0705e40 = UNSTREAM_STRING( &constant_bin[ 285811 ], 23, 0 );
    const_str_plain_preserver_variable_counts = UNSTREAM_STRING( &constant_bin[ 285834 ], 25, 1 );
    const_str_digest_67ca7d3d1f9da51471c81acdf3cc1989 = UNSTREAM_STRING( &constant_bin[ 285859 ], 36, 0 );
    const_str_digest_700c551f886c1e8bdb659afa747b8b81 = UNSTREAM_STRING( &constant_bin[ 285895 ], 49, 0 );
    const_str_digest_356c04499a5502c401c8fb4a5ef9e7f5 = UNSTREAM_STRING( &constant_bin[ 285944 ], 29, 0 );
    const_str_digest_2bfea02cce6dbb334c2151f2711d23f4 = UNSTREAM_STRING( &constant_bin[ 285973 ], 50, 0 );
    const_str_digest_a17c2210ab6063e2443b17d15f0b7260 = UNSTREAM_STRING( &constant_bin[ 286023 ], 31, 0 );
    const_str_digest_e6d81c4ac5540cfd7927cbc32a7fec8e = UNSTREAM_STRING( &constant_bin[ 286054 ], 33, 0 );
    const_str_digest_cb11a3d64d8c17af6ecf3ea5918cd8cf = UNSTREAM_STRING( &constant_bin[ 286087 ], 30, 0 );
    const_str_plain_needs_module_filename_object = UNSTREAM_STRING( &constant_bin[ 286117 ], 28, 1 );
    const_tuple_str_plain_bytes_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bytes_tuple, 0, const_str_plain_bytes ); Py_INCREF( const_str_plain_bytes );
    const_str_digest_3785c5b02b975eee6bd504145377678f = UNSTREAM_STRING( &constant_bin[ 286145 ], 38, 0 );
    const_str_digest_dc2f9ff63062bab5d561c96bac21dc35 = UNSTREAM_STRING( &constant_bin[ 286183 ], 24, 0 );
    const_str_digest_8687966f175199d40968e4bfcf00bb4c = UNSTREAM_STRING( &constant_bin[ 286207 ], 26, 0 );
    const_str_digest_e36decde46776641c89c99776519f544 = UNSTREAM_STRING( &constant_bin[ 286233 ], 41, 0 );
    const_str_digest_e8a76356f3b9c8af74157ada4361c7e5 = UNSTREAM_STRING( &constant_bin[ 286274 ], 35, 0 );
    const_str_digest_f09cea3c42a5b06c37300a17fc8cc6c9 = UNSTREAM_STRING( &constant_bin[ 286309 ], 43, 0 );
    const_str_digest_23422f93eb40a66425e75e64a3122a5e = UNSTREAM_STRING( &constant_bin[ 286352 ], 25, 0 );
    const_tuple_str_plain_self_str_plain_body_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_body_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_body_tuple, 1, const_str_plain_body ); Py_INCREF( const_str_plain_body );
    const_str_plain_loop_break = UNSTREAM_STRING( &constant_bin[ 286377 ], 10, 1 );
    const_str_digest_c679c48f65d794c255401ec1bd4db6f2 = UNSTREAM_STRING( &constant_bin[ 286387 ], 41, 0 );
    const_str_plain_helper_codes = UNSTREAM_STRING( &constant_bin[ 286428 ], 12, 1 );
    const_str_digest_3d722941febc13409bb9dd17980dd7b2 = UNSTREAM_STRING( &constant_bin[ 286440 ], 37, 0 );
    const_str_digest_56d6f8d6f93635fba2f1d030ee12aad5 = UNSTREAM_STRING( &constant_bin[ 286477 ], 39, 0 );
    const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 1, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 2, const_str_plain_base_name ); Py_INCREF( const_str_plain_base_name );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 3, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 4, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    PyTuple_SET_ITEM( const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 5, const_str_plain_tmp_name ); Py_INCREF( const_str_plain_tmp_name );
    const_str_digest_008caa6a1952819819f4e87b68280429 = UNSTREAM_STRING( &constant_bin[ 286516 ], 37, 0 );
    const_tuple_str_plain_self_str_plain_frame_variables_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_variables_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_frame_variables_tuple, 1, const_str_plain_frame_variables ); Py_INCREF( const_str_plain_frame_variables );
    const_tuple_str_plain_site_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_site_tuple, 0, const_str_plain_site ); Py_INCREF( const_str_plain_site );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_codegen$Contexts( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_3de0a0bf0e868e366b136f144a22d3b0;
static PyCodeObject *codeobj_c7075fa0b098e8aa790b3d043f315ca3;
static PyCodeObject *codeobj_f4ce2351b00e0ce552f4c14d83c392e3;
static PyCodeObject *codeobj_e964a1438f89be085a632221056be03e;
static PyCodeObject *codeobj_40cf1bb35fdb9c8653d4a2c9734319c3;
static PyCodeObject *codeobj_421a1e46a9e9caad65d20098cf3f5960;
static PyCodeObject *codeobj_45c666bd5eb5ec6b1395dd9b61ec9933;
static PyCodeObject *codeobj_ce8dbbdab23e99501a4f8b8d0c44e890;
static PyCodeObject *codeobj_ab26b52d74ca01bee050b92a01449059;
static PyCodeObject *codeobj_d392c7b9f3b90fb3dd6cdc42524742b3;
static PyCodeObject *codeobj_27fa39f491c05c261c623c66b96c4cc1;
static PyCodeObject *codeobj_b594da56adba1a1498a3a92440907540;
static PyCodeObject *codeobj_b0a85f471c9ed507afddbbd59b8dec86;
static PyCodeObject *codeobj_3d3abe187d18270ac2a8ce626f258fc6;
static PyCodeObject *codeobj_799ed93275cf11ee83e5b7ceb08f85d2;
static PyCodeObject *codeobj_fae641ec8eec5d068fe3d2c09c05647e;
static PyCodeObject *codeobj_6c7e42fc2655943f084285a0d2beca7a;
static PyCodeObject *codeobj_486b646812c00d76f05648102465b41b;
static PyCodeObject *codeobj_d04ebf6bd401874fd48b1c7091e8d919;
static PyCodeObject *codeobj_2206ecab54a182234641a463879cf13e;
static PyCodeObject *codeobj_1c666778cb70d20ac1d70782a03d8dbf;
static PyCodeObject *codeobj_6616b03b6b092083572f0278ce78197f;
static PyCodeObject *codeobj_ff8880cfcc099c1b7f4d600a34e00055;
static PyCodeObject *codeobj_a0ef32db630ee7ffab650705f82949c8;
static PyCodeObject *codeobj_59a17da53e33902710c637e22db4c9b1;
static PyCodeObject *codeobj_2777fa368a6d504ba4aea9a4f87a5412;
static PyCodeObject *codeobj_08b55f1c830914b1c00bb1fbb8d5e0e1;
static PyCodeObject *codeobj_a880a57d69225bd871448e0e669fbddb;
static PyCodeObject *codeobj_d53cfde73f72214ed37edab3336cb686;
static PyCodeObject *codeobj_d1140159ac5a2635ab9d67bd3668ed3d;
static PyCodeObject *codeobj_19354f51df5d22d64f453b358453021a;
static PyCodeObject *codeobj_ccf29b7ee74112863a6d491d6ec142c0;
static PyCodeObject *codeobj_e3c6e6d8bb7af7f501ea790a81f35acc;
static PyCodeObject *codeobj_613a6bbb05a901dd8b334f4a997d5bc5;
static PyCodeObject *codeobj_85e21af2194bee806e06cec22bd6a1aa;
static PyCodeObject *codeobj_7eaad5cd6e9a3020f306eeeaadae319e;
static PyCodeObject *codeobj_400a54fbda0b9175da9ab7297c4d8602;
static PyCodeObject *codeobj_40d22dd518c0b73c1b417580ffaf0490;
static PyCodeObject *codeobj_93e628b68fd76d7a819dc42f0e39ccca;
static PyCodeObject *codeobj_e0086fb7b6654192c83c3e220cf1b3aa;
static PyCodeObject *codeobj_123a6f951e965e6fb7230426dd617881;
static PyCodeObject *codeobj_0d6215760e5a9758515b53993f3d3c33;
static PyCodeObject *codeobj_48f8ffbaefbbfeea20a2a0e4cbdf97f6;
static PyCodeObject *codeobj_3ea37739a94a8673680bdc0143fe787d;
static PyCodeObject *codeobj_c7640666dea5664bfa1e5cf63b3c9d8d;
static PyCodeObject *codeobj_5db4abeaa8c0925e341eca632b344412;
static PyCodeObject *codeobj_a8e8f43fad7d6a884e735dcde5ecdc85;
static PyCodeObject *codeobj_3ee379237e2305259cec4dab3e46caf3;
static PyCodeObject *codeobj_1a6088137005dcdc22495df50b45ac40;
static PyCodeObject *codeobj_c930f80771924b211918f96bdbee2bdb;
static PyCodeObject *codeobj_c032e014639a5201ab6ce13b4ab904b1;
static PyCodeObject *codeobj_32e8717831f25acd24b268462c12b153;
static PyCodeObject *codeobj_aa625e5bde3b7485c41350c37ff67f2a;
static PyCodeObject *codeobj_e5debafd2ef2b4e74f48417bf9d35ade;
static PyCodeObject *codeobj_289d35c36f0d3170b0bfd7889bb96aec;
static PyCodeObject *codeobj_18531e2c3df21d06d06b3440746610a9;
static PyCodeObject *codeobj_c41cb4a985460523df9fca9f52e03756;
static PyCodeObject *codeobj_976dcc88b248a86fafc0bfcdfb26be3c;
static PyCodeObject *codeobj_18eac65d2d920f5f38b85e7f4ef610c7;
static PyCodeObject *codeobj_3ce00aefad6d38d30ea6233871152475;
static PyCodeObject *codeobj_77c61d5bd22dcc42f21df1f71a44aea1;
static PyCodeObject *codeobj_7258131e4814e657599d76c2db3de494;
static PyCodeObject *codeobj_510e6c497cbb49b08de7170063f94e4e;
static PyCodeObject *codeobj_63fe25d792e86d16301c9159503968b8;
static PyCodeObject *codeobj_41dcb69da7bdde8dd50557005a6d275e;
static PyCodeObject *codeobj_fa6abd275388513d61e5b9c564027913;
static PyCodeObject *codeobj_005a5c350706bb96d64cf7bfa995f5a7;
static PyCodeObject *codeobj_3b679cd95e3a31562535f2691a8b80ed;
static PyCodeObject *codeobj_c7c67814bd691dfa70eb9aac797832b3;
static PyCodeObject *codeobj_5ad6fde19e8b5c9b68323260584b0de7;
static PyCodeObject *codeobj_d695ea0bd890a59839886611b81768e6;
static PyCodeObject *codeobj_0d7b531e9016f557c16c8d652d9e7c59;
static PyCodeObject *codeobj_8ceab6ad3a6a956eae170d8b6b7a9594;
static PyCodeObject *codeobj_0775874c728351eae1d857552f127a9a;
static PyCodeObject *codeobj_fae54a9f06e0ed034c5de9b4ee7af97d;
static PyCodeObject *codeobj_a21b52799fd40d6cddeda3aff6401c83;
static PyCodeObject *codeobj_d4a852c96da0e1bef940ac0123a460db;
static PyCodeObject *codeobj_6f603200238b09ef26c50ca74a7a3ca3;
static PyCodeObject *codeobj_f3b6ad571f323c66dedac13a51fcc3aa;
static PyCodeObject *codeobj_ab5f0102d0ffd0cd21a6d2012cd290dc;
static PyCodeObject *codeobj_68228c0be8b8808971465d0a1408a345;
static PyCodeObject *codeobj_08a0ffcb553873f9109c5535422adcc6;
static PyCodeObject *codeobj_0720f22b9189e028227fd16c8ef29ce6;
static PyCodeObject *codeobj_480190d8a56a895a45640015b8023065;
static PyCodeObject *codeobj_b1892c8848832e71a89f357e844f61ae;
static PyCodeObject *codeobj_e34dd389195b9b5d05ef8e27ef774772;
static PyCodeObject *codeobj_246089cfed5fbe1fdb5587fa09925e84;
static PyCodeObject *codeobj_fa62dfe2689c2cca55df838ea54b38f1;
static PyCodeObject *codeobj_ecbb3e58cf1a324d3fee77f80485d062;
static PyCodeObject *codeobj_e8f19c2b9290c9456f79bbc3dfb9d448;
static PyCodeObject *codeobj_a11729747c4562fc817aa06514420ea3;
static PyCodeObject *codeobj_baccea888939a034905427023ae07b09;
static PyCodeObject *codeobj_12167aea291207bc873ca5cc89cf807a;
static PyCodeObject *codeobj_ccbc97c6110016c7171355558be21fbd;
static PyCodeObject *codeobj_c8d2336e16342fea05bbf0081149a358;
static PyCodeObject *codeobj_10f7bdb9ae2bc054a9c0c263ad83cc9a;
static PyCodeObject *codeobj_21f739fea84c01208bf5eb23a1cf98c5;
static PyCodeObject *codeobj_0dffe05d8b6ce6b1c521696575d86a6e;
static PyCodeObject *codeobj_d54eb5ba5893d1ae05af5148e04a0656;
static PyCodeObject *codeobj_d1388dd4214b2fc52f21d3b0d26f5934;
static PyCodeObject *codeobj_d7d44a047d7778e18ffd841c6272c8a7;
static PyCodeObject *codeobj_31a12923b2304b2b93b956f8d0cb3abe;
static PyCodeObject *codeobj_75b89845119f8c8005f380471373e6dc;
static PyCodeObject *codeobj_127c51962806469f83c7f9a0745fb87d;
static PyCodeObject *codeobj_207104a18d78f5ed6b253d8b4b459bfc;
static PyCodeObject *codeobj_a2f3e46eb4b8fab13824777627e278b6;
static PyCodeObject *codeobj_90e7eac2a5f70c5cb1e6755566df31af;
static PyCodeObject *codeobj_abb448aafa670c9e0c7e7828b119b318;
static PyCodeObject *codeobj_16516945308d0a5395abe7708ab9ebb3;
static PyCodeObject *codeobj_8d42c686e4a517ffb33aa31922634976;
static PyCodeObject *codeobj_98cffa7b5c3321bba0e3b3b4dbdebdbc;
static PyCodeObject *codeobj_28b5f5dfc9237b6e4c4c44c7cd214134;
static PyCodeObject *codeobj_9789c7a9a1b96341f824bcd892fd6fc8;
static PyCodeObject *codeobj_7c8a5be6be74a118fe62e7b98ec5a9dd;
static PyCodeObject *codeobj_5873edf1802cd7b348b13d18cd21bd1e;
static PyCodeObject *codeobj_a8d22b33c3f6a04ca0441835b99858b8;
static PyCodeObject *codeobj_ca788999b2bab9557a685cdad355065e;
static PyCodeObject *codeobj_7ba49a81baaa679e56580a3c99359313;
static PyCodeObject *codeobj_9d77b296fdbd4ff057d1c68f0611810d;
static PyCodeObject *codeobj_04de0bdd770837d7f5241aa4307407c5;
static PyCodeObject *codeobj_5ead817b54d2298e0d2090f7ad673419;
static PyCodeObject *codeobj_2897788a6282b03b8e14bfd7bf173c6c;
static PyCodeObject *codeobj_aacc4e70971f38d612ad85ce26f10578;
static PyCodeObject *codeobj_63608cdfddc117fbbbd31d7e1d31905d;
static PyCodeObject *codeobj_8f30b9d54479a733f44d394bf922d625;
static PyCodeObject *codeobj_6d1671c5ceb048fda74df856cbe3cb42;
static PyCodeObject *codeobj_1dc5c3c7f783016616c31176f5a18b1e;
static PyCodeObject *codeobj_2940b3916d417f563bbc9fd5b3454d3a;
static PyCodeObject *codeobj_110f78dca44d50f35817a88c63803340;
static PyCodeObject *codeobj_e3bfb88b743c357810841524ae9a785b;
static PyCodeObject *codeobj_cef9045d2b139705558e7cf485ca9fed;
static PyCodeObject *codeobj_e4a1a975a42152ea18e2086b7d1fa099;
static PyCodeObject *codeobj_91c274ed8c779e361411af5e2a005341;
static PyCodeObject *codeobj_0b8aff2b67bd850d7a94360575b83331;
static PyCodeObject *codeobj_7cf25d12e8eafbe4cc9261e4240505c2;
static PyCodeObject *codeobj_6a911389a85e2285f16b7e383cb2cc90;
static PyCodeObject *codeobj_93fbb8e78e1c1e542ed28c23238b843a;
static PyCodeObject *codeobj_10153a387e306c78fb2c8f8c19993ab4;
static PyCodeObject *codeobj_52265f0f9c5f7a05f5e1456e052b9e62;
static PyCodeObject *codeobj_95f24e5d6299d1570dfff6c07cb8ddc0;
static PyCodeObject *codeobj_ac1b8b2a3510b8b6fb20c92646b3a0c6;
static PyCodeObject *codeobj_177a9713a5382a6b4e6ae137a3cc5bc8;
static PyCodeObject *codeobj_dbbd5fda9f1254551c0fb70f409d3e16;
static PyCodeObject *codeobj_444dad8cfb1dc0e5631f164cb9cb7400;
static PyCodeObject *codeobj_2a5236b378b84e3ed78714dd0cc21dbc;
static PyCodeObject *codeobj_d775eb951e8acbf39f0107df6ba117a4;
static PyCodeObject *codeobj_c4f76c9457a95c8629cda68ea00fbd20;
static PyCodeObject *codeobj_48364e2a74d45ea733ddce4841f7fd1c;
static PyCodeObject *codeobj_44eb22fce37e611bb4f0e50131926be1;
static PyCodeObject *codeobj_3d90a84f25de934ac6d35312780bedee;
static PyCodeObject *codeobj_c180803f2ed4cac44b4083fd3f86f6a5;
static PyCodeObject *codeobj_c9da538500192f015102f0acb10bd9be;
static PyCodeObject *codeobj_99cfb1922f7d39cea221a50095787761;
static PyCodeObject *codeobj_effca39acf7537335eca7e16bd4108b6;
static PyCodeObject *codeobj_2039fc5753d46c59ecc59d1e891b40f3;
static PyCodeObject *codeobj_cb055aa1fed9fd9bd4ae8d63750c7904;
static PyCodeObject *codeobj_5aced0946905314d67dc30b7cc4ba622;
static PyCodeObject *codeobj_2044b140be824528f2820f598d0af4f7;
static PyCodeObject *codeobj_29f7c3b38e6d53a40a956a20b16d6a34;
static PyCodeObject *codeobj_9efc0faceb0e8844bc6c15dfe746edb6;
static PyCodeObject *codeobj_ae4b8267deb3d26ce0c7eb76803f3d17;
static PyCodeObject *codeobj_dcf379d7f6b136958531782e123734ed;
static PyCodeObject *codeobj_7a2a8e63c9a4a219a6492c9a00590253;
static PyCodeObject *codeobj_fbe6e3f473c148ab130adb7dbc9a3930;
static PyCodeObject *codeobj_7ee471b65ba840a9274147fd818068ec;
static PyCodeObject *codeobj_965b732c40016204a19a42cfa9fb8934;
static PyCodeObject *codeobj_03fe2f29eeaf1b6c13e3bbff28f413d7;
static PyCodeObject *codeobj_32d328860bd7a4295a84b2f4aee8dc2b;
static PyCodeObject *codeobj_d4fc9340eeaa4816566dd22c485b1649;
static PyCodeObject *codeobj_481359ae921de5d7cd6a8e86fa6bab1d;
static PyCodeObject *codeobj_73a198267b8f72d47574b1f82e0719e6;
static PyCodeObject *codeobj_b565aa4c14f8fadd1cc440ee24825913;
static PyCodeObject *codeobj_7bfaf8f94c79d7bb59ed1e69d078e4d7;
static PyCodeObject *codeobj_13d2f0d69592eadd21dabc1c3ed96b0e;
static PyCodeObject *codeobj_e7b576ee4c7a5c9fc0ce06af7f7931e0;
static PyCodeObject *codeobj_b0d590703165fda438f2da3aacbe7d2d;
static PyCodeObject *codeobj_77c444ca8dca0610c5acf3f13bb1614a;
static PyCodeObject *codeobj_60f4102fc3fe690ec05ebdd92da25085;
static PyCodeObject *codeobj_88e960102132df69b1bf74e42693142a;
static PyCodeObject *codeobj_8dac2dd25f484b6fbafc57bac1df13f7;
static PyCodeObject *codeobj_506b8e6a8b5a824731eeeb15d36723bb;
static PyCodeObject *codeobj_6ff4954f4c5834ba3a15403825cd3927;
static PyCodeObject *codeobj_fd30e95d7240c9a202d3e86b9cc66759;
static PyCodeObject *codeobj_fbe2a55516c1146765544ec27bca7c43;
static PyCodeObject *codeobj_b278eb993f98bbc79fe6a60b92219ea8;
static PyCodeObject *codeobj_9e0a9ab898ad06ae88ce9151dade15d4;
static PyCodeObject *codeobj_3418a410b97e4041bebb9c5903bf4509;
static PyCodeObject *codeobj_279c6ac248d6c8229d505a9997d1a146;
static PyCodeObject *codeobj_0635b043d9d9da0611a172be20832e3c;
static PyCodeObject *codeobj_8b7e56d94d9f72d48d449f61dca25c56;
static PyCodeObject *codeobj_02dfe0aee0348ef048c777d56d4a31b5;
static PyCodeObject *codeobj_ec6404e2172c5be8f927926822edfaae;
static PyCodeObject *codeobj_f3b1d16b097f5d8492f39777ee3e5e98;
static PyCodeObject *codeobj_45d881e87ed34ede0a5375de19ee372a;
static PyCodeObject *codeobj_5edf0029e317204c2f87493cebac3dd6;
static PyCodeObject *codeobj_c20a736617c75414f4021a5a879f2f04;
static PyCodeObject *codeobj_1979d68cf3efafb6570219d9b631a4ae;
static PyCodeObject *codeobj_faf0faf3e3ec0767046b0fd2c7d2d995;
static PyCodeObject *codeobj_27b8f23b5afbde7937db11a3c1152e92;
static PyCodeObject *codeobj_654b29fe95db02fc79a3d82f282749b2;
static PyCodeObject *codeobj_880b697f323251673cdcbabbac586b78;
static PyCodeObject *codeobj_6c45637dccab2f4fca178cc695aa3ea3;
static PyCodeObject *codeobj_992161e4a323a8379d54e03131a47bfc;
static PyCodeObject *codeobj_9cfed625fb66042ae350c88c741f7122;
static PyCodeObject *codeobj_56ffd0795b86a54640ed68201fec27ae;
static PyCodeObject *codeobj_724fba5810b7acf38fda1cc2f0b5c1e6;
static PyCodeObject *codeobj_4c6120df83a9dbf8ff1e54c044cc7f3a;
static PyCodeObject *codeobj_02944e336bec971fc1e13809d923d826;
static PyCodeObject *codeobj_af763aa9b8f7990b27f16cc4e3308fdf;
static PyCodeObject *codeobj_e8c27ad0792b99a8ee8459e88b6a9011;
static PyCodeObject *codeobj_39aa69e44c2541146519c4855420db06;
static PyCodeObject *codeobj_27ec5ae7c651087046c1d05725307a23;
static PyCodeObject *codeobj_b960f5882c5ec8c26d803081a724846d;
static PyCodeObject *codeobj_67dfd733f52487a7c4d36642ce19b712;
static PyCodeObject *codeobj_853421309d4f32df28d83b518c6517b1;
static PyCodeObject *codeobj_8a73adcf3cfe40ef45962ca8da9ad7b0;
static PyCodeObject *codeobj_18cf21dc66bd30fd6968cbd2e996eb14;
static PyCodeObject *codeobj_621066726fe1091c06922280efd94ece;
static PyCodeObject *codeobj_c57ff65d7609b04f11302060074276cb;
static PyCodeObject *codeobj_19d9a6aa5f8decfa87b27417a66f16d8;
static PyCodeObject *codeobj_d6fa1a058f407c200a6dfa1b40ebb1e4;
static PyCodeObject *codeobj_d9b1ec8ba2549aca9e21f996e90c7f4d;
static PyCodeObject *codeobj_c7a4bc4a6885f31a13c4655359e3c6fd;
static PyCodeObject *codeobj_f2e1337788de1cc3038b91d47ad9bb11;
static PyCodeObject *codeobj_4c820eb09910985e593218325029b18a;
static PyCodeObject *codeobj_8e47898037383dd96d5f512fcc78d56c;
static PyCodeObject *codeobj_4fd0fc1c3c1f8c2a276b2b063220e476;
static PyCodeObject *codeobj_87b218ddf91dac49519b4a8ec3f78958;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_125f5277815f5b7d7e6feb17e062156d;
    codeobj_3de0a0bf0e868e366b136f144a22d3b0 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 897, const_tuple_bad5e3d4cc3e0b6c8c4fc2c004e19a74_tuple, 1, 0, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c7075fa0b098e8aa790b3d043f315ca3 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 869, const_tuple_str_plain_i_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f4ce2351b00e0ce552f4c14d83c392e3 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_432e03233e910c077a0c0791042b8b37, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_e964a1438f89be085a632221056be03e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CodeObjectsMixin, 266, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_40cf1bb35fdb9c8653d4a2c9734319c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_FrameDeclarationsMixin, 823, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_421a1e46a9e9caad65d20098cf3f5960 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonAsyncgenObjectContext, 1159, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_45c666bd5eb5ec6b1395dd9b61ec9933 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonChildContextBase, 511, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_ce8dbbdab23e99501a4f8b8d0c44e890 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonContextBase, 312, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_ab26b52d74ca01bee050b92a01449059 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonCoroutineObjectContext, 1154, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_d392c7b9f3b90fb3dd6cdc42524742b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonFunctionContext, 1073, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_27fa39f491c05c261c623c66b96c4cc1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonFunctionCreatedContext, 1164, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_b594da56adba1a1498a3a92440907540 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonFunctionDirectContext, 1115, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_b0a85f471c9ed507afddbbd59b8dec86 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonFunctionOutlineContext, 1173, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_3d3abe187d18270ac2a8ce626f258fc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonGeneratorObjectContext, 1126, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_799ed93275cf11ee83e5b7ceb08f85d2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonGlobalContext, 738, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_fae641ec8eec5d068fe3d2c09c05647e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PythonModuleContext, 968, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_6c7e42fc2655943f084285a0d2beca7a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ReturnReleaseModeMixin, 927, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_486b646812c00d76f05648102465b41b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ReturnValueNameMixin, 950, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_d04ebf6bd401874fd48b1c7091e8d919 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_TempMixin, 54, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_2206ecab54a182234641a463879cf13e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 58, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1c666778cb70d20ac1d70782a03d8dbf = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 267, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6616b03b6b092083572f0278ce78197f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 313, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ff8880cfcc099c1b7f4d600a34e00055 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 514, const_tuple_str_plain_self_str_plain_parent_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a0ef32db630ee7ffab650705f82949c8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 739, const_tuple_str_plain_self_str_plain_constant_str_plain_code_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_59a17da53e33902710c637e22db4c9b1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 824, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2777fa368a6d504ba4aea9a4f87a5412 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 928, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_08b55f1c830914b1c00bb1fbb8d5e0e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 951, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a880a57d69225bd871448e0e669fbddb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 972, const_tuple_60536d512e7395e2cfe11459ddd28893_tuple, 6, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d53cfde73f72214ed37edab3336cb686 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1074, const_tuple_str_plain_self_str_plain_parent_str_plain_function_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d1140159ac5a2635ab9d67bd3668ed3d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1174, const_tuple_str_plain_self_str_plain_parent_str_plain_outline_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_19354f51df5d22d64f453b358453021a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 999, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ccf29b7ee74112863a6d491d6ec142c0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1092, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e3c6e6d8bb7af7f501ea790a81f35acc = MAKE_CODEOBJ( module_filename_obj, const_str_plain__calcHash, 297, const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_613a6bbb05a901dd8b334f4a997d5bc5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__calcHash, 304, const_tuple_str_plain_self_str_plain_key_str_plain_hash_value_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_85e21af2194bee806e06cec22bd6a1aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__getConstantDefaultPopulation, 556, const_tuple_str_plain_result_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7eaad5cd6e9a3020f306eeeaadae319e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addCleanupTempName, 246, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_400a54fbda0b9175da9ab7297c4d8602 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addCleanupTempName, 490, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_NOFREE );
    codeobj_40d22dd518c0b73c1b417580ffaf0490 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addCleanupTempName, 1204, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_93e628b68fd76d7a819dc42f0e39ccca = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addDeclaration, 365, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_NOFREE );
    codeobj_e0086fb7b6654192c83c3e220cf1b3aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addDeclaration, 534, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_123a6f951e965e6fb7230426dd617881 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addDeclaration, 1041, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d6215760e5a9758515b53993f3d3c33 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addExceptionPreserverVariables, 227, const_tuple_str_plain_self_str_plain_count_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_48f8ffbaefbbfeea20a2a0e4cbdf97f6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addExceptionPreserverVariables, 466, const_tuple_str_plain_self_str_plain_count_tuple, 2, 0, CO_NOFREE );
    codeobj_3ea37739a94a8673680bdc0143fe787d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addExceptionPreserverVariables, 1299, const_tuple_str_plain_self_str_plain_count_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c7640666dea5664bfa1e5cf63b3c9d8d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addFrameDeclaration, 864, const_tuple_str_plain_self_str_plain_frame_decl_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5db4abeaa8c0925e341eca632b344412 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addFrameDeclaration, 1285, const_tuple_str_plain_self_str_plain_frame_decl_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8e8f43fad7d6a884e735dcde5ecdc85 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addHelperCode, 357, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_NOFREE );
    codeobj_3ee379237e2305259cec4dab3e46caf3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addHelperCode, 528, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1a6088137005dcdc22495df50b45ac40 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addHelperCode, 1030, const_tuple_str_plain_self_str_plain_key_str_plain_code_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c930f80771924b211918f96bdbee2bdb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addLocalsDictName, 923, const_tuple_str_plain_self_str_plain_locals_dict_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c032e014639a5201ab6ce13b4ab904b1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_addLocalsDictName, 1296, const_tuple_str_plain_self_str_plain_locals_dict_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_32e8717831f25acd24b268462c12b153 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateExceptionKeeperVariables, 203, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aa625e5bde3b7485c41350c37ff67f2a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateExceptionKeeperVariables, 454, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_e5debafd2ef2b4e74f48417bf9d35ade = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateExceptionKeeperVariables, 1282, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_289d35c36f0d3170b0bfd7889bb96aec = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateLabel, 184, const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_18531e2c3df21d06d06b3440746610a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateLabel, 442, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_c41cb4a985460523df9fca9f52e03756 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateLabel, 1191, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_976dcc88b248a86fafc0bfcdfb26be3c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateTempName, 93, const_tuple_1030a72de6da2f553a9a5914d274acfb_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_18eac65d2d920f5f38b85e7f4ef610c7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateTempName, 393, const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 4, 0, CO_NOFREE );
    codeobj_3ce00aefad6d38d30ea6233871152475 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_allocateTempName, 1194, const_tuple_4b28ac162cb81133f72222fb4e057d22_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_77c61d5bd22dcc42f21df1f71a44aea1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_countConstantUse, 810, const_tuple_str_plain_self_str_plain_constant_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7258131e4814e657599d76c2db3de494 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_forgetTempName, 123, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_510e6c497cbb49b08de7170063f94e4e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_forgetTempName, 410, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_NOFREE );
    codeobj_63fe25d792e86d16301c9159503968b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_forgetTempName, 1305, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_41dcb69da7bdde8dd50557005a6d275e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_formatTempName, 82, const_tuple_str_plain_self_str_plain_base_name_str_plain_number_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fa6abd275388513d61e5b9c564027913 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getBoolResName, 117, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_005a5c350706bb96d64cf7bfa995f5a7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getBoolResName, 402, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_3b679cd95e3a31562535f2691a8b80ed = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getBoolResName, 1273, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c7c67814bd691dfa70eb9aac797832b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCleanupTempnames, 243, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5ad6fde19e8b5c9b68323260584b0de7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCleanupTempnames, 486, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_d695ea0bd890a59839886611b81768e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCleanupTempnames, 1201, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d7b531e9016f557c16c8d652d9e7c59 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCodeObjectHandle, 274, const_tuple_str_plain_self_str_plain_code_object_str_plain_key_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8ceab6ad3a6a956eae170d8b6b7a9594 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCodeObjectHandle, 1111, const_tuple_str_plain_self_str_plain_code_object_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0775874c728351eae1d857552f127a9a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCodeObjectHandle, 1219, const_tuple_str_plain_self_str_plain_code_object_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fae54a9f06e0ed034c5de9b4ee7af97d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCodeObjects, 271, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a21b52799fd40d6cddeda3aff6401c83 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstantCode, 345, const_tuple_str_plain_self_str_plain_constant_tuple, 2, 0, CO_NOFREE );
    codeobj_d4a852c96da0e1bef940ac0123a460db = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstantCode, 519, const_tuple_str_plain_self_str_plain_constant_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f603200238b09ef26c50ca74a7a3ca3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstantCode, 752, const_tuple_c7270c0b3d6a1408324a969e4d85ed60_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f3b6ad571f323c66dedac13a51fcc3aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstantCode, 1052, const_tuple_str_plain_self_str_plain_constant_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ab5f0102d0ffd0cd21a6d2012cd290dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstantUseCount, 816, const_tuple_str_plain_self_str_plain_constant_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68228c0be8b8808971465d0a1408a345 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstants, 819, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_08a0ffcb553873f9109c5535422adcc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getConstants, 1061, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0720f22b9189e028227fd16c8ef29ce6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getContextObjectName, 1136, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_480190d8a56a895a45640015b8023065 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getContextObjectName, 1155, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b1892c8848832e71a89f357e844f61ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getContextObjectName, 1160, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e34dd389195b9b5d05ef8e27ef774772 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getContextObjectName, 1308, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_246089cfed5fbe1fdb5587fa09925e84 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCurrentSourceCodeReference, 322, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fa62dfe2689c2cca55df838ea54b38f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getDeclarations, 1046, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ecbb3e58cf1a324d3fee77f80485d062 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getEntryPoint, 1005, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e8f19c2b9290c9456f79bbc3dfb9d448 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getEntryPoint, 1104, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a11729747c4562fc817aa06514420ea3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getEntryPoint, 1188, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_baccea888939a034905427023ae07b09 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionEscape, 160, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_12167aea291207bc873ca5cc89cf807a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionEscape, 418, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_ccbc97c6110016c7171355558be21fbd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionEscape, 1222, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c8d2336e16342fea05bbf0081149a358 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionKeeperVariables, 216, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10f7bdb9ae2bc054a9c0c263ad83cc9a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionKeeperVariables, 458, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_21f739fea84c01208bf5eb23a1cf98c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionKeeperVariables, 1261, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0dffe05d8b6ce6b1c521696575d86a6e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExceptionPreserverCounts, 224, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d54eb5ba5893d1ae05af5148e04a0656 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFalseBranchTarget, 234, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d1388dd4214b2fc52f21d3b0d26f5934 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFalseBranchTarget, 474, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_d7d44a047d7778e18ffd841c6272c8a7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFalseBranchTarget, 1243, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_31a12923b2304b2b93b956f8d0cb3abe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFilename, 1014, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_75b89845119f8c8005f380471373e6dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameDeclarations, 867, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_127c51962806469f83c7f9a0745fb87d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameHandle, 843, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_207104a18d78f5ed6b253d8b4b459bfc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameHandle, 1252, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a2f3e46eb4b8fab13824777627e278b6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableCodeNames, 389, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_90e7eac2a5f70c5cb1e6755566df31af = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableCodeNames, 552, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_abb448aafa670c9e0c7e7828b119b318 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableCodeNames, 907, const_tuple_4a5c35b461b84b87ca3ce9e92f7250e3_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_16516945308d0a5395abe7708ab9ebb3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescription, 381, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_8d42c686e4a517ffb33aa31922634976 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescription, 546, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_98cffa7b5c3321bba0e3b3b4dbdebdbc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescription, 895, const_tuple_str_plain_self_str_plain_result_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_28b5f5dfc9237b6e4c4c44c7cd214134 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptionName, 385, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_9789c7a9a1b96341f824bcd892fd6fc8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptionName, 549, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7c8a5be6be74a118fe62e7b98ec5a9dd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptionName, 892, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5873edf1802cd7b348b13d18cd21bd1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptions, 377, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_a8d22b33c3f6a04ca0441835b99858b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptions, 543, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ca788999b2bab9557a685cdad355065e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFrameVariableTypeDescriptions, 889, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ba49a81baaa679e56580a3c99359313 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFramesCount, 861, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9d77b296fdbd4ff057d1c68f0611810d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFunction, 1098, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_04de0bdd770837d7f5241aa4307407c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getGeneratorReturnValueName, 1139, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5ead817b54d2298e0d2090f7ad673419 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getHelperCodes, 1038, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2897788a6282b03b8e14bfd7bf173c6c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIntResName, 114, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aacc4e70971f38d612ad85ce26f10578 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIntResName, 398, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_63608cdfddc117fbbbd31d7e1d31905d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIntResName, 1270, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8f30b9d54479a733f44d394bf922d625 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getKeeperVariableCount, 213, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6d1671c5ceb048fda74df856cbe3cb42 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLabelCount, 194, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1dc5c3c7f783016616c31176f5a18b1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLastSourceCodeReference, 334, const_tuple_str_plain_self_str_plain_result_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2940b3916d417f563bbc9fd5b3454d3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLocalsDictNames, 920, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_110f78dca44d50f35817a88c63803340 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopBreakTarget, 168, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e3bfb88b743c357810841524ae9a785b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopBreakTarget, 426, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_cef9045d2b139705558e7cf485ca9fed = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopBreakTarget, 1228, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e4a1a975a42152ea18e2086b7d1fa099 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopContinueTarget, 176, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_91c274ed8c779e361411af5e2a005341 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopContinueTarget, 434, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_0b8aff2b67bd850d7a94360575b83331 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getLoopContinueTarget, 1234, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7cf25d12e8eafbe4cc9261e4240505c2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getModuleCodeName, 349, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_6a911389a85e2285f16b7e383cb2cc90 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getModuleCodeName, 522, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_93fbb8e78e1c1e542ed28c23238b843a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getModuleCodeName, 1024, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10153a387e306c78fb2c8f8c19993ab4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getModuleName, 353, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_52265f0f9c5f7a05f5e1456e052b9e62 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getModuleName, 525, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95f24e5d6299d1570dfff6c07cb8ddc0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getName, 1011, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ac1b8b2a3510b8b6fb20c92646b3a0c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getOwner, 1002, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_177a9713a5382a6b4e6ae137a3cc5bc8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getOwner, 1101, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbbd5fda9f1254551c0fb70f409d3e16 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getOwner, 1185, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_444dad8cfb1dc0e5631f164cb9cb7400 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getReturnReleaseMode, 938, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2a5236b378b84e3ed78714dd0cc21dbc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getReturnTarget, 946, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d775eb951e8acbf39f0107df6ba117a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getReturnValueName, 954, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c4f76c9457a95c8629cda68ea00fbd20 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTempNameInfos, 126, const_tuple_e6ee39258ba4a508def4c14c0271daac_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_48364e2a74d45ea733ddce4841f7fd1c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTempNameInfos, 414, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_44eb22fce37e611bb4f0e50131926be1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTempNameInfos, 1302, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3d90a84f25de934ac6d35312780bedee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTrueBranchTarget, 231, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c180803f2ed4cac44b4083fd3f86f6a5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTrueBranchTarget, 470, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_c9da538500192f015102f0acb10bd9be = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTrueBranchTarget, 1240, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_99cfb1922f7d39cea221a50095787761 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasHelperCode, 361, const_tuple_str_plain_self_str_plain_key_tuple, 2, 0, CO_NOFREE );
    codeobj_effca39acf7537335eca7e16bd4108b6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasHelperCode, 531, const_tuple_str_plain_self_str_plain_key_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2039fc5753d46c59ecc59d1e891b40f3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasHelperCode, 1035, const_tuple_str_plain_self_str_plain_key_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cb055aa1fed9fd9bd4ae8d63750c7904 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasTempName, 120, const_tuple_str_plain_self_str_plain_base_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5aced0946905314d67dc30b7cc4ba622 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasTempName, 406, const_tuple_str_plain_self_str_plain_base_name_tuple, 2, 0, CO_NOFREE );
    codeobj_2044b140be824528f2820f598d0af4f7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasTempName, 1198, const_tuple_str_plain_self_str_plain_base_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_29f7c3b38e6d53a40a956a20b16d6a34 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isCompiledPythonModule, 1008, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9efc0faceb0e8844bc6c15dfe746edb6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForCreatedFunction, 1122, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ae4b8267deb3d26ce0c7eb76803f3d17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForCreatedFunction, 1133, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dcf379d7f6b136958531782e123734ed = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForCreatedFunction, 1168, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7a2a8e63c9a4a219a6492c9a00590253 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForCrossModuleUsage, 1119, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fbe6e3f473c148ab130adb7dbc9a3930 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForCrossModuleUsage, 1130, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ee471b65ba840a9274147fd818068ec = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForDirectCall, 1116, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_965b732c40016204a19a42cfa9fb8934 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForDirectCall, 1127, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_03fe2f29eeaf1b6c13e3bbff28f413d7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForDirectCall, 1165, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_32d328860bd7a4295a84b2f4aee8dc2b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isForDirectCall, 1288, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d4fc9340eeaa4816566dd22c485b1649 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isUsed, 339, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_481359ae921de5d7cd6a8e86fa6bab1d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_markAsNeedsExceptionVariables, 200, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_73a198267b8f72d47574b1f82e0719e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_markAsNeedsExceptionVariables, 450, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_b565aa4c14f8fadd1cc440ee24825913 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_markAsNeedsExceptionVariables, 1279, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7bfaf8f94c79d7bb59ed1e69d078e4d7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_markAsNeedsModuleFilenameObject, 1064, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_13d2f0d69592eadd21dabc1c3ed96b0e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_mayRaiseException, 1017, const_tuple_str_plain_self_str_plain_body_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e7b576ee4c7a5c9fc0ce06af7f7931e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_mayRecurse, 1049, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b0d590703165fda438f2da3aacbe7d2d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_mayRecurse, 1107, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_77c444ca8dca0610c5acf3f13bb1614a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_mayRecurse, 1291, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_60f4102fc3fe690ec05ebdd92da25085 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsCleanup, 255, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_88e960102132df69b1bf74e42693142a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsCleanup, 498, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_NOFREE );
    codeobj_8dac2dd25f484b6fbafc57bac1df13f7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsCleanup, 1210, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_506b8e6a8b5a824731eeeb15d36723bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsExceptionVariables, 197, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6ff4954f4c5834ba3a15403825cd3927 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsExceptionVariables, 446, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_fd30e95d7240c9a202d3e86b9cc66759 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsExceptionVariables, 1276, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fbe2a55516c1146765544ec27bca7c43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_needsModuleFilenameObject, 1067, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b278eb993f98bbc79fe6a60b92219ea8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popCleanupScope, 261, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9e0a9ab898ad06ae88ce9151dade15d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popCleanupScope, 506, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_3418a410b97e4041bebb9c5903bf4509 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popCleanupScope, 1216, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_279c6ac248d6c8229d505a9997d1a146 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popFrameHandle, 855, const_tuple_str_plain_self_str_plain_result_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0635b043d9d9da0611a172be20832e3c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popFrameHandle, 1258, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b7e56d94d9f72d48d449f61dca25c56 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popFrameVariables, 373, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_02dfe0aee0348ef048c777d56d4a31b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popFrameVariables, 540, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ec6404e2172c5be8f927926822edfaae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popFrameVariables, 879, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f3b1d16b097f5d8492f39777ee3e5e98 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushCleanupScope, 258, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_45d881e87ed34ede0a5375de19ee372a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushCleanupScope, 502, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_5edf0029e317204c2f87493cebac3dd6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushCleanupScope, 1213, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c20a736617c75414f4021a5a879f2f04 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushFrameHandle, 846, const_tuple_str_plain_self_str_plain_frame_handle_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1979d68cf3efafb6570219d9b631a4ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushFrameHandle, 1255, const_tuple_str_plain_self_str_plain_frame_handle_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_faf0faf3e3ec0767046b0fd2c7d2d995 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushFrameVariables, 369, const_tuple_str_plain_self_str_plain_frame_variables_tuple, 2, 0, CO_NOFREE );
    codeobj_27b8f23b5afbde7937db11a3c1152e92 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushFrameVariables, 537, const_tuple_str_plain_self_str_plain_frame_variables_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_654b29fe95db02fc79a3d82f282749b2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pushFrameVariables, 874, const_tuple_str_plain_self_str_plain_frame_variables_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_880b697f323251673cdcbabbac586b78 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeCleanupTempName, 251, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6c45637dccab2f4fca178cc695aa3ea3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeCleanupTempName, 494, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_NOFREE );
    codeobj_992161e4a323a8379d54e03131a47bfc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeCleanupTempName, 1207, const_tuple_str_plain_self_str_plain_tmp_name_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9cfed625fb66042ae350c88c741f7122 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setCurrentSourceCodeReference, 325, const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_56ffd0795b86a54640ed68201fec27ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionEscape, 163, const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_724fba5810b7acf38fda1cc2f0b5c1e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionEscape, 422, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_4c6120df83a9dbf8ff1e54c044cc7f3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionEscape, 1225, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_02944e336bec971fc1e13809d923d826 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionKeeperVariables, 219, const_tuple_str_plain_self_str_plain_keeper_vars_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_af763aa9b8f7990b27f16cc4e3308fdf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionKeeperVariables, 462, const_tuple_str_plain_self_str_plain_keeper_vars_tuple, 2, 0, CO_NOFREE );
    codeobj_e8c27ad0792b99a8ee8459e88b6a9011 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setExceptionKeeperVariables, 1264, const_tuple_str_plain_self_str_plain_keeper_vars_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_39aa69e44c2541146519c4855420db06 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setFalseBranchTarget, 240, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_27ec5ae7c651087046c1d05725307a23 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setFalseBranchTarget, 482, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_b960f5882c5ec8c26d803081a724846d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setFalseBranchTarget, 1249, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_67dfd733f52487a7c4d36642ce19b712 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setFrameGuardMode, 1027, const_tuple_str_plain_self_str_plain_guard_mode_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_853421309d4f32df28d83b518c6517b1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopBreakTarget, 171, const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a73adcf3cfe40ef45962ca8da9ad7b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopBreakTarget, 430, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_18cf21dc66bd30fd6968cbd2e996eb14 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopBreakTarget, 1231, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_621066726fe1091c06922280efd94ece = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopContinueTarget, 179, const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c57ff65d7609b04f11302060074276cb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopContinueTarget, 438, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_19d9a6aa5f8decfa87b27417a66f16d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setLoopContinueTarget, 1237, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d6fa1a058f407c200a6dfa1b40ebb1e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setReturnReleaseMode, 933, const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9b1ec8ba2549aca9e21f996e90c7f4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setReturnTarget, 941, const_tuple_str_plain_self_str_plain_label_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c7a4bc4a6885f31a13c4655359e3c6fd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setReturnValueName, 960, const_tuple_str_plain_self_str_plain_value_str_plain_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f2e1337788de1cc3038b91d47ad9bb11 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setTrueBranchTarget, 237, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4c820eb09910985e593218325029b18a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setTrueBranchTarget, 478, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_NOFREE );
    codeobj_8e47898037383dd96d5f512fcc78d56c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setTrueBranchTarget, 1246, const_tuple_str_plain_self_str_plain_label_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4fd0fc1c3c1f8c2a276b2b063220e476 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setVariableType, 884, const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87b218ddf91dac49519b4a8ec3f78958 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setVariableType, 1267, const_tuple_aff218260b6ea30f5250eeb24ed0526e_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value );
#else
static void codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator );
#endif


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_100___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_101_getConstantCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_102_countConstantUse(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_103_getConstantUseCount(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_104_getConstants(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_105___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_106_getFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_107_pushFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_108_popFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_109_getFramesCount(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_10_setExceptionEscape(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_110_addFrameDeclaration(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_111_getFrameDeclarations(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_112_pushFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_113_popFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_114_setVariableType(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_117_getFrameVariableTypeDescription(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_118_getFrameVariableCodeNames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_119_getLocalsDictNames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_11_getLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_120_addLocalsDictName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_121___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_122_setReturnReleaseMode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_123_getReturnReleaseMode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_124_setReturnTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_125_getReturnTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_126___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_127_getReturnValueName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_128_setReturnValueName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_129___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_12_setLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_130___repr__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_131_getOwner(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_132_getEntryPoint(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_133_isCompiledPythonModule(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_134_getName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_135_getFilename(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_136_mayRaiseException(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_137_getModuleCodeName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_138_setFrameGuardMode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_139_addHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_13_getLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_140_hasHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_141_getHelperCodes(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_142_addDeclaration(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_143_getDeclarations(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_144_mayRecurse(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_145_getConstantCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_146_getConstants(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_148_needsModuleFilenameObject(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_149___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_14_setLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_150___repr__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_151_getFunction(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_152_getOwner(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_153_getEntryPoint(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_154_mayRecurse(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_155_getCodeObjectHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_156_isForDirectCall(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_157_isForCrossModuleUsage(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_158_isForCreatedFunction(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_159_isForDirectCall(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_15_allocateLabel(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_160_isForCrossModuleUsage(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_161_isForCreatedFunction(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_162_getContextObjectName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_163_getGeneratorReturnValueName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_164_getContextObjectName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_165_getContextObjectName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_166_isForDirectCall(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_167_isForCreatedFunction(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_168___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_169_getOwner(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_16_getLabelCount(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_170_getEntryPoint(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_171_allocateLabel(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_172_allocateTempName( PyObject *defaults );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_173_hasTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_174_getCleanupTempnames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_175_addCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_176_removeCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_177_needsCleanup(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_178_pushCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_179_popCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_17_needsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_180_getCodeObjectHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_181_getExceptionEscape(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_182_setExceptionEscape(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_183_getLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_184_setLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_185_getLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_186_setLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_187_getTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_188_getFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_189_setTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_18_markAsNeedsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_190_setFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_191_getFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_192_pushFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_193_popFrameHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_194_getExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_195_setExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_196_setVariableType(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_197_getIntResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_198_getBoolResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_199_needsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_19_allocateExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_1___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_200_markAsNeedsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_201_allocateExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_202_addFrameDeclaration(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_203_isForDirectCall(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_204_mayRecurse(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_205_addLocalsDictName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_206_addExceptionPreserverVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_207_getTempNameInfos(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_208_forgetTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_209_getContextObjectName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_20_getKeeperVariableCount(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_21_getExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_22_setExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_23_getExceptionPreserverCounts(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_24_addExceptionPreserverVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_25_getTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_26_getFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_27_setTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_28_setFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_29_getCleanupTempnames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_2_formatTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_30_addCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_31_removeCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_32_needsCleanup(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_33_pushCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_34_popCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_35___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_36_getCodeObjects(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_37_getCodeObjectHandle(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_38__calcHash(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_39__calcHash(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_3_allocateTempName( PyObject *defaults );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_40___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_41_getCurrentSourceCodeReference(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_42_setCurrentSourceCodeReference(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_43_getLastSourceCodeReference(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_44_isUsed(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_45_getConstantCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_46_getModuleCodeName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_47_getModuleName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_48_addHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_49_hasHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_4_getIntResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_50_addDeclaration(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_51_pushFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_52_popFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_54_getFrameVariableTypeDescription(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_56_getFrameVariableCodeNames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_57_allocateTempName( PyObject *defaults );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_58_getIntResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_59_getBoolResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_5_getBoolResName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_60_hasTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_61_forgetTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_62_getTempNameInfos(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_63_getExceptionEscape(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_64_setExceptionEscape(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_65_getLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_66_setLoopBreakTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_67_getLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_68_setLoopContinueTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_69_allocateLabel(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_6_hasTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_70_needsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_71_markAsNeedsExceptionVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_72_allocateExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_73_getExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_74_setExceptionKeeperVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_75_addExceptionPreserverVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_76_getTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_77_getFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_78_setTrueBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_79_setFalseBranchTarget(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_7_forgetTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_80_getCleanupTempnames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_81_addCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_82_removeCleanupTempName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_83_needsCleanup(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_84_pushCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_85_popCleanupScope(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_86___init__(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_87_getConstantCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_88_getModuleCodeName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_89_getModuleName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_8_getTempNameInfos(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_90_addHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_91_hasHelperCode(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_92_addDeclaration(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_93_pushFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_94_popFrameVariables(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_96_getFrameVariableTypeDescription(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_98_getFrameVariableCodeNames(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_99__getConstantDefaultPopulation(  );


static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_9_getExceptionEscape(  );


// The module function definitions.
static PyObject *impl_codegen$Contexts$$$function_1___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_name_10;
    PyObject *tmp_assattr_name_11;
    PyObject *tmp_assattr_name_12;
    PyObject *tmp_assattr_name_13;
    PyObject *tmp_assattr_name_14;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    PyObject *tmp_assattr_target_10;
    PyObject *tmp_assattr_target_11;
    PyObject *tmp_assattr_target_12;
    PyObject *tmp_assattr_target_13;
    PyObject *tmp_assattr_target_14;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2206ecab54a182234641a463879cf13e = NULL;

    struct Nuitka_FrameObject *frame_2206ecab54a182234641a463879cf13e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2206ecab54a182234641a463879cf13e, codeobj_2206ecab54a182234641a463879cf13e, module_codegen$Contexts, sizeof(void *) );
    frame_2206ecab54a182234641a463879cf13e = cache_frame_2206ecab54a182234641a463879cf13e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2206ecab54a182234641a463879cf13e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2206ecab54a182234641a463879cf13e ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyDict_New();
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_tmp_names, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 59;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = PyDict_New();
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 60;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_tmp_types, tmp_assattr_name_2 );
    Py_DECREF( tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 60;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = PySet_New( NULL );
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {
        Py_DECREF( tmp_assattr_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 61;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_forgotten_names, tmp_assattr_name_3 );
    Py_DECREF( tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 61;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = PyDict_New();
    tmp_assattr_target_4 = par_self;

    if ( tmp_assattr_target_4 == NULL )
    {
        Py_DECREF( tmp_assattr_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 63;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_labels, tmp_assattr_name_4 );
    Py_DECREF( tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 63;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = Py_False;
    tmp_assattr_target_5 = par_self;

    if ( tmp_assattr_target_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 66;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_needs_exception_variables, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 66;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = Py_None;
    tmp_assattr_target_6 = par_self;

    if ( tmp_assattr_target_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 67;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_exception_escape, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = Py_None;
    tmp_assattr_target_7 = par_self;

    if ( tmp_assattr_target_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 68;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_loop_continue, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_8 = Py_None;
    tmp_assattr_target_8 = par_self;

    if ( tmp_assattr_target_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 69;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_loop_break, tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 69;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_9 = Py_None;
    tmp_assattr_target_9 = par_self;

    if ( tmp_assattr_target_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 72;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_true_target, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 72;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_10 = Py_None;
    tmp_assattr_target_10 = par_self;

    if ( tmp_assattr_target_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 73;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain_false_target, tmp_assattr_name_10 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 73;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_11 = const_int_0;
    tmp_assattr_target_11 = par_self;

    if ( tmp_assattr_target_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 75;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_keeper_variable_count, tmp_assattr_name_11 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_12 = const_tuple_none_none_none_none_tuple;
    tmp_assattr_target_12 = par_self;

    if ( tmp_assattr_target_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 76;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain_exception_keepers, tmp_assattr_name_12 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 76;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_13 = PySet_New( NULL );
    tmp_assattr_target_13 = par_self;

    if ( tmp_assattr_target_13 == NULL )
    {
        Py_DECREF( tmp_assattr_name_13 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 78;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain_preserver_variable_counts, tmp_assattr_name_13 );
    Py_DECREF( tmp_assattr_name_13 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_14 = PyList_New( 0 );
    tmp_assattr_target_14 = par_self;

    if ( tmp_assattr_target_14 == NULL )
    {
        Py_DECREF( tmp_assattr_name_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 80;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_14, const_str_plain_cleanup_names, tmp_assattr_name_14 );
    Py_DECREF( tmp_assattr_name_14 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2206ecab54a182234641a463879cf13e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2206ecab54a182234641a463879cf13e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2206ecab54a182234641a463879cf13e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2206ecab54a182234641a463879cf13e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2206ecab54a182234641a463879cf13e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2206ecab54a182234641a463879cf13e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2206ecab54a182234641a463879cf13e == cache_frame_2206ecab54a182234641a463879cf13e )
    {
        Py_DECREF( frame_2206ecab54a182234641a463879cf13e );
    }
    cache_frame_2206ecab54a182234641a463879cf13e = NULL;

    assertFrameObject( frame_2206ecab54a182234641a463879cf13e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_1___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_1___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_2_formatTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *par_number = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    bool tmp_is_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_41dcb69da7bdde8dd50557005a6d275e = NULL;

    struct Nuitka_FrameObject *frame_41dcb69da7bdde8dd50557005a6d275e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_41dcb69da7bdde8dd50557005a6d275e, codeobj_41dcb69da7bdde8dd50557005a6d275e, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_41dcb69da7bdde8dd50557005a6d275e = cache_frame_41dcb69da7bdde8dd50557005a6d275e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_41dcb69da7bdde8dd50557005a6d275e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_41dcb69da7bdde8dd50557005a6d275e ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_number;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = const_str_digest_f6d30af9f62732609e854dc2c3e57bc8;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_format );
    assert( !(tmp_called_name_1 == NULL) );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_dict_value_1 = par_base_name;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 85;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_41dcb69da7bdde8dd50557005a6d275e->m_frame.f_lineno = 84;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = const_str_digest_e7002c0ee8e5bbb559c41cccff652c68;
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_format );
    assert( !(tmp_called_name_2 == NULL) );
    tmp_dict_key_2 = const_str_plain_name;
    tmp_dict_value_2 = par_base_name;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 89;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_number;
    tmp_dict_value_3 = par_number;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "number" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 90;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_41dcb69da7bdde8dd50557005a6d275e->m_frame.f_lineno = 88;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 88;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41dcb69da7bdde8dd50557005a6d275e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_41dcb69da7bdde8dd50557005a6d275e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41dcb69da7bdde8dd50557005a6d275e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_41dcb69da7bdde8dd50557005a6d275e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_41dcb69da7bdde8dd50557005a6d275e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_41dcb69da7bdde8dd50557005a6d275e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_41dcb69da7bdde8dd50557005a6d275e,
        type_description_1,
        par_self,
        par_base_name,
        par_number
    );


    // Release cached frame.
    if ( frame_41dcb69da7bdde8dd50557005a6d275e == cache_frame_41dcb69da7bdde8dd50557005a6d275e )
    {
        Py_DECREF( frame_41dcb69da7bdde8dd50557005a6d275e );
    }
    cache_frame_41dcb69da7bdde8dd50557005a6d275e = NULL;

    assertFrameObject( frame_41dcb69da7bdde8dd50557005a6d275e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_2_formatTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_number );
    par_number = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_number );
    par_number = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_2_formatTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_3_allocateTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *par_type_name = python_pars[ 2 ];
    PyObject *par_unique = python_pars[ 3 ];
    PyObject *var_number = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_value_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static struct Nuitka_FrameObject *cache_frame_976dcc88b248a86fafc0bfcdfb26be3c = NULL;

    struct Nuitka_FrameObject *frame_976dcc88b248a86fafc0bfcdfb26be3c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_976dcc88b248a86fafc0bfcdfb26be3c, codeobj_976dcc88b248a86fafc0bfcdfb26be3c, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_976dcc88b248a86fafc0bfcdfb26be3c = cache_frame_976dcc88b248a86fafc0bfcdfb26be3c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_976dcc88b248a86fafc0bfcdfb26be3c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_976dcc88b248a86fafc0bfcdfb26be3c ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = par_unique;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 95;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = Py_None;
    assert( var_number == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_number = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_tmp_names );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_base_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 98;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_0;
    frame_976dcc88b248a86fafc0bfcdfb26be3c->m_frame.f_lineno = 98;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_number == NULL );
    var_number = tmp_assign_source_2;

    tmp_left_name_1 = var_number;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_3 = tmp_left_name_1;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 99;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    var_number = tmp_assign_source_3;

    branch_end_1:;
    tmp_ass_subvalue_1 = var_number;

    CHECK_OBJECT( tmp_ass_subvalue_1 );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_tmp_names );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_base_name;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = par_base_name;

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 103;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 103;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_tmp_types );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 103;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_ass_subvalue_2 = par_type_name;

    if ( tmp_ass_subvalue_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_tmp_types );
    if ( tmp_ass_subscribed_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_2 = par_base_name;

    if ( tmp_ass_subscript_2 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subscribed_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 104;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_tmp_types );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_base_name;

    if ( tmp_subscript_name_1 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = par_type_name;

    if ( tmp_compare_right_2 == NULL )
    {
        Py_DECREF( tmp_compare_left_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 106;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_raise_type_1 = PyExc_AssertionError;
    tmp_source_name_7 = par_self;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 107;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_tmp_types );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 107;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = par_base_name;

    if ( tmp_subscript_name_2 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 107;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 107;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = PyTuple_New( 2 );
    PyTuple_SET_ITEM( tmp_tuple_element_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = par_type_name;

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 107;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_tuple_element_1, 1, tmp_tuple_element_2 );
    tmp_raise_value_1 = PyTuple_New( 1 );
    PyTuple_SET_ITEM( tmp_raise_value_1, 0, tmp_tuple_element_1 );
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_value = tmp_raise_value_1;
    exception_lineno = 106;
    RAISE_EXCEPTION_WITH_VALUE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    branch_end_2:;
    tmp_source_name_8 = par_self;

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 109;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_formatTempName );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_key_1 = const_str_plain_base_name;
    tmp_dict_value_1 = par_base_name;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 110;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_number;
    tmp_dict_value_2 = var_number;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "number" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 111;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_976dcc88b248a86fafc0bfcdfb26be3c->m_frame.f_lineno = 109;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_976dcc88b248a86fafc0bfcdfb26be3c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_976dcc88b248a86fafc0bfcdfb26be3c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_976dcc88b248a86fafc0bfcdfb26be3c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_976dcc88b248a86fafc0bfcdfb26be3c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_976dcc88b248a86fafc0bfcdfb26be3c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_976dcc88b248a86fafc0bfcdfb26be3c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_976dcc88b248a86fafc0bfcdfb26be3c,
        type_description_1,
        par_self,
        par_base_name,
        par_type_name,
        par_unique,
        var_number
    );


    // Release cached frame.
    if ( frame_976dcc88b248a86fafc0bfcdfb26be3c == cache_frame_976dcc88b248a86fafc0bfcdfb26be3c )
    {
        Py_DECREF( frame_976dcc88b248a86fafc0bfcdfb26be3c );
    }
    cache_frame_976dcc88b248a86fafc0bfcdfb26be3c = NULL;

    assertFrameObject( frame_976dcc88b248a86fafc0bfcdfb26be3c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_3_allocateTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;

    Py_XDECREF( var_number );
    var_number = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;

    Py_XDECREF( var_number );
    var_number = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_3_allocateTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_4_getIntResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_2897788a6282b03b8e14bfd7bf173c6c = NULL;

    struct Nuitka_FrameObject *frame_2897788a6282b03b8e14bfd7bf173c6c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2897788a6282b03b8e14bfd7bf173c6c, codeobj_2897788a6282b03b8e14bfd7bf173c6c, module_codegen$Contexts, sizeof(void *) );
    frame_2897788a6282b03b8e14bfd7bf173c6c = cache_frame_2897788a6282b03b8e14bfd7bf173c6c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2897788a6282b03b8e14bfd7bf173c6c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2897788a6282b03b8e14bfd7bf173c6c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allocateTempName );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 115;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_str_plain_res_str_plain_int_tuple;
    tmp_kw_name_1 = PyDict_Copy( const_dict_628013539fe17b0c3c196c9e449729d6 );
    frame_2897788a6282b03b8e14bfd7bf173c6c->m_frame.f_lineno = 115;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 115;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2897788a6282b03b8e14bfd7bf173c6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2897788a6282b03b8e14bfd7bf173c6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2897788a6282b03b8e14bfd7bf173c6c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2897788a6282b03b8e14bfd7bf173c6c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2897788a6282b03b8e14bfd7bf173c6c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2897788a6282b03b8e14bfd7bf173c6c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2897788a6282b03b8e14bfd7bf173c6c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2897788a6282b03b8e14bfd7bf173c6c == cache_frame_2897788a6282b03b8e14bfd7bf173c6c )
    {
        Py_DECREF( frame_2897788a6282b03b8e14bfd7bf173c6c );
    }
    cache_frame_2897788a6282b03b8e14bfd7bf173c6c = NULL;

    assertFrameObject( frame_2897788a6282b03b8e14bfd7bf173c6c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_4_getIntResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_4_getIntResName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_5_getBoolResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fa6abd275388513d61e5b9c564027913 = NULL;

    struct Nuitka_FrameObject *frame_fa6abd275388513d61e5b9c564027913;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fa6abd275388513d61e5b9c564027913, codeobj_fa6abd275388513d61e5b9c564027913, module_codegen$Contexts, sizeof(void *) );
    frame_fa6abd275388513d61e5b9c564027913 = cache_frame_fa6abd275388513d61e5b9c564027913;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fa6abd275388513d61e5b9c564027913 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fa6abd275388513d61e5b9c564027913 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allocateTempName );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_str_plain_result_str_plain_bool_tuple;
    tmp_kw_name_1 = PyDict_Copy( const_dict_628013539fe17b0c3c196c9e449729d6 );
    frame_fa6abd275388513d61e5b9c564027913->m_frame.f_lineno = 118;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa6abd275388513d61e5b9c564027913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa6abd275388513d61e5b9c564027913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa6abd275388513d61e5b9c564027913 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fa6abd275388513d61e5b9c564027913, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fa6abd275388513d61e5b9c564027913->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fa6abd275388513d61e5b9c564027913, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa6abd275388513d61e5b9c564027913,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fa6abd275388513d61e5b9c564027913 == cache_frame_fa6abd275388513d61e5b9c564027913 )
    {
        Py_DECREF( frame_fa6abd275388513d61e5b9c564027913 );
    }
    cache_frame_fa6abd275388513d61e5b9c564027913 = NULL;

    assertFrameObject( frame_fa6abd275388513d61e5b9c564027913 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_5_getBoolResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_5_getBoolResName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_6_hasTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_cb055aa1fed9fd9bd4ae8d63750c7904 = NULL;

    struct Nuitka_FrameObject *frame_cb055aa1fed9fd9bd4ae8d63750c7904;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cb055aa1fed9fd9bd4ae8d63750c7904, codeobj_cb055aa1fed9fd9bd4ae8d63750c7904, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_cb055aa1fed9fd9bd4ae8d63750c7904 = cache_frame_cb055aa1fed9fd9bd4ae8d63750c7904;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cb055aa1fed9fd9bd4ae8d63750c7904 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_base_name;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_tmp_names );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cb055aa1fed9fd9bd4ae8d63750c7904, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cb055aa1fed9fd9bd4ae8d63750c7904->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cb055aa1fed9fd9bd4ae8d63750c7904, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cb055aa1fed9fd9bd4ae8d63750c7904,
        type_description_1,
        par_self,
        par_base_name
    );


    // Release cached frame.
    if ( frame_cb055aa1fed9fd9bd4ae8d63750c7904 == cache_frame_cb055aa1fed9fd9bd4ae8d63750c7904 )
    {
        Py_DECREF( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );
    }
    cache_frame_cb055aa1fed9fd9bd4ae8d63750c7904 = NULL;

    assertFrameObject( frame_cb055aa1fed9fd9bd4ae8d63750c7904 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_6_hasTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_6_hasTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_7_forgetTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7258131e4814e657599d76c2db3de494 = NULL;

    struct Nuitka_FrameObject *frame_7258131e4814e657599d76c2db3de494;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7258131e4814e657599d76c2db3de494, codeobj_7258131e4814e657599d76c2db3de494, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_7258131e4814e657599d76c2db3de494 = cache_frame_7258131e4814e657599d76c2db3de494;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7258131e4814e657599d76c2db3de494 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7258131e4814e657599d76c2db3de494 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_forgotten_names );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_add );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_7258131e4814e657599d76c2db3de494->m_frame.f_lineno = 124;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 124;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7258131e4814e657599d76c2db3de494 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7258131e4814e657599d76c2db3de494 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7258131e4814e657599d76c2db3de494, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7258131e4814e657599d76c2db3de494->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7258131e4814e657599d76c2db3de494, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7258131e4814e657599d76c2db3de494,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_7258131e4814e657599d76c2db3de494 == cache_frame_7258131e4814e657599d76c2db3de494 )
    {
        Py_DECREF( frame_7258131e4814e657599d76c2db3de494 );
    }
    cache_frame_7258131e4814e657599d76c2db3de494 = NULL;

    assertFrameObject( frame_7258131e4814e657599d76c2db3de494 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_7_forgetTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_7_forgetTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_8_getTempNameInfos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *var_base_name = NULL;
    PyObject *var_count = NULL;
    PyObject *var_number = NULL;
    PyObject *var_tmp_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_NotIn_1;
    int tmp_cmp_NotIn_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_left_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    PyObject *tmp_value_name_2;
    PyObject *tmp_xrange_high_1;
    PyObject *tmp_xrange_low_1;
    static struct Nuitka_FrameObject *cache_frame_c4f76c9457a95c8629cda68ea00fbd20 = NULL;

    struct Nuitka_FrameObject *frame_c4f76c9457a95c8629cda68ea00fbd20;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c4f76c9457a95c8629cda68ea00fbd20, codeobj_c4f76c9457a95c8629cda68ea00fbd20, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c4f76c9457a95c8629cda68ea00fbd20 = cache_frame_c4f76c9457a95c8629cda68ea00fbd20;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c4f76c9457a95c8629cda68ea00fbd20 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c4f76c9457a95c8629cda68ea00fbd20 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_sorted );
    assert( tmp_called_name_1 != NULL );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_iterItems );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iterItems );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "iterItems" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_tmp_names );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 129;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 129;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 129;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    // Tried code:
    tmp_iter_arg_2 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 129;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 129;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooo";
                exception_lineno = 129;
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "oooooo";
        exception_lineno = 129;
        goto try_except_handler_5;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_7 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_base_name;
        var_base_name = tmp_assign_source_7;
        Py_INCREF( var_base_name );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_8 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_count;
        var_count = tmp_assign_source_8;
        Py_INCREF( var_count );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_2 = var_count;

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 130;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_xrange_low_1 = const_int_pos_1;
    tmp_left_name_1 = var_count;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_1 = const_int_pos_1;
    tmp_xrange_high_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_xrange_high_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_iter_arg_3 = BUILTIN_XRANGE2( tmp_xrange_low_1, tmp_xrange_high_1 );
    Py_DECREF( tmp_xrange_high_1 );
    if ( tmp_iter_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_9 = MAKE_ITERATOR( tmp_iter_arg_3 );
    Py_DECREF( tmp_iter_arg_3 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_2:;
    // Tried code:
    tmp_value_name_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_value_name_2 );
    tmp_assign_source_10 = ITERATOR_NEXT( tmp_value_name_2 );
    if ( tmp_assign_source_10 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooo";
        exception_lineno = 131;
        goto try_except_handler_7;
    }
    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    goto try_end_4;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_3 = exception_keeper_type_4;
    tmp_compare_right_3 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_4 );
        Py_XDECREF( exception_keeper_value_4 );
        Py_XDECREF( exception_keeper_tb_4 );

        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    Py_DECREF( exception_keeper_type_4 );
    Py_XDECREF( exception_keeper_value_4 );
    Py_XDECREF( exception_keeper_tb_4 );
    goto loop_end_2;
    goto branch_end_3;
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_6;
    branch_end_3:;
    // End of try:
    try_end_4:;
    tmp_assign_source_11 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_11 );
    {
        PyObject *old = var_number;
        var_number = tmp_assign_source_11;
        Py_INCREF( var_number );
        Py_XDECREF( old );
    }

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 132;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_formatTempName );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    tmp_dict_key_1 = const_str_plain_base_name;
    tmp_dict_value_1 = var_base_name;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 133;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_number;
    tmp_dict_value_2 = var_number;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "number" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 134;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 132;
    tmp_assign_source_12 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    {
        PyObject *old = var_tmp_name;
        var_tmp_name = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    tmp_compare_left_4 = var_tmp_name;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 137;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_compare_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_forgotten_names );
    if ( tmp_compare_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 137;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    Py_DECREF( tmp_compare_right_4 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_4 = var_result;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 138;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    tmp_tuple_element_1 = var_tmp_name;

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 140;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_args_element_name_3 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_3, 0, tmp_tuple_element_1 );
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 141;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_tmp_types );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 141;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    tmp_subscript_name_1 = var_base_name;

    if ( tmp_subscript_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_subscribed_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 141;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }

    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 141;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    PyTuple_SET_ITEM( tmp_args_element_name_3, 1, tmp_tuple_element_1 );
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 138;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_2;
    // End of try:
    try_end_5:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 145;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_formatTempName );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_dict_key_3 = const_str_plain_base_name;
    tmp_dict_value_3 = var_base_name;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 146;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_number;
    tmp_dict_value_4 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_4, tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 145;
    tmp_assign_source_13 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_5, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_tmp_name;
        var_tmp_name = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    tmp_compare_left_5 = var_tmp_name;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_source_name_7 = par_self;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 150;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_forgotten_names );
    if ( tmp_compare_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotIn_2 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    Py_DECREF( tmp_compare_right_5 );
    assert( !(tmp_cmp_NotIn_2 == -1) );
    if ( tmp_cmp_NotIn_2 == 0 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_8 = var_result;

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 151;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_append );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 151;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_tuple_element_2 = var_tmp_name;

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 153;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_element_name_4, 0, tmp_tuple_element_2 );
    tmp_source_name_9 = par_self;

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 154;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_tmp_types );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 154;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    tmp_subscript_name_2 = var_base_name;

    if ( tmp_subscript_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_subscribed_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 154;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }

    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 154;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_element_name_4, 1, tmp_tuple_element_2 );
    frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame.f_lineno = 151;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 151;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    branch_end_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_6;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 158;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4f76c9457a95c8629cda68ea00fbd20 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4f76c9457a95c8629cda68ea00fbd20 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4f76c9457a95c8629cda68ea00fbd20 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c4f76c9457a95c8629cda68ea00fbd20, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c4f76c9457a95c8629cda68ea00fbd20->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c4f76c9457a95c8629cda68ea00fbd20, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c4f76c9457a95c8629cda68ea00fbd20,
        type_description_1,
        par_self,
        var_result,
        var_base_name,
        var_count,
        var_number,
        var_tmp_name
    );


    // Release cached frame.
    if ( frame_c4f76c9457a95c8629cda68ea00fbd20 == cache_frame_c4f76c9457a95c8629cda68ea00fbd20 )
    {
        Py_DECREF( frame_c4f76c9457a95c8629cda68ea00fbd20 );
    }
    cache_frame_c4f76c9457a95c8629cda68ea00fbd20 = NULL;

    assertFrameObject( frame_c4f76c9457a95c8629cda68ea00fbd20 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_8_getTempNameInfos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_base_name );
    var_base_name = NULL;

    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_number );
    var_number = NULL;

    Py_XDECREF( var_tmp_name );
    var_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_base_name );
    var_base_name = NULL;

    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_number );
    var_number = NULL;

    Py_XDECREF( var_tmp_name );
    var_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_8_getTempNameInfos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_9_getExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_baccea888939a034905427023ae07b09 = NULL;

    struct Nuitka_FrameObject *frame_baccea888939a034905427023ae07b09;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_baccea888939a034905427023ae07b09, codeobj_baccea888939a034905427023ae07b09, module_codegen$Contexts, sizeof(void *) );
    frame_baccea888939a034905427023ae07b09 = cache_frame_baccea888939a034905427023ae07b09;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_baccea888939a034905427023ae07b09 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_baccea888939a034905427023ae07b09 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_exception_escape );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 161;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_baccea888939a034905427023ae07b09 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_baccea888939a034905427023ae07b09 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_baccea888939a034905427023ae07b09 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_baccea888939a034905427023ae07b09, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_baccea888939a034905427023ae07b09->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_baccea888939a034905427023ae07b09, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_baccea888939a034905427023ae07b09,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_baccea888939a034905427023ae07b09 == cache_frame_baccea888939a034905427023ae07b09 )
    {
        Py_DECREF( frame_baccea888939a034905427023ae07b09 );
    }
    cache_frame_baccea888939a034905427023ae07b09 = NULL;

    assertFrameObject( frame_baccea888939a034905427023ae07b09 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_9_getExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_9_getExceptionEscape );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_10_setExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_56ffd0795b86a54640ed68201fec27ae = NULL;

    struct Nuitka_FrameObject *frame_56ffd0795b86a54640ed68201fec27ae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_56ffd0795b86a54640ed68201fec27ae, codeobj_56ffd0795b86a54640ed68201fec27ae, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_56ffd0795b86a54640ed68201fec27ae = cache_frame_56ffd0795b86a54640ed68201fec27ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_56ffd0795b86a54640ed68201fec27ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_56ffd0795b86a54640ed68201fec27ae ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_exception_escape );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_label;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 165;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 165;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_exception_escape, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 166;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56ffd0795b86a54640ed68201fec27ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_56ffd0795b86a54640ed68201fec27ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56ffd0795b86a54640ed68201fec27ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_56ffd0795b86a54640ed68201fec27ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_56ffd0795b86a54640ed68201fec27ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_56ffd0795b86a54640ed68201fec27ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_56ffd0795b86a54640ed68201fec27ae,
        type_description_1,
        par_self,
        par_label,
        var_result
    );


    // Release cached frame.
    if ( frame_56ffd0795b86a54640ed68201fec27ae == cache_frame_56ffd0795b86a54640ed68201fec27ae )
    {
        Py_DECREF( frame_56ffd0795b86a54640ed68201fec27ae );
    }
    cache_frame_56ffd0795b86a54640ed68201fec27ae = NULL;

    assertFrameObject( frame_56ffd0795b86a54640ed68201fec27ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_10_setExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_10_setExceptionEscape );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_11_getLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_110f78dca44d50f35817a88c63803340 = NULL;

    struct Nuitka_FrameObject *frame_110f78dca44d50f35817a88c63803340;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_110f78dca44d50f35817a88c63803340, codeobj_110f78dca44d50f35817a88c63803340, module_codegen$Contexts, sizeof(void *) );
    frame_110f78dca44d50f35817a88c63803340 = cache_frame_110f78dca44d50f35817a88c63803340;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_110f78dca44d50f35817a88c63803340 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_110f78dca44d50f35817a88c63803340 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_loop_break );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 169;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_110f78dca44d50f35817a88c63803340 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_110f78dca44d50f35817a88c63803340 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_110f78dca44d50f35817a88c63803340 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_110f78dca44d50f35817a88c63803340, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_110f78dca44d50f35817a88c63803340->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_110f78dca44d50f35817a88c63803340, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_110f78dca44d50f35817a88c63803340,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_110f78dca44d50f35817a88c63803340 == cache_frame_110f78dca44d50f35817a88c63803340 )
    {
        Py_DECREF( frame_110f78dca44d50f35817a88c63803340 );
    }
    cache_frame_110f78dca44d50f35817a88c63803340 = NULL;

    assertFrameObject( frame_110f78dca44d50f35817a88c63803340 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_11_getLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_11_getLoopBreakTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_12_setLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_853421309d4f32df28d83b518c6517b1 = NULL;

    struct Nuitka_FrameObject *frame_853421309d4f32df28d83b518c6517b1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_853421309d4f32df28d83b518c6517b1, codeobj_853421309d4f32df28d83b518c6517b1, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_853421309d4f32df28d83b518c6517b1 = cache_frame_853421309d4f32df28d83b518c6517b1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_853421309d4f32df28d83b518c6517b1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_853421309d4f32df28d83b518c6517b1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_loop_break );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_label;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 173;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 173;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_loop_break, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 173;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 174;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_853421309d4f32df28d83b518c6517b1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_853421309d4f32df28d83b518c6517b1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_853421309d4f32df28d83b518c6517b1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_853421309d4f32df28d83b518c6517b1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_853421309d4f32df28d83b518c6517b1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_853421309d4f32df28d83b518c6517b1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_853421309d4f32df28d83b518c6517b1,
        type_description_1,
        par_self,
        par_label,
        var_result
    );


    // Release cached frame.
    if ( frame_853421309d4f32df28d83b518c6517b1 == cache_frame_853421309d4f32df28d83b518c6517b1 )
    {
        Py_DECREF( frame_853421309d4f32df28d83b518c6517b1 );
    }
    cache_frame_853421309d4f32df28d83b518c6517b1 = NULL;

    assertFrameObject( frame_853421309d4f32df28d83b518c6517b1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_12_setLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_12_setLoopBreakTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_13_getLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e4a1a975a42152ea18e2086b7d1fa099 = NULL;

    struct Nuitka_FrameObject *frame_e4a1a975a42152ea18e2086b7d1fa099;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e4a1a975a42152ea18e2086b7d1fa099, codeobj_e4a1a975a42152ea18e2086b7d1fa099, module_codegen$Contexts, sizeof(void *) );
    frame_e4a1a975a42152ea18e2086b7d1fa099 = cache_frame_e4a1a975a42152ea18e2086b7d1fa099;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e4a1a975a42152ea18e2086b7d1fa099 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e4a1a975a42152ea18e2086b7d1fa099 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_loop_continue );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4a1a975a42152ea18e2086b7d1fa099 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4a1a975a42152ea18e2086b7d1fa099 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4a1a975a42152ea18e2086b7d1fa099 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e4a1a975a42152ea18e2086b7d1fa099, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e4a1a975a42152ea18e2086b7d1fa099->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e4a1a975a42152ea18e2086b7d1fa099, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4a1a975a42152ea18e2086b7d1fa099,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e4a1a975a42152ea18e2086b7d1fa099 == cache_frame_e4a1a975a42152ea18e2086b7d1fa099 )
    {
        Py_DECREF( frame_e4a1a975a42152ea18e2086b7d1fa099 );
    }
    cache_frame_e4a1a975a42152ea18e2086b7d1fa099 = NULL;

    assertFrameObject( frame_e4a1a975a42152ea18e2086b7d1fa099 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_13_getLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_13_getLoopContinueTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_14_setLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_621066726fe1091c06922280efd94ece = NULL;

    struct Nuitka_FrameObject *frame_621066726fe1091c06922280efd94ece;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_621066726fe1091c06922280efd94ece, codeobj_621066726fe1091c06922280efd94ece, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_621066726fe1091c06922280efd94ece = cache_frame_621066726fe1091c06922280efd94ece;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_621066726fe1091c06922280efd94ece );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_621066726fe1091c06922280efd94ece ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_loop_continue );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_label;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_loop_continue, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 182;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_621066726fe1091c06922280efd94ece );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_621066726fe1091c06922280efd94ece );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_621066726fe1091c06922280efd94ece );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_621066726fe1091c06922280efd94ece, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_621066726fe1091c06922280efd94ece->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_621066726fe1091c06922280efd94ece, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_621066726fe1091c06922280efd94ece,
        type_description_1,
        par_self,
        par_label,
        var_result
    );


    // Release cached frame.
    if ( frame_621066726fe1091c06922280efd94ece == cache_frame_621066726fe1091c06922280efd94ece )
    {
        Py_DECREF( frame_621066726fe1091c06922280efd94ece );
    }
    cache_frame_621066726fe1091c06922280efd94ece = NULL;

    assertFrameObject( frame_621066726fe1091c06922280efd94ece );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_14_setLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_14_setLoopContinueTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_15_allocateLabel( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    static struct Nuitka_FrameObject *cache_frame_289d35c36f0d3170b0bfd7889bb96aec = NULL;

    struct Nuitka_FrameObject *frame_289d35c36f0d3170b0bfd7889bb96aec;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_289d35c36f0d3170b0bfd7889bb96aec, codeobj_289d35c36f0d3170b0bfd7889bb96aec, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_289d35c36f0d3170b0bfd7889bb96aec = cache_frame_289d35c36f0d3170b0bfd7889bb96aec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_289d35c36f0d3170b0bfd7889bb96aec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_289d35c36f0d3170b0bfd7889bb96aec ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_labels );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 185;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_0;
    frame_289d35c36f0d3170b0bfd7889bb96aec->m_frame.f_lineno = 185;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_left_name_1 = var_result;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_2 = tmp_left_name_1;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 186;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_2;

    tmp_ass_subvalue_1 = var_result;

    CHECK_OBJECT( tmp_ass_subvalue_1 );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_labels );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_label;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = const_str_digest_b15c2d9cc14aa119965733d8bffb6657;
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_format );
    assert( !(tmp_called_name_2 == NULL) );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_dict_value_1 = par_label;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 190;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_number;
    tmp_dict_value_2 = var_result;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 191;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_289d35c36f0d3170b0bfd7889bb96aec->m_frame.f_lineno = 189;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 189;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_289d35c36f0d3170b0bfd7889bb96aec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_289d35c36f0d3170b0bfd7889bb96aec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_289d35c36f0d3170b0bfd7889bb96aec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_289d35c36f0d3170b0bfd7889bb96aec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_289d35c36f0d3170b0bfd7889bb96aec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_289d35c36f0d3170b0bfd7889bb96aec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_289d35c36f0d3170b0bfd7889bb96aec,
        type_description_1,
        par_self,
        par_label,
        var_result
    );


    // Release cached frame.
    if ( frame_289d35c36f0d3170b0bfd7889bb96aec == cache_frame_289d35c36f0d3170b0bfd7889bb96aec )
    {
        Py_DECREF( frame_289d35c36f0d3170b0bfd7889bb96aec );
    }
    cache_frame_289d35c36f0d3170b0bfd7889bb96aec = NULL;

    assertFrameObject( frame_289d35c36f0d3170b0bfd7889bb96aec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_15_allocateLabel );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_15_allocateLabel );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_16_getLabelCount( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_6d1671c5ceb048fda74df856cbe3cb42 = NULL;

    struct Nuitka_FrameObject *frame_6d1671c5ceb048fda74df856cbe3cb42;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6d1671c5ceb048fda74df856cbe3cb42, codeobj_6d1671c5ceb048fda74df856cbe3cb42, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_6d1671c5ceb048fda74df856cbe3cb42 = cache_frame_6d1671c5ceb048fda74df856cbe3cb42;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6d1671c5ceb048fda74df856cbe3cb42 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6d1671c5ceb048fda74df856cbe3cb42 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_labels );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_0;
    frame_6d1671c5ceb048fda74df856cbe3cb42->m_frame.f_lineno = 195;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1671c5ceb048fda74df856cbe3cb42 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1671c5ceb048fda74df856cbe3cb42 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1671c5ceb048fda74df856cbe3cb42 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6d1671c5ceb048fda74df856cbe3cb42, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6d1671c5ceb048fda74df856cbe3cb42->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6d1671c5ceb048fda74df856cbe3cb42, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6d1671c5ceb048fda74df856cbe3cb42,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_6d1671c5ceb048fda74df856cbe3cb42 == cache_frame_6d1671c5ceb048fda74df856cbe3cb42 )
    {
        Py_DECREF( frame_6d1671c5ceb048fda74df856cbe3cb42 );
    }
    cache_frame_6d1671c5ceb048fda74df856cbe3cb42 = NULL;

    assertFrameObject( frame_6d1671c5ceb048fda74df856cbe3cb42 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_16_getLabelCount );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_16_getLabelCount );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_17_needsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_506b8e6a8b5a824731eeeb15d36723bb = NULL;

    struct Nuitka_FrameObject *frame_506b8e6a8b5a824731eeeb15d36723bb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_506b8e6a8b5a824731eeeb15d36723bb, codeobj_506b8e6a8b5a824731eeeb15d36723bb, module_codegen$Contexts, sizeof(void *) );
    frame_506b8e6a8b5a824731eeeb15d36723bb = cache_frame_506b8e6a8b5a824731eeeb15d36723bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_506b8e6a8b5a824731eeeb15d36723bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_506b8e6a8b5a824731eeeb15d36723bb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_needs_exception_variables );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 198;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_506b8e6a8b5a824731eeeb15d36723bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_506b8e6a8b5a824731eeeb15d36723bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_506b8e6a8b5a824731eeeb15d36723bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_506b8e6a8b5a824731eeeb15d36723bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_506b8e6a8b5a824731eeeb15d36723bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_506b8e6a8b5a824731eeeb15d36723bb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_506b8e6a8b5a824731eeeb15d36723bb,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_506b8e6a8b5a824731eeeb15d36723bb == cache_frame_506b8e6a8b5a824731eeeb15d36723bb )
    {
        Py_DECREF( frame_506b8e6a8b5a824731eeeb15d36723bb );
    }
    cache_frame_506b8e6a8b5a824731eeeb15d36723bb = NULL;

    assertFrameObject( frame_506b8e6a8b5a824731eeeb15d36723bb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_17_needsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_17_needsExceptionVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_18_markAsNeedsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_481359ae921de5d7cd6a8e86fa6bab1d = NULL;

    struct Nuitka_FrameObject *frame_481359ae921de5d7cd6a8e86fa6bab1d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_481359ae921de5d7cd6a8e86fa6bab1d, codeobj_481359ae921de5d7cd6a8e86fa6bab1d, module_codegen$Contexts, sizeof(void *) );
    frame_481359ae921de5d7cd6a8e86fa6bab1d = cache_frame_481359ae921de5d7cd6a8e86fa6bab1d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_481359ae921de5d7cd6a8e86fa6bab1d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_481359ae921de5d7cd6a8e86fa6bab1d ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_True;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_needs_exception_variables, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 201;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_481359ae921de5d7cd6a8e86fa6bab1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_481359ae921de5d7cd6a8e86fa6bab1d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_481359ae921de5d7cd6a8e86fa6bab1d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_481359ae921de5d7cd6a8e86fa6bab1d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_481359ae921de5d7cd6a8e86fa6bab1d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_481359ae921de5d7cd6a8e86fa6bab1d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_481359ae921de5d7cd6a8e86fa6bab1d == cache_frame_481359ae921de5d7cd6a8e86fa6bab1d )
    {
        Py_DECREF( frame_481359ae921de5d7cd6a8e86fa6bab1d );
    }
    cache_frame_481359ae921de5d7cd6a8e86fa6bab1d = NULL;

    assertFrameObject( frame_481359ae921de5d7cd6a8e86fa6bab1d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_18_markAsNeedsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_18_markAsNeedsExceptionVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_19_allocateExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_inplace_assign_attr_1__end = NULL;
    PyObject *tmp_inplace_assign_attr_1__start = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_32e8717831f25acd24b268462c12b153 = NULL;

    struct Nuitka_FrameObject *frame_32e8717831f25acd24b268462c12b153;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_32e8717831f25acd24b268462c12b153, codeobj_32e8717831f25acd24b268462c12b153, module_codegen$Contexts, sizeof(void *) );
    frame_32e8717831f25acd24b268462c12b153 = cache_frame_32e8717831f25acd24b268462c12b153;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_32e8717831f25acd24b268462c12b153 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_32e8717831f25acd24b268462c12b153 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_keeper_variable_count );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    assert( tmp_inplace_assign_attr_1__start == NULL );
    tmp_inplace_assign_attr_1__start = tmp_assign_source_1;

    // Tried code:
    tmp_left_name_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_assign_source_2 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    assert( tmp_inplace_assign_attr_1__end == NULL );
    tmp_inplace_assign_attr_1__end = tmp_assign_source_2;

    // Tried code:
    tmp_compare_left_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_1 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 204;
        type_description_1 = "o";
        goto try_except_handler_3;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_keeper_variable_count, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description_1 = "o";
        goto try_except_handler_3;
    }
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    tmp_left_name_2 = const_str_digest_5e3b8e7b3051f5b55143cd8a3ff855dc;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 207;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_keeper_variable_count );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = PyTuple_New( 4 );
    PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
    tmp_left_name_3 = const_str_digest_540034c844a611d69b7ba61d2b242481;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_return_value );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 208;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_keeper_variable_count );
    if ( tmp_right_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 208;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 208;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
    tmp_left_name_4 = const_str_digest_b682238f4a2007d1b13f98b0fdc5e1e3;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_return_value );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 209;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_keeper_variable_count );
    if ( tmp_right_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 209;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 209;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_return_value, 2, tmp_tuple_element_1 );
    tmp_left_name_5 = const_str_digest_ce77b93bf9baebf6bd099f4ee0e9423a;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_return_value );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 210;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_keeper_variable_count );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 210;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_return_value );

        exception_lineno = 210;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_return_value, 3, tmp_tuple_element_1 );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e8717831f25acd24b268462c12b153 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e8717831f25acd24b268462c12b153 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e8717831f25acd24b268462c12b153 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_32e8717831f25acd24b268462c12b153, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_32e8717831f25acd24b268462c12b153->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_32e8717831f25acd24b268462c12b153, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32e8717831f25acd24b268462c12b153,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_32e8717831f25acd24b268462c12b153 == cache_frame_32e8717831f25acd24b268462c12b153 )
    {
        Py_DECREF( frame_32e8717831f25acd24b268462c12b153 );
    }
    cache_frame_32e8717831f25acd24b268462c12b153 = NULL;

    assertFrameObject( frame_32e8717831f25acd24b268462c12b153 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_19_allocateExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_19_allocateExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_20_getKeeperVariableCount( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_8f30b9d54479a733f44d394bf922d625 = NULL;

    struct Nuitka_FrameObject *frame_8f30b9d54479a733f44d394bf922d625;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f30b9d54479a733f44d394bf922d625, codeobj_8f30b9d54479a733f44d394bf922d625, module_codegen$Contexts, sizeof(void *) );
    frame_8f30b9d54479a733f44d394bf922d625 = cache_frame_8f30b9d54479a733f44d394bf922d625;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f30b9d54479a733f44d394bf922d625 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f30b9d54479a733f44d394bf922d625 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_keeper_variable_count );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f30b9d54479a733f44d394bf922d625 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f30b9d54479a733f44d394bf922d625 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f30b9d54479a733f44d394bf922d625 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f30b9d54479a733f44d394bf922d625, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f30b9d54479a733f44d394bf922d625->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f30b9d54479a733f44d394bf922d625, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f30b9d54479a733f44d394bf922d625,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8f30b9d54479a733f44d394bf922d625 == cache_frame_8f30b9d54479a733f44d394bf922d625 )
    {
        Py_DECREF( frame_8f30b9d54479a733f44d394bf922d625 );
    }
    cache_frame_8f30b9d54479a733f44d394bf922d625 = NULL;

    assertFrameObject( frame_8f30b9d54479a733f44d394bf922d625 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_20_getKeeperVariableCount );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_20_getKeeperVariableCount );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_21_getExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_c8d2336e16342fea05bbf0081149a358 = NULL;

    struct Nuitka_FrameObject *frame_c8d2336e16342fea05bbf0081149a358;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c8d2336e16342fea05bbf0081149a358, codeobj_c8d2336e16342fea05bbf0081149a358, module_codegen$Contexts, sizeof(void *) );
    frame_c8d2336e16342fea05bbf0081149a358 = cache_frame_c8d2336e16342fea05bbf0081149a358;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c8d2336e16342fea05bbf0081149a358 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c8d2336e16342fea05bbf0081149a358 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_exception_keepers );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 217;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8d2336e16342fea05bbf0081149a358 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8d2336e16342fea05bbf0081149a358 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c8d2336e16342fea05bbf0081149a358 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c8d2336e16342fea05bbf0081149a358, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c8d2336e16342fea05bbf0081149a358->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c8d2336e16342fea05bbf0081149a358, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c8d2336e16342fea05bbf0081149a358,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c8d2336e16342fea05bbf0081149a358 == cache_frame_c8d2336e16342fea05bbf0081149a358 )
    {
        Py_DECREF( frame_c8d2336e16342fea05bbf0081149a358 );
    }
    cache_frame_c8d2336e16342fea05bbf0081149a358 = NULL;

    assertFrameObject( frame_c8d2336e16342fea05bbf0081149a358 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_21_getExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_21_getExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_22_setExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_keeper_vars = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_02944e336bec971fc1e13809d923d826 = NULL;

    struct Nuitka_FrameObject *frame_02944e336bec971fc1e13809d923d826;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02944e336bec971fc1e13809d923d826, codeobj_02944e336bec971fc1e13809d923d826, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_02944e336bec971fc1e13809d923d826 = cache_frame_02944e336bec971fc1e13809d923d826;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02944e336bec971fc1e13809d923d826 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02944e336bec971fc1e13809d923d826 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_exception_keepers );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_tuple_arg_1 = par_keeper_vars;

    if ( tmp_tuple_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "keeper_vars" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 221;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_name_1 = PySequence_Tuple( tmp_tuple_arg_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 221;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 221;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_exception_keepers, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 221;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 222;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02944e336bec971fc1e13809d923d826 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_02944e336bec971fc1e13809d923d826 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02944e336bec971fc1e13809d923d826 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02944e336bec971fc1e13809d923d826, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02944e336bec971fc1e13809d923d826->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02944e336bec971fc1e13809d923d826, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02944e336bec971fc1e13809d923d826,
        type_description_1,
        par_self,
        par_keeper_vars,
        var_result
    );


    // Release cached frame.
    if ( frame_02944e336bec971fc1e13809d923d826 == cache_frame_02944e336bec971fc1e13809d923d826 )
    {
        Py_DECREF( frame_02944e336bec971fc1e13809d923d826 );
    }
    cache_frame_02944e336bec971fc1e13809d923d826 = NULL;

    assertFrameObject( frame_02944e336bec971fc1e13809d923d826 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_22_setExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_22_setExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_23_getExceptionPreserverCounts( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_0dffe05d8b6ce6b1c521696575d86a6e = NULL;

    struct Nuitka_FrameObject *frame_0dffe05d8b6ce6b1c521696575d86a6e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0dffe05d8b6ce6b1c521696575d86a6e, codeobj_0dffe05d8b6ce6b1c521696575d86a6e, module_codegen$Contexts, sizeof(void *) );
    frame_0dffe05d8b6ce6b1c521696575d86a6e = cache_frame_0dffe05d8b6ce6b1c521696575d86a6e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0dffe05d8b6ce6b1c521696575d86a6e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0dffe05d8b6ce6b1c521696575d86a6e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_preserver_variable_counts );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dffe05d8b6ce6b1c521696575d86a6e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dffe05d8b6ce6b1c521696575d86a6e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dffe05d8b6ce6b1c521696575d86a6e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0dffe05d8b6ce6b1c521696575d86a6e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0dffe05d8b6ce6b1c521696575d86a6e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0dffe05d8b6ce6b1c521696575d86a6e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0dffe05d8b6ce6b1c521696575d86a6e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0dffe05d8b6ce6b1c521696575d86a6e == cache_frame_0dffe05d8b6ce6b1c521696575d86a6e )
    {
        Py_DECREF( frame_0dffe05d8b6ce6b1c521696575d86a6e );
    }
    cache_frame_0dffe05d8b6ce6b1c521696575d86a6e = NULL;

    assertFrameObject( frame_0dffe05d8b6ce6b1c521696575d86a6e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_23_getExceptionPreserverCounts );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_23_getExceptionPreserverCounts );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_24_addExceptionPreserverVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_count = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_0d6215760e5a9758515b53993f3d3c33 = NULL;

    struct Nuitka_FrameObject *frame_0d6215760e5a9758515b53993f3d3c33;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d6215760e5a9758515b53993f3d3c33, codeobj_0d6215760e5a9758515b53993f3d3c33, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_0d6215760e5a9758515b53993f3d3c33 = cache_frame_0d6215760e5a9758515b53993f3d3c33;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d6215760e5a9758515b53993f3d3c33 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d6215760e5a9758515b53993f3d3c33 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_count;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 228;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 228;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_preserver_variable_counts );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_add );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_count;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_0d6215760e5a9758515b53993f3d3c33->m_frame.f_lineno = 229;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d6215760e5a9758515b53993f3d3c33 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d6215760e5a9758515b53993f3d3c33 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d6215760e5a9758515b53993f3d3c33, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d6215760e5a9758515b53993f3d3c33->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d6215760e5a9758515b53993f3d3c33, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d6215760e5a9758515b53993f3d3c33,
        type_description_1,
        par_self,
        par_count
    );


    // Release cached frame.
    if ( frame_0d6215760e5a9758515b53993f3d3c33 == cache_frame_0d6215760e5a9758515b53993f3d3c33 )
    {
        Py_DECREF( frame_0d6215760e5a9758515b53993f3d3c33 );
    }
    cache_frame_0d6215760e5a9758515b53993f3d3c33 = NULL;

    assertFrameObject( frame_0d6215760e5a9758515b53993f3d3c33 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_24_addExceptionPreserverVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_24_addExceptionPreserverVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_25_getTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_3d90a84f25de934ac6d35312780bedee = NULL;

    struct Nuitka_FrameObject *frame_3d90a84f25de934ac6d35312780bedee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3d90a84f25de934ac6d35312780bedee, codeobj_3d90a84f25de934ac6d35312780bedee, module_codegen$Contexts, sizeof(void *) );
    frame_3d90a84f25de934ac6d35312780bedee = cache_frame_3d90a84f25de934ac6d35312780bedee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3d90a84f25de934ac6d35312780bedee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3d90a84f25de934ac6d35312780bedee ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_true_target );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 232;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d90a84f25de934ac6d35312780bedee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d90a84f25de934ac6d35312780bedee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d90a84f25de934ac6d35312780bedee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3d90a84f25de934ac6d35312780bedee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3d90a84f25de934ac6d35312780bedee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3d90a84f25de934ac6d35312780bedee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d90a84f25de934ac6d35312780bedee,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3d90a84f25de934ac6d35312780bedee == cache_frame_3d90a84f25de934ac6d35312780bedee )
    {
        Py_DECREF( frame_3d90a84f25de934ac6d35312780bedee );
    }
    cache_frame_3d90a84f25de934ac6d35312780bedee = NULL;

    assertFrameObject( frame_3d90a84f25de934ac6d35312780bedee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_25_getTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_25_getTrueBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_26_getFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d54eb5ba5893d1ae05af5148e04a0656 = NULL;

    struct Nuitka_FrameObject *frame_d54eb5ba5893d1ae05af5148e04a0656;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d54eb5ba5893d1ae05af5148e04a0656, codeobj_d54eb5ba5893d1ae05af5148e04a0656, module_codegen$Contexts, sizeof(void *) );
    frame_d54eb5ba5893d1ae05af5148e04a0656 = cache_frame_d54eb5ba5893d1ae05af5148e04a0656;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d54eb5ba5893d1ae05af5148e04a0656 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d54eb5ba5893d1ae05af5148e04a0656 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_false_target );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d54eb5ba5893d1ae05af5148e04a0656 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d54eb5ba5893d1ae05af5148e04a0656 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d54eb5ba5893d1ae05af5148e04a0656 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d54eb5ba5893d1ae05af5148e04a0656, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d54eb5ba5893d1ae05af5148e04a0656->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d54eb5ba5893d1ae05af5148e04a0656, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d54eb5ba5893d1ae05af5148e04a0656,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d54eb5ba5893d1ae05af5148e04a0656 == cache_frame_d54eb5ba5893d1ae05af5148e04a0656 )
    {
        Py_DECREF( frame_d54eb5ba5893d1ae05af5148e04a0656 );
    }
    cache_frame_d54eb5ba5893d1ae05af5148e04a0656 = NULL;

    assertFrameObject( frame_d54eb5ba5893d1ae05af5148e04a0656 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_26_getFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_26_getFalseBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_27_setTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_f2e1337788de1cc3038b91d47ad9bb11 = NULL;

    struct Nuitka_FrameObject *frame_f2e1337788de1cc3038b91d47ad9bb11;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f2e1337788de1cc3038b91d47ad9bb11, codeobj_f2e1337788de1cc3038b91d47ad9bb11, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_f2e1337788de1cc3038b91d47ad9bb11 = cache_frame_f2e1337788de1cc3038b91d47ad9bb11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f2e1337788de1cc3038b91d47ad9bb11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f2e1337788de1cc3038b91d47ad9bb11 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_label;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_true_target, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f2e1337788de1cc3038b91d47ad9bb11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f2e1337788de1cc3038b91d47ad9bb11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f2e1337788de1cc3038b91d47ad9bb11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f2e1337788de1cc3038b91d47ad9bb11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f2e1337788de1cc3038b91d47ad9bb11, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f2e1337788de1cc3038b91d47ad9bb11,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_f2e1337788de1cc3038b91d47ad9bb11 == cache_frame_f2e1337788de1cc3038b91d47ad9bb11 )
    {
        Py_DECREF( frame_f2e1337788de1cc3038b91d47ad9bb11 );
    }
    cache_frame_f2e1337788de1cc3038b91d47ad9bb11 = NULL;

    assertFrameObject( frame_f2e1337788de1cc3038b91d47ad9bb11 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_27_setTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_27_setTrueBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_28_setFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_39aa69e44c2541146519c4855420db06 = NULL;

    struct Nuitka_FrameObject *frame_39aa69e44c2541146519c4855420db06;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_39aa69e44c2541146519c4855420db06, codeobj_39aa69e44c2541146519c4855420db06, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_39aa69e44c2541146519c4855420db06 = cache_frame_39aa69e44c2541146519c4855420db06;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_39aa69e44c2541146519c4855420db06 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_39aa69e44c2541146519c4855420db06 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_label;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_false_target, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 241;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39aa69e44c2541146519c4855420db06 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39aa69e44c2541146519c4855420db06 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_39aa69e44c2541146519c4855420db06, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_39aa69e44c2541146519c4855420db06->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_39aa69e44c2541146519c4855420db06, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_39aa69e44c2541146519c4855420db06,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_39aa69e44c2541146519c4855420db06 == cache_frame_39aa69e44c2541146519c4855420db06 )
    {
        Py_DECREF( frame_39aa69e44c2541146519c4855420db06 );
    }
    cache_frame_39aa69e44c2541146519c4855420db06 = NULL;

    assertFrameObject( frame_39aa69e44c2541146519c4855420db06 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_28_setFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_28_setFalseBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_29_getCleanupTempnames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_c7c67814bd691dfa70eb9aac797832b3 = NULL;

    struct Nuitka_FrameObject *frame_c7c67814bd691dfa70eb9aac797832b3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c7c67814bd691dfa70eb9aac797832b3, codeobj_c7c67814bd691dfa70eb9aac797832b3, module_codegen$Contexts, sizeof(void *) );
    frame_c7c67814bd691dfa70eb9aac797832b3 = cache_frame_c7c67814bd691dfa70eb9aac797832b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c7c67814bd691dfa70eb9aac797832b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c7c67814bd691dfa70eb9aac797832b3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 244;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 244;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7c67814bd691dfa70eb9aac797832b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7c67814bd691dfa70eb9aac797832b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7c67814bd691dfa70eb9aac797832b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c7c67814bd691dfa70eb9aac797832b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c7c67814bd691dfa70eb9aac797832b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c7c67814bd691dfa70eb9aac797832b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7c67814bd691dfa70eb9aac797832b3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c7c67814bd691dfa70eb9aac797832b3 == cache_frame_c7c67814bd691dfa70eb9aac797832b3 )
    {
        Py_DECREF( frame_c7c67814bd691dfa70eb9aac797832b3 );
    }
    cache_frame_c7c67814bd691dfa70eb9aac797832b3 = NULL;

    assertFrameObject( frame_c7c67814bd691dfa70eb9aac797832b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_29_getCleanupTempnames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_29_getCleanupTempnames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_30_addCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7eaad5cd6e9a3020f306eeeaadae319e = NULL;

    struct Nuitka_FrameObject *frame_7eaad5cd6e9a3020f306eeeaadae319e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7eaad5cd6e9a3020f306eeeaadae319e, codeobj_7eaad5cd6e9a3020f306eeeaadae319e, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_7eaad5cd6e9a3020f306eeeaadae319e = cache_frame_7eaad5cd6e9a3020f306eeeaadae319e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7eaad5cd6e9a3020f306eeeaadae319e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7eaad5cd6e9a3020f306eeeaadae319e ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_tmp_name;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_compare_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    tmp_tuple_element_1 = par_tmp_name;

    if ( tmp_tuple_element_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_raise_value_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_raise_value_1, 0, tmp_tuple_element_1 );
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_value = tmp_raise_value_1;
    exception_lineno = 247;
    RAISE_EXCEPTION_WITH_VALUE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_neg_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_append );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_7eaad5cd6e9a3020f306eeeaadae319e->m_frame.f_lineno = 249;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7eaad5cd6e9a3020f306eeeaadae319e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7eaad5cd6e9a3020f306eeeaadae319e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7eaad5cd6e9a3020f306eeeaadae319e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7eaad5cd6e9a3020f306eeeaadae319e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7eaad5cd6e9a3020f306eeeaadae319e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7eaad5cd6e9a3020f306eeeaadae319e,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_7eaad5cd6e9a3020f306eeeaadae319e == cache_frame_7eaad5cd6e9a3020f306eeeaadae319e )
    {
        Py_DECREF( frame_7eaad5cd6e9a3020f306eeeaadae319e );
    }
    cache_frame_7eaad5cd6e9a3020f306eeeaadae319e = NULL;

    assertFrameObject( frame_7eaad5cd6e9a3020f306eeeaadae319e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_30_addCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_30_addCleanupTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_31_removeCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_880b697f323251673cdcbabbac586b78 = NULL;

    struct Nuitka_FrameObject *frame_880b697f323251673cdcbabbac586b78;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_880b697f323251673cdcbabbac586b78, codeobj_880b697f323251673cdcbabbac586b78, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_880b697f323251673cdcbabbac586b78 = cache_frame_880b697f323251673cdcbabbac586b78;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_880b697f323251673cdcbabbac586b78 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_880b697f323251673cdcbabbac586b78 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_tmp_name;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_compare_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    tmp_tuple_element_1 = par_tmp_name;

    if ( tmp_tuple_element_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 252;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_raise_value_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_raise_value_1, 0, tmp_tuple_element_1 );
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_value = tmp_raise_value_1;
    exception_lineno = 252;
    RAISE_EXCEPTION_WITH_VALUE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_neg_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_remove );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_880b697f323251673cdcbabbac586b78->m_frame.f_lineno = 253;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_880b697f323251673cdcbabbac586b78 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_880b697f323251673cdcbabbac586b78 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_880b697f323251673cdcbabbac586b78, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_880b697f323251673cdcbabbac586b78->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_880b697f323251673cdcbabbac586b78, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_880b697f323251673cdcbabbac586b78,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_880b697f323251673cdcbabbac586b78 == cache_frame_880b697f323251673cdcbabbac586b78 )
    {
        Py_DECREF( frame_880b697f323251673cdcbabbac586b78 );
    }
    cache_frame_880b697f323251673cdcbabbac586b78 = NULL;

    assertFrameObject( frame_880b697f323251673cdcbabbac586b78 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_31_removeCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_31_removeCleanupTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_32_needsCleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_60f4102fc3fe690ec05ebdd92da25085 = NULL;

    struct Nuitka_FrameObject *frame_60f4102fc3fe690ec05ebdd92da25085;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_60f4102fc3fe690ec05ebdd92da25085, codeobj_60f4102fc3fe690ec05ebdd92da25085, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_60f4102fc3fe690ec05ebdd92da25085 = cache_frame_60f4102fc3fe690ec05ebdd92da25085;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_60f4102fc3fe690ec05ebdd92da25085 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_60f4102fc3fe690ec05ebdd92da25085 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_tmp_name;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_compexpr_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60f4102fc3fe690ec05ebdd92da25085 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_60f4102fc3fe690ec05ebdd92da25085 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_60f4102fc3fe690ec05ebdd92da25085 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_60f4102fc3fe690ec05ebdd92da25085, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_60f4102fc3fe690ec05ebdd92da25085->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_60f4102fc3fe690ec05ebdd92da25085, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_60f4102fc3fe690ec05ebdd92da25085,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_60f4102fc3fe690ec05ebdd92da25085 == cache_frame_60f4102fc3fe690ec05ebdd92da25085 )
    {
        Py_DECREF( frame_60f4102fc3fe690ec05ebdd92da25085 );
    }
    cache_frame_60f4102fc3fe690ec05ebdd92da25085 = NULL;

    assertFrameObject( frame_60f4102fc3fe690ec05ebdd92da25085 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_32_needsCleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_32_needsCleanup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_33_pushCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f3b1d16b097f5d8492f39777ee3e5e98 = NULL;

    struct Nuitka_FrameObject *frame_f3b1d16b097f5d8492f39777ee3e5e98;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3b1d16b097f5d8492f39777ee3e5e98, codeobj_f3b1d16b097f5d8492f39777ee3e5e98, module_codegen$Contexts, sizeof(void *) );
    frame_f3b1d16b097f5d8492f39777ee3e5e98 = cache_frame_f3b1d16b097f5d8492f39777ee3e5e98;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3b1d16b097f5d8492f39777ee3e5e98 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3b1d16b097f5d8492f39777ee3e5e98 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 259;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_call_arg_element_1 = PyList_New( 0 );
    frame_f3b1d16b097f5d8492f39777ee3e5e98->m_frame.f_lineno = 259;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    Py_DECREF( tmp_call_arg_element_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 259;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3b1d16b097f5d8492f39777ee3e5e98 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3b1d16b097f5d8492f39777ee3e5e98 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3b1d16b097f5d8492f39777ee3e5e98, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3b1d16b097f5d8492f39777ee3e5e98->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3b1d16b097f5d8492f39777ee3e5e98, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3b1d16b097f5d8492f39777ee3e5e98,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f3b1d16b097f5d8492f39777ee3e5e98 == cache_frame_f3b1d16b097f5d8492f39777ee3e5e98 )
    {
        Py_DECREF( frame_f3b1d16b097f5d8492f39777ee3e5e98 );
    }
    cache_frame_f3b1d16b097f5d8492f39777ee3e5e98 = NULL;

    assertFrameObject( frame_f3b1d16b097f5d8492f39777ee3e5e98 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_33_pushCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_33_pushCleanupScope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_34_popCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_delsubscr_subscript_1;
    PyObject *tmp_delsubscr_target_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_b278eb993f98bbc79fe6a60b92219ea8 = NULL;

    struct Nuitka_FrameObject *frame_b278eb993f98bbc79fe6a60b92219ea8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b278eb993f98bbc79fe6a60b92219ea8, codeobj_b278eb993f98bbc79fe6a60b92219ea8, module_codegen$Contexts, sizeof(void *) );
    frame_b278eb993f98bbc79fe6a60b92219ea8 = cache_frame_b278eb993f98bbc79fe6a60b92219ea8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b278eb993f98bbc79fe6a60b92219ea8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b278eb993f98bbc79fe6a60b92219ea8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cleanup_names );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_cond_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 262;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 262;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "o";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 263;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_delsubscr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_cleanup_names );
    if ( tmp_delsubscr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_1 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
    Py_DECREF( tmp_delsubscr_target_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b278eb993f98bbc79fe6a60b92219ea8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b278eb993f98bbc79fe6a60b92219ea8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b278eb993f98bbc79fe6a60b92219ea8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b278eb993f98bbc79fe6a60b92219ea8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b278eb993f98bbc79fe6a60b92219ea8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b278eb993f98bbc79fe6a60b92219ea8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b278eb993f98bbc79fe6a60b92219ea8 == cache_frame_b278eb993f98bbc79fe6a60b92219ea8 )
    {
        Py_DECREF( frame_b278eb993f98bbc79fe6a60b92219ea8 );
    }
    cache_frame_b278eb993f98bbc79fe6a60b92219ea8 = NULL;

    assertFrameObject( frame_b278eb993f98bbc79fe6a60b92219ea8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_34_popCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_34_popCleanupScope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_35___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_1c666778cb70d20ac1d70782a03d8dbf = NULL;

    struct Nuitka_FrameObject *frame_1c666778cb70d20ac1d70782a03d8dbf;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1c666778cb70d20ac1d70782a03d8dbf, codeobj_1c666778cb70d20ac1d70782a03d8dbf, module_codegen$Contexts, sizeof(void *) );
    frame_1c666778cb70d20ac1d70782a03d8dbf = cache_frame_1c666778cb70d20ac1d70782a03d8dbf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1c666778cb70d20ac1d70782a03d8dbf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1c666778cb70d20ac1d70782a03d8dbf ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyDict_New();
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_code_objects, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 269;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c666778cb70d20ac1d70782a03d8dbf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c666778cb70d20ac1d70782a03d8dbf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1c666778cb70d20ac1d70782a03d8dbf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1c666778cb70d20ac1d70782a03d8dbf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1c666778cb70d20ac1d70782a03d8dbf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1c666778cb70d20ac1d70782a03d8dbf,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1c666778cb70d20ac1d70782a03d8dbf == cache_frame_1c666778cb70d20ac1d70782a03d8dbf )
    {
        Py_DECREF( frame_1c666778cb70d20ac1d70782a03d8dbf );
    }
    cache_frame_1c666778cb70d20ac1d70782a03d8dbf = NULL;

    assertFrameObject( frame_1c666778cb70d20ac1d70782a03d8dbf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_35___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_35___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_36_getCodeObjects( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fae54a9f06e0ed034c5de9b4ee7af97d = NULL;

    struct Nuitka_FrameObject *frame_fae54a9f06e0ed034c5de9b4ee7af97d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fae54a9f06e0ed034c5de9b4ee7af97d, codeobj_fae54a9f06e0ed034c5de9b4ee7af97d, module_codegen$Contexts, sizeof(void *) );
    frame_fae54a9f06e0ed034c5de9b4ee7af97d = cache_frame_fae54a9f06e0ed034c5de9b4ee7af97d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fae54a9f06e0ed034c5de9b4ee7af97d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fae54a9f06e0ed034c5de9b4ee7af97d ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_sorted );
    assert( tmp_called_name_1 != NULL );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_iterItems );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iterItems );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "iterItems" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 272;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_code_objects );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 272;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_fae54a9f06e0ed034c5de9b4ee7af97d->m_frame.f_lineno = 272;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 272;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_fae54a9f06e0ed034c5de9b4ee7af97d->m_frame.f_lineno = 272;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 272;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae54a9f06e0ed034c5de9b4ee7af97d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae54a9f06e0ed034c5de9b4ee7af97d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae54a9f06e0ed034c5de9b4ee7af97d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fae54a9f06e0ed034c5de9b4ee7af97d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fae54a9f06e0ed034c5de9b4ee7af97d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fae54a9f06e0ed034c5de9b4ee7af97d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fae54a9f06e0ed034c5de9b4ee7af97d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fae54a9f06e0ed034c5de9b4ee7af97d == cache_frame_fae54a9f06e0ed034c5de9b4ee7af97d )
    {
        Py_DECREF( frame_fae54a9f06e0ed034c5de9b4ee7af97d );
    }
    cache_frame_fae54a9f06e0ed034c5de9b4ee7af97d = NULL;

    assertFrameObject( frame_fae54a9f06e0ed034c5de9b4ee7af97d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_36_getCodeObjects );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_36_getCodeObjects );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_37_getCodeObjectHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_code_object = python_pars[ 1 ];
    PyObject *var_key = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_name_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_0d7b531e9016f557c16c8d652d9e7c59 = NULL;

    struct Nuitka_FrameObject *frame_0d7b531e9016f557c16c8d652d9e7c59;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d7b531e9016f557c16c8d652d9e7c59, codeobj_0d7b531e9016f557c16c8d652d9e7c59, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0d7b531e9016f557c16c8d652d9e7c59 = cache_frame_0d7b531e9016f557c16c8d652d9e7c59;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d7b531e9016f557c16c8d652d9e7c59 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d7b531e9016f557c16c8d652d9e7c59 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_code_object;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 276;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFilename );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 276;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PyTuple_New( 13 );
    PyTuple_SET_ITEM( tmp_assign_source_1, 0, tmp_tuple_element_1 );
    tmp_called_instance_2 = par_code_object;

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 277;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 277;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getCodeObjectName );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 277;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 1, tmp_tuple_element_1 );
    tmp_called_instance_3 = par_code_object;

    if ( tmp_called_instance_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 278;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getLineNumber );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 278;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 2, tmp_tuple_element_1 );
    tmp_called_instance_4 = par_code_object;

    if ( tmp_called_instance_4 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 279;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 279;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getVarNames );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 279;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 3, tmp_tuple_element_1 );
    tmp_called_instance_5 = par_code_object;

    if ( tmp_called_instance_5 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 280;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 280;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getArgumentCount );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 280;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 4, tmp_tuple_element_1 );
    tmp_called_instance_6 = par_code_object;

    if ( tmp_called_instance_6 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 281;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 281;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getKwOnlyParameterCount );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 281;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 5, tmp_tuple_element_1 );
    tmp_called_instance_7 = par_code_object;

    if ( tmp_called_instance_7 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 282;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 282;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getCodeObjectKind );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 282;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 6, tmp_tuple_element_1 );
    tmp_called_instance_8 = par_code_object;

    if ( tmp_called_instance_8 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 283;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 283;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getFlagIsOptimizedValue );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 283;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 7, tmp_tuple_element_1 );
    tmp_called_instance_9 = par_code_object;

    if ( tmp_called_instance_9 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 284;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 284;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_getFlagNewLocalsValue );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 284;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 8, tmp_tuple_element_1 );
    tmp_called_instance_10 = par_code_object;

    if ( tmp_called_instance_10 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 285;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 285;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_hasStarListArg );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 285;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 9, tmp_tuple_element_1 );
    tmp_called_instance_11 = par_code_object;

    if ( tmp_called_instance_11 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 286;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_hasStarDictArg );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 286;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 10, tmp_tuple_element_1 );
    tmp_called_instance_12 = par_code_object;

    if ( tmp_called_instance_12 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 287;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 287;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_12, const_str_plain_getFlagHasClosureValue );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 287;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 11, tmp_tuple_element_1 );
    tmp_called_instance_14 = par_code_object;

    if ( tmp_called_instance_14 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 288;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 288;
    tmp_called_instance_13 = CALL_METHOD_NO_ARGS( tmp_called_instance_14, const_str_plain_getFutureSpec );
    if ( tmp_called_instance_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 288;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 288;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_13, const_str_plain_asFlags );
    Py_DECREF( tmp_called_instance_13 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 288;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_1, 12, tmp_tuple_element_1 );
    assert( var_key == NULL );
    var_key = tmp_assign_source_1;

    tmp_compare_left_1 = var_key;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_code_objects );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 291;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_5d74e5cd1518c783fc6a69f3668478fe;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__calcHash );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_key;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame.f_lineno = 292;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_code_objects );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = var_key;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 294;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_code_objects );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = var_key;

    if ( tmp_subscript_name_1 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 294;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d7b531e9016f557c16c8d652d9e7c59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d7b531e9016f557c16c8d652d9e7c59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d7b531e9016f557c16c8d652d9e7c59 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d7b531e9016f557c16c8d652d9e7c59, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d7b531e9016f557c16c8d652d9e7c59->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d7b531e9016f557c16c8d652d9e7c59, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d7b531e9016f557c16c8d652d9e7c59,
        type_description_1,
        par_self,
        par_code_object,
        var_key
    );


    // Release cached frame.
    if ( frame_0d7b531e9016f557c16c8d652d9e7c59 == cache_frame_0d7b531e9016f557c16c8d652d9e7c59 )
    {
        Py_DECREF( frame_0d7b531e9016f557c16c8d652d9e7c59 );
    }
    cache_frame_0d7b531e9016f557c16c8d652d9e7c59 = NULL;

    assertFrameObject( frame_0d7b531e9016f557c16c8d652d9e7c59 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_37_getCodeObjectHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_37_getCodeObjectHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_38__calcHash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *var_hash_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e3c6e6d8bb7af7f501ea790a81f35acc = NULL;

    struct Nuitka_FrameObject *frame_e3c6e6d8bb7af7f501ea790a81f35acc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e3c6e6d8bb7af7f501ea790a81f35acc, codeobj_e3c6e6d8bb7af7f501ea790a81f35acc, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e3c6e6d8bb7af7f501ea790a81f35acc = cache_frame_e3c6e6d8bb7af7f501ea790a81f35acc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e3c6e6d8bb7af7f501ea790a81f35acc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e3c6e6d8bb7af7f501ea790a81f35acc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_hashlib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hashlib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "hashlib" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 298;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_md5 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 298;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_a0e70fff63384bf33577c66143d20c55;
    tmp_right_name_1 = par_key;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 299;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 299;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_e3c6e6d8bb7af7f501ea790a81f35acc->m_frame.f_lineno = 298;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 298;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_hash_value == NULL );
    var_hash_value = tmp_assign_source_1;

    tmp_called_instance_1 = var_hash_value;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_e3c6e6d8bb7af7f501ea790a81f35acc->m_frame.f_lineno = 302;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_hexdigest );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3c6e6d8bb7af7f501ea790a81f35acc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3c6e6d8bb7af7f501ea790a81f35acc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3c6e6d8bb7af7f501ea790a81f35acc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e3c6e6d8bb7af7f501ea790a81f35acc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e3c6e6d8bb7af7f501ea790a81f35acc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e3c6e6d8bb7af7f501ea790a81f35acc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3c6e6d8bb7af7f501ea790a81f35acc,
        type_description_1,
        par_self,
        par_key,
        var_hash_value
    );


    // Release cached frame.
    if ( frame_e3c6e6d8bb7af7f501ea790a81f35acc == cache_frame_e3c6e6d8bb7af7f501ea790a81f35acc )
    {
        Py_DECREF( frame_e3c6e6d8bb7af7f501ea790a81f35acc );
    }
    cache_frame_e3c6e6d8bb7af7f501ea790a81f35acc = NULL;

    assertFrameObject( frame_e3c6e6d8bb7af7f501ea790a81f35acc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_38__calcHash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( var_hash_value );
    var_hash_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( var_hash_value );
    var_hash_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_38__calcHash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_39__calcHash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *var_hash_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_613a6bbb05a901dd8b334f4a997d5bc5 = NULL;

    struct Nuitka_FrameObject *frame_613a6bbb05a901dd8b334f4a997d5bc5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_613a6bbb05a901dd8b334f4a997d5bc5, codeobj_613a6bbb05a901dd8b334f4a997d5bc5, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_613a6bbb05a901dd8b334f4a997d5bc5 = cache_frame_613a6bbb05a901dd8b334f4a997d5bc5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_613a6bbb05a901dd8b334f4a997d5bc5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_613a6bbb05a901dd8b334f4a997d5bc5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_hashlib );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hashlib );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "hashlib" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 305;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_md5 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_a0e70fff63384bf33577c66143d20c55;
    tmp_right_name_1 = par_key;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 306;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 306;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_613a6bbb05a901dd8b334f4a997d5bc5->m_frame.f_lineno = 306;
    tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 306;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    frame_613a6bbb05a901dd8b334f4a997d5bc5->m_frame.f_lineno = 305;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_hash_value == NULL );
    var_hash_value = tmp_assign_source_1;

    tmp_called_instance_2 = var_hash_value;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_613a6bbb05a901dd8b334f4a997d5bc5->m_frame.f_lineno = 309;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_hexdigest );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 309;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_613a6bbb05a901dd8b334f4a997d5bc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_613a6bbb05a901dd8b334f4a997d5bc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_613a6bbb05a901dd8b334f4a997d5bc5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_613a6bbb05a901dd8b334f4a997d5bc5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_613a6bbb05a901dd8b334f4a997d5bc5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_613a6bbb05a901dd8b334f4a997d5bc5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_613a6bbb05a901dd8b334f4a997d5bc5,
        type_description_1,
        par_self,
        par_key,
        var_hash_value
    );


    // Release cached frame.
    if ( frame_613a6bbb05a901dd8b334f4a997d5bc5 == cache_frame_613a6bbb05a901dd8b334f4a997d5bc5 )
    {
        Py_DECREF( frame_613a6bbb05a901dd8b334f4a997d5bc5 );
    }
    cache_frame_613a6bbb05a901dd8b334f4a997d5bc5 = NULL;

    assertFrameObject( frame_613a6bbb05a901dd8b334f4a997d5bc5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_39__calcHash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( var_hash_value );
    var_hash_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( var_hash_value );
    var_hash_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_39__calcHash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_40___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_6616b03b6b092083572f0278ce78197f = NULL;

    struct Nuitka_FrameObject *frame_6616b03b6b092083572f0278ce78197f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6616b03b6b092083572f0278ce78197f, codeobj_6616b03b6b092083572f0278ce78197f, module_codegen$Contexts, sizeof(void *) );
    frame_6616b03b6b092083572f0278ce78197f = cache_frame_6616b03b6b092083572f0278ce78197f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6616b03b6b092083572f0278ce78197f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6616b03b6b092083572f0278ce78197f ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_source_ref, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 317;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_current_source_ref, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = Py_None;
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 318;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_last_source_ref, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 318;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6616b03b6b092083572f0278ce78197f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6616b03b6b092083572f0278ce78197f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6616b03b6b092083572f0278ce78197f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6616b03b6b092083572f0278ce78197f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6616b03b6b092083572f0278ce78197f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6616b03b6b092083572f0278ce78197f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6616b03b6b092083572f0278ce78197f == cache_frame_6616b03b6b092083572f0278ce78197f )
    {
        Py_DECREF( frame_6616b03b6b092083572f0278ce78197f );
    }
    cache_frame_6616b03b6b092083572f0278ce78197f = NULL;

    assertFrameObject( frame_6616b03b6b092083572f0278ce78197f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_40___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_40___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_41_getCurrentSourceCodeReference( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_246089cfed5fbe1fdb5587fa09925e84 = NULL;

    struct Nuitka_FrameObject *frame_246089cfed5fbe1fdb5587fa09925e84;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_246089cfed5fbe1fdb5587fa09925e84, codeobj_246089cfed5fbe1fdb5587fa09925e84, module_codegen$Contexts, sizeof(void *) );
    frame_246089cfed5fbe1fdb5587fa09925e84 = cache_frame_246089cfed5fbe1fdb5587fa09925e84;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_246089cfed5fbe1fdb5587fa09925e84 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_246089cfed5fbe1fdb5587fa09925e84 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_current_source_ref );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 323;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_246089cfed5fbe1fdb5587fa09925e84 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_246089cfed5fbe1fdb5587fa09925e84 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_246089cfed5fbe1fdb5587fa09925e84 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_246089cfed5fbe1fdb5587fa09925e84, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_246089cfed5fbe1fdb5587fa09925e84->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_246089cfed5fbe1fdb5587fa09925e84, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_246089cfed5fbe1fdb5587fa09925e84,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_246089cfed5fbe1fdb5587fa09925e84 == cache_frame_246089cfed5fbe1fdb5587fa09925e84 )
    {
        Py_DECREF( frame_246089cfed5fbe1fdb5587fa09925e84 );
    }
    cache_frame_246089cfed5fbe1fdb5587fa09925e84 = NULL;

    assertFrameObject( frame_246089cfed5fbe1fdb5587fa09925e84 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_41_getCurrentSourceCodeReference );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_41_getCurrentSourceCodeReference );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_42_setCurrentSourceCodeReference( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_9cfed625fb66042ae350c88c741f7122 = NULL;

    struct Nuitka_FrameObject *frame_9cfed625fb66042ae350c88c741f7122;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9cfed625fb66042ae350c88c741f7122, codeobj_9cfed625fb66042ae350c88c741f7122, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9cfed625fb66042ae350c88c741f7122 = cache_frame_9cfed625fb66042ae350c88c741f7122;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9cfed625fb66042ae350c88c741f7122 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9cfed625fb66042ae350c88c741f7122 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_current_source_ref );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_value;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 327;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 327;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_current_source_ref, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = par_value;

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 329;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_2 = var_result;

    if ( tmp_assattr_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 330;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 330;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_last_source_ref, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 330;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 332;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cfed625fb66042ae350c88c741f7122 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cfed625fb66042ae350c88c741f7122 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cfed625fb66042ae350c88c741f7122 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9cfed625fb66042ae350c88c741f7122, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9cfed625fb66042ae350c88c741f7122->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9cfed625fb66042ae350c88c741f7122, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9cfed625fb66042ae350c88c741f7122,
        type_description_1,
        par_self,
        par_value,
        var_result
    );


    // Release cached frame.
    if ( frame_9cfed625fb66042ae350c88c741f7122 == cache_frame_9cfed625fb66042ae350c88c741f7122 )
    {
        Py_DECREF( frame_9cfed625fb66042ae350c88c741f7122 );
    }
    cache_frame_9cfed625fb66042ae350c88c741f7122 = NULL;

    assertFrameObject( frame_9cfed625fb66042ae350c88c741f7122 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_42_setCurrentSourceCodeReference );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_42_setCurrentSourceCodeReference );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_43_getLastSourceCodeReference( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_1dc5c3c7f783016616c31176f5a18b1e = NULL;

    struct Nuitka_FrameObject *frame_1dc5c3c7f783016616c31176f5a18b1e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1dc5c3c7f783016616c31176f5a18b1e, codeobj_1dc5c3c7f783016616c31176f5a18b1e, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_1dc5c3c7f783016616c31176f5a18b1e = cache_frame_1dc5c3c7f783016616c31176f5a18b1e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1dc5c3c7f783016616c31176f5a18b1e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1dc5c3c7f783016616c31176f5a18b1e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_last_source_ref );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 335;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_1dc5c3c7f783016616c31176f5a18b1e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1dc5c3c7f783016616c31176f5a18b1e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1dc5c3c7f783016616c31176f5a18b1e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1dc5c3c7f783016616c31176f5a18b1e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1dc5c3c7f783016616c31176f5a18b1e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1dc5c3c7f783016616c31176f5a18b1e,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_1dc5c3c7f783016616c31176f5a18b1e == cache_frame_1dc5c3c7f783016616c31176f5a18b1e )
    {
        Py_DECREF( frame_1dc5c3c7f783016616c31176f5a18b1e );
    }
    cache_frame_1dc5c3c7f783016616c31176f5a18b1e = NULL;

    assertFrameObject( frame_1dc5c3c7f783016616c31176f5a18b1e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_43_getLastSourceCodeReference );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_43_getLastSourceCodeReference );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_44_isUsed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_d4fc9340eeaa4816566dd22c485b1649 = NULL;

    struct Nuitka_FrameObject *frame_d4fc9340eeaa4816566dd22c485b1649;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d4fc9340eeaa4816566dd22c485b1649, codeobj_d4fc9340eeaa4816566dd22c485b1649, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_d4fc9340eeaa4816566dd22c485b1649 = cache_frame_d4fc9340eeaa4816566dd22c485b1649;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d4fc9340eeaa4816566dd22c485b1649 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d4fc9340eeaa4816566dd22c485b1649 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_tmp_name;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_d4fc9340eeaa4816566dd22c485b1649->m_frame.f_lineno = 340;
    tmp_cond_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_tmp_unused__tuple, 0 ) );

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 340;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 340;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4fc9340eeaa4816566dd22c485b1649 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4fc9340eeaa4816566dd22c485b1649 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4fc9340eeaa4816566dd22c485b1649 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d4fc9340eeaa4816566dd22c485b1649, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d4fc9340eeaa4816566dd22c485b1649->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d4fc9340eeaa4816566dd22c485b1649, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d4fc9340eeaa4816566dd22c485b1649,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_d4fc9340eeaa4816566dd22c485b1649 == cache_frame_d4fc9340eeaa4816566dd22c485b1649 )
    {
        Py_DECREF( frame_d4fc9340eeaa4816566dd22c485b1649 );
    }
    cache_frame_d4fc9340eeaa4816566dd22c485b1649 = NULL;

    assertFrameObject( frame_d4fc9340eeaa4816566dd22c485b1649 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_44_isUsed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_44_isUsed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_45_getConstantCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_45_getConstantCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_45_getConstantCode );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_46_getModuleCodeName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_46_getModuleCodeName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_46_getModuleCodeName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_47_getModuleName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_47_getModuleName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_47_getModuleName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_48_addHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_48_addHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_48_addHelperCode );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_49_hasHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_49_hasHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_49_hasHelperCode );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_50_addDeclaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_50_addDeclaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_50_addDeclaration );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_51_pushFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_variables = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_51_pushFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_51_pushFrameVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_52_popFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_52_popFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_52_popFrameVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_54_getFrameVariableTypeDescription( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_54_getFrameVariableTypeDescription );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_54_getFrameVariableTypeDescription );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_56_getFrameVariableCodeNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_56_getFrameVariableCodeNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_56_getFrameVariableCodeNames );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_57_allocateTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *par_type_name = python_pars[ 2 ];
    PyObject *par_unique = python_pars[ 3 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_57_allocateTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_57_allocateTempName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_58_getIntResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_58_getIntResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_58_getIntResName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_59_getBoolResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_59_getBoolResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_59_getBoolResName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_60_hasTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_60_hasTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_60_hasTempName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_61_forgetTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_61_forgetTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_61_forgetTempName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_62_getTempNameInfos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_62_getTempNameInfos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_62_getTempNameInfos );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_63_getExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_63_getExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_63_getExceptionEscape );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_64_setExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_64_setExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_64_setExceptionEscape );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_65_getLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_65_getLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_65_getLoopBreakTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_66_setLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_66_setLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_66_setLoopBreakTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_67_getLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_67_getLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_67_getLoopContinueTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_68_setLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_68_setLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_68_setLoopContinueTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_69_allocateLabel( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_69_allocateLabel );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_69_allocateLabel );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_70_needsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_70_needsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_70_needsExceptionVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_71_markAsNeedsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_71_markAsNeedsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_71_markAsNeedsExceptionVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_72_allocateExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_72_allocateExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_72_allocateExceptionKeeperVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_73_getExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_73_getExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_73_getExceptionKeeperVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_74_setExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_keeper_vars = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_74_setExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_74_setExceptionKeeperVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_75_addExceptionPreserverVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_count = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_75_addExceptionPreserverVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_75_addExceptionPreserverVariables );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_76_getTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_76_getTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_76_getTrueBranchTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_77_getFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_77_getFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_77_getFalseBranchTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_78_setTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_78_setTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_78_setTrueBranchTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_79_setFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_79_setFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_79_setFalseBranchTarget );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_80_getCleanupTempnames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_80_getCleanupTempnames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_80_getCleanupTempnames );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_81_addCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_81_addCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_81_addCleanupTempName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_82_removeCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_82_removeCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_82_removeCleanupTempName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_83_needsCleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_83_needsCleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_83_needsCleanup );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_84_pushCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_84_pushCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_84_pushCleanupScope );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_85_popCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_85_popCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_85_popCleanupScope );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_86___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_parent = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ff8880cfcc099c1b7f4d600a34e00055 = NULL;

    struct Nuitka_FrameObject *frame_ff8880cfcc099c1b7f4d600a34e00055;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff8880cfcc099c1b7f4d600a34e00055, codeobj_ff8880cfcc099c1b7f4d600a34e00055, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_ff8880cfcc099c1b7f4d600a34e00055 = cache_frame_ff8880cfcc099c1b7f4d600a34e00055;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff8880cfcc099c1b7f4d600a34e00055 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff8880cfcc099c1b7f4d600a34e00055 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonContextBase );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonContextBase );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 515;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___init__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 515;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 515;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_ff8880cfcc099c1b7f4d600a34e00055->m_frame.f_lineno = 515;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 515;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_parent;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "parent" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 517;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 517;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_parent, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 517;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff8880cfcc099c1b7f4d600a34e00055 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff8880cfcc099c1b7f4d600a34e00055 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff8880cfcc099c1b7f4d600a34e00055, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff8880cfcc099c1b7f4d600a34e00055->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff8880cfcc099c1b7f4d600a34e00055, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff8880cfcc099c1b7f4d600a34e00055,
        type_description_1,
        par_self,
        par_parent
    );


    // Release cached frame.
    if ( frame_ff8880cfcc099c1b7f4d600a34e00055 == cache_frame_ff8880cfcc099c1b7f4d600a34e00055 )
    {
        Py_DECREF( frame_ff8880cfcc099c1b7f4d600a34e00055 );
    }
    cache_frame_ff8880cfcc099c1b7f4d600a34e00055 = NULL;

    assertFrameObject( frame_ff8880cfcc099c1b7f4d600a34e00055 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_86___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_86___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_87_getConstantCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d4a852c96da0e1bef940ac0123a460db = NULL;

    struct Nuitka_FrameObject *frame_d4a852c96da0e1bef940ac0123a460db;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d4a852c96da0e1bef940ac0123a460db, codeobj_d4a852c96da0e1bef940ac0123a460db, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_d4a852c96da0e1bef940ac0123a460db = cache_frame_d4a852c96da0e1bef940ac0123a460db;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d4a852c96da0e1bef940ac0123a460db );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d4a852c96da0e1bef940ac0123a460db ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getConstantCode );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_constant;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 520;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_d4a852c96da0e1bef940ac0123a460db->m_frame.f_lineno = 520;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4a852c96da0e1bef940ac0123a460db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4a852c96da0e1bef940ac0123a460db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4a852c96da0e1bef940ac0123a460db );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d4a852c96da0e1bef940ac0123a460db, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d4a852c96da0e1bef940ac0123a460db->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d4a852c96da0e1bef940ac0123a460db, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d4a852c96da0e1bef940ac0123a460db,
        type_description_1,
        par_self,
        par_constant
    );


    // Release cached frame.
    if ( frame_d4a852c96da0e1bef940ac0123a460db == cache_frame_d4a852c96da0e1bef940ac0123a460db )
    {
        Py_DECREF( frame_d4a852c96da0e1bef940ac0123a460db );
    }
    cache_frame_d4a852c96da0e1bef940ac0123a460db = NULL;

    assertFrameObject( frame_d4a852c96da0e1bef940ac0123a460db );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_87_getConstantCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_87_getConstantCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_88_getModuleCodeName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6a911389a85e2285f16b7e383cb2cc90 = NULL;

    struct Nuitka_FrameObject *frame_6a911389a85e2285f16b7e383cb2cc90;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a911389a85e2285f16b7e383cb2cc90, codeobj_6a911389a85e2285f16b7e383cb2cc90, module_codegen$Contexts, sizeof(void *) );
    frame_6a911389a85e2285f16b7e383cb2cc90 = cache_frame_6a911389a85e2285f16b7e383cb2cc90;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a911389a85e2285f16b7e383cb2cc90 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a911389a85e2285f16b7e383cb2cc90 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 523;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_6a911389a85e2285f16b7e383cb2cc90->m_frame.f_lineno = 523;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getModuleCodeName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 523;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a911389a85e2285f16b7e383cb2cc90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a911389a85e2285f16b7e383cb2cc90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a911389a85e2285f16b7e383cb2cc90 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a911389a85e2285f16b7e383cb2cc90, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a911389a85e2285f16b7e383cb2cc90->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a911389a85e2285f16b7e383cb2cc90, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a911389a85e2285f16b7e383cb2cc90,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6a911389a85e2285f16b7e383cb2cc90 == cache_frame_6a911389a85e2285f16b7e383cb2cc90 )
    {
        Py_DECREF( frame_6a911389a85e2285f16b7e383cb2cc90 );
    }
    cache_frame_6a911389a85e2285f16b7e383cb2cc90 = NULL;

    assertFrameObject( frame_6a911389a85e2285f16b7e383cb2cc90 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_88_getModuleCodeName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_88_getModuleCodeName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_89_getModuleName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_52265f0f9c5f7a05f5e1456e052b9e62 = NULL;

    struct Nuitka_FrameObject *frame_52265f0f9c5f7a05f5e1456e052b9e62;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_52265f0f9c5f7a05f5e1456e052b9e62, codeobj_52265f0f9c5f7a05f5e1456e052b9e62, module_codegen$Contexts, sizeof(void *) );
    frame_52265f0f9c5f7a05f5e1456e052b9e62 = cache_frame_52265f0f9c5f7a05f5e1456e052b9e62;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_52265f0f9c5f7a05f5e1456e052b9e62 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_52265f0f9c5f7a05f5e1456e052b9e62 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 526;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_52265f0f9c5f7a05f5e1456e052b9e62->m_frame.f_lineno = 526;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getModuleName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 526;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52265f0f9c5f7a05f5e1456e052b9e62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_52265f0f9c5f7a05f5e1456e052b9e62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52265f0f9c5f7a05f5e1456e052b9e62 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_52265f0f9c5f7a05f5e1456e052b9e62, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_52265f0f9c5f7a05f5e1456e052b9e62->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_52265f0f9c5f7a05f5e1456e052b9e62, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_52265f0f9c5f7a05f5e1456e052b9e62,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_52265f0f9c5f7a05f5e1456e052b9e62 == cache_frame_52265f0f9c5f7a05f5e1456e052b9e62 )
    {
        Py_DECREF( frame_52265f0f9c5f7a05f5e1456e052b9e62 );
    }
    cache_frame_52265f0f9c5f7a05f5e1456e052b9e62 = NULL;

    assertFrameObject( frame_52265f0f9c5f7a05f5e1456e052b9e62 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_89_getModuleName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_89_getModuleName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_90_addHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_3ee379237e2305259cec4dab3e46caf3 = NULL;

    struct Nuitka_FrameObject *frame_3ee379237e2305259cec4dab3e46caf3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ee379237e2305259cec4dab3e46caf3, codeobj_3ee379237e2305259cec4dab3e46caf3, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3ee379237e2305259cec4dab3e46caf3 = cache_frame_3ee379237e2305259cec4dab3e46caf3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ee379237e2305259cec4dab3e46caf3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ee379237e2305259cec4dab3e46caf3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addHelperCode );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_key;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_code;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_3ee379237e2305259cec4dab3e46caf3->m_frame.f_lineno = 529;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 529;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ee379237e2305259cec4dab3e46caf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ee379237e2305259cec4dab3e46caf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ee379237e2305259cec4dab3e46caf3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ee379237e2305259cec4dab3e46caf3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ee379237e2305259cec4dab3e46caf3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ee379237e2305259cec4dab3e46caf3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ee379237e2305259cec4dab3e46caf3,
        type_description_1,
        par_self,
        par_key,
        par_code
    );


    // Release cached frame.
    if ( frame_3ee379237e2305259cec4dab3e46caf3 == cache_frame_3ee379237e2305259cec4dab3e46caf3 )
    {
        Py_DECREF( frame_3ee379237e2305259cec4dab3e46caf3 );
    }
    cache_frame_3ee379237e2305259cec4dab3e46caf3 = NULL;

    assertFrameObject( frame_3ee379237e2305259cec4dab3e46caf3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_90_addHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_90_addHelperCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_91_hasHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_effca39acf7537335eca7e16bd4108b6 = NULL;

    struct Nuitka_FrameObject *frame_effca39acf7537335eca7e16bd4108b6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_effca39acf7537335eca7e16bd4108b6, codeobj_effca39acf7537335eca7e16bd4108b6, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_effca39acf7537335eca7e16bd4108b6 = cache_frame_effca39acf7537335eca7e16bd4108b6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_effca39acf7537335eca7e16bd4108b6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_effca39acf7537335eca7e16bd4108b6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 532;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_hasHelperCode );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 532;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_key;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 532;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_effca39acf7537335eca7e16bd4108b6->m_frame.f_lineno = 532;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 532;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_effca39acf7537335eca7e16bd4108b6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_effca39acf7537335eca7e16bd4108b6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_effca39acf7537335eca7e16bd4108b6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_effca39acf7537335eca7e16bd4108b6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_effca39acf7537335eca7e16bd4108b6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_effca39acf7537335eca7e16bd4108b6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_effca39acf7537335eca7e16bd4108b6,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_effca39acf7537335eca7e16bd4108b6 == cache_frame_effca39acf7537335eca7e16bd4108b6 )
    {
        Py_DECREF( frame_effca39acf7537335eca7e16bd4108b6 );
    }
    cache_frame_effca39acf7537335eca7e16bd4108b6 = NULL;

    assertFrameObject( frame_effca39acf7537335eca7e16bd4108b6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_91_hasHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_91_hasHelperCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_92_addDeclaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e0086fb7b6654192c83c3e220cf1b3aa = NULL;

    struct Nuitka_FrameObject *frame_e0086fb7b6654192c83c3e220cf1b3aa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e0086fb7b6654192c83c3e220cf1b3aa, codeobj_e0086fb7b6654192c83c3e220cf1b3aa, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e0086fb7b6654192c83c3e220cf1b3aa = cache_frame_e0086fb7b6654192c83c3e220cf1b3aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e0086fb7b6654192c83c3e220cf1b3aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e0086fb7b6654192c83c3e220cf1b3aa ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addDeclaration );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_key;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 535;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_code;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 535;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_e0086fb7b6654192c83c3e220cf1b3aa->m_frame.f_lineno = 535;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e0086fb7b6654192c83c3e220cf1b3aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e0086fb7b6654192c83c3e220cf1b3aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e0086fb7b6654192c83c3e220cf1b3aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e0086fb7b6654192c83c3e220cf1b3aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e0086fb7b6654192c83c3e220cf1b3aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e0086fb7b6654192c83c3e220cf1b3aa,
        type_description_1,
        par_self,
        par_key,
        par_code
    );


    // Release cached frame.
    if ( frame_e0086fb7b6654192c83c3e220cf1b3aa == cache_frame_e0086fb7b6654192c83c3e220cf1b3aa )
    {
        Py_DECREF( frame_e0086fb7b6654192c83c3e220cf1b3aa );
    }
    cache_frame_e0086fb7b6654192c83c3e220cf1b3aa = NULL;

    assertFrameObject( frame_e0086fb7b6654192c83c3e220cf1b3aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_92_addDeclaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_92_addDeclaration );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_93_pushFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_variables = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_27b8f23b5afbde7937db11a3c1152e92 = NULL;

    struct Nuitka_FrameObject *frame_27b8f23b5afbde7937db11a3c1152e92;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27b8f23b5afbde7937db11a3c1152e92, codeobj_27b8f23b5afbde7937db11a3c1152e92, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_27b8f23b5afbde7937db11a3c1152e92 = cache_frame_27b8f23b5afbde7937db11a3c1152e92;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27b8f23b5afbde7937db11a3c1152e92 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27b8f23b5afbde7937db11a3c1152e92 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_pushFrameVariables );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_variables;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_variables" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_27b8f23b5afbde7937db11a3c1152e92->m_frame.f_lineno = 538;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 538;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27b8f23b5afbde7937db11a3c1152e92 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_27b8f23b5afbde7937db11a3c1152e92 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27b8f23b5afbde7937db11a3c1152e92 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27b8f23b5afbde7937db11a3c1152e92, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27b8f23b5afbde7937db11a3c1152e92->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27b8f23b5afbde7937db11a3c1152e92, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27b8f23b5afbde7937db11a3c1152e92,
        type_description_1,
        par_self,
        par_frame_variables
    );


    // Release cached frame.
    if ( frame_27b8f23b5afbde7937db11a3c1152e92 == cache_frame_27b8f23b5afbde7937db11a3c1152e92 )
    {
        Py_DECREF( frame_27b8f23b5afbde7937db11a3c1152e92 );
    }
    cache_frame_27b8f23b5afbde7937db11a3c1152e92 = NULL;

    assertFrameObject( frame_27b8f23b5afbde7937db11a3c1152e92 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_93_pushFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_93_pushFrameVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_94_popFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_02dfe0aee0348ef048c777d56d4a31b5 = NULL;

    struct Nuitka_FrameObject *frame_02dfe0aee0348ef048c777d56d4a31b5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02dfe0aee0348ef048c777d56d4a31b5, codeobj_02dfe0aee0348ef048c777d56d4a31b5, module_codegen$Contexts, sizeof(void *) );
    frame_02dfe0aee0348ef048c777d56d4a31b5 = cache_frame_02dfe0aee0348ef048c777d56d4a31b5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02dfe0aee0348ef048c777d56d4a31b5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02dfe0aee0348ef048c777d56d4a31b5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_02dfe0aee0348ef048c777d56d4a31b5->m_frame.f_lineno = 541;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_popFrameVariables );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02dfe0aee0348ef048c777d56d4a31b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_02dfe0aee0348ef048c777d56d4a31b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02dfe0aee0348ef048c777d56d4a31b5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02dfe0aee0348ef048c777d56d4a31b5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02dfe0aee0348ef048c777d56d4a31b5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02dfe0aee0348ef048c777d56d4a31b5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02dfe0aee0348ef048c777d56d4a31b5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_02dfe0aee0348ef048c777d56d4a31b5 == cache_frame_02dfe0aee0348ef048c777d56d4a31b5 )
    {
        Py_DECREF( frame_02dfe0aee0348ef048c777d56d4a31b5 );
    }
    cache_frame_02dfe0aee0348ef048c777d56d4a31b5 = NULL;

    assertFrameObject( frame_02dfe0aee0348ef048c777d56d4a31b5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_94_popFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_94_popFrameVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a8d22b33c3f6a04ca0441835b99858b8 = NULL;

    struct Nuitka_FrameObject *frame_a8d22b33c3f6a04ca0441835b99858b8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a8d22b33c3f6a04ca0441835b99858b8, codeobj_a8d22b33c3f6a04ca0441835b99858b8, module_codegen$Contexts, sizeof(void *) );
    frame_a8d22b33c3f6a04ca0441835b99858b8 = cache_frame_a8d22b33c3f6a04ca0441835b99858b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a8d22b33c3f6a04ca0441835b99858b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a8d22b33c3f6a04ca0441835b99858b8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_a8d22b33c3f6a04ca0441835b99858b8->m_frame.f_lineno = 544;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameVariableTypeDescriptions );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8d22b33c3f6a04ca0441835b99858b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8d22b33c3f6a04ca0441835b99858b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8d22b33c3f6a04ca0441835b99858b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a8d22b33c3f6a04ca0441835b99858b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a8d22b33c3f6a04ca0441835b99858b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a8d22b33c3f6a04ca0441835b99858b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8d22b33c3f6a04ca0441835b99858b8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a8d22b33c3f6a04ca0441835b99858b8 == cache_frame_a8d22b33c3f6a04ca0441835b99858b8 )
    {
        Py_DECREF( frame_a8d22b33c3f6a04ca0441835b99858b8 );
    }
    cache_frame_a8d22b33c3f6a04ca0441835b99858b8 = NULL;

    assertFrameObject( frame_a8d22b33c3f6a04ca0441835b99858b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_96_getFrameVariableTypeDescription( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_8d42c686e4a517ffb33aa31922634976 = NULL;

    struct Nuitka_FrameObject *frame_8d42c686e4a517ffb33aa31922634976;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8d42c686e4a517ffb33aa31922634976, codeobj_8d42c686e4a517ffb33aa31922634976, module_codegen$Contexts, sizeof(void *) );
    frame_8d42c686e4a517ffb33aa31922634976 = cache_frame_8d42c686e4a517ffb33aa31922634976;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8d42c686e4a517ffb33aa31922634976 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8d42c686e4a517ffb33aa31922634976 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_8d42c686e4a517ffb33aa31922634976->m_frame.f_lineno = 547;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameVariableTypeDescription );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d42c686e4a517ffb33aa31922634976 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d42c686e4a517ffb33aa31922634976 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d42c686e4a517ffb33aa31922634976 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8d42c686e4a517ffb33aa31922634976, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8d42c686e4a517ffb33aa31922634976->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8d42c686e4a517ffb33aa31922634976, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d42c686e4a517ffb33aa31922634976,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8d42c686e4a517ffb33aa31922634976 == cache_frame_8d42c686e4a517ffb33aa31922634976 )
    {
        Py_DECREF( frame_8d42c686e4a517ffb33aa31922634976 );
    }
    cache_frame_8d42c686e4a517ffb33aa31922634976 = NULL;

    assertFrameObject( frame_8d42c686e4a517ffb33aa31922634976 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_96_getFrameVariableTypeDescription );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_96_getFrameVariableTypeDescription );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_9789c7a9a1b96341f824bcd892fd6fc8 = NULL;

    struct Nuitka_FrameObject *frame_9789c7a9a1b96341f824bcd892fd6fc8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9789c7a9a1b96341f824bcd892fd6fc8, codeobj_9789c7a9a1b96341f824bcd892fd6fc8, module_codegen$Contexts, sizeof(void *) );
    frame_9789c7a9a1b96341f824bcd892fd6fc8 = cache_frame_9789c7a9a1b96341f824bcd892fd6fc8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9789c7a9a1b96341f824bcd892fd6fc8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9789c7a9a1b96341f824bcd892fd6fc8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 550;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_9789c7a9a1b96341f824bcd892fd6fc8->m_frame.f_lineno = 550;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameVariableTypeDescriptionName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 550;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9789c7a9a1b96341f824bcd892fd6fc8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9789c7a9a1b96341f824bcd892fd6fc8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9789c7a9a1b96341f824bcd892fd6fc8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9789c7a9a1b96341f824bcd892fd6fc8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9789c7a9a1b96341f824bcd892fd6fc8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9789c7a9a1b96341f824bcd892fd6fc8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9789c7a9a1b96341f824bcd892fd6fc8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9789c7a9a1b96341f824bcd892fd6fc8 == cache_frame_9789c7a9a1b96341f824bcd892fd6fc8 )
    {
        Py_DECREF( frame_9789c7a9a1b96341f824bcd892fd6fc8 );
    }
    cache_frame_9789c7a9a1b96341f824bcd892fd6fc8 = NULL;

    assertFrameObject( frame_9789c7a9a1b96341f824bcd892fd6fc8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_98_getFrameVariableCodeNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_90e7eac2a5f70c5cb1e6755566df31af = NULL;

    struct Nuitka_FrameObject *frame_90e7eac2a5f70c5cb1e6755566df31af;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_90e7eac2a5f70c5cb1e6755566df31af, codeobj_90e7eac2a5f70c5cb1e6755566df31af, module_codegen$Contexts, sizeof(void *) );
    frame_90e7eac2a5f70c5cb1e6755566df31af = cache_frame_90e7eac2a5f70c5cb1e6755566df31af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_90e7eac2a5f70c5cb1e6755566df31af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_90e7eac2a5f70c5cb1e6755566df31af ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_90e7eac2a5f70c5cb1e6755566df31af->m_frame.f_lineno = 553;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameVariableCodeNames );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_90e7eac2a5f70c5cb1e6755566df31af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_90e7eac2a5f70c5cb1e6755566df31af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_90e7eac2a5f70c5cb1e6755566df31af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_90e7eac2a5f70c5cb1e6755566df31af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_90e7eac2a5f70c5cb1e6755566df31af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_90e7eac2a5f70c5cb1e6755566df31af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_90e7eac2a5f70c5cb1e6755566df31af,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_90e7eac2a5f70c5cb1e6755566df31af == cache_frame_90e7eac2a5f70c5cb1e6755566df31af )
    {
        Py_DECREF( frame_90e7eac2a5f70c5cb1e6755566df31af );
    }
    cache_frame_90e7eac2a5f70c5cb1e6755566df31af = NULL;

    assertFrameObject( frame_90e7eac2a5f70c5cb1e6755566df31af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_98_getFrameVariableCodeNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_98_getFrameVariableCodeNames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_99__getConstantDefaultPopulation( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_name_1;
    int tmp_cmp_GtE_1;
    int tmp_cmp_GtE_2;
    int tmp_cmp_GtE_3;
    int tmp_cmp_GtE_4;
    int tmp_cmp_GtE_5;
    int tmp_cmp_GtE_6;
    int tmp_cmp_In_1;
    int tmp_cmp_Lt_1;
    int tmp_cmp_Lt_2;
    int tmp_cmp_Lt_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_85e21af2194bee806e06cec22bd6a1aa = NULL;

    struct Nuitka_FrameObject *frame_85e21af2194bee806e06cec22bd6a1aa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = DEEP_COPY( const_list_6f2f6b405ec0ec1cb9c5e98a4eadddb0_list );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_85e21af2194bee806e06cec22bd6a1aa, codeobj_85e21af2194bee806e06cec22bd6a1aa, module_codegen$Contexts, sizeof(void *) );
    frame_85e21af2194bee806e06cec22bd6a1aa = cache_frame_85e21af2194bee806e06cec22bd6a1aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_85e21af2194bee806e06cec22bd6a1aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_85e21af2194bee806e06cec22bd6a1aa ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_1 == NULL ))
    {
        tmp_compare_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 619;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = const_int_pos_300;
    tmp_cmp_GtE_1 = RICH_COMPARE_BOOL_GE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_GtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = var_result;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 621;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = const_tuple_str_plain___cached___str_plain___loader___tuple;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_2 = tmp_left_name_1;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 621;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_2;

    tmp_left_name_2 = var_result;

    CHECK_OBJECT( tmp_left_name_2 );
    tmp_right_name_2 = const_tuple_str_plain_print_str_plain_end_str_plain_file_tuple;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
    tmp_assign_source_3 = tmp_left_name_2;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 627;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_3;

    tmp_called_instance_1 = var_result;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 634;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_bytes_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_result;

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 639;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 639;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_compare_left_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_2 == NULL ))
    {
        tmp_compare_left_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 644;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = const_int_pos_330;
    tmp_cmp_GtE_2 = RICH_COMPARE_BOOL_GE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_GtE_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_3 = var_result;

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 646;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 646;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain___loader___tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 646;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_compare_left_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_3 == NULL ))
    {
        tmp_compare_left_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 650;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = const_int_pos_340;
    tmp_cmp_GtE_3 = RICH_COMPARE_BOOL_GE( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_GtE_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_instance_4 = var_result;

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 651;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 651;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_send_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 651;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_compare_left_4 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_4 == NULL ))
    {
        tmp_compare_left_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 656;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_4 = const_int_pos_330;
    tmp_cmp_GtE_4 = RICH_COMPARE_BOOL_GE( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_GtE_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 656;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_4 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_left_name_3 = var_result;

    if ( tmp_left_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 657;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_3 = const_tuple_str_plain_throw_str_plain_close_tuple;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
    tmp_assign_source_4 = tmp_left_name_3;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_4;

    branch_no_4:;
    tmp_compare_left_5 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_5 == NULL ))
    {
        tmp_compare_left_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 664;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_5 = const_int_pos_300;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 664;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_left_name_4 = var_result;

    if ( tmp_left_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 666;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_4 = const_tuple_3b992cae161038cd22ae814b4c32d389_tuple;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_4, tmp_right_name_4 );
    tmp_assign_source_5 = tmp_left_name_4;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 666;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_5;

    tmp_left_name_5 = var_result;

    CHECK_OBJECT( tmp_left_name_5 );
    tmp_right_name_5 = const_tuple_3e0152c1b843d85c58311a1686cbd9ae_tuple;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_5, tmp_right_name_5 );
    tmp_assign_source_6 = tmp_left_name_5;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 673;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_6;

    branch_no_5:;
    tmp_compare_left_6 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_6 == NULL ))
    {
        tmp_compare_left_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 680;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_6 = const_int_pos_300;
    tmp_cmp_Lt_2 = RICH_COMPARE_BOOL_LT( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Lt_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 680;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_2 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_instance_5 = var_result;

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 681;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 681;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_xrange_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 681;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_Options );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 686;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 686;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_shallMakeModule );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 686;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_called_instance_7 = var_result;

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 687;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 687;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain___main___tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_8 = var_result;

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 692;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 692;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_site_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 692;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_7:;
    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_Options );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 697;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 697;
    tmp_cond_value_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_shallMakeModule );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 697;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_left_name_6 = var_result;

    if ( tmp_left_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 698;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_right_name_6 = LIST_COPY( const_list_ac54667c64cc9a45e24ec255bd4d57dc_list );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_6, tmp_right_name_6 );
    tmp_assign_source_7 = tmp_left_name_6;
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    var_result = tmp_assign_source_7;

    tmp_compare_left_7 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_7 == NULL ))
    {
        tmp_compare_left_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 707;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_7 = const_int_pos_300;
    tmp_cmp_Lt_3 = RICH_COMPARE_BOOL_LT( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Lt_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 707;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_3 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_called_instance_10 = var_result;

    if ( tmp_called_instance_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 708;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 708;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_long_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_9:;
    branch_no_8:;
    tmp_compare_left_8 = const_str_plain_no_warnings;
    tmp_called_instance_11 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_Options );

    if (unlikely( tmp_called_instance_11 == NULL ))
    {
        tmp_called_instance_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
    }

    if ( tmp_called_instance_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 713;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 713;
    tmp_compare_right_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_getPythonFlags );
    if ( tmp_compare_right_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 713;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    Py_DECREF( tmp_compare_right_8 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_called_instance_12 = var_result;

    if ( tmp_called_instance_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 714;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 714;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_12, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_ignore_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_10:;
    tmp_compare_left_9 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_9 == NULL ))
    {
        tmp_compare_left_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 718;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_9 = const_int_pos_340;
    tmp_cmp_GtE_5 = RICH_COMPARE_BOOL_GE( tmp_compare_left_9, tmp_compare_right_9 );
    if ( tmp_cmp_GtE_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 718;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_5 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_called_instance_13 = var_result;

    if ( tmp_called_instance_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 720;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 720;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_13, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain___spec___tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 720;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_11:;
    tmp_compare_left_10 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_10 == NULL ))
    {
        tmp_compare_left_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 724;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_10 = const_int_pos_350;
    tmp_cmp_GtE_6 = RICH_COMPARE_BOOL_GE( tmp_compare_left_10, tmp_compare_right_10 );
    if ( tmp_cmp_GtE_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 724;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_6 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_called_instance_14 = var_result;

    if ( tmp_called_instance_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 726;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 726;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_14, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_plain_types_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 726;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_12:;
    tmp_called_instance_15 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_Options );

    if (unlikely( tmp_called_instance_15 == NULL ))
    {
        tmp_called_instance_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
    }

    if ( tmp_called_instance_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 730;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 730;
    tmp_cond_value_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_15, const_str_plain_shallMakeModule );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 730;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 730;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_13;
    }
    else
    {
        goto branch_yes_13;
    }
    branch_yes_13:;
    tmp_source_name_1 = var_result;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 731;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 731;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 732;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_executable );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 732;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_85e21af2194bee806e06cec22bd6a1aa->m_frame.f_lineno = 731;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 731;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 735;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85e21af2194bee806e06cec22bd6a1aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_85e21af2194bee806e06cec22bd6a1aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85e21af2194bee806e06cec22bd6a1aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_85e21af2194bee806e06cec22bd6a1aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_85e21af2194bee806e06cec22bd6a1aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_85e21af2194bee806e06cec22bd6a1aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_85e21af2194bee806e06cec22bd6a1aa,
        type_description_1,
        var_result
    );


    // Release cached frame.
    if ( frame_85e21af2194bee806e06cec22bd6a1aa == cache_frame_85e21af2194bee806e06cec22bd6a1aa )
    {
        Py_DECREF( frame_85e21af2194bee806e06cec22bd6a1aa );
    }
    cache_frame_85e21af2194bee806e06cec22bd6a1aa = NULL;

    assertFrameObject( frame_85e21af2194bee806e06cec22bd6a1aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_99__getConstantDefaultPopulation );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_99__getConstantDefaultPopulation );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_100___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_constant = NULL;
    PyObject *var_code = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_a0ef32db630ee7ffab650705f82949c8 = NULL;

    struct Nuitka_FrameObject *frame_a0ef32db630ee7ffab650705f82949c8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0ef32db630ee7ffab650705f82949c8, codeobj_a0ef32db630ee7ffab650705f82949c8, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a0ef32db630ee7ffab650705f82949c8 = cache_frame_a0ef32db630ee7ffab650705f82949c8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0ef32db630ee7ffab650705f82949c8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0ef32db630ee7ffab650705f82949c8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyDict_New();
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_constants, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = PyDict_New();
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 741;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_constant_use_count, tmp_assattr_name_2 );
    Py_DECREF( tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 741;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain__getConstantDefaultPopulation );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__getConstantDefaultPopulation );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_getConstantDefaultPopulation" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 743;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_a0ef32db630ee7ffab650705f82949c8->m_frame.f_lineno = 743;
    tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooo";
        exception_lineno = 743;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 743;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_constant;
        var_constant = tmp_assign_source_3;
        Py_INCREF( var_constant );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 744;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getConstantCode );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = var_constant;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 744;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    frame_a0ef32db630ee7ffab650705f82949c8->m_frame.f_lineno = 744;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_code;
        var_code = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 747;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_countConstantUse );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = var_code;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 747;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    frame_a0ef32db630ee7ffab650705f82949c8->m_frame.f_lineno = 747;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 748;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_countConstantUse );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 748;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_3 = var_code;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 748;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }

    frame_a0ef32db630ee7ffab650705f82949c8->m_frame.f_lineno = 748;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 748;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_assattr_name_3 = Py_False;
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 750;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_needs_exception_variables, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 750;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0ef32db630ee7ffab650705f82949c8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0ef32db630ee7ffab650705f82949c8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0ef32db630ee7ffab650705f82949c8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0ef32db630ee7ffab650705f82949c8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0ef32db630ee7ffab650705f82949c8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0ef32db630ee7ffab650705f82949c8,
        type_description_1,
        par_self,
        var_constant,
        var_code
    );


    // Release cached frame.
    if ( frame_a0ef32db630ee7ffab650705f82949c8 == cache_frame_a0ef32db630ee7ffab650705f82949c8 )
    {
        Py_DECREF( frame_a0ef32db630ee7ffab650705f82949c8 );
    }
    cache_frame_a0ef32db630ee7ffab650705f82949c8 = NULL;

    assertFrameObject( frame_a0ef32db630ee7ffab650705f82949c8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_100___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_constant );
    var_constant = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_constant );
    var_constant = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_100___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_101_getConstantCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *var_key = NULL;
    PyObject *var_type_name = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_Lt_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_left_15;
    PyObject *tmp_compare_left_16;
    PyObject *tmp_compare_left_17;
    PyObject *tmp_compare_left_18;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compare_right_15;
    PyObject *tmp_compare_right_16;
    PyObject *tmp_compare_right_17;
    PyObject *tmp_compare_right_18;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_left_7;
    PyObject *tmp_compexpr_left_8;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    PyObject *tmp_compexpr_right_7;
    PyObject *tmp_compexpr_right_8;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    bool tmp_is_4;
    bool tmp_is_5;
    bool tmp_is_6;
    bool tmp_is_7;
    bool tmp_is_8;
    bool tmp_is_9;
    bool tmp_is_10;
    bool tmp_is_11;
    bool tmp_is_12;
    bool tmp_is_13;
    bool tmp_is_14;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_type_arg_1;
    static struct Nuitka_FrameObject *cache_frame_6f603200238b09ef26c50ca74a7a3ca3 = NULL;

    struct Nuitka_FrameObject *frame_6f603200238b09ef26c50ca74a7a3ca3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f603200238b09ef26c50ca74a7a3ca3, codeobj_6f603200238b09ef26c50ca74a7a3ca3, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6f603200238b09ef26c50ca74a7a3ca3 = cache_frame_6f603200238b09ef26c50ca74a7a3ca3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f603200238b09ef26c50ca74a7a3ca3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f603200238b09ef26c50ca74a7a3ca3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_constant;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = const_str_plain_Py_None;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_key = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = par_constant;

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 758;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_2 = Py_True;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_2 = const_str_plain_Py_True;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_key = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_3 = par_constant;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 760;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_3 = Py_False;
    tmp_is_3 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_3 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_3 = const_str_plain_Py_False;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_key = tmp_assign_source_3;

    goto branch_end_3;
    branch_no_3:;
    tmp_compare_left_4 = par_constant;

    if ( tmp_compare_left_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 762;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_4 = Py_Ellipsis;
    tmp_is_4 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_4 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_assign_source_4 = const_str_plain_Py_Ellipsis;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_key = tmp_assign_source_4;

    goto branch_end_4;
    branch_no_4:;
    tmp_compare_left_5 = par_constant;

    if ( tmp_compare_left_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 764;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_5 = Py_NotImplemented;
    tmp_is_5 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    if ( tmp_is_5 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_assign_source_5 = const_str_plain_Py_NotImplemented;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_key = tmp_assign_source_5;

    goto branch_end_5;
    branch_no_5:;
    tmp_type_arg_1 = par_constant;

    if ( tmp_type_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 766;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_6 = BUILTIN_TYPE1( tmp_type_arg_1 );
    if ( tmp_compare_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 766;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_6 = (PyObject *)&PyType_Type;
    tmp_is_6 = ( tmp_compare_left_6 == tmp_compare_right_6 );
    Py_DECREF( tmp_compare_left_6 );
    if ( tmp_is_6 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_compare_left_7 = par_constant;

    if ( tmp_compare_left_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 769;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_7 = Py_None;
    tmp_is_7 = ( tmp_compare_left_7 == tmp_compare_right_7 );
    if ( tmp_is_7 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_assign_source_6 = const_str_digest_6c01341e24783701776f89abd8684492;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_key = tmp_assign_source_6;

    goto branch_end_7;
    branch_no_7:;
    tmp_compare_left_8 = par_constant;

    if ( tmp_compare_left_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 771;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_8 = (PyObject *)&PyBaseObject_Type;
    tmp_is_8 = ( tmp_compare_left_8 == tmp_compare_right_8 );
    if ( tmp_is_8 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_assign_source_7 = const_str_digest_620eee19046de9c28a5f5941004f50e0;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_7 );
    var_key = tmp_assign_source_7;

    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_9 = par_constant;

    if ( tmp_compare_left_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 773;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_9 = (PyObject *)&PyStaticMethod_Type;
    tmp_is_9 = ( tmp_compare_left_9 == tmp_compare_right_9 );
    if ( tmp_is_9 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_assign_source_8 = const_str_digest_96845c9d961382c5fbf5500a9e7469c3;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_key = tmp_assign_source_8;

    goto branch_end_9;
    branch_no_9:;
    tmp_compare_left_10 = par_constant;

    if ( tmp_compare_left_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 775;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_10 = (PyObject *)&PyClassMethod_Type;
    tmp_is_10 = ( tmp_compare_left_10 == tmp_compare_right_10 );
    if ( tmp_is_10 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_assign_source_9 = const_str_digest_32fd3375c92eca260cdd6ad686088f06;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_key = tmp_assign_source_9;

    goto branch_end_10;
    branch_no_10:;
    tmp_compare_left_11 = par_constant;

    if ( tmp_compare_left_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 777;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_11 = (PyObject *)&PyByteArray_Type;
    tmp_is_11 = ( tmp_compare_left_11 == tmp_compare_right_11 );
    if ( tmp_is_11 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_assign_source_10 = const_str_digest_40aee10a90964f455d9ea1ff7aac6117;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_10 );
    var_key = tmp_assign_source_10;

    goto branch_end_11;
    branch_no_11:;
    tmp_compare_left_12 = par_constant;

    if ( tmp_compare_left_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 779;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_12 = (PyObject *)&PyEnum_Type;
    tmp_is_12 = ( tmp_compare_left_12 == tmp_compare_right_12 );
    if ( tmp_is_12 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_assign_source_11 = const_str_digest_dc2f9ff63062bab5d561c96bac21dc35;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_11 );
    var_key = tmp_assign_source_11;

    goto branch_end_12;
    branch_no_12:;
    tmp_compare_left_13 = par_constant;

    if ( tmp_compare_left_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 781;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_13 = (PyObject *)&PyFrozenSet_Type;
    tmp_is_13 = ( tmp_compare_left_13 == tmp_compare_right_13 );
    if ( tmp_is_13 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_assign_source_12 = const_str_digest_77c7b66f03bbae96a3d7f48c86745c88;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_12 );
    var_key = tmp_assign_source_12;

    goto branch_end_13;
    branch_no_13:;
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = const_int_pos_270;
    tmp_and_left_value_1 = RICH_COMPARE_GE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 783;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_compexpr_left_2 = par_constant;

    if ( tmp_compexpr_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_2 = (PyObject *)&PyMemoryView_Type;
    tmp_and_right_value_1 = BOOL_FROM( tmp_compexpr_left_2 == tmp_compexpr_right_2 );
    Py_INCREF( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 783;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_14;
    }
    else
    {
        goto branch_no_14;
    }
    branch_yes_14:;
    tmp_assign_source_13 = const_str_digest_da55172e86e697e30db1acc837d8ae44;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_13 );
    var_key = tmp_assign_source_13;

    goto branch_end_14;
    branch_no_14:;
    tmp_compexpr_left_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compexpr_left_3 == NULL ))
    {
        tmp_compexpr_left_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compexpr_left_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_3 = const_int_pos_300;
    tmp_and_left_value_2 = RICH_COMPARE_LT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_compexpr_left_4 = par_constant;

    if ( tmp_compexpr_left_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_4 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_basestring );

    if (unlikely( tmp_compexpr_right_4 == NULL ))
    {
        tmp_compexpr_right_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_basestring );
    }

    if ( tmp_compexpr_right_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "basestring" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_and_right_value_2 = BOOL_FROM( tmp_compexpr_left_4 == tmp_compexpr_right_4 );
    Py_INCREF( tmp_and_right_value_2 );
    tmp_cond_value_2 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_2 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 785;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_15;
    }
    else
    {
        goto branch_no_15;
    }
    branch_yes_15:;
    tmp_assign_source_14 = const_str_digest_90b2ac0e44b346ffb88bff778c792d92;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_14 );
    var_key = tmp_assign_source_14;

    goto branch_end_15;
    branch_no_15:;
    tmp_compexpr_left_5 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compexpr_left_5 == NULL ))
    {
        tmp_compexpr_left_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compexpr_left_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_5 = const_int_pos_300;
    tmp_and_left_value_3 = RICH_COMPARE_LT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    if ( tmp_and_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_3 );

        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    Py_DECREF( tmp_and_left_value_3 );
    tmp_compexpr_left_6 = par_constant;

    if ( tmp_compexpr_left_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_6 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_xrange );

    if (unlikely( tmp_compexpr_right_6 == NULL ))
    {
        tmp_compexpr_right_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_xrange );
    }

    if ( tmp_compexpr_right_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "xrange" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_and_right_value_3 = BOOL_FROM( tmp_compexpr_left_6 == tmp_compexpr_right_6 );
    Py_INCREF( tmp_and_right_value_3 );
    tmp_cond_value_3 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_cond_value_3 = tmp_and_left_value_3;
    and_end_3:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 787;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_16;
    }
    else
    {
        goto branch_no_16;
    }
    branch_yes_16:;
    tmp_assign_source_15 = const_str_digest_9c42ff6703757defdbe30715d3ba3dc6;
    assert( var_key == NULL );
    Py_INCREF( tmp_assign_source_15 );
    var_key = tmp_assign_source_15;

    goto branch_end_16;
    branch_no_16:;
    tmp_compare_left_14 = par_constant;

    if ( tmp_compare_left_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 789;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_14 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_anon_values );

    if (unlikely( tmp_compare_right_14 == NULL ))
    {
        tmp_compare_right_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_builtin_anon_values );
    }

    if ( tmp_compare_right_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "builtin_anon_values" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 789;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_14, tmp_compare_left_14 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_17;
    }
    else
    {
        goto branch_no_17;
    }
    branch_yes_17:;
    tmp_left_name_1 = const_str_digest_8b84bac5d679cc4833da523c95bcdd7d;
    tmp_subscribed_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_anon_codes );

    if (unlikely( tmp_subscribed_name_1 == NULL ))
    {
        tmp_subscribed_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_builtin_anon_codes );
    }

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "builtin_anon_codes" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_anon_values );

    if (unlikely( tmp_subscribed_name_2 == NULL ))
    {
        tmp_subscribed_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_builtin_anon_values );
    }

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "builtin_anon_values" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = par_constant;

    if ( tmp_subscript_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_subscript_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscript_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_16 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_key == NULL );
    var_key = tmp_assign_source_16;

    goto branch_end_17;
    branch_no_17:;
    tmp_compare_left_15 = par_constant;

    if ( tmp_compare_left_15 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 791;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_15 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_exception_values_list );

    if (unlikely( tmp_compare_right_15 == NULL ))
    {
        tmp_compare_right_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_builtin_exception_values_list );
    }

    if ( tmp_compare_right_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "builtin_exception_values_list" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 791;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_15, tmp_compare_left_15 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto branch_yes_18;
    }
    else
    {
        goto branch_no_18;
    }
    branch_yes_18:;
    tmp_left_name_2 = const_str_digest_8b43f078b192122dc45357ec9f7330da;
    tmp_source_name_1 = par_constant;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 792;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_17 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_key == NULL );
    var_key = tmp_assign_source_17;

    goto branch_end_18;
    branch_no_18:;
    tmp_source_name_2 = par_constant;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 794;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_18 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_type_name == NULL );
    var_type_name = tmp_assign_source_18;

    tmp_compexpr_left_7 = par_constant;

    if ( tmp_compexpr_left_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_7 = (PyObject *)&PyLong_Type;
    tmp_and_left_value_4 = BOOL_FROM( tmp_compexpr_left_7 == tmp_compexpr_right_7 );
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    assert( !(tmp_and_left_truth_4 == -1) );
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    tmp_compexpr_left_8 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compexpr_left_8 == NULL ))
    {
        tmp_compexpr_left_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compexpr_left_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_8 = const_int_pos_300;
    tmp_and_right_value_4 = RICH_COMPARE_GE( tmp_compexpr_left_8, tmp_compexpr_right_8 );
    if ( tmp_and_right_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_4 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    Py_INCREF( tmp_and_left_value_4 );
    tmp_cond_value_4 = tmp_and_left_value_4;
    and_end_4:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 796;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_19;
    }
    else
    {
        goto branch_no_19;
    }
    branch_yes_19:;
    tmp_assign_source_19 = const_str_plain_long;
    {
        PyObject *old = var_type_name;
        var_type_name = tmp_assign_source_19;
        Py_INCREF( var_type_name );
        Py_XDECREF( old );
    }

    goto branch_end_19;
    branch_no_19:;
    tmp_compare_left_16 = par_constant;

    if ( tmp_compare_left_16 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 798;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_16 = (PyObject *)&PyUnicode_Type;
    tmp_is_14 = ( tmp_compare_left_16 == tmp_compare_right_16 );
    if ( tmp_is_14 )
    {
        goto branch_yes_20;
    }
    else
    {
        goto branch_no_20;
    }
    branch_yes_20:;
    tmp_compare_left_17 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_17 == NULL ))
    {
        tmp_compare_left_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 799;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_17 = const_int_pos_300;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_17, tmp_compare_right_17 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 799;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_assign_source_20 = const_str_plain_string;
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_assign_source_20 = const_str_plain_unicode;
    condexpr_end_1:;
    {
        PyObject *old = var_type_name;
        var_type_name = tmp_assign_source_20;
        Py_INCREF( var_type_name );
        Py_XDECREF( old );
    }

    branch_no_20:;
    branch_end_19:;
    tmp_left_name_3 = const_str_digest_5bc885749965f660b02bd91c96e09784;
    tmp_called_instance_1 = var_type_name;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 801;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_6f603200238b09ef26c50ca74a7a3ca3->m_frame.f_lineno = 801;
    tmp_right_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_title );
    if ( tmp_right_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_21 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_key == NULL );
    var_key = tmp_assign_source_21;

    branch_end_18:;
    branch_end_17:;
    branch_end_16:;
    branch_end_15:;
    branch_end_14:;
    branch_end_13:;
    branch_end_12:;
    branch_end_11:;
    branch_end_10:;
    branch_end_9:;
    branch_end_8:;
    branch_end_7:;
    goto branch_end_6;
    branch_no_6:;
    tmp_left_name_4 = const_str_plain_const_;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_namifyConstant );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_namifyConstant );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "namifyConstant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 803;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_constant;

    if ( tmp_args_element_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 803;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_6f603200238b09ef26c50ca74a7a3ca3->m_frame.f_lineno = 803;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_right_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_right_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_22 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_key == NULL );
    var_key = tmp_assign_source_22;

    branch_end_6:;
    branch_end_5:;
    branch_end_4:;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;
    tmp_compare_left_18 = var_key;

    if ( tmp_compare_left_18 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 805;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 805;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_18 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_constants );
    if ( tmp_compare_right_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 805;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_18, tmp_compare_left_18 );
    Py_DECREF( tmp_compare_right_18 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_21;
    }
    else
    {
        goto branch_no_21;
    }
    branch_yes_21:;
    tmp_ass_subvalue_1 = par_constant;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 806;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 806;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_constants );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 806;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = var_key;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 806;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 806;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    branch_no_21:;
    tmp_return_value = var_key;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 808;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f603200238b09ef26c50ca74a7a3ca3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f603200238b09ef26c50ca74a7a3ca3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f603200238b09ef26c50ca74a7a3ca3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f603200238b09ef26c50ca74a7a3ca3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f603200238b09ef26c50ca74a7a3ca3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f603200238b09ef26c50ca74a7a3ca3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f603200238b09ef26c50ca74a7a3ca3,
        type_description_1,
        par_self,
        par_constant,
        var_key,
        var_type_name
    );


    // Release cached frame.
    if ( frame_6f603200238b09ef26c50ca74a7a3ca3 == cache_frame_6f603200238b09ef26c50ca74a7a3ca3 )
    {
        Py_DECREF( frame_6f603200238b09ef26c50ca74a7a3ca3 );
    }
    cache_frame_6f603200238b09ef26c50ca74a7a3ca3 = NULL;

    assertFrameObject( frame_6f603200238b09ef26c50ca74a7a3ca3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_101_getConstantCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_type_name );
    var_type_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_type_name );
    var_type_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_101_getConstantCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_102_countConstantUse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *tmp_inplace_assign_subscr_1__subscript = NULL;
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_77c61d5bd22dcc42f21df1f71a44aea1 = NULL;

    struct Nuitka_FrameObject *frame_77c61d5bd22dcc42f21df1f71a44aea1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_77c61d5bd22dcc42f21df1f71a44aea1, codeobj_77c61d5bd22dcc42f21df1f71a44aea1, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_77c61d5bd22dcc42f21df1f71a44aea1 = cache_frame_77c61d5bd22dcc42f21df1f71a44aea1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_77c61d5bd22dcc42f21df1f71a44aea1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_77c61d5bd22dcc42f21df1f71a44aea1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_constant;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_constant_use_count );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_ass_subvalue_1 = const_int_0;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 812;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_constant_use_count );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 812;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_constant;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 812;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 812;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 814;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_constant_use_count );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 814;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_assign_source_2 = par_constant;

    if ( tmp_assign_source_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 814;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }

    assert( tmp_inplace_assign_subscr_1__subscript == NULL );
    Py_INCREF( tmp_assign_source_2 );
    tmp_inplace_assign_subscr_1__subscript = tmp_assign_source_2;

    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = tmp_inplace_assign_subscr_1__subscript;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 814;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_2 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 814;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_2 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_2 );
    tmp_ass_subscript_2 = tmp_inplace_assign_subscr_1__subscript;

    CHECK_OBJECT( tmp_ass_subscript_2 );
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 814;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    Py_XDECREF( tmp_inplace_assign_subscr_1__subscript );
    tmp_inplace_assign_subscr_1__subscript = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_77c61d5bd22dcc42f21df1f71a44aea1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_77c61d5bd22dcc42f21df1f71a44aea1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_77c61d5bd22dcc42f21df1f71a44aea1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_77c61d5bd22dcc42f21df1f71a44aea1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_77c61d5bd22dcc42f21df1f71a44aea1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_77c61d5bd22dcc42f21df1f71a44aea1,
        type_description_1,
        par_self,
        par_constant
    );


    // Release cached frame.
    if ( frame_77c61d5bd22dcc42f21df1f71a44aea1 == cache_frame_77c61d5bd22dcc42f21df1f71a44aea1 )
    {
        Py_DECREF( frame_77c61d5bd22dcc42f21df1f71a44aea1 );
    }
    cache_frame_77c61d5bd22dcc42f21df1f71a44aea1 = NULL;

    assertFrameObject( frame_77c61d5bd22dcc42f21df1f71a44aea1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__subscript );
    Py_DECREF( tmp_inplace_assign_subscr_1__subscript );
    tmp_inplace_assign_subscr_1__subscript = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_102_countConstantUse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_102_countConstantUse );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_103_getConstantUseCount( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_ab5f0102d0ffd0cd21a6d2012cd290dc = NULL;

    struct Nuitka_FrameObject *frame_ab5f0102d0ffd0cd21a6d2012cd290dc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab5f0102d0ffd0cd21a6d2012cd290dc, codeobj_ab5f0102d0ffd0cd21a6d2012cd290dc, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_ab5f0102d0ffd0cd21a6d2012cd290dc = cache_frame_ab5f0102d0ffd0cd21a6d2012cd290dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab5f0102d0ffd0cd21a6d2012cd290dc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_constant_use_count );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = par_constant;

    if ( tmp_subscript_name_1 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 817;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab5f0102d0ffd0cd21a6d2012cd290dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab5f0102d0ffd0cd21a6d2012cd290dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab5f0102d0ffd0cd21a6d2012cd290dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab5f0102d0ffd0cd21a6d2012cd290dc,
        type_description_1,
        par_self,
        par_constant
    );


    // Release cached frame.
    if ( frame_ab5f0102d0ffd0cd21a6d2012cd290dc == cache_frame_ab5f0102d0ffd0cd21a6d2012cd290dc )
    {
        Py_DECREF( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );
    }
    cache_frame_ab5f0102d0ffd0cd21a6d2012cd290dc = NULL;

    assertFrameObject( frame_ab5f0102d0ffd0cd21a6d2012cd290dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_103_getConstantUseCount );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_103_getConstantUseCount );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_104_getConstants( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_68228c0be8b8808971465d0a1408a345 = NULL;

    struct Nuitka_FrameObject *frame_68228c0be8b8808971465d0a1408a345;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68228c0be8b8808971465d0a1408a345, codeobj_68228c0be8b8808971465d0a1408a345, module_codegen$Contexts, sizeof(void *) );
    frame_68228c0be8b8808971465d0a1408a345 = cache_frame_68228c0be8b8808971465d0a1408a345;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68228c0be8b8808971465d0a1408a345 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68228c0be8b8808971465d0a1408a345 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_constants );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 820;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68228c0be8b8808971465d0a1408a345 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_68228c0be8b8808971465d0a1408a345 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68228c0be8b8808971465d0a1408a345 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68228c0be8b8808971465d0a1408a345, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68228c0be8b8808971465d0a1408a345->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68228c0be8b8808971465d0a1408a345, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68228c0be8b8808971465d0a1408a345,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_68228c0be8b8808971465d0a1408a345 == cache_frame_68228c0be8b8808971465d0a1408a345 )
    {
        Py_DECREF( frame_68228c0be8b8808971465d0a1408a345 );
    }
    cache_frame_68228c0be8b8808971465d0a1408a345 = NULL;

    assertFrameObject( frame_68228c0be8b8808971465d0a1408a345 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_104_getConstants );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_104_getConstants );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_105___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_59a17da53e33902710c637e22db4c9b1 = NULL;

    struct Nuitka_FrameObject *frame_59a17da53e33902710c637e22db4c9b1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_59a17da53e33902710c637e22db4c9b1, codeobj_59a17da53e33902710c637e22db4c9b1, module_codegen$Contexts, sizeof(void *) );
    frame_59a17da53e33902710c637e22db4c9b1 = cache_frame_59a17da53e33902710c637e22db4c9b1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_59a17da53e33902710c637e22db4c9b1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_59a17da53e33902710c637e22db4c9b1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = PyList_New( 0 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_frame_declarations, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = LIST_COPY( const_list_str_empty_list );
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_frame_variables_stack, tmp_assattr_name_2 );
    Py_DECREF( tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = LIST_COPY( const_list_tuple_empty_list );
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {
        Py_DECREF( tmp_assattr_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 830;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_frame_type_descriptions, tmp_assattr_name_3 );
    Py_DECREF( tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = PyDict_New();
    tmp_assattr_target_4 = par_self;

    if ( tmp_assattr_target_4 == NULL )
    {
        Py_DECREF( tmp_assattr_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 833;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_frame_variable_types, tmp_assattr_name_4 );
    Py_DECREF( tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 833;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = const_int_0;
    tmp_assattr_target_5 = par_self;

    if ( tmp_assattr_target_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 835;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_frames_used, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 835;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = LIST_COPY( const_list_none_list );
    tmp_assattr_target_6 = par_self;

    if ( tmp_assattr_target_6 == NULL )
    {
        Py_DECREF( tmp_assattr_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_frame_stack, tmp_assattr_name_6 );
    Py_DECREF( tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 838;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = PySet_New( NULL );
    tmp_assattr_target_7 = par_self;

    if ( tmp_assattr_target_7 == NULL )
    {
        Py_DECREF( tmp_assattr_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 840;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_locals_dict_names, tmp_assattr_name_7 );
    Py_DECREF( tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59a17da53e33902710c637e22db4c9b1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59a17da53e33902710c637e22db4c9b1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_59a17da53e33902710c637e22db4c9b1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_59a17da53e33902710c637e22db4c9b1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_59a17da53e33902710c637e22db4c9b1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_59a17da53e33902710c637e22db4c9b1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_59a17da53e33902710c637e22db4c9b1 == cache_frame_59a17da53e33902710c637e22db4c9b1 )
    {
        Py_DECREF( frame_59a17da53e33902710c637e22db4c9b1 );
    }
    cache_frame_59a17da53e33902710c637e22db4c9b1 = NULL;

    assertFrameObject( frame_59a17da53e33902710c637e22db4c9b1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_105___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_105___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_106_getFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_127c51962806469f83c7f9a0745fb87d = NULL;

    struct Nuitka_FrameObject *frame_127c51962806469f83c7f9a0745fb87d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_127c51962806469f83c7f9a0745fb87d, codeobj_127c51962806469f83c7f9a0745fb87d, module_codegen$Contexts, sizeof(void *) );
    frame_127c51962806469f83c7f9a0745fb87d = cache_frame_127c51962806469f83c7f9a0745fb87d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_127c51962806469f83c7f9a0745fb87d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_127c51962806469f83c7f9a0745fb87d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 844;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 844;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_127c51962806469f83c7f9a0745fb87d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_127c51962806469f83c7f9a0745fb87d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_127c51962806469f83c7f9a0745fb87d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_127c51962806469f83c7f9a0745fb87d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_127c51962806469f83c7f9a0745fb87d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_127c51962806469f83c7f9a0745fb87d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_127c51962806469f83c7f9a0745fb87d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_127c51962806469f83c7f9a0745fb87d == cache_frame_127c51962806469f83c7f9a0745fb87d )
    {
        Py_DECREF( frame_127c51962806469f83c7f9a0745fb87d );
    }
    cache_frame_127c51962806469f83c7f9a0745fb87d = NULL;

    assertFrameObject( frame_127c51962806469f83c7f9a0745fb87d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_106_getFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_106_getFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_107_pushFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_handle = python_pars[ 1 ];
    PyObject *tmp_inplace_assign_attr_1__end = NULL;
    PyObject *tmp_inplace_assign_attr_1__start = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    bool tmp_isnot_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c20a736617c75414f4021a5a879f2f04 = NULL;

    struct Nuitka_FrameObject *frame_c20a736617c75414f4021a5a879f2f04;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c20a736617c75414f4021a5a879f2f04, codeobj_c20a736617c75414f4021a5a879f2f04, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_c20a736617c75414f4021a5a879f2f04 = cache_frame_c20a736617c75414f4021a5a879f2f04;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c20a736617c75414f4021a5a879f2f04 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c20a736617c75414f4021a5a879f2f04 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frames_used );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_inplace_assign_attr_1__start == NULL );
    tmp_inplace_assign_attr_1__start = tmp_assign_source_1;

    // Tried code:
    tmp_left_name_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_assign_source_2 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    assert( tmp_inplace_assign_attr_1__end == NULL );
    tmp_inplace_assign_attr_1__end = tmp_assign_source_2;

    // Tried code:
    tmp_compare_left_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_1 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 847;
        type_description_1 = "oo";
        goto try_except_handler_3;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_frames_used, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 847;
        type_description_1 = "oo";
        goto try_except_handler_3;
    }
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 849;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frames_used );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 849;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_2, tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 849;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_left_name_2 = par_frame_handle;

    if ( tmp_left_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_handle" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 850;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_left_name_3 = const_str_digest_0bee88bea05a6d16838bce17fe2050b5;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 850;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_frames_used );
    if ( tmp_right_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 850;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 850;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
    tmp_assign_source_3 = tmp_left_name_2;
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 850;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    par_frame_handle = tmp_assign_source_3;

    branch_no_2:;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 852;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_frame_stack );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_handle;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_handle" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 852;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c20a736617c75414f4021a5a879f2f04->m_frame.f_lineno = 852;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 853;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_frame_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c20a736617c75414f4021a5a879f2f04 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c20a736617c75414f4021a5a879f2f04 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c20a736617c75414f4021a5a879f2f04 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c20a736617c75414f4021a5a879f2f04, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c20a736617c75414f4021a5a879f2f04->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c20a736617c75414f4021a5a879f2f04, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c20a736617c75414f4021a5a879f2f04,
        type_description_1,
        par_self,
        par_frame_handle
    );


    // Release cached frame.
    if ( frame_c20a736617c75414f4021a5a879f2f04 == cache_frame_c20a736617c75414f4021a5a879f2f04 )
    {
        Py_DECREF( frame_c20a736617c75414f4021a5a879f2f04 );
    }
    cache_frame_c20a736617c75414f4021a5a879f2f04 = NULL;

    assertFrameObject( frame_c20a736617c75414f4021a5a879f2f04 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_107_pushFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_handle );
    par_frame_handle = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_handle );
    par_frame_handle = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_107_pushFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_108_popFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_delsubscr_subscript_1;
    PyObject *tmp_delsubscr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_279c6ac248d6c8229d505a9997d1a146 = NULL;

    struct Nuitka_FrameObject *frame_279c6ac248d6c8229d505a9997d1a146;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_279c6ac248d6c8229d505a9997d1a146, codeobj_279c6ac248d6c8229d505a9997d1a146, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_279c6ac248d6c8229d505a9997d1a146 = cache_frame_279c6ac248d6c8229d505a9997d1a146;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_279c6ac248d6c8229d505a9997d1a146 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_279c6ac248d6c8229d505a9997d1a146 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 857;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_delsubscr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_stack );
    if ( tmp_delsubscr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_1 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
    Py_DECREF( tmp_delsubscr_target_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 859;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_279c6ac248d6c8229d505a9997d1a146 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_279c6ac248d6c8229d505a9997d1a146 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_279c6ac248d6c8229d505a9997d1a146 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_279c6ac248d6c8229d505a9997d1a146, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_279c6ac248d6c8229d505a9997d1a146->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_279c6ac248d6c8229d505a9997d1a146, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_279c6ac248d6c8229d505a9997d1a146,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_279c6ac248d6c8229d505a9997d1a146 == cache_frame_279c6ac248d6c8229d505a9997d1a146 )
    {
        Py_DECREF( frame_279c6ac248d6c8229d505a9997d1a146 );
    }
    cache_frame_279c6ac248d6c8229d505a9997d1a146 = NULL;

    assertFrameObject( frame_279c6ac248d6c8229d505a9997d1a146 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_108_popFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_108_popFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_109_getFramesCount( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_7ba49a81baaa679e56580a3c99359313 = NULL;

    struct Nuitka_FrameObject *frame_7ba49a81baaa679e56580a3c99359313;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7ba49a81baaa679e56580a3c99359313, codeobj_7ba49a81baaa679e56580a3c99359313, module_codegen$Contexts, sizeof(void *) );
    frame_7ba49a81baaa679e56580a3c99359313 = cache_frame_7ba49a81baaa679e56580a3c99359313;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7ba49a81baaa679e56580a3c99359313 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7ba49a81baaa679e56580a3c99359313 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frames_used );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 862;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ba49a81baaa679e56580a3c99359313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ba49a81baaa679e56580a3c99359313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ba49a81baaa679e56580a3c99359313 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ba49a81baaa679e56580a3c99359313, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ba49a81baaa679e56580a3c99359313->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ba49a81baaa679e56580a3c99359313, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ba49a81baaa679e56580a3c99359313,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7ba49a81baaa679e56580a3c99359313 == cache_frame_7ba49a81baaa679e56580a3c99359313 )
    {
        Py_DECREF( frame_7ba49a81baaa679e56580a3c99359313 );
    }
    cache_frame_7ba49a81baaa679e56580a3c99359313 = NULL;

    assertFrameObject( frame_7ba49a81baaa679e56580a3c99359313 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_109_getFramesCount );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_109_getFramesCount );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_110_addFrameDeclaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_decl = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c7640666dea5664bfa1e5cf63b3c9d8d = NULL;

    struct Nuitka_FrameObject *frame_c7640666dea5664bfa1e5cf63b3c9d8d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c7640666dea5664bfa1e5cf63b3c9d8d, codeobj_c7640666dea5664bfa1e5cf63b3c9d8d, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_c7640666dea5664bfa1e5cf63b3c9d8d = cache_frame_c7640666dea5664bfa1e5cf63b3c9d8d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c7640666dea5664bfa1e5cf63b3c9d8d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c7640666dea5664bfa1e5cf63b3c9d8d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_declarations );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_decl;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 865;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c7640666dea5664bfa1e5cf63b3c9d8d->m_frame.f_lineno = 865;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7640666dea5664bfa1e5cf63b3c9d8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7640666dea5664bfa1e5cf63b3c9d8d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c7640666dea5664bfa1e5cf63b3c9d8d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c7640666dea5664bfa1e5cf63b3c9d8d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c7640666dea5664bfa1e5cf63b3c9d8d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7640666dea5664bfa1e5cf63b3c9d8d,
        type_description_1,
        par_self,
        par_frame_decl
    );


    // Release cached frame.
    if ( frame_c7640666dea5664bfa1e5cf63b3c9d8d == cache_frame_c7640666dea5664bfa1e5cf63b3c9d8d )
    {
        Py_DECREF( frame_c7640666dea5664bfa1e5cf63b3c9d8d );
    }
    cache_frame_c7640666dea5664bfa1e5cf63b3c9d8d = NULL;

    assertFrameObject( frame_c7640666dea5664bfa1e5cf63b3c9d8d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_110_addFrameDeclaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_decl );
    par_frame_decl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_decl );
    par_frame_decl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_110_addFrameDeclaration );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_111_getFrameDeclarations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *outline_0_var_i = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_source_name_1;
    PyObject *tmp_value_name_1;
    PyObject *tmp_xrange_low_1;
    static struct Nuitka_FrameObject *cache_frame_c7075fa0b098e8aa790b3d043f315ca3_2 = NULL;

    struct Nuitka_FrameObject *frame_c7075fa0b098e8aa790b3d043f315ca3_2;

    static struct Nuitka_FrameObject *cache_frame_75b89845119f8c8005f380471373e6dc = NULL;

    struct Nuitka_FrameObject *frame_75b89845119f8c8005f380471373e6dc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_75b89845119f8c8005f380471373e6dc, codeobj_75b89845119f8c8005f380471373e6dc, module_codegen$Contexts, sizeof(void *) );
    frame_75b89845119f8c8005f380471373e6dc = cache_frame_75b89845119f8c8005f380471373e6dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_75b89845119f8c8005f380471373e6dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_75b89845119f8c8005f380471373e6dc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_declarations );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    // Tried code:
    tmp_called_instance_1 = par_self;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 871;
        type_description_1 = "o";
        goto try_except_handler_2;
    }

    frame_75b89845119f8c8005f380471373e6dc->m_frame.f_lineno = 871;
    tmp_xrange_low_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFramesCount );
    if ( tmp_xrange_low_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 871;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    tmp_iter_arg_1 = BUILTIN_XRANGE1( tmp_xrange_low_1 );
    Py_DECREF( tmp_xrange_low_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 871;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_c7075fa0b098e8aa790b3d043f315ca3_2, codeobj_c7075fa0b098e8aa790b3d043f315ca3, module_codegen$Contexts, sizeof(void *) );
    frame_c7075fa0b098e8aa790b3d043f315ca3_2 = cache_frame_c7075fa0b098e8aa790b3d043f315ca3_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c7075fa0b098e8aa790b3d043f315ca3_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 869;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 869;
        type_description_2 = "o";
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_i;
        outline_0_var_i = tmp_assign_source_4;
        Py_INCREF( outline_0_var_i );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_left_name_2 = const_str_digest_cd5c4b50f1feb6b43661c8d06b8ea3b6;
    tmp_left_name_3 = outline_0_var_i;

    CHECK_OBJECT( tmp_left_name_3 );
    tmp_right_name_3 = const_int_pos_1;
    tmp_right_name_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_3 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_2 = "o";
        goto try_except_handler_3;
    }
    tmp_append_value_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_2 = "o";
        goto try_except_handler_3;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_2 = "o";
        goto try_except_handler_3;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        type_description_2 = "o";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_111_getFrameDeclarations );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_2;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c7075fa0b098e8aa790b3d043f315ca3_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c7075fa0b098e8aa790b3d043f315ca3_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c7075fa0b098e8aa790b3d043f315ca3_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7075fa0b098e8aa790b3d043f315ca3_2,
        type_description_2,
        outline_0_var_i
    );


    // Release cached frame.
    if ( frame_c7075fa0b098e8aa790b3d043f315ca3_2 == cache_frame_c7075fa0b098e8aa790b3d043f315ca3_2 )
    {
        Py_DECREF( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );
    }
    cache_frame_c7075fa0b098e8aa790b3d043f315ca3_2 = NULL;

    assertFrameObject( frame_c7075fa0b098e8aa790b3d043f315ca3_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;
    type_description_1 = "o";
    goto try_except_handler_2;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_111_getFrameDeclarations );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( outline_0_var_i );
    outline_0_var_i = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_i );
    outline_0_var_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_111_getFrameDeclarations );
    return NULL;
    outline_exception_1:;
    exception_lineno = 869;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_right_name_1 = tmp_outline_return_value_1;
    tmp_return_value = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75b89845119f8c8005f380471373e6dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_75b89845119f8c8005f380471373e6dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75b89845119f8c8005f380471373e6dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_75b89845119f8c8005f380471373e6dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_75b89845119f8c8005f380471373e6dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_75b89845119f8c8005f380471373e6dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_75b89845119f8c8005f380471373e6dc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_75b89845119f8c8005f380471373e6dc == cache_frame_75b89845119f8c8005f380471373e6dc )
    {
        Py_DECREF( frame_75b89845119f8c8005f380471373e6dc );
    }
    cache_frame_75b89845119f8c8005f380471373e6dc = NULL;

    assertFrameObject( frame_75b89845119f8c8005f380471373e6dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_111_getFrameDeclarations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_111_getFrameDeclarations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_112_pushFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_variables = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_654b29fe95db02fc79a3d82f282749b2 = NULL;

    struct Nuitka_FrameObject *frame_654b29fe95db02fc79a3d82f282749b2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_654b29fe95db02fc79a3d82f282749b2, codeobj_654b29fe95db02fc79a3d82f282749b2, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_654b29fe95db02fc79a3d82f282749b2 = cache_frame_654b29fe95db02fc79a3d82f282749b2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_654b29fe95db02fc79a3d82f282749b2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_654b29fe95db02fc79a3d82f282749b2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_variables_stack );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_variables;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_variables" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_654b29fe95db02fc79a3d82f282749b2->m_frame.f_lineno = 876;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 877;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_frame_type_descriptions );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_call_arg_element_1 = PySet_New( NULL );
    frame_654b29fe95db02fc79a3d82f282749b2->m_frame.f_lineno = 877;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    Py_DECREF( tmp_call_arg_element_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_654b29fe95db02fc79a3d82f282749b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_654b29fe95db02fc79a3d82f282749b2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_654b29fe95db02fc79a3d82f282749b2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_654b29fe95db02fc79a3d82f282749b2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_654b29fe95db02fc79a3d82f282749b2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_654b29fe95db02fc79a3d82f282749b2,
        type_description_1,
        par_self,
        par_frame_variables
    );


    // Release cached frame.
    if ( frame_654b29fe95db02fc79a3d82f282749b2 == cache_frame_654b29fe95db02fc79a3d82f282749b2 )
    {
        Py_DECREF( frame_654b29fe95db02fc79a3d82f282749b2 );
    }
    cache_frame_654b29fe95db02fc79a3d82f282749b2 = NULL;

    assertFrameObject( frame_654b29fe95db02fc79a3d82f282749b2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_112_pushFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_variables );
    par_frame_variables = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_112_pushFrameVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_113_popFrameVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_delsubscr_subscript_1;
    PyObject *tmp_delsubscr_subscript_2;
    PyObject *tmp_delsubscr_target_1;
    PyObject *tmp_delsubscr_target_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_ec6404e2172c5be8f927926822edfaae = NULL;

    struct Nuitka_FrameObject *frame_ec6404e2172c5be8f927926822edfaae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ec6404e2172c5be8f927926822edfaae, codeobj_ec6404e2172c5be8f927926822edfaae, module_codegen$Contexts, sizeof(void *) );
    frame_ec6404e2172c5be8f927926822edfaae = cache_frame_ec6404e2172c5be8f927926822edfaae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ec6404e2172c5be8f927926822edfaae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ec6404e2172c5be8f927926822edfaae ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_delsubscr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_variables_stack );
    if ( tmp_delsubscr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 881;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_1 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
    Py_DECREF( tmp_delsubscr_target_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 881;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 882;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_delsubscr_target_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_type_descriptions );
    if ( tmp_delsubscr_target_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 882;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_2 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_2, tmp_delsubscr_subscript_2 );
    Py_DECREF( tmp_delsubscr_target_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 882;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec6404e2172c5be8f927926822edfaae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec6404e2172c5be8f927926822edfaae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ec6404e2172c5be8f927926822edfaae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ec6404e2172c5be8f927926822edfaae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ec6404e2172c5be8f927926822edfaae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ec6404e2172c5be8f927926822edfaae,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ec6404e2172c5be8f927926822edfaae == cache_frame_ec6404e2172c5be8f927926822edfaae )
    {
        Py_DECREF( frame_ec6404e2172c5be8f927926822edfaae );
    }
    cache_frame_ec6404e2172c5be8f927926822edfaae = NULL;

    assertFrameObject( frame_ec6404e2172c5be8f927926822edfaae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_113_popFrameVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_113_popFrameVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_114_setVariableType( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_variable = python_pars[ 1 ];
    PyObject *par_variable_code_name = python_pars[ 2 ];
    PyObject *par_variable_c_type = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_value_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static struct Nuitka_FrameObject *cache_frame_4fd0fc1c3c1f8c2a276b2b063220e476 = NULL;

    struct Nuitka_FrameObject *frame_4fd0fc1c3c1f8c2a276b2b063220e476;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4fd0fc1c3c1f8c2a276b2b063220e476, codeobj_4fd0fc1c3c1f8c2a276b2b063220e476, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4fd0fc1c3c1f8c2a276b2b063220e476 = cache_frame_4fd0fc1c3c1f8c2a276b2b063220e476;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4fd0fc1c3c1f8c2a276b2b063220e476 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4fd0fc1c3c1f8c2a276b2b063220e476 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_variable;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_4fd0fc1c3c1f8c2a276b2b063220e476->m_frame.f_lineno = 885;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isLocalVariable );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 885;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    tmp_tuple_element_1 = par_variable;

    if ( tmp_tuple_element_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 885;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_raise_value_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_raise_value_1, 0, tmp_tuple_element_1 );
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_value = tmp_raise_value_1;
    exception_lineno = 885;
    RAISE_EXCEPTION_WITH_VALUE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_tuple_element_2 = par_variable_code_name;

    if ( tmp_tuple_element_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_code_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subvalue_1 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_tuple_element_2 );
    tmp_called_instance_2 = par_variable_c_type;

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_c_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_4fd0fc1c3c1f8c2a276b2b063220e476->m_frame.f_lineno = 887;
    tmp_tuple_element_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getTypeIndicator );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_ass_subvalue_1, 1, tmp_tuple_element_2 );
    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_variable_types );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_variable;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 887;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4fd0fc1c3c1f8c2a276b2b063220e476 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4fd0fc1c3c1f8c2a276b2b063220e476 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4fd0fc1c3c1f8c2a276b2b063220e476, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4fd0fc1c3c1f8c2a276b2b063220e476->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4fd0fc1c3c1f8c2a276b2b063220e476, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4fd0fc1c3c1f8c2a276b2b063220e476,
        type_description_1,
        par_self,
        par_variable,
        par_variable_code_name,
        par_variable_c_type
    );


    // Release cached frame.
    if ( frame_4fd0fc1c3c1f8c2a276b2b063220e476 == cache_frame_4fd0fc1c3c1f8c2a276b2b063220e476 )
    {
        Py_DECREF( frame_4fd0fc1c3c1f8c2a276b2b063220e476 );
    }
    cache_frame_4fd0fc1c3c1f8c2a276b2b063220e476 = NULL;

    assertFrameObject( frame_4fd0fc1c3c1f8c2a276b2b063220e476 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_114_setVariableType );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_variable );
    par_variable = NULL;

    Py_XDECREF( par_variable_code_name );
    par_variable_code_name = NULL;

    Py_XDECREF( par_variable_c_type );
    par_variable_c_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_variable );
    par_variable = NULL;

    Py_XDECREF( par_variable_code_name );
    par_variable_code_name = NULL;

    Py_XDECREF( par_variable_c_type );
    par_variable_c_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_114_setVariableType );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_ca788999b2bab9557a685cdad355065e = NULL;

    struct Nuitka_FrameObject *frame_ca788999b2bab9557a685cdad355065e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ca788999b2bab9557a685cdad355065e, codeobj_ca788999b2bab9557a685cdad355065e, module_codegen$Contexts, sizeof(void *) );
    frame_ca788999b2bab9557a685cdad355065e = cache_frame_ca788999b2bab9557a685cdad355065e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ca788999b2bab9557a685cdad355065e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ca788999b2bab9557a685cdad355065e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_type_descriptions );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 890;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 890;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca788999b2bab9557a685cdad355065e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca788999b2bab9557a685cdad355065e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ca788999b2bab9557a685cdad355065e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ca788999b2bab9557a685cdad355065e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ca788999b2bab9557a685cdad355065e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ca788999b2bab9557a685cdad355065e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ca788999b2bab9557a685cdad355065e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ca788999b2bab9557a685cdad355065e == cache_frame_ca788999b2bab9557a685cdad355065e )
    {
        Py_DECREF( frame_ca788999b2bab9557a685cdad355065e );
    }
    cache_frame_ca788999b2bab9557a685cdad355065e = NULL;

    assertFrameObject( frame_ca788999b2bab9557a685cdad355065e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_7c8a5be6be74a118fe62e7b98ec5a9dd = NULL;

    struct Nuitka_FrameObject *frame_7c8a5be6be74a118fe62e7b98ec5a9dd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7c8a5be6be74a118fe62e7b98ec5a9dd, codeobj_7c8a5be6be74a118fe62e7b98ec5a9dd, module_codegen$Contexts, sizeof(void *) );
    frame_7c8a5be6be74a118fe62e7b98ec5a9dd = cache_frame_7c8a5be6be74a118fe62e7b98ec5a9dd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7c8a5be6be74a118fe62e7b98ec5a9dd ) == 2 ); // Frame stack

    // Framed code:
    tmp_left_name_1 = const_str_digest_22dcf374b1775b5a2a7cb67abb10c1a8;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_stack );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 893;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 893;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_right_name_2 = const_int_pos_1;
    tmp_right_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 893;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 893;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7c8a5be6be74a118fe62e7b98ec5a9dd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7c8a5be6be74a118fe62e7b98ec5a9dd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7c8a5be6be74a118fe62e7b98ec5a9dd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c8a5be6be74a118fe62e7b98ec5a9dd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7c8a5be6be74a118fe62e7b98ec5a9dd == cache_frame_7c8a5be6be74a118fe62e7b98ec5a9dd )
    {
        Py_DECREF( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );
    }
    cache_frame_7c8a5be6be74a118fe62e7b98ec5a9dd = NULL;

    assertFrameObject( frame_7c8a5be6be74a118fe62e7b98ec5a9dd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_117_getFrameVariableTypeDescription( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_result = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_98cffa7b5c3321bba0e3b3b4dbdebdbc = NULL;

    struct Nuitka_FrameObject *frame_98cffa7b5c3321bba0e3b3b4dbdebdbc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_98cffa7b5c3321bba0e3b3b4dbdebdbc, codeobj_98cffa7b5c3321bba0e3b3b4dbdebdbc, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_98cffa7b5c3321bba0e3b3b4dbdebdbc = cache_frame_98cffa7b5c3321bba0e3b3b4dbdebdbc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = const_str_empty;
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
    assert( !(tmp_called_name_1 == NULL) );
    if ( par_self == NULL )
    {
        tmp_source_name_2 = NULL;
    }
    else
    {
        tmp_source_name_2 = PyCell_GET( par_self );
    }

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_variables_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 899;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_iter_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 899;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    assert( tmp_genexpr_1__$0 == NULL );
    tmp_genexpr_1__$0 = tmp_assign_source_2;

    // Tried code:
    tmp_outline_return_value_1 = Nuitka_Generator_New(
        codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_context,
        module_codegen$Contexts,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        const_str_digest_2b3e70ac3e1ab3c1f0f382782169dcd9,
#endif
        codeobj_3de0a0bf0e868e366b136f144a22d3b0,
        2
    );

    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
    ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[1] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_outline_return_value_1)->m_closure[1] );
    assert( Py_SIZE( tmp_outline_return_value_1 ) >= 2 ); 


    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_117_getFrameVariableTypeDescription );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    goto outline_result_1;
    // End of try:
    CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
    Py_DECREF( tmp_genexpr_1__$0 );
    tmp_genexpr_1__$0 = NULL;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_117_getFrameVariableTypeDescription );
    return NULL;
    outline_result_1:;
    tmp_args_element_name_1 = tmp_outline_return_value_1;
    frame_98cffa7b5c3321bba0e3b3b4dbdebdbc->m_frame.f_lineno = 896;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_cond_value_1 = var_result;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 902;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    if ( par_self == NULL )
    {
        tmp_source_name_4 = NULL;
    }
    else
    {
        tmp_source_name_4 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_frame_type_descriptions );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_neg_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_add );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_result;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }

    frame_98cffa7b5c3321bba0e3b3b4dbdebdbc->m_frame.f_lineno = 903;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 903;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 905;
        type_description_1 = "co";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_98cffa7b5c3321bba0e3b3b4dbdebdbc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_98cffa7b5c3321bba0e3b3b4dbdebdbc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98cffa7b5c3321bba0e3b3b4dbdebdbc,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc == cache_frame_98cffa7b5c3321bba0e3b3b4dbdebdbc )
    {
        Py_DECREF( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );
    }
    cache_frame_98cffa7b5c3321bba0e3b3b4dbdebdbc = NULL;

    assertFrameObject( frame_98cffa7b5c3321bba0e3b3b4dbdebdbc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_117_getFrameVariableTypeDescription );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_117_getFrameVariableTypeDescription );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
struct codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_locals {
    PyObject *var_variable
    PyObject *tmp_iter_value_0
    PyObject *exception_type
    PyObject *exception_value
    PyTracebackObject *exception_tb
    int exception_lineno
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_value_name_1;
    char const *type_description_1
};
#endif

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
static PyObject *codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
#else
static void codegen$Contexts$$$function_117_getFrameVariableTypeDescription$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator )
#endif
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_variable = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_generator = NULL;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Dispatch to yield based on return label index:


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_3de0a0bf0e868e366b136f144a22d3b0, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_frame_generator;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
    generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
    Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
    Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
    generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
    if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
    Py_XINCREF( generator->m_exc_state.exc_type );
    generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
    Py_XINCREF( generator->m_exc_state.exc_value );
    generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
    Py_XINCREF( generator->m_exc_state.exc_traceback );

#endif

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    if ( generator->m_closure[0] == NULL )
    {
        tmp_value_name_1 = NULL;
    }
    else
    {
        tmp_value_name_1 = PyCell_GET( generator->m_closure[0] );
    }

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_1 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "Noc";
        exception_lineno = 897;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_1;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_2 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_2 );
    {
        PyObject *old = var_variable;
        var_variable = tmp_assign_source_2;
        Py_INCREF( var_variable );
        Py_XDECREF( old );
    }

    if ( generator->m_closure[1] == NULL )
    {
        tmp_source_name_2 = NULL;
    }
    else
    {
        tmp_source_name_2 = PyCell_GET( generator->m_closure[1] );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_frame_variable_types );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = var_variable;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = const_tuple_str_plain_NULL_str_plain_N_tuple;
    generator->m_frame->m_frame.f_lineno = 897;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_subscribed_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_expression_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_expression_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    tmp_unused = GENERATOR_YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, generator->m_frame, exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            type_description_1,
            NULL,
            var_variable,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_frame_generator )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_frame_generator = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_variable );
    var_variable = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( var_variable );
    var_variable = NULL;


#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

#if _NUITKA_EXPERIMENTAL_GENERATOR_GOTO
    return NULL;
#else
    generator->m_yielded = NULL;
    return;
#endif

}


static PyObject *impl_codegen$Contexts$$$function_118_getFrameVariableCodeNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *var_variable = NULL;
    PyObject *var_variable_code_name = NULL;
    PyObject *var_variable_code_type = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_abb448aafa670c9e0c7e7828b119b318 = NULL;

    struct Nuitka_FrameObject *frame_abb448aafa670c9e0c7e7828b119b318;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_abb448aafa670c9e0c7e7828b119b318, codeobj_abb448aafa670c9e0c7e7828b119b318, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_abb448aafa670c9e0c7e7828b119b318 = cache_frame_abb448aafa670c9e0c7e7828b119b318;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_abb448aafa670c9e0c7e7828b119b318 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_abb448aafa670c9e0c7e7828b119b318 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_frame_variables_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_iter_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 910;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 910;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_variable;
        var_variable = tmp_assign_source_4;
        Py_INCREF( var_variable );
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_frame_variable_types );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_get );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_1 = var_variable;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }

    tmp_args_element_name_2 = const_tuple_str_plain_NULL_str_plain_N_tuple;
    frame_abb448aafa670c9e0c7e7828b119b318->m_frame.f_lineno = 911;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_iter_arg_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 911;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 911;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "ooooo";
                exception_lineno = 911;
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "ooooo";
        exception_lineno = 911;
        goto try_except_handler_5;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_variable_code_name;
        var_variable_code_name = tmp_assign_source_8;
        Py_INCREF( var_variable_code_name );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_9 );
    {
        PyObject *old = var_variable_code_type;
        var_variable_code_type = tmp_assign_source_9;
        Py_INCREF( var_variable_code_type );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_2 = var_variable_code_type;

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_code_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 913;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = const_tuple_str_plain_b_tuple;
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_4 = var_result;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 914;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 914;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_1 = const_str_digest_2fed9bd860ef22890aae00273ef8b1e9;
    tmp_right_name_1 = var_variable_code_name;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_code_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 914;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_3 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 914;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    frame_abb448aafa670c9e0c7e7828b119b318->m_frame.f_lineno = 914;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 914;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_5 = var_result;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 916;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_append );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 916;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_4 = var_variable_code_name;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_code_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 916;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    frame_abb448aafa670c9e0c7e7828b119b318->m_frame.f_lineno = 916;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 916;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 918;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_abb448aafa670c9e0c7e7828b119b318 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_abb448aafa670c9e0c7e7828b119b318 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_abb448aafa670c9e0c7e7828b119b318 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_abb448aafa670c9e0c7e7828b119b318, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_abb448aafa670c9e0c7e7828b119b318->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_abb448aafa670c9e0c7e7828b119b318, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_abb448aafa670c9e0c7e7828b119b318,
        type_description_1,
        par_self,
        var_result,
        var_variable,
        var_variable_code_name,
        var_variable_code_type
    );


    // Release cached frame.
    if ( frame_abb448aafa670c9e0c7e7828b119b318 == cache_frame_abb448aafa670c9e0c7e7828b119b318 )
    {
        Py_DECREF( frame_abb448aafa670c9e0c7e7828b119b318 );
    }
    cache_frame_abb448aafa670c9e0c7e7828b119b318 = NULL;

    assertFrameObject( frame_abb448aafa670c9e0c7e7828b119b318 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_118_getFrameVariableCodeNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_variable );
    var_variable = NULL;

    Py_XDECREF( var_variable_code_name );
    var_variable_code_name = NULL;

    Py_XDECREF( var_variable_code_type );
    var_variable_code_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_variable );
    var_variable = NULL;

    Py_XDECREF( var_variable_code_name );
    var_variable_code_name = NULL;

    Py_XDECREF( var_variable_code_type );
    var_variable_code_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_118_getFrameVariableCodeNames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_119_getLocalsDictNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_2940b3916d417f563bbc9fd5b3454d3a = NULL;

    struct Nuitka_FrameObject *frame_2940b3916d417f563bbc9fd5b3454d3a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2940b3916d417f563bbc9fd5b3454d3a, codeobj_2940b3916d417f563bbc9fd5b3454d3a, module_codegen$Contexts, sizeof(void *) );
    frame_2940b3916d417f563bbc9fd5b3454d3a = cache_frame_2940b3916d417f563bbc9fd5b3454d3a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2940b3916d417f563bbc9fd5b3454d3a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2940b3916d417f563bbc9fd5b3454d3a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_locals_dict_names );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 921;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2940b3916d417f563bbc9fd5b3454d3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2940b3916d417f563bbc9fd5b3454d3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2940b3916d417f563bbc9fd5b3454d3a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2940b3916d417f563bbc9fd5b3454d3a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2940b3916d417f563bbc9fd5b3454d3a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2940b3916d417f563bbc9fd5b3454d3a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2940b3916d417f563bbc9fd5b3454d3a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2940b3916d417f563bbc9fd5b3454d3a == cache_frame_2940b3916d417f563bbc9fd5b3454d3a )
    {
        Py_DECREF( frame_2940b3916d417f563bbc9fd5b3454d3a );
    }
    cache_frame_2940b3916d417f563bbc9fd5b3454d3a = NULL;

    assertFrameObject( frame_2940b3916d417f563bbc9fd5b3454d3a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_119_getLocalsDictNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_119_getLocalsDictNames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_120_addLocalsDictName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_locals_dict_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c930f80771924b211918f96bdbee2bdb = NULL;

    struct Nuitka_FrameObject *frame_c930f80771924b211918f96bdbee2bdb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c930f80771924b211918f96bdbee2bdb, codeobj_c930f80771924b211918f96bdbee2bdb, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_c930f80771924b211918f96bdbee2bdb = cache_frame_c930f80771924b211918f96bdbee2bdb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c930f80771924b211918f96bdbee2bdb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c930f80771924b211918f96bdbee2bdb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_locals_dict_names );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 924;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_add );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 924;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_locals_dict_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "locals_dict_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 924;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c930f80771924b211918f96bdbee2bdb->m_frame.f_lineno = 924;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 924;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c930f80771924b211918f96bdbee2bdb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c930f80771924b211918f96bdbee2bdb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c930f80771924b211918f96bdbee2bdb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c930f80771924b211918f96bdbee2bdb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c930f80771924b211918f96bdbee2bdb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c930f80771924b211918f96bdbee2bdb,
        type_description_1,
        par_self,
        par_locals_dict_name
    );


    // Release cached frame.
    if ( frame_c930f80771924b211918f96bdbee2bdb == cache_frame_c930f80771924b211918f96bdbee2bdb )
    {
        Py_DECREF( frame_c930f80771924b211918f96bdbee2bdb );
    }
    cache_frame_c930f80771924b211918f96bdbee2bdb = NULL;

    assertFrameObject( frame_c930f80771924b211918f96bdbee2bdb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_120_addLocalsDictName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_locals_dict_name );
    par_locals_dict_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_locals_dict_name );
    par_locals_dict_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_120_addLocalsDictName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_121___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_2777fa368a6d504ba4aea9a4f87a5412 = NULL;

    struct Nuitka_FrameObject *frame_2777fa368a6d504ba4aea9a4f87a5412;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2777fa368a6d504ba4aea9a4f87a5412, codeobj_2777fa368a6d504ba4aea9a4f87a5412, module_codegen$Contexts, sizeof(void *) );
    frame_2777fa368a6d504ba4aea9a4f87a5412 = cache_frame_2777fa368a6d504ba4aea9a4f87a5412;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2777fa368a6d504ba4aea9a4f87a5412 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2777fa368a6d504ba4aea9a4f87a5412 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_False;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_release_mode, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 929;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 931;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_return_exit, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2777fa368a6d504ba4aea9a4f87a5412 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2777fa368a6d504ba4aea9a4f87a5412 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2777fa368a6d504ba4aea9a4f87a5412, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2777fa368a6d504ba4aea9a4f87a5412->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2777fa368a6d504ba4aea9a4f87a5412, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2777fa368a6d504ba4aea9a4f87a5412,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2777fa368a6d504ba4aea9a4f87a5412 == cache_frame_2777fa368a6d504ba4aea9a4f87a5412 )
    {
        Py_DECREF( frame_2777fa368a6d504ba4aea9a4f87a5412 );
    }
    cache_frame_2777fa368a6d504ba4aea9a4f87a5412 = NULL;

    assertFrameObject( frame_2777fa368a6d504ba4aea9a4f87a5412 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_121___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_121___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_122_setReturnReleaseMode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d6fa1a058f407c200a6dfa1b40ebb1e4 = NULL;

    struct Nuitka_FrameObject *frame_d6fa1a058f407c200a6dfa1b40ebb1e4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d6fa1a058f407c200a6dfa1b40ebb1e4, codeobj_d6fa1a058f407c200a6dfa1b40ebb1e4, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d6fa1a058f407c200a6dfa1b40ebb1e4 = cache_frame_d6fa1a058f407c200a6dfa1b40ebb1e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_release_mode );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 934;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_value;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 935;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 935;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_release_mode, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 936;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d6fa1a058f407c200a6dfa1b40ebb1e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d6fa1a058f407c200a6dfa1b40ebb1e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d6fa1a058f407c200a6dfa1b40ebb1e4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d6fa1a058f407c200a6dfa1b40ebb1e4,
        type_description_1,
        par_self,
        par_value,
        var_result
    );


    // Release cached frame.
    if ( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 == cache_frame_d6fa1a058f407c200a6dfa1b40ebb1e4 )
    {
        Py_DECREF( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );
    }
    cache_frame_d6fa1a058f407c200a6dfa1b40ebb1e4 = NULL;

    assertFrameObject( frame_d6fa1a058f407c200a6dfa1b40ebb1e4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_122_setReturnReleaseMode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_122_setReturnReleaseMode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_123_getReturnReleaseMode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_444dad8cfb1dc0e5631f164cb9cb7400 = NULL;

    struct Nuitka_FrameObject *frame_444dad8cfb1dc0e5631f164cb9cb7400;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_444dad8cfb1dc0e5631f164cb9cb7400, codeobj_444dad8cfb1dc0e5631f164cb9cb7400, module_codegen$Contexts, sizeof(void *) );
    frame_444dad8cfb1dc0e5631f164cb9cb7400 = cache_frame_444dad8cfb1dc0e5631f164cb9cb7400;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_444dad8cfb1dc0e5631f164cb9cb7400 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_444dad8cfb1dc0e5631f164cb9cb7400 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_release_mode );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_444dad8cfb1dc0e5631f164cb9cb7400 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_444dad8cfb1dc0e5631f164cb9cb7400 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_444dad8cfb1dc0e5631f164cb9cb7400 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_444dad8cfb1dc0e5631f164cb9cb7400, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_444dad8cfb1dc0e5631f164cb9cb7400->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_444dad8cfb1dc0e5631f164cb9cb7400, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_444dad8cfb1dc0e5631f164cb9cb7400,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_444dad8cfb1dc0e5631f164cb9cb7400 == cache_frame_444dad8cfb1dc0e5631f164cb9cb7400 )
    {
        Py_DECREF( frame_444dad8cfb1dc0e5631f164cb9cb7400 );
    }
    cache_frame_444dad8cfb1dc0e5631f164cb9cb7400 = NULL;

    assertFrameObject( frame_444dad8cfb1dc0e5631f164cb9cb7400 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_123_getReturnReleaseMode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_123_getReturnReleaseMode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_124_setReturnTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d9b1ec8ba2549aca9e21f996e90c7f4d = NULL;

    struct Nuitka_FrameObject *frame_d9b1ec8ba2549aca9e21f996e90c7f4d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d9b1ec8ba2549aca9e21f996e90c7f4d, codeobj_d9b1ec8ba2549aca9e21f996e90c7f4d, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d9b1ec8ba2549aca9e21f996e90c7f4d = cache_frame_d9b1ec8ba2549aca9e21f996e90c7f4d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d9b1ec8ba2549aca9e21f996e90c7f4d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_exit );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 942;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_label;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 943;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 943;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_exit, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 943;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 944;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d9b1ec8ba2549aca9e21f996e90c7f4d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d9b1ec8ba2549aca9e21f996e90c7f4d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d9b1ec8ba2549aca9e21f996e90c7f4d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d9b1ec8ba2549aca9e21f996e90c7f4d,
        type_description_1,
        par_self,
        par_label,
        var_result
    );


    // Release cached frame.
    if ( frame_d9b1ec8ba2549aca9e21f996e90c7f4d == cache_frame_d9b1ec8ba2549aca9e21f996e90c7f4d )
    {
        Py_DECREF( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );
    }
    cache_frame_d9b1ec8ba2549aca9e21f996e90c7f4d = NULL;

    assertFrameObject( frame_d9b1ec8ba2549aca9e21f996e90c7f4d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_124_setReturnTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_124_setReturnTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_125_getReturnTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_2a5236b378b84e3ed78714dd0cc21dbc = NULL;

    struct Nuitka_FrameObject *frame_2a5236b378b84e3ed78714dd0cc21dbc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2a5236b378b84e3ed78714dd0cc21dbc, codeobj_2a5236b378b84e3ed78714dd0cc21dbc, module_codegen$Contexts, sizeof(void *) );
    frame_2a5236b378b84e3ed78714dd0cc21dbc = cache_frame_2a5236b378b84e3ed78714dd0cc21dbc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2a5236b378b84e3ed78714dd0cc21dbc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2a5236b378b84e3ed78714dd0cc21dbc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_exit );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 947;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a5236b378b84e3ed78714dd0cc21dbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a5236b378b84e3ed78714dd0cc21dbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a5236b378b84e3ed78714dd0cc21dbc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2a5236b378b84e3ed78714dd0cc21dbc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2a5236b378b84e3ed78714dd0cc21dbc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2a5236b378b84e3ed78714dd0cc21dbc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a5236b378b84e3ed78714dd0cc21dbc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2a5236b378b84e3ed78714dd0cc21dbc == cache_frame_2a5236b378b84e3ed78714dd0cc21dbc )
    {
        Py_DECREF( frame_2a5236b378b84e3ed78714dd0cc21dbc );
    }
    cache_frame_2a5236b378b84e3ed78714dd0cc21dbc = NULL;

    assertFrameObject( frame_2a5236b378b84e3ed78714dd0cc21dbc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_125_getReturnTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_125_getReturnTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_126___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_08b55f1c830914b1c00bb1fbb8d5e0e1 = NULL;

    struct Nuitka_FrameObject *frame_08b55f1c830914b1c00bb1fbb8d5e0e1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08b55f1c830914b1c00bb1fbb8d5e0e1, codeobj_08b55f1c830914b1c00bb1fbb8d5e0e1, module_codegen$Contexts, sizeof(void *) );
    frame_08b55f1c830914b1c00bb1fbb8d5e0e1 = cache_frame_08b55f1c830914b1c00bb1fbb8d5e0e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_None;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 952;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08b55f1c830914b1c00bb1fbb8d5e0e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08b55f1c830914b1c00bb1fbb8d5e0e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08b55f1c830914b1c00bb1fbb8d5e0e1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08b55f1c830914b1c00bb1fbb8d5e0e1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 == cache_frame_08b55f1c830914b1c00bb1fbb8d5e0e1 )
    {
        Py_DECREF( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 );
    }
    cache_frame_08b55f1c830914b1c00bb1fbb8d5e0e1 = NULL;

    assertFrameObject( frame_08b55f1c830914b1c00bb1fbb8d5e0e1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_126___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_126___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_127_getReturnValueName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_kw_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_d775eb951e8acbf39f0107df6ba117a4 = NULL;

    struct Nuitka_FrameObject *frame_d775eb951e8acbf39f0107df6ba117a4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d775eb951e8acbf39f0107df6ba117a4, codeobj_d775eb951e8acbf39f0107df6ba117a4, module_codegen$Contexts, sizeof(void *) );
    frame_d775eb951e8acbf39f0107df6ba117a4 = cache_frame_d775eb951e8acbf39f0107df6ba117a4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d775eb951e8acbf39f0107df6ba117a4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d775eb951e8acbf39f0107df6ba117a4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 955;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 956;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_allocateTempName );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_str_plain_return_value_tuple;
    tmp_kw_name_1 = PyDict_Copy( const_dict_628013539fe17b0c3c196c9e449729d6 );
    frame_d775eb951e8acbf39f0107df6ba117a4->m_frame.f_lineno = 956;
    tmp_assattr_name_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 956;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_name, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 958;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_return_name );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 958;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d775eb951e8acbf39f0107df6ba117a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d775eb951e8acbf39f0107df6ba117a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d775eb951e8acbf39f0107df6ba117a4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d775eb951e8acbf39f0107df6ba117a4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d775eb951e8acbf39f0107df6ba117a4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d775eb951e8acbf39f0107df6ba117a4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d775eb951e8acbf39f0107df6ba117a4,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d775eb951e8acbf39f0107df6ba117a4 == cache_frame_d775eb951e8acbf39f0107df6ba117a4 )
    {
        Py_DECREF( frame_d775eb951e8acbf39f0107df6ba117a4 );
    }
    cache_frame_d775eb951e8acbf39f0107df6ba117a4 = NULL;

    assertFrameObject( frame_d775eb951e8acbf39f0107df6ba117a4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_127_getReturnValueName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_127_getReturnValueName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_128_setReturnValueName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_c7a4bc4a6885f31a13c4655359e3c6fd = NULL;

    struct Nuitka_FrameObject *frame_c7a4bc4a6885f31a13c4655359e3c6fd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c7a4bc4a6885f31a13c4655359e3c6fd, codeobj_c7a4bc4a6885f31a13c4655359e3c6fd, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c7a4bc4a6885f31a13c4655359e3c6fd = cache_frame_c7a4bc4a6885f31a13c4655359e3c6fd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c7a4bc4a6885f31a13c4655359e3c6fd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c7a4bc4a6885f31a13c4655359e3c6fd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_return_name );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 961;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_assattr_name_1 = par_value;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 962;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 962;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_return_name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 963;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7a4bc4a6885f31a13c4655359e3c6fd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7a4bc4a6885f31a13c4655359e3c6fd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c7a4bc4a6885f31a13c4655359e3c6fd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c7a4bc4a6885f31a13c4655359e3c6fd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c7a4bc4a6885f31a13c4655359e3c6fd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c7a4bc4a6885f31a13c4655359e3c6fd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c7a4bc4a6885f31a13c4655359e3c6fd,
        type_description_1,
        par_self,
        par_value,
        var_result
    );


    // Release cached frame.
    if ( frame_c7a4bc4a6885f31a13c4655359e3c6fd == cache_frame_c7a4bc4a6885f31a13c4655359e3c6fd )
    {
        Py_DECREF( frame_c7a4bc4a6885f31a13c4655359e3c6fd );
    }
    cache_frame_c7a4bc4a6885f31a13c4655359e3c6fd = NULL;

    assertFrameObject( frame_c7a4bc4a6885f31a13c4655359e3c6fd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_128_setReturnValueName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_128_setReturnValueName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_129___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_module = python_pars[ 1 ];
    PyObject *par_module_name = python_pars[ 2 ];
    PyObject *par_code_name = python_pars[ 3 ];
    PyObject *par_filename = python_pars[ 4 ];
    PyObject *par_global_context = python_pars[ 5 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_name_10;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    PyObject *tmp_assattr_target_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a880a57d69225bd871448e0e669fbddb = NULL;

    struct Nuitka_FrameObject *frame_a880a57d69225bd871448e0e669fbddb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a880a57d69225bd871448e0e669fbddb, codeobj_a880a57d69225bd871448e0e669fbddb, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a880a57d69225bd871448e0e669fbddb = cache_frame_a880a57d69225bd871448e0e669fbddb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a880a57d69225bd871448e0e669fbddb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a880a57d69225bd871448e0e669fbddb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonContextBase );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonContextBase );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 973;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___init__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 973;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 973;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 973;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 973;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_TempMixin );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TempMixin );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TempMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 975;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___init__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 975;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_self;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 975;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 975;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 975;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_CodeObjectsMixin );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CodeObjectsMixin );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CodeObjectsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 976;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 976;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_self;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 976;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 976;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 976;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "FrameDeclarationsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 977;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___init__ );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_self;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 977;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 977;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 977;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 978;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___init__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 978;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_self;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 978;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 978;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 978;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 981;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___init__ );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = par_self;

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 981;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_a880a57d69225bd871448e0e669fbddb->m_frame.f_lineno = 981;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_module;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "module" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 983;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 983;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_module, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 983;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_module_name;

    if ( tmp_assattr_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "module_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 984;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 984;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_name, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 984;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = par_code_name;

    if ( tmp_assattr_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 985;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 985;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_code_name, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = par_filename;

    if ( tmp_assattr_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "filename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 986;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_4 = par_self;

    if ( tmp_assattr_target_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 986;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_filename, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 986;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = par_global_context;

    if ( tmp_assattr_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "global_context" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_5 = par_self;

    if ( tmp_assattr_target_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_global_context, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = PyDict_New();
    tmp_assattr_target_6 = par_self;

    if ( tmp_assattr_target_6 == NULL )
    {
        Py_DECREF( tmp_assattr_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 990;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_declaration_codes, tmp_assattr_name_6 );
    Py_DECREF( tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 990;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = PyDict_New();
    tmp_assattr_target_7 = par_self;

    if ( tmp_assattr_target_7 == NULL )
    {
        Py_DECREF( tmp_assattr_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 991;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_helper_codes, tmp_assattr_name_7 );
    Py_DECREF( tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 991;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_8 = PySet_New( NULL );
    tmp_assattr_target_8 = par_self;

    if ( tmp_assattr_target_8 == NULL )
    {
        Py_DECREF( tmp_assattr_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 993;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_constants, tmp_assattr_name_8 );
    Py_DECREF( tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 993;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_9 = Py_None;
    tmp_assattr_target_9 = par_self;

    if ( tmp_assattr_target_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 995;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_frame_handle, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_10 = Py_False;
    tmp_assattr_target_10 = par_self;

    if ( tmp_assattr_target_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 997;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain_needs_module_filename_object, tmp_assattr_name_10 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 997;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a880a57d69225bd871448e0e669fbddb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a880a57d69225bd871448e0e669fbddb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a880a57d69225bd871448e0e669fbddb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a880a57d69225bd871448e0e669fbddb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a880a57d69225bd871448e0e669fbddb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a880a57d69225bd871448e0e669fbddb,
        type_description_1,
        par_self,
        par_module,
        par_module_name,
        par_code_name,
        par_filename,
        par_global_context
    );


    // Release cached frame.
    if ( frame_a880a57d69225bd871448e0e669fbddb == cache_frame_a880a57d69225bd871448e0e669fbddb )
    {
        Py_DECREF( frame_a880a57d69225bd871448e0e669fbddb );
    }
    cache_frame_a880a57d69225bd871448e0e669fbddb = NULL;

    assertFrameObject( frame_a880a57d69225bd871448e0e669fbddb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_129___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_module );
    par_module = NULL;

    Py_XDECREF( par_module_name );
    par_module_name = NULL;

    Py_XDECREF( par_code_name );
    par_code_name = NULL;

    Py_XDECREF( par_filename );
    par_filename = NULL;

    Py_XDECREF( par_global_context );
    par_global_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_module );
    par_module = NULL;

    Py_XDECREF( par_module_name );
    par_module_name = NULL;

    Py_XDECREF( par_code_name );
    par_code_name = NULL;

    Py_XDECREF( par_filename );
    par_filename = NULL;

    Py_XDECREF( par_global_context );
    par_global_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_129___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_130___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_19354f51df5d22d64f453b358453021a = NULL;

    struct Nuitka_FrameObject *frame_19354f51df5d22d64f453b358453021a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_19354f51df5d22d64f453b358453021a, codeobj_19354f51df5d22d64f453b358453021a, module_codegen$Contexts, sizeof(void *) );
    frame_19354f51df5d22d64f453b358453021a = cache_frame_19354f51df5d22d64f453b358453021a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_19354f51df5d22d64f453b358453021a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_19354f51df5d22d64f453b358453021a ) == 2 ); // Frame stack

    // Framed code:
    tmp_left_name_1 = const_str_digest_312280c60bdc0537d21c15fc13a6ee1b;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_filename );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19354f51df5d22d64f453b358453021a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_19354f51df5d22d64f453b358453021a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19354f51df5d22d64f453b358453021a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_19354f51df5d22d64f453b358453021a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_19354f51df5d22d64f453b358453021a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_19354f51df5d22d64f453b358453021a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_19354f51df5d22d64f453b358453021a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_19354f51df5d22d64f453b358453021a == cache_frame_19354f51df5d22d64f453b358453021a )
    {
        Py_DECREF( frame_19354f51df5d22d64f453b358453021a );
    }
    cache_frame_19354f51df5d22d64f453b358453021a = NULL;

    assertFrameObject( frame_19354f51df5d22d64f453b358453021a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_130___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_130___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_131_getOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 = NULL;

    struct Nuitka_FrameObject *frame_ac1b8b2a3510b8b6fb20c92646b3a0c6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac1b8b2a3510b8b6fb20c92646b3a0c6, codeobj_ac1b8b2a3510b8b6fb20c92646b3a0c6, module_codegen$Contexts, sizeof(void *) );
    frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 = cache_frame_ac1b8b2a3510b8b6fb20c92646b3a0c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_module );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1003;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac1b8b2a3510b8b6fb20c92646b3a0c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac1b8b2a3510b8b6fb20c92646b3a0c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac1b8b2a3510b8b6fb20c92646b3a0c6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 == cache_frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 )
    {
        Py_DECREF( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );
    }
    cache_frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 = NULL;

    assertFrameObject( frame_ac1b8b2a3510b8b6fb20c92646b3a0c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_131_getOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_131_getOwner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_132_getEntryPoint( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ecbb3e58cf1a324d3fee77f80485d062 = NULL;

    struct Nuitka_FrameObject *frame_ecbb3e58cf1a324d3fee77f80485d062;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ecbb3e58cf1a324d3fee77f80485d062, codeobj_ecbb3e58cf1a324d3fee77f80485d062, module_codegen$Contexts, sizeof(void *) );
    frame_ecbb3e58cf1a324d3fee77f80485d062 = cache_frame_ecbb3e58cf1a324d3fee77f80485d062;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ecbb3e58cf1a324d3fee77f80485d062 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ecbb3e58cf1a324d3fee77f80485d062 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_module );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecbb3e58cf1a324d3fee77f80485d062 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecbb3e58cf1a324d3fee77f80485d062 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ecbb3e58cf1a324d3fee77f80485d062 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ecbb3e58cf1a324d3fee77f80485d062, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ecbb3e58cf1a324d3fee77f80485d062->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ecbb3e58cf1a324d3fee77f80485d062, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ecbb3e58cf1a324d3fee77f80485d062,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ecbb3e58cf1a324d3fee77f80485d062 == cache_frame_ecbb3e58cf1a324d3fee77f80485d062 )
    {
        Py_DECREF( frame_ecbb3e58cf1a324d3fee77f80485d062 );
    }
    cache_frame_ecbb3e58cf1a324d3fee77f80485d062 = NULL;

    assertFrameObject( frame_ecbb3e58cf1a324d3fee77f80485d062 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_132_getEntryPoint );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_132_getEntryPoint );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_133_isCompiledPythonModule( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_133_isCompiledPythonModule );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_133_isCompiledPythonModule );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_134_getName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_95f24e5d6299d1570dfff6c07cb8ddc0 = NULL;

    struct Nuitka_FrameObject *frame_95f24e5d6299d1570dfff6c07cb8ddc0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_95f24e5d6299d1570dfff6c07cb8ddc0, codeobj_95f24e5d6299d1570dfff6c07cb8ddc0, module_codegen$Contexts, sizeof(void *) );
    frame_95f24e5d6299d1570dfff6c07cb8ddc0 = cache_frame_95f24e5d6299d1570dfff6c07cb8ddc0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_95f24e5d6299d1570dfff6c07cb8ddc0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1012;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_95f24e5d6299d1570dfff6c07cb8ddc0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_95f24e5d6299d1570dfff6c07cb8ddc0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_95f24e5d6299d1570dfff6c07cb8ddc0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_95f24e5d6299d1570dfff6c07cb8ddc0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_95f24e5d6299d1570dfff6c07cb8ddc0 == cache_frame_95f24e5d6299d1570dfff6c07cb8ddc0 )
    {
        Py_DECREF( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );
    }
    cache_frame_95f24e5d6299d1570dfff6c07cb8ddc0 = NULL;

    assertFrameObject( frame_95f24e5d6299d1570dfff6c07cb8ddc0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_134_getName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_134_getName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_135_getFilename( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_31a12923b2304b2b93b956f8d0cb3abe = NULL;

    struct Nuitka_FrameObject *frame_31a12923b2304b2b93b956f8d0cb3abe;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_31a12923b2304b2b93b956f8d0cb3abe, codeobj_31a12923b2304b2b93b956f8d0cb3abe, module_codegen$Contexts, sizeof(void *) );
    frame_31a12923b2304b2b93b956f8d0cb3abe = cache_frame_31a12923b2304b2b93b956f8d0cb3abe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31a12923b2304b2b93b956f8d0cb3abe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31a12923b2304b2b93b956f8d0cb3abe ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_filename );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1015;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31a12923b2304b2b93b956f8d0cb3abe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_31a12923b2304b2b93b956f8d0cb3abe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31a12923b2304b2b93b956f8d0cb3abe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31a12923b2304b2b93b956f8d0cb3abe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31a12923b2304b2b93b956f8d0cb3abe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31a12923b2304b2b93b956f8d0cb3abe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31a12923b2304b2b93b956f8d0cb3abe,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_31a12923b2304b2b93b956f8d0cb3abe == cache_frame_31a12923b2304b2b93b956f8d0cb3abe )
    {
        Py_DECREF( frame_31a12923b2304b2b93b956f8d0cb3abe );
    }
    cache_frame_31a12923b2304b2b93b956f8d0cb3abe = NULL;

    assertFrameObject( frame_31a12923b2304b2b93b956f8d0cb3abe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_135_getFilename );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_135_getFilename );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_136_mayRaiseException( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_body = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_13d2f0d69592eadd21dabc1c3ed96b0e = NULL;

    struct Nuitka_FrameObject *frame_13d2f0d69592eadd21dabc1c3ed96b0e;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_13d2f0d69592eadd21dabc1c3ed96b0e, codeobj_13d2f0d69592eadd21dabc1c3ed96b0e, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_13d2f0d69592eadd21dabc1c3ed96b0e = cache_frame_13d2f0d69592eadd21dabc1c3ed96b0e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_13d2f0d69592eadd21dabc1c3ed96b0e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_13d2f0d69592eadd21dabc1c3ed96b0e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_module );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1018;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    frame_13d2f0d69592eadd21dabc1c3ed96b0e->m_frame.f_lineno = 1018;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getBody );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1018;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_body == NULL );
    var_body = tmp_assign_source_1;

    tmp_compexpr_left_1 = var_body;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_called_instance_2 = var_body;

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "body" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1020;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_13d2f0d69592eadd21dabc1c3ed96b0e->m_frame.f_lineno = 1020;
    tmp_and_right_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_mayRaiseException, &PyTuple_GET_ITEM( const_tuple_type_BaseException_tuple, 0 ) );

    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1020;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_13d2f0d69592eadd21dabc1c3ed96b0e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_13d2f0d69592eadd21dabc1c3ed96b0e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_13d2f0d69592eadd21dabc1c3ed96b0e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_13d2f0d69592eadd21dabc1c3ed96b0e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_13d2f0d69592eadd21dabc1c3ed96b0e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_13d2f0d69592eadd21dabc1c3ed96b0e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_13d2f0d69592eadd21dabc1c3ed96b0e,
        type_description_1,
        par_self,
        var_body
    );


    // Release cached frame.
    if ( frame_13d2f0d69592eadd21dabc1c3ed96b0e == cache_frame_13d2f0d69592eadd21dabc1c3ed96b0e )
    {
        Py_DECREF( frame_13d2f0d69592eadd21dabc1c3ed96b0e );
    }
    cache_frame_13d2f0d69592eadd21dabc1c3ed96b0e = NULL;

    assertFrameObject( frame_13d2f0d69592eadd21dabc1c3ed96b0e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_136_mayRaiseException );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_body );
    var_body = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_body );
    var_body = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_136_mayRaiseException );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_137_getModuleCodeName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_93fbb8e78e1c1e542ed28c23238b843a = NULL;

    struct Nuitka_FrameObject *frame_93fbb8e78e1c1e542ed28c23238b843a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_93fbb8e78e1c1e542ed28c23238b843a, codeobj_93fbb8e78e1c1e542ed28c23238b843a, module_codegen$Contexts, sizeof(void *) );
    frame_93fbb8e78e1c1e542ed28c23238b843a = cache_frame_93fbb8e78e1c1e542ed28c23238b843a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_93fbb8e78e1c1e542ed28c23238b843a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_93fbb8e78e1c1e542ed28c23238b843a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_code_name );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93fbb8e78e1c1e542ed28c23238b843a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_93fbb8e78e1c1e542ed28c23238b843a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93fbb8e78e1c1e542ed28c23238b843a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_93fbb8e78e1c1e542ed28c23238b843a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_93fbb8e78e1c1e542ed28c23238b843a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_93fbb8e78e1c1e542ed28c23238b843a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93fbb8e78e1c1e542ed28c23238b843a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_93fbb8e78e1c1e542ed28c23238b843a == cache_frame_93fbb8e78e1c1e542ed28c23238b843a )
    {
        Py_DECREF( frame_93fbb8e78e1c1e542ed28c23238b843a );
    }
    cache_frame_93fbb8e78e1c1e542ed28c23238b843a = NULL;

    assertFrameObject( frame_93fbb8e78e1c1e542ed28c23238b843a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_137_getModuleCodeName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_137_getModuleCodeName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_138_setFrameGuardMode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_guard_mode = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_67dfd733f52487a7c4d36642ce19b712 = NULL;

    struct Nuitka_FrameObject *frame_67dfd733f52487a7c4d36642ce19b712;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_67dfd733f52487a7c4d36642ce19b712, codeobj_67dfd733f52487a7c4d36642ce19b712, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_67dfd733f52487a7c4d36642ce19b712 = cache_frame_67dfd733f52487a7c4d36642ce19b712;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_67dfd733f52487a7c4d36642ce19b712 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_67dfd733f52487a7c4d36642ce19b712 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_guard_mode;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_str_plain_once;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1028;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67dfd733f52487a7c4d36642ce19b712 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67dfd733f52487a7c4d36642ce19b712 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_67dfd733f52487a7c4d36642ce19b712, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_67dfd733f52487a7c4d36642ce19b712->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_67dfd733f52487a7c4d36642ce19b712, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67dfd733f52487a7c4d36642ce19b712,
        type_description_1,
        par_self,
        par_guard_mode
    );


    // Release cached frame.
    if ( frame_67dfd733f52487a7c4d36642ce19b712 == cache_frame_67dfd733f52487a7c4d36642ce19b712 )
    {
        Py_DECREF( frame_67dfd733f52487a7c4d36642ce19b712 );
    }
    cache_frame_67dfd733f52487a7c4d36642ce19b712 = NULL;

    assertFrameObject( frame_67dfd733f52487a7c4d36642ce19b712 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_138_setFrameGuardMode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_guard_mode );
    par_guard_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_guard_mode );
    par_guard_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_138_setFrameGuardMode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_139_addHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_value_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_1a6088137005dcdc22495df50b45ac40 = NULL;

    struct Nuitka_FrameObject *frame_1a6088137005dcdc22495df50b45ac40;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1a6088137005dcdc22495df50b45ac40, codeobj_1a6088137005dcdc22495df50b45ac40, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1a6088137005dcdc22495df50b45ac40 = cache_frame_1a6088137005dcdc22495df50b45ac40;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1a6088137005dcdc22495df50b45ac40 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1a6088137005dcdc22495df50b45ac40 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_key;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_helper_codes );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1031;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    tmp_tuple_element_1 = par_key;

    if ( tmp_tuple_element_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1031;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_raise_value_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_raise_value_1, 0, tmp_tuple_element_1 );
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_value = tmp_raise_value_1;
    exception_lineno = 1031;
    RAISE_EXCEPTION_WITH_VALUE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_ass_subvalue_1 = par_code;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_helper_codes );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_key;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1a6088137005dcdc22495df50b45ac40 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1a6088137005dcdc22495df50b45ac40 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1a6088137005dcdc22495df50b45ac40, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1a6088137005dcdc22495df50b45ac40->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1a6088137005dcdc22495df50b45ac40, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1a6088137005dcdc22495df50b45ac40,
        type_description_1,
        par_self,
        par_key,
        par_code
    );


    // Release cached frame.
    if ( frame_1a6088137005dcdc22495df50b45ac40 == cache_frame_1a6088137005dcdc22495df50b45ac40 )
    {
        Py_DECREF( frame_1a6088137005dcdc22495df50b45ac40 );
    }
    cache_frame_1a6088137005dcdc22495df50b45ac40 = NULL;

    assertFrameObject( frame_1a6088137005dcdc22495df50b45ac40 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_139_addHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_139_addHelperCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_140_hasHelperCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_2039fc5753d46c59ecc59d1e891b40f3 = NULL;

    struct Nuitka_FrameObject *frame_2039fc5753d46c59ecc59d1e891b40f3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2039fc5753d46c59ecc59d1e891b40f3, codeobj_2039fc5753d46c59ecc59d1e891b40f3, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_2039fc5753d46c59ecc59d1e891b40f3 = cache_frame_2039fc5753d46c59ecc59d1e891b40f3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2039fc5753d46c59ecc59d1e891b40f3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2039fc5753d46c59ecc59d1e891b40f3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = par_key;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_helper_codes );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1036;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1036;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2039fc5753d46c59ecc59d1e891b40f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2039fc5753d46c59ecc59d1e891b40f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2039fc5753d46c59ecc59d1e891b40f3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2039fc5753d46c59ecc59d1e891b40f3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2039fc5753d46c59ecc59d1e891b40f3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2039fc5753d46c59ecc59d1e891b40f3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2039fc5753d46c59ecc59d1e891b40f3,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_2039fc5753d46c59ecc59d1e891b40f3 == cache_frame_2039fc5753d46c59ecc59d1e891b40f3 )
    {
        Py_DECREF( frame_2039fc5753d46c59ecc59d1e891b40f3 );
    }
    cache_frame_2039fc5753d46c59ecc59d1e891b40f3 = NULL;

    assertFrameObject( frame_2039fc5753d46c59ecc59d1e891b40f3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_140_hasHelperCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_140_hasHelperCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_141_getHelperCodes( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_5ead817b54d2298e0d2090f7ad673419 = NULL;

    struct Nuitka_FrameObject *frame_5ead817b54d2298e0d2090f7ad673419;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5ead817b54d2298e0d2090f7ad673419, codeobj_5ead817b54d2298e0d2090f7ad673419, module_codegen$Contexts, sizeof(void *) );
    frame_5ead817b54d2298e0d2090f7ad673419 = cache_frame_5ead817b54d2298e0d2090f7ad673419;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5ead817b54d2298e0d2090f7ad673419 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5ead817b54d2298e0d2090f7ad673419 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_helper_codes );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1039;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ead817b54d2298e0d2090f7ad673419 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ead817b54d2298e0d2090f7ad673419 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ead817b54d2298e0d2090f7ad673419 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5ead817b54d2298e0d2090f7ad673419, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5ead817b54d2298e0d2090f7ad673419->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5ead817b54d2298e0d2090f7ad673419, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5ead817b54d2298e0d2090f7ad673419,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5ead817b54d2298e0d2090f7ad673419 == cache_frame_5ead817b54d2298e0d2090f7ad673419 )
    {
        Py_DECREF( frame_5ead817b54d2298e0d2090f7ad673419 );
    }
    cache_frame_5ead817b54d2298e0d2090f7ad673419 = NULL;

    assertFrameObject( frame_5ead817b54d2298e0d2090f7ad673419 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_141_getHelperCodes );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_141_getHelperCodes );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_142_addDeclaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_code = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_123a6f951e965e6fb7230426dd617881 = NULL;

    struct Nuitka_FrameObject *frame_123a6f951e965e6fb7230426dd617881;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_123a6f951e965e6fb7230426dd617881, codeobj_123a6f951e965e6fb7230426dd617881, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_123a6f951e965e6fb7230426dd617881 = cache_frame_123a6f951e965e6fb7230426dd617881;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_123a6f951e965e6fb7230426dd617881 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_123a6f951e965e6fb7230426dd617881 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_key;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_declaration_codes );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1042;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1042;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description_1 = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_ass_subvalue_1 = par_code;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1044;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1044;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_declaration_codes );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1044;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_key;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "key" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1044;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1044;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_123a6f951e965e6fb7230426dd617881 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_123a6f951e965e6fb7230426dd617881 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_123a6f951e965e6fb7230426dd617881, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_123a6f951e965e6fb7230426dd617881->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_123a6f951e965e6fb7230426dd617881, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_123a6f951e965e6fb7230426dd617881,
        type_description_1,
        par_self,
        par_key,
        par_code
    );


    // Release cached frame.
    if ( frame_123a6f951e965e6fb7230426dd617881 == cache_frame_123a6f951e965e6fb7230426dd617881 )
    {
        Py_DECREF( frame_123a6f951e965e6fb7230426dd617881 );
    }
    cache_frame_123a6f951e965e6fb7230426dd617881 = NULL;

    assertFrameObject( frame_123a6f951e965e6fb7230426dd617881 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_142_addDeclaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_key );
    par_key = NULL;

    Py_XDECREF( par_code );
    par_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_142_addDeclaration );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_143_getDeclarations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fa62dfe2689c2cca55df838ea54b38f1 = NULL;

    struct Nuitka_FrameObject *frame_fa62dfe2689c2cca55df838ea54b38f1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fa62dfe2689c2cca55df838ea54b38f1, codeobj_fa62dfe2689c2cca55df838ea54b38f1, module_codegen$Contexts, sizeof(void *) );
    frame_fa62dfe2689c2cca55df838ea54b38f1 = cache_frame_fa62dfe2689c2cca55df838ea54b38f1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fa62dfe2689c2cca55df838ea54b38f1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fa62dfe2689c2cca55df838ea54b38f1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_declaration_codes );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1047;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa62dfe2689c2cca55df838ea54b38f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa62dfe2689c2cca55df838ea54b38f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa62dfe2689c2cca55df838ea54b38f1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fa62dfe2689c2cca55df838ea54b38f1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fa62dfe2689c2cca55df838ea54b38f1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fa62dfe2689c2cca55df838ea54b38f1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa62dfe2689c2cca55df838ea54b38f1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fa62dfe2689c2cca55df838ea54b38f1 == cache_frame_fa62dfe2689c2cca55df838ea54b38f1 )
    {
        Py_DECREF( frame_fa62dfe2689c2cca55df838ea54b38f1 );
    }
    cache_frame_fa62dfe2689c2cca55df838ea54b38f1 = NULL;

    assertFrameObject( frame_fa62dfe2689c2cca55df838ea54b38f1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_143_getDeclarations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_143_getDeclarations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_144_mayRecurse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_144_mayRecurse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_144_mayRecurse );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_145_getConstantCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_constant = python_pars[ 1 ];
    PyObject *var_result = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f3b6ad571f323c66dedac13a51fcc3aa = NULL;

    struct Nuitka_FrameObject *frame_f3b6ad571f323c66dedac13a51fcc3aa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f3b6ad571f323c66dedac13a51fcc3aa, codeobj_f3b6ad571f323c66dedac13a51fcc3aa, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f3b6ad571f323c66dedac13a51fcc3aa = cache_frame_f3b6ad571f323c66dedac13a51fcc3aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f3b6ad571f323c66dedac13a51fcc3aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f3b6ad571f323c66dedac13a51fcc3aa ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_global_context );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1053;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getConstantCode );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1053;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_constant;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "constant" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1053;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_f3b6ad571f323c66dedac13a51fcc3aa->m_frame.f_lineno = 1053;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1053;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    tmp_compare_left_1 = var_result;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1055;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_constants );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1056;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_constants );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_add );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = var_result;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1056;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_f3b6ad571f323c66dedac13a51fcc3aa->m_frame.f_lineno = 1056;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = par_self;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1057;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_global_context );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_countConstantUse );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_result;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1057;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_f3b6ad571f323c66dedac13a51fcc3aa->m_frame.f_lineno = 1057;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1059;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3b6ad571f323c66dedac13a51fcc3aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3b6ad571f323c66dedac13a51fcc3aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f3b6ad571f323c66dedac13a51fcc3aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f3b6ad571f323c66dedac13a51fcc3aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f3b6ad571f323c66dedac13a51fcc3aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f3b6ad571f323c66dedac13a51fcc3aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f3b6ad571f323c66dedac13a51fcc3aa,
        type_description_1,
        par_self,
        par_constant,
        var_result
    );


    // Release cached frame.
    if ( frame_f3b6ad571f323c66dedac13a51fcc3aa == cache_frame_f3b6ad571f323c66dedac13a51fcc3aa )
    {
        Py_DECREF( frame_f3b6ad571f323c66dedac13a51fcc3aa );
    }
    cache_frame_f3b6ad571f323c66dedac13a51fcc3aa = NULL;

    assertFrameObject( frame_f3b6ad571f323c66dedac13a51fcc3aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_145_getConstantCode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_constant );
    par_constant = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_145_getConstantCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_146_getConstants( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_08a0ffcb553873f9109c5535422adcc6 = NULL;

    struct Nuitka_FrameObject *frame_08a0ffcb553873f9109c5535422adcc6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08a0ffcb553873f9109c5535422adcc6, codeobj_08a0ffcb553873f9109c5535422adcc6, module_codegen$Contexts, sizeof(void *) );
    frame_08a0ffcb553873f9109c5535422adcc6 = cache_frame_08a0ffcb553873f9109c5535422adcc6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08a0ffcb553873f9109c5535422adcc6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08a0ffcb553873f9109c5535422adcc6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_constants );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1062;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08a0ffcb553873f9109c5535422adcc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_08a0ffcb553873f9109c5535422adcc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08a0ffcb553873f9109c5535422adcc6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08a0ffcb553873f9109c5535422adcc6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08a0ffcb553873f9109c5535422adcc6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08a0ffcb553873f9109c5535422adcc6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08a0ffcb553873f9109c5535422adcc6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_08a0ffcb553873f9109c5535422adcc6 == cache_frame_08a0ffcb553873f9109c5535422adcc6 )
    {
        Py_DECREF( frame_08a0ffcb553873f9109c5535422adcc6 );
    }
    cache_frame_08a0ffcb553873f9109c5535422adcc6 = NULL;

    assertFrameObject( frame_08a0ffcb553873f9109c5535422adcc6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_146_getConstants );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_146_getConstants );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 = NULL;

    struct Nuitka_FrameObject *frame_7bfaf8f94c79d7bb59ed1e69d078e4d7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7bfaf8f94c79d7bb59ed1e69d078e4d7, codeobj_7bfaf8f94c79d7bb59ed1e69d078e4d7, module_codegen$Contexts, sizeof(void *) );
    frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 = cache_frame_7bfaf8f94c79d7bb59ed1e69d078e4d7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_True;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_needs_module_filename_object, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1065;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7bfaf8f94c79d7bb59ed1e69d078e4d7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7bfaf8f94c79d7bb59ed1e69d078e4d7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7bfaf8f94c79d7bb59ed1e69d078e4d7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 == cache_frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 )
    {
        Py_DECREF( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 );
    }
    cache_frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 = NULL;

    assertFrameObject( frame_7bfaf8f94c79d7bb59ed1e69d078e4d7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_148_needsModuleFilenameObject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fbe2a55516c1146765544ec27bca7c43 = NULL;

    struct Nuitka_FrameObject *frame_fbe2a55516c1146765544ec27bca7c43;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fbe2a55516c1146765544ec27bca7c43, codeobj_fbe2a55516c1146765544ec27bca7c43, module_codegen$Contexts, sizeof(void *) );
    frame_fbe2a55516c1146765544ec27bca7c43 = cache_frame_fbe2a55516c1146765544ec27bca7c43;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fbe2a55516c1146765544ec27bca7c43 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fbe2a55516c1146765544ec27bca7c43 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_needs_module_filename_object );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe2a55516c1146765544ec27bca7c43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe2a55516c1146765544ec27bca7c43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe2a55516c1146765544ec27bca7c43 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fbe2a55516c1146765544ec27bca7c43, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fbe2a55516c1146765544ec27bca7c43->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fbe2a55516c1146765544ec27bca7c43, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fbe2a55516c1146765544ec27bca7c43,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fbe2a55516c1146765544ec27bca7c43 == cache_frame_fbe2a55516c1146765544ec27bca7c43 )
    {
        Py_DECREF( frame_fbe2a55516c1146765544ec27bca7c43 );
    }
    cache_frame_fbe2a55516c1146765544ec27bca7c43 = NULL;

    assertFrameObject( frame_fbe2a55516c1146765544ec27bca7c43 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_148_needsModuleFilenameObject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_148_needsModuleFilenameObject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_149___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_parent = python_pars[ 1 ];
    PyObject *par_function = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d53cfde73f72214ed37edab3336cb686 = NULL;

    struct Nuitka_FrameObject *frame_d53cfde73f72214ed37edab3336cb686;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d53cfde73f72214ed37edab3336cb686, codeobj_d53cfde73f72214ed37edab3336cb686, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d53cfde73f72214ed37edab3336cb686 = cache_frame_d53cfde73f72214ed37edab3336cb686;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d53cfde73f72214ed37edab3336cb686 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d53cfde73f72214ed37edab3336cb686 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonChildContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1075;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___init__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1075;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = par_self;

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1076;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_dict_key_1 = const_str_plain_parent;
    tmp_dict_value_1 = par_parent;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "parent" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1077;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1075;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1075;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_TempMixin );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TempMixin );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TempMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1080;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___init__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1080;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1080;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "FrameDeclarationsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1081;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_self;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1081;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1081;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1082;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___init__ );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_self;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1082;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1082;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1083;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___init__ );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_self;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1083;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1083;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_function;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "function" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1085;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1085;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_function, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1085;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1087;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1087;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_setExceptionEscape, &PyTuple_GET_ITEM( const_tuple_str_plain_function_exception_exit_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1087;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = par_self;

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d53cfde73f72214ed37edab3336cb686->m_frame.f_lineno = 1088;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setReturnTarget, &PyTuple_GET_ITEM( const_tuple_str_plain_function_return_exit_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1090;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_frame_handle, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1090;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d53cfde73f72214ed37edab3336cb686 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d53cfde73f72214ed37edab3336cb686 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d53cfde73f72214ed37edab3336cb686, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d53cfde73f72214ed37edab3336cb686->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d53cfde73f72214ed37edab3336cb686, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d53cfde73f72214ed37edab3336cb686,
        type_description_1,
        par_self,
        par_parent,
        par_function
    );


    // Release cached frame.
    if ( frame_d53cfde73f72214ed37edab3336cb686 == cache_frame_d53cfde73f72214ed37edab3336cb686 )
    {
        Py_DECREF( frame_d53cfde73f72214ed37edab3336cb686 );
    }
    cache_frame_d53cfde73f72214ed37edab3336cb686 = NULL;

    assertFrameObject( frame_d53cfde73f72214ed37edab3336cb686 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_149___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    Py_XDECREF( par_function );
    par_function = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    Py_XDECREF( par_function );
    par_function = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_149___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_150___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_ccf29b7ee74112863a6d491d6ec142c0 = NULL;

    struct Nuitka_FrameObject *frame_ccf29b7ee74112863a6d491d6ec142c0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ccf29b7ee74112863a6d491d6ec142c0, codeobj_ccf29b7ee74112863a6d491d6ec142c0, module_codegen$Contexts, sizeof(void *) );
    frame_ccf29b7ee74112863a6d491d6ec142c0 = cache_frame_ccf29b7ee74112863a6d491d6ec142c0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ccf29b7ee74112863a6d491d6ec142c0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ccf29b7ee74112863a6d491d6ec142c0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_left_name_1 = const_str_digest_54e9e6535450bc1ab4b1290b4ca34a3d;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ccf29b7ee74112863a6d491d6ec142c0->m_frame.f_lineno = 1094;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isExpressionClassBody );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1094;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_false_1;
    }
    else
    {
        goto condexpr_true_1;
    }
    condexpr_true_1:;
    tmp_tuple_element_1 = const_str_plain_function;
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_tuple_element_1 = const_str_plain_class;
    condexpr_end_1:;
    tmp_right_name_1 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1095;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_function );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1095;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ccf29b7ee74112863a6d491d6ec142c0->m_frame.f_lineno = 1095;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1095;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1093;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccf29b7ee74112863a6d491d6ec142c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccf29b7ee74112863a6d491d6ec142c0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccf29b7ee74112863a6d491d6ec142c0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ccf29b7ee74112863a6d491d6ec142c0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ccf29b7ee74112863a6d491d6ec142c0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ccf29b7ee74112863a6d491d6ec142c0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ccf29b7ee74112863a6d491d6ec142c0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ccf29b7ee74112863a6d491d6ec142c0 == cache_frame_ccf29b7ee74112863a6d491d6ec142c0 )
    {
        Py_DECREF( frame_ccf29b7ee74112863a6d491d6ec142c0 );
    }
    cache_frame_ccf29b7ee74112863a6d491d6ec142c0 = NULL;

    assertFrameObject( frame_ccf29b7ee74112863a6d491d6ec142c0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_150___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_150___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_151_getFunction( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_9d77b296fdbd4ff057d1c68f0611810d = NULL;

    struct Nuitka_FrameObject *frame_9d77b296fdbd4ff057d1c68f0611810d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9d77b296fdbd4ff057d1c68f0611810d, codeobj_9d77b296fdbd4ff057d1c68f0611810d, module_codegen$Contexts, sizeof(void *) );
    frame_9d77b296fdbd4ff057d1c68f0611810d = cache_frame_9d77b296fdbd4ff057d1c68f0611810d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9d77b296fdbd4ff057d1c68f0611810d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9d77b296fdbd4ff057d1c68f0611810d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d77b296fdbd4ff057d1c68f0611810d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d77b296fdbd4ff057d1c68f0611810d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d77b296fdbd4ff057d1c68f0611810d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9d77b296fdbd4ff057d1c68f0611810d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9d77b296fdbd4ff057d1c68f0611810d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9d77b296fdbd4ff057d1c68f0611810d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9d77b296fdbd4ff057d1c68f0611810d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9d77b296fdbd4ff057d1c68f0611810d == cache_frame_9d77b296fdbd4ff057d1c68f0611810d )
    {
        Py_DECREF( frame_9d77b296fdbd4ff057d1c68f0611810d );
    }
    cache_frame_9d77b296fdbd4ff057d1c68f0611810d = NULL;

    assertFrameObject( frame_9d77b296fdbd4ff057d1c68f0611810d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_151_getFunction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_151_getFunction );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_152_getOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_177a9713a5382a6b4e6ae137a3cc5bc8 = NULL;

    struct Nuitka_FrameObject *frame_177a9713a5382a6b4e6ae137a3cc5bc8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_177a9713a5382a6b4e6ae137a3cc5bc8, codeobj_177a9713a5382a6b4e6ae137a3cc5bc8, module_codegen$Contexts, sizeof(void *) );
    frame_177a9713a5382a6b4e6ae137a3cc5bc8 = cache_frame_177a9713a5382a6b4e6ae137a3cc5bc8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_177a9713a5382a6b4e6ae137a3cc5bc8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1102;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_177a9713a5382a6b4e6ae137a3cc5bc8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_177a9713a5382a6b4e6ae137a3cc5bc8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_177a9713a5382a6b4e6ae137a3cc5bc8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_177a9713a5382a6b4e6ae137a3cc5bc8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_177a9713a5382a6b4e6ae137a3cc5bc8 == cache_frame_177a9713a5382a6b4e6ae137a3cc5bc8 )
    {
        Py_DECREF( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );
    }
    cache_frame_177a9713a5382a6b4e6ae137a3cc5bc8 = NULL;

    assertFrameObject( frame_177a9713a5382a6b4e6ae137a3cc5bc8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_152_getOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_152_getOwner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_153_getEntryPoint( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e8f19c2b9290c9456f79bbc3dfb9d448 = NULL;

    struct Nuitka_FrameObject *frame_e8f19c2b9290c9456f79bbc3dfb9d448;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e8f19c2b9290c9456f79bbc3dfb9d448, codeobj_e8f19c2b9290c9456f79bbc3dfb9d448, module_codegen$Contexts, sizeof(void *) );
    frame_e8f19c2b9290c9456f79bbc3dfb9d448 = cache_frame_e8f19c2b9290c9456f79bbc3dfb9d448;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e8f19c2b9290c9456f79bbc3dfb9d448 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1105;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e8f19c2b9290c9456f79bbc3dfb9d448, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e8f19c2b9290c9456f79bbc3dfb9d448->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e8f19c2b9290c9456f79bbc3dfb9d448, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e8f19c2b9290c9456f79bbc3dfb9d448,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e8f19c2b9290c9456f79bbc3dfb9d448 == cache_frame_e8f19c2b9290c9456f79bbc3dfb9d448 )
    {
        Py_DECREF( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );
    }
    cache_frame_e8f19c2b9290c9456f79bbc3dfb9d448 = NULL;

    assertFrameObject( frame_e8f19c2b9290c9456f79bbc3dfb9d448 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_153_getEntryPoint );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_153_getEntryPoint );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_154_mayRecurse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_154_mayRecurse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_154_mayRecurse );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_155_getCodeObjectHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_code_object = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8ceab6ad3a6a956eae170d8b6b7a9594 = NULL;

    struct Nuitka_FrameObject *frame_8ceab6ad3a6a956eae170d8b6b7a9594;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8ceab6ad3a6a956eae170d8b6b7a9594, codeobj_8ceab6ad3a6a956eae170d8b6b7a9594, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_8ceab6ad3a6a956eae170d8b6b7a9594 = cache_frame_8ceab6ad3a6a956eae170d8b6b7a9594;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8ceab6ad3a6a956eae170d8b6b7a9594 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getCodeObjectHandle );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_code_object;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1112;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_8ceab6ad3a6a956eae170d8b6b7a9594->m_frame.f_lineno = 1112;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8ceab6ad3a6a956eae170d8b6b7a9594, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8ceab6ad3a6a956eae170d8b6b7a9594->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8ceab6ad3a6a956eae170d8b6b7a9594, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8ceab6ad3a6a956eae170d8b6b7a9594,
        type_description_1,
        par_self,
        par_code_object
    );


    // Release cached frame.
    if ( frame_8ceab6ad3a6a956eae170d8b6b7a9594 == cache_frame_8ceab6ad3a6a956eae170d8b6b7a9594 )
    {
        Py_DECREF( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );
    }
    cache_frame_8ceab6ad3a6a956eae170d8b6b7a9594 = NULL;

    assertFrameObject( frame_8ceab6ad3a6a956eae170d8b6b7a9594 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_155_getCodeObjectHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_155_getCodeObjectHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_156_isForDirectCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_156_isForDirectCall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_156_isForDirectCall );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_157_isForCrossModuleUsage( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_7a2a8e63c9a4a219a6492c9a00590253 = NULL;

    struct Nuitka_FrameObject *frame_7a2a8e63c9a4a219a6492c9a00590253;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7a2a8e63c9a4a219a6492c9a00590253, codeobj_7a2a8e63c9a4a219a6492c9a00590253, module_codegen$Contexts, sizeof(void *) );
    frame_7a2a8e63c9a4a219a6492c9a00590253 = cache_frame_7a2a8e63c9a4a219a6492c9a00590253;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7a2a8e63c9a4a219a6492c9a00590253 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7a2a8e63c9a4a219a6492c9a00590253 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1120;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_7a2a8e63c9a4a219a6492c9a00590253->m_frame.f_lineno = 1120;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isCrossModuleUsed );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1120;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a2a8e63c9a4a219a6492c9a00590253 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a2a8e63c9a4a219a6492c9a00590253 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a2a8e63c9a4a219a6492c9a00590253 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7a2a8e63c9a4a219a6492c9a00590253, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7a2a8e63c9a4a219a6492c9a00590253->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7a2a8e63c9a4a219a6492c9a00590253, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7a2a8e63c9a4a219a6492c9a00590253,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7a2a8e63c9a4a219a6492c9a00590253 == cache_frame_7a2a8e63c9a4a219a6492c9a00590253 )
    {
        Py_DECREF( frame_7a2a8e63c9a4a219a6492c9a00590253 );
    }
    cache_frame_7a2a8e63c9a4a219a6492c9a00590253 = NULL;

    assertFrameObject( frame_7a2a8e63c9a4a219a6492c9a00590253 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_157_isForCrossModuleUsage );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_157_isForCrossModuleUsage );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_158_isForCreatedFunction( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_158_isForCreatedFunction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_158_isForCreatedFunction );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_159_isForDirectCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_159_isForDirectCall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_159_isForDirectCall );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_160_isForCrossModuleUsage( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fbe6e3f473c148ab130adb7dbc9a3930 = NULL;

    struct Nuitka_FrameObject *frame_fbe6e3f473c148ab130adb7dbc9a3930;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fbe6e3f473c148ab130adb7dbc9a3930, codeobj_fbe6e3f473c148ab130adb7dbc9a3930, module_codegen$Contexts, sizeof(void *) );
    frame_fbe6e3f473c148ab130adb7dbc9a3930 = cache_frame_fbe6e3f473c148ab130adb7dbc9a3930;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fbe6e3f473c148ab130adb7dbc9a3930 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fbe6e3f473c148ab130adb7dbc9a3930 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_function );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_fbe6e3f473c148ab130adb7dbc9a3930->m_frame.f_lineno = 1131;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isCrossModuleUsed );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe6e3f473c148ab130adb7dbc9a3930 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe6e3f473c148ab130adb7dbc9a3930 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fbe6e3f473c148ab130adb7dbc9a3930 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fbe6e3f473c148ab130adb7dbc9a3930, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fbe6e3f473c148ab130adb7dbc9a3930->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fbe6e3f473c148ab130adb7dbc9a3930, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fbe6e3f473c148ab130adb7dbc9a3930,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fbe6e3f473c148ab130adb7dbc9a3930 == cache_frame_fbe6e3f473c148ab130adb7dbc9a3930 )
    {
        Py_DECREF( frame_fbe6e3f473c148ab130adb7dbc9a3930 );
    }
    cache_frame_fbe6e3f473c148ab130adb7dbc9a3930 = NULL;

    assertFrameObject( frame_fbe6e3f473c148ab130adb7dbc9a3930 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_160_isForCrossModuleUsage );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_160_isForCrossModuleUsage );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_161_isForCreatedFunction( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_161_isForCreatedFunction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_161_isForCreatedFunction );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_162_getContextObjectName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = const_str_plain_generator;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_162_getContextObjectName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_162_getContextObjectName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_163_getGeneratorReturnValueName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_GtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_04de0bdd770837d7f5241aa4307407c5 = NULL;

    struct Nuitka_FrameObject *frame_04de0bdd770837d7f5241aa4307407c5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_04de0bdd770837d7f5241aa4307407c5, codeobj_04de0bdd770837d7f5241aa4307407c5, module_codegen$Contexts, sizeof(void *) );
    frame_04de0bdd770837d7f5241aa4307407c5 = cache_frame_04de0bdd770837d7f5241aa4307407c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_04de0bdd770837d7f5241aa4307407c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_04de0bdd770837d7f5241aa4307407c5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

    if (unlikely( tmp_compare_left_1 == NULL ))
    {
        tmp_compare_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
    }

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1140;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = const_int_pos_330;
    tmp_cmp_GtE_1 = RICH_COMPARE_BOOL_GE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_GtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1140;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_GtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1141;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allocateTempName );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1141;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_a446bcf39958ef92ff15a8277e4ac2b0_tuple;
    tmp_kw_name_1 = PyDict_Copy( const_dict_628013539fe17b0c3c196c9e449729d6 );
    frame_04de0bdd770837d7f5241aa4307407c5->m_frame.f_lineno = 1141;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1141;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1147;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_allocateTempName );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_name_2 = const_tuple_str_plain_generator_return_str_plain_bool_tuple;
    tmp_kw_name_2 = PyDict_Copy( const_dict_628013539fe17b0c3c196c9e449729d6 );
    frame_04de0bdd770837d7f5241aa4307407c5->m_frame.f_lineno = 1147;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04de0bdd770837d7f5241aa4307407c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_04de0bdd770837d7f5241aa4307407c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04de0bdd770837d7f5241aa4307407c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_04de0bdd770837d7f5241aa4307407c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_04de0bdd770837d7f5241aa4307407c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_04de0bdd770837d7f5241aa4307407c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_04de0bdd770837d7f5241aa4307407c5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_04de0bdd770837d7f5241aa4307407c5 == cache_frame_04de0bdd770837d7f5241aa4307407c5 )
    {
        Py_DECREF( frame_04de0bdd770837d7f5241aa4307407c5 );
    }
    cache_frame_04de0bdd770837d7f5241aa4307407c5 = NULL;

    assertFrameObject( frame_04de0bdd770837d7f5241aa4307407c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_163_getGeneratorReturnValueName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_163_getGeneratorReturnValueName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_164_getContextObjectName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = const_str_plain_coroutine;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_164_getContextObjectName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_164_getContextObjectName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_165_getContextObjectName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = const_str_plain_asyncgen;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_165_getContextObjectName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_165_getContextObjectName );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_166_isForDirectCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_166_isForDirectCall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_166_isForDirectCall );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_167_isForCreatedFunction( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_167_isForCreatedFunction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_167_isForCreatedFunction );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_168___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_parent = python_pars[ 1 ];
    PyObject *par_outline = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_d1140159ac5a2635ab9d67bd3668ed3d = NULL;

    struct Nuitka_FrameObject *frame_d1140159ac5a2635ab9d67bd3668ed3d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d1140159ac5a2635ab9d67bd3668ed3d, codeobj_d1140159ac5a2635ab9d67bd3668ed3d, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d1140159ac5a2635ab9d67bd3668ed3d = cache_frame_d1140159ac5a2635ab9d67bd3668ed3d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d1140159ac5a2635ab9d67bd3668ed3d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d1140159ac5a2635ab9d67bd3668ed3d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonChildContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1175;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___init__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = par_self;

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1176;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_dict_key_1 = const_str_plain_parent;
    tmp_dict_value_1 = par_parent;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "parent" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1177;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_d1140159ac5a2635ab9d67bd3668ed3d->m_frame.f_lineno = 1175;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1180;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___init__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1180;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1180;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d1140159ac5a2635ab9d67bd3668ed3d->m_frame.f_lineno = 1180;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1180;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_self;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    frame_d1140159ac5a2635ab9d67bd3668ed3d->m_frame.f_lineno = 1181;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1181;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_outline;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "outline" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1183;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1183;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_outline, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1183;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1140159ac5a2635ab9d67bd3668ed3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1140159ac5a2635ab9d67bd3668ed3d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d1140159ac5a2635ab9d67bd3668ed3d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d1140159ac5a2635ab9d67bd3668ed3d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d1140159ac5a2635ab9d67bd3668ed3d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d1140159ac5a2635ab9d67bd3668ed3d,
        type_description_1,
        par_self,
        par_parent,
        par_outline
    );


    // Release cached frame.
    if ( frame_d1140159ac5a2635ab9d67bd3668ed3d == cache_frame_d1140159ac5a2635ab9d67bd3668ed3d )
    {
        Py_DECREF( frame_d1140159ac5a2635ab9d67bd3668ed3d );
    }
    cache_frame_d1140159ac5a2635ab9d67bd3668ed3d = NULL;

    assertFrameObject( frame_d1140159ac5a2635ab9d67bd3668ed3d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_168___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    Py_XDECREF( par_outline );
    par_outline = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_parent );
    par_parent = NULL;

    Py_XDECREF( par_outline );
    par_outline = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_168___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_169_getOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_dbbd5fda9f1254551c0fb70f409d3e16 = NULL;

    struct Nuitka_FrameObject *frame_dbbd5fda9f1254551c0fb70f409d3e16;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbbd5fda9f1254551c0fb70f409d3e16, codeobj_dbbd5fda9f1254551c0fb70f409d3e16, module_codegen$Contexts, sizeof(void *) );
    frame_dbbd5fda9f1254551c0fb70f409d3e16 = cache_frame_dbbd5fda9f1254551c0fb70f409d3e16;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbbd5fda9f1254551c0fb70f409d3e16 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbbd5fda9f1254551c0fb70f409d3e16 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_outline );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1186;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbbd5fda9f1254551c0fb70f409d3e16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbbd5fda9f1254551c0fb70f409d3e16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbbd5fda9f1254551c0fb70f409d3e16 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbbd5fda9f1254551c0fb70f409d3e16, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbbd5fda9f1254551c0fb70f409d3e16->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbbd5fda9f1254551c0fb70f409d3e16, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dbbd5fda9f1254551c0fb70f409d3e16,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_dbbd5fda9f1254551c0fb70f409d3e16 == cache_frame_dbbd5fda9f1254551c0fb70f409d3e16 )
    {
        Py_DECREF( frame_dbbd5fda9f1254551c0fb70f409d3e16 );
    }
    cache_frame_dbbd5fda9f1254551c0fb70f409d3e16 = NULL;

    assertFrameObject( frame_dbbd5fda9f1254551c0fb70f409d3e16 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_169_getOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_169_getOwner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_170_getEntryPoint( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a11729747c4562fc817aa06514420ea3 = NULL;

    struct Nuitka_FrameObject *frame_a11729747c4562fc817aa06514420ea3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a11729747c4562fc817aa06514420ea3, codeobj_a11729747c4562fc817aa06514420ea3, module_codegen$Contexts, sizeof(void *) );
    frame_a11729747c4562fc817aa06514420ea3 = cache_frame_a11729747c4562fc817aa06514420ea3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a11729747c4562fc817aa06514420ea3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a11729747c4562fc817aa06514420ea3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_outline );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_a11729747c4562fc817aa06514420ea3->m_frame.f_lineno = 1189;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getEntryPoint );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a11729747c4562fc817aa06514420ea3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a11729747c4562fc817aa06514420ea3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a11729747c4562fc817aa06514420ea3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a11729747c4562fc817aa06514420ea3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a11729747c4562fc817aa06514420ea3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a11729747c4562fc817aa06514420ea3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a11729747c4562fc817aa06514420ea3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a11729747c4562fc817aa06514420ea3 == cache_frame_a11729747c4562fc817aa06514420ea3 )
    {
        Py_DECREF( frame_a11729747c4562fc817aa06514420ea3 );
    }
    cache_frame_a11729747c4562fc817aa06514420ea3 = NULL;

    assertFrameObject( frame_a11729747c4562fc817aa06514420ea3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_170_getEntryPoint );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_170_getEntryPoint );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_171_allocateLabel( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_c41cb4a985460523df9fca9f52e03756 = NULL;

    struct Nuitka_FrameObject *frame_c41cb4a985460523df9fca9f52e03756;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c41cb4a985460523df9fca9f52e03756, codeobj_c41cb4a985460523df9fca9f52e03756, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_c41cb4a985460523df9fca9f52e03756 = cache_frame_c41cb4a985460523df9fca9f52e03756;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c41cb4a985460523df9fca9f52e03756 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c41cb4a985460523df9fca9f52e03756 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allocateLabel );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c41cb4a985460523df9fca9f52e03756->m_frame.f_lineno = 1192;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c41cb4a985460523df9fca9f52e03756 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c41cb4a985460523df9fca9f52e03756 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c41cb4a985460523df9fca9f52e03756 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c41cb4a985460523df9fca9f52e03756, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c41cb4a985460523df9fca9f52e03756->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c41cb4a985460523df9fca9f52e03756, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c41cb4a985460523df9fca9f52e03756,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_c41cb4a985460523df9fca9f52e03756 == cache_frame_c41cb4a985460523df9fca9f52e03756 )
    {
        Py_DECREF( frame_c41cb4a985460523df9fca9f52e03756 );
    }
    cache_frame_c41cb4a985460523df9fca9f52e03756 = NULL;

    assertFrameObject( frame_c41cb4a985460523df9fca9f52e03756 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_171_allocateLabel );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_171_allocateLabel );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_172_allocateTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *par_type_name = python_pars[ 2 ];
    PyObject *par_unique = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_3ce00aefad6d38d30ea6233871152475 = NULL;

    struct Nuitka_FrameObject *frame_3ce00aefad6d38d30ea6233871152475;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ce00aefad6d38d30ea6233871152475, codeobj_3ce00aefad6d38d30ea6233871152475, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3ce00aefad6d38d30ea6233871152475 = cache_frame_3ce00aefad6d38d30ea6233871152475;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ce00aefad6d38d30ea6233871152475 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ce00aefad6d38d30ea6233871152475 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allocateTempName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_base_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_type_name;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_unique;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "unique" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_3ce00aefad6d38d30ea6233871152475->m_frame.f_lineno = 1196;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ce00aefad6d38d30ea6233871152475 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ce00aefad6d38d30ea6233871152475 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ce00aefad6d38d30ea6233871152475 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ce00aefad6d38d30ea6233871152475, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ce00aefad6d38d30ea6233871152475->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ce00aefad6d38d30ea6233871152475, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ce00aefad6d38d30ea6233871152475,
        type_description_1,
        par_self,
        par_base_name,
        par_type_name,
        par_unique
    );


    // Release cached frame.
    if ( frame_3ce00aefad6d38d30ea6233871152475 == cache_frame_3ce00aefad6d38d30ea6233871152475 )
    {
        Py_DECREF( frame_3ce00aefad6d38d30ea6233871152475 );
    }
    cache_frame_3ce00aefad6d38d30ea6233871152475 = NULL;

    assertFrameObject( frame_3ce00aefad6d38d30ea6233871152475 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_172_allocateTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    Py_XDECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( par_unique );
    par_unique = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_172_allocateTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_173_hasTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_base_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_2044b140be824528f2820f598d0af4f7 = NULL;

    struct Nuitka_FrameObject *frame_2044b140be824528f2820f598d0af4f7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2044b140be824528f2820f598d0af4f7, codeobj_2044b140be824528f2820f598d0af4f7, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_2044b140be824528f2820f598d0af4f7 = cache_frame_2044b140be824528f2820f598d0af4f7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2044b140be824528f2820f598d0af4f7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2044b140be824528f2820f598d0af4f7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1199;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_hasTempName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1199;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_base_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "base_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1199;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_2044b140be824528f2820f598d0af4f7->m_frame.f_lineno = 1199;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1199;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2044b140be824528f2820f598d0af4f7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2044b140be824528f2820f598d0af4f7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2044b140be824528f2820f598d0af4f7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2044b140be824528f2820f598d0af4f7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2044b140be824528f2820f598d0af4f7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2044b140be824528f2820f598d0af4f7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2044b140be824528f2820f598d0af4f7,
        type_description_1,
        par_self,
        par_base_name
    );


    // Release cached frame.
    if ( frame_2044b140be824528f2820f598d0af4f7 == cache_frame_2044b140be824528f2820f598d0af4f7 )
    {
        Py_DECREF( frame_2044b140be824528f2820f598d0af4f7 );
    }
    cache_frame_2044b140be824528f2820f598d0af4f7 = NULL;

    assertFrameObject( frame_2044b140be824528f2820f598d0af4f7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_173_hasTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_base_name );
    par_base_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_173_hasTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_174_getCleanupTempnames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d695ea0bd890a59839886611b81768e6 = NULL;

    struct Nuitka_FrameObject *frame_d695ea0bd890a59839886611b81768e6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d695ea0bd890a59839886611b81768e6, codeobj_d695ea0bd890a59839886611b81768e6, module_codegen$Contexts, sizeof(void *) );
    frame_d695ea0bd890a59839886611b81768e6 = cache_frame_d695ea0bd890a59839886611b81768e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d695ea0bd890a59839886611b81768e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d695ea0bd890a59839886611b81768e6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1202;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d695ea0bd890a59839886611b81768e6->m_frame.f_lineno = 1202;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getCleanupTempnames );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1202;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d695ea0bd890a59839886611b81768e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d695ea0bd890a59839886611b81768e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d695ea0bd890a59839886611b81768e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d695ea0bd890a59839886611b81768e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d695ea0bd890a59839886611b81768e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d695ea0bd890a59839886611b81768e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d695ea0bd890a59839886611b81768e6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d695ea0bd890a59839886611b81768e6 == cache_frame_d695ea0bd890a59839886611b81768e6 )
    {
        Py_DECREF( frame_d695ea0bd890a59839886611b81768e6 );
    }
    cache_frame_d695ea0bd890a59839886611b81768e6 = NULL;

    assertFrameObject( frame_d695ea0bd890a59839886611b81768e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_174_getCleanupTempnames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_174_getCleanupTempnames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_175_addCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_40d22dd518c0b73c1b417580ffaf0490 = NULL;

    struct Nuitka_FrameObject *frame_40d22dd518c0b73c1b417580ffaf0490;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40d22dd518c0b73c1b417580ffaf0490, codeobj_40d22dd518c0b73c1b417580ffaf0490, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_40d22dd518c0b73c1b417580ffaf0490 = cache_frame_40d22dd518c0b73c1b417580ffaf0490;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40d22dd518c0b73c1b417580ffaf0490 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40d22dd518c0b73c1b417580ffaf0490 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addCleanupTempName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1205;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_40d22dd518c0b73c1b417580ffaf0490->m_frame.f_lineno = 1205;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40d22dd518c0b73c1b417580ffaf0490 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40d22dd518c0b73c1b417580ffaf0490 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40d22dd518c0b73c1b417580ffaf0490, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40d22dd518c0b73c1b417580ffaf0490->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40d22dd518c0b73c1b417580ffaf0490, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40d22dd518c0b73c1b417580ffaf0490,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_40d22dd518c0b73c1b417580ffaf0490 == cache_frame_40d22dd518c0b73c1b417580ffaf0490 )
    {
        Py_DECREF( frame_40d22dd518c0b73c1b417580ffaf0490 );
    }
    cache_frame_40d22dd518c0b73c1b417580ffaf0490 = NULL;

    assertFrameObject( frame_40d22dd518c0b73c1b417580ffaf0490 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_175_addCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_175_addCleanupTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_176_removeCleanupTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_992161e4a323a8379d54e03131a47bfc = NULL;

    struct Nuitka_FrameObject *frame_992161e4a323a8379d54e03131a47bfc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_992161e4a323a8379d54e03131a47bfc, codeobj_992161e4a323a8379d54e03131a47bfc, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_992161e4a323a8379d54e03131a47bfc = cache_frame_992161e4a323a8379d54e03131a47bfc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_992161e4a323a8379d54e03131a47bfc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_992161e4a323a8379d54e03131a47bfc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1208;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_removeCleanupTempName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1208;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1208;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_992161e4a323a8379d54e03131a47bfc->m_frame.f_lineno = 1208;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1208;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_992161e4a323a8379d54e03131a47bfc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_992161e4a323a8379d54e03131a47bfc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_992161e4a323a8379d54e03131a47bfc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_992161e4a323a8379d54e03131a47bfc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_992161e4a323a8379d54e03131a47bfc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_992161e4a323a8379d54e03131a47bfc,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_992161e4a323a8379d54e03131a47bfc == cache_frame_992161e4a323a8379d54e03131a47bfc )
    {
        Py_DECREF( frame_992161e4a323a8379d54e03131a47bfc );
    }
    cache_frame_992161e4a323a8379d54e03131a47bfc = NULL;

    assertFrameObject( frame_992161e4a323a8379d54e03131a47bfc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_176_removeCleanupTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_176_removeCleanupTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_177_needsCleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_8dac2dd25f484b6fbafc57bac1df13f7 = NULL;

    struct Nuitka_FrameObject *frame_8dac2dd25f484b6fbafc57bac1df13f7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8dac2dd25f484b6fbafc57bac1df13f7, codeobj_8dac2dd25f484b6fbafc57bac1df13f7, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_8dac2dd25f484b6fbafc57bac1df13f7 = cache_frame_8dac2dd25f484b6fbafc57bac1df13f7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8dac2dd25f484b6fbafc57bac1df13f7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8dac2dd25f484b6fbafc57bac1df13f7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_needsCleanup );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1211;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_8dac2dd25f484b6fbafc57bac1df13f7->m_frame.f_lineno = 1211;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8dac2dd25f484b6fbafc57bac1df13f7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8dac2dd25f484b6fbafc57bac1df13f7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8dac2dd25f484b6fbafc57bac1df13f7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8dac2dd25f484b6fbafc57bac1df13f7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8dac2dd25f484b6fbafc57bac1df13f7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8dac2dd25f484b6fbafc57bac1df13f7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8dac2dd25f484b6fbafc57bac1df13f7,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_8dac2dd25f484b6fbafc57bac1df13f7 == cache_frame_8dac2dd25f484b6fbafc57bac1df13f7 )
    {
        Py_DECREF( frame_8dac2dd25f484b6fbafc57bac1df13f7 );
    }
    cache_frame_8dac2dd25f484b6fbafc57bac1df13f7 = NULL;

    assertFrameObject( frame_8dac2dd25f484b6fbafc57bac1df13f7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_177_needsCleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_177_needsCleanup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_178_pushCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_5edf0029e317204c2f87493cebac3dd6 = NULL;

    struct Nuitka_FrameObject *frame_5edf0029e317204c2f87493cebac3dd6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5edf0029e317204c2f87493cebac3dd6, codeobj_5edf0029e317204c2f87493cebac3dd6, module_codegen$Contexts, sizeof(void *) );
    frame_5edf0029e317204c2f87493cebac3dd6 = cache_frame_5edf0029e317204c2f87493cebac3dd6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5edf0029e317204c2f87493cebac3dd6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5edf0029e317204c2f87493cebac3dd6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1214;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_5edf0029e317204c2f87493cebac3dd6->m_frame.f_lineno = 1214;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pushCleanupScope );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1214;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5edf0029e317204c2f87493cebac3dd6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5edf0029e317204c2f87493cebac3dd6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5edf0029e317204c2f87493cebac3dd6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5edf0029e317204c2f87493cebac3dd6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5edf0029e317204c2f87493cebac3dd6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5edf0029e317204c2f87493cebac3dd6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5edf0029e317204c2f87493cebac3dd6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5edf0029e317204c2f87493cebac3dd6 == cache_frame_5edf0029e317204c2f87493cebac3dd6 )
    {
        Py_DECREF( frame_5edf0029e317204c2f87493cebac3dd6 );
    }
    cache_frame_5edf0029e317204c2f87493cebac3dd6 = NULL;

    assertFrameObject( frame_5edf0029e317204c2f87493cebac3dd6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_178_pushCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_178_pushCleanupScope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_179_popCleanupScope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3418a410b97e4041bebb9c5903bf4509 = NULL;

    struct Nuitka_FrameObject *frame_3418a410b97e4041bebb9c5903bf4509;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3418a410b97e4041bebb9c5903bf4509, codeobj_3418a410b97e4041bebb9c5903bf4509, module_codegen$Contexts, sizeof(void *) );
    frame_3418a410b97e4041bebb9c5903bf4509 = cache_frame_3418a410b97e4041bebb9c5903bf4509;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3418a410b97e4041bebb9c5903bf4509 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3418a410b97e4041bebb9c5903bf4509 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_3418a410b97e4041bebb9c5903bf4509->m_frame.f_lineno = 1217;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_popCleanupScope );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1217;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3418a410b97e4041bebb9c5903bf4509 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3418a410b97e4041bebb9c5903bf4509 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3418a410b97e4041bebb9c5903bf4509, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3418a410b97e4041bebb9c5903bf4509->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3418a410b97e4041bebb9c5903bf4509, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3418a410b97e4041bebb9c5903bf4509,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3418a410b97e4041bebb9c5903bf4509 == cache_frame_3418a410b97e4041bebb9c5903bf4509 )
    {
        Py_DECREF( frame_3418a410b97e4041bebb9c5903bf4509 );
    }
    cache_frame_3418a410b97e4041bebb9c5903bf4509 = NULL;

    assertFrameObject( frame_3418a410b97e4041bebb9c5903bf4509 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_179_popCleanupScope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_179_popCleanupScope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_180_getCodeObjectHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_code_object = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_0775874c728351eae1d857552f127a9a = NULL;

    struct Nuitka_FrameObject *frame_0775874c728351eae1d857552f127a9a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0775874c728351eae1d857552f127a9a, codeobj_0775874c728351eae1d857552f127a9a, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_0775874c728351eae1d857552f127a9a = cache_frame_0775874c728351eae1d857552f127a9a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0775874c728351eae1d857552f127a9a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0775874c728351eae1d857552f127a9a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1220;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getCodeObjectHandle );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1220;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_code_object;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "code_object" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1220;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_0775874c728351eae1d857552f127a9a->m_frame.f_lineno = 1220;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1220;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0775874c728351eae1d857552f127a9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0775874c728351eae1d857552f127a9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0775874c728351eae1d857552f127a9a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0775874c728351eae1d857552f127a9a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0775874c728351eae1d857552f127a9a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0775874c728351eae1d857552f127a9a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0775874c728351eae1d857552f127a9a,
        type_description_1,
        par_self,
        par_code_object
    );


    // Release cached frame.
    if ( frame_0775874c728351eae1d857552f127a9a == cache_frame_0775874c728351eae1d857552f127a9a )
    {
        Py_DECREF( frame_0775874c728351eae1d857552f127a9a );
    }
    cache_frame_0775874c728351eae1d857552f127a9a = NULL;

    assertFrameObject( frame_0775874c728351eae1d857552f127a9a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_180_getCodeObjectHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_code_object );
    par_code_object = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_180_getCodeObjectHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_181_getExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ccbc97c6110016c7171355558be21fbd = NULL;

    struct Nuitka_FrameObject *frame_ccbc97c6110016c7171355558be21fbd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ccbc97c6110016c7171355558be21fbd, codeobj_ccbc97c6110016c7171355558be21fbd, module_codegen$Contexts, sizeof(void *) );
    frame_ccbc97c6110016c7171355558be21fbd = cache_frame_ccbc97c6110016c7171355558be21fbd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ccbc97c6110016c7171355558be21fbd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ccbc97c6110016c7171355558be21fbd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1223;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_ccbc97c6110016c7171355558be21fbd->m_frame.f_lineno = 1223;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getExceptionEscape );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1223;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccbc97c6110016c7171355558be21fbd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccbc97c6110016c7171355558be21fbd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ccbc97c6110016c7171355558be21fbd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ccbc97c6110016c7171355558be21fbd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ccbc97c6110016c7171355558be21fbd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ccbc97c6110016c7171355558be21fbd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ccbc97c6110016c7171355558be21fbd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ccbc97c6110016c7171355558be21fbd == cache_frame_ccbc97c6110016c7171355558be21fbd )
    {
        Py_DECREF( frame_ccbc97c6110016c7171355558be21fbd );
    }
    cache_frame_ccbc97c6110016c7171355558be21fbd = NULL;

    assertFrameObject( frame_ccbc97c6110016c7171355558be21fbd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_181_getExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_181_getExceptionEscape );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_182_setExceptionEscape( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_4c6120df83a9dbf8ff1e54c044cc7f3a = NULL;

    struct Nuitka_FrameObject *frame_4c6120df83a9dbf8ff1e54c044cc7f3a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4c6120df83a9dbf8ff1e54c044cc7f3a, codeobj_4c6120df83a9dbf8ff1e54c044cc7f3a, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_4c6120df83a9dbf8ff1e54c044cc7f3a = cache_frame_4c6120df83a9dbf8ff1e54c044cc7f3a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4c6120df83a9dbf8ff1e54c044cc7f3a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setExceptionEscape );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_4c6120df83a9dbf8ff1e54c044cc7f3a->m_frame.f_lineno = 1226;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1226;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4c6120df83a9dbf8ff1e54c044cc7f3a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4c6120df83a9dbf8ff1e54c044cc7f3a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4c6120df83a9dbf8ff1e54c044cc7f3a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4c6120df83a9dbf8ff1e54c044cc7f3a,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_4c6120df83a9dbf8ff1e54c044cc7f3a == cache_frame_4c6120df83a9dbf8ff1e54c044cc7f3a )
    {
        Py_DECREF( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );
    }
    cache_frame_4c6120df83a9dbf8ff1e54c044cc7f3a = NULL;

    assertFrameObject( frame_4c6120df83a9dbf8ff1e54c044cc7f3a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_182_setExceptionEscape );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_182_setExceptionEscape );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_183_getLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_cef9045d2b139705558e7cf485ca9fed = NULL;

    struct Nuitka_FrameObject *frame_cef9045d2b139705558e7cf485ca9fed;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cef9045d2b139705558e7cf485ca9fed, codeobj_cef9045d2b139705558e7cf485ca9fed, module_codegen$Contexts, sizeof(void *) );
    frame_cef9045d2b139705558e7cf485ca9fed = cache_frame_cef9045d2b139705558e7cf485ca9fed;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cef9045d2b139705558e7cf485ca9fed );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cef9045d2b139705558e7cf485ca9fed ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_cef9045d2b139705558e7cf485ca9fed->m_frame.f_lineno = 1229;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getLoopBreakTarget );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cef9045d2b139705558e7cf485ca9fed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cef9045d2b139705558e7cf485ca9fed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cef9045d2b139705558e7cf485ca9fed );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cef9045d2b139705558e7cf485ca9fed, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cef9045d2b139705558e7cf485ca9fed->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cef9045d2b139705558e7cf485ca9fed, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cef9045d2b139705558e7cf485ca9fed,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_cef9045d2b139705558e7cf485ca9fed == cache_frame_cef9045d2b139705558e7cf485ca9fed )
    {
        Py_DECREF( frame_cef9045d2b139705558e7cf485ca9fed );
    }
    cache_frame_cef9045d2b139705558e7cf485ca9fed = NULL;

    assertFrameObject( frame_cef9045d2b139705558e7cf485ca9fed );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_183_getLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_183_getLoopBreakTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_184_setLoopBreakTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_18cf21dc66bd30fd6968cbd2e996eb14 = NULL;

    struct Nuitka_FrameObject *frame_18cf21dc66bd30fd6968cbd2e996eb14;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_18cf21dc66bd30fd6968cbd2e996eb14, codeobj_18cf21dc66bd30fd6968cbd2e996eb14, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_18cf21dc66bd30fd6968cbd2e996eb14 = cache_frame_18cf21dc66bd30fd6968cbd2e996eb14;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_18cf21dc66bd30fd6968cbd2e996eb14 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_18cf21dc66bd30fd6968cbd2e996eb14 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setLoopBreakTarget );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_18cf21dc66bd30fd6968cbd2e996eb14->m_frame.f_lineno = 1232;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18cf21dc66bd30fd6968cbd2e996eb14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_18cf21dc66bd30fd6968cbd2e996eb14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18cf21dc66bd30fd6968cbd2e996eb14 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_18cf21dc66bd30fd6968cbd2e996eb14, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_18cf21dc66bd30fd6968cbd2e996eb14->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_18cf21dc66bd30fd6968cbd2e996eb14, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_18cf21dc66bd30fd6968cbd2e996eb14,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_18cf21dc66bd30fd6968cbd2e996eb14 == cache_frame_18cf21dc66bd30fd6968cbd2e996eb14 )
    {
        Py_DECREF( frame_18cf21dc66bd30fd6968cbd2e996eb14 );
    }
    cache_frame_18cf21dc66bd30fd6968cbd2e996eb14 = NULL;

    assertFrameObject( frame_18cf21dc66bd30fd6968cbd2e996eb14 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_184_setLoopBreakTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_184_setLoopBreakTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_185_getLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_0b8aff2b67bd850d7a94360575b83331 = NULL;

    struct Nuitka_FrameObject *frame_0b8aff2b67bd850d7a94360575b83331;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0b8aff2b67bd850d7a94360575b83331, codeobj_0b8aff2b67bd850d7a94360575b83331, module_codegen$Contexts, sizeof(void *) );
    frame_0b8aff2b67bd850d7a94360575b83331 = cache_frame_0b8aff2b67bd850d7a94360575b83331;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b8aff2b67bd850d7a94360575b83331 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b8aff2b67bd850d7a94360575b83331 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_0b8aff2b67bd850d7a94360575b83331->m_frame.f_lineno = 1235;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getLoopContinueTarget );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b8aff2b67bd850d7a94360575b83331 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b8aff2b67bd850d7a94360575b83331 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b8aff2b67bd850d7a94360575b83331 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b8aff2b67bd850d7a94360575b83331, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b8aff2b67bd850d7a94360575b83331->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b8aff2b67bd850d7a94360575b83331, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b8aff2b67bd850d7a94360575b83331,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0b8aff2b67bd850d7a94360575b83331 == cache_frame_0b8aff2b67bd850d7a94360575b83331 )
    {
        Py_DECREF( frame_0b8aff2b67bd850d7a94360575b83331 );
    }
    cache_frame_0b8aff2b67bd850d7a94360575b83331 = NULL;

    assertFrameObject( frame_0b8aff2b67bd850d7a94360575b83331 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_185_getLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_185_getLoopContinueTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_186_setLoopContinueTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_19d9a6aa5f8decfa87b27417a66f16d8 = NULL;

    struct Nuitka_FrameObject *frame_19d9a6aa5f8decfa87b27417a66f16d8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_19d9a6aa5f8decfa87b27417a66f16d8, codeobj_19d9a6aa5f8decfa87b27417a66f16d8, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_19d9a6aa5f8decfa87b27417a66f16d8 = cache_frame_19d9a6aa5f8decfa87b27417a66f16d8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_19d9a6aa5f8decfa87b27417a66f16d8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_19d9a6aa5f8decfa87b27417a66f16d8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setLoopContinueTarget );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1238;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_19d9a6aa5f8decfa87b27417a66f16d8->m_frame.f_lineno = 1238;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19d9a6aa5f8decfa87b27417a66f16d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_19d9a6aa5f8decfa87b27417a66f16d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19d9a6aa5f8decfa87b27417a66f16d8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_19d9a6aa5f8decfa87b27417a66f16d8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_19d9a6aa5f8decfa87b27417a66f16d8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_19d9a6aa5f8decfa87b27417a66f16d8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_19d9a6aa5f8decfa87b27417a66f16d8,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_19d9a6aa5f8decfa87b27417a66f16d8 == cache_frame_19d9a6aa5f8decfa87b27417a66f16d8 )
    {
        Py_DECREF( frame_19d9a6aa5f8decfa87b27417a66f16d8 );
    }
    cache_frame_19d9a6aa5f8decfa87b27417a66f16d8 = NULL;

    assertFrameObject( frame_19d9a6aa5f8decfa87b27417a66f16d8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_186_setLoopContinueTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_186_setLoopContinueTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_187_getTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_c9da538500192f015102f0acb10bd9be = NULL;

    struct Nuitka_FrameObject *frame_c9da538500192f015102f0acb10bd9be;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c9da538500192f015102f0acb10bd9be, codeobj_c9da538500192f015102f0acb10bd9be, module_codegen$Contexts, sizeof(void *) );
    frame_c9da538500192f015102f0acb10bd9be = cache_frame_c9da538500192f015102f0acb10bd9be;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c9da538500192f015102f0acb10bd9be );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c9da538500192f015102f0acb10bd9be ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1241;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_c9da538500192f015102f0acb10bd9be->m_frame.f_lineno = 1241;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getTrueBranchTarget );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1241;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9da538500192f015102f0acb10bd9be );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9da538500192f015102f0acb10bd9be );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9da538500192f015102f0acb10bd9be );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c9da538500192f015102f0acb10bd9be, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c9da538500192f015102f0acb10bd9be->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c9da538500192f015102f0acb10bd9be, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c9da538500192f015102f0acb10bd9be,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c9da538500192f015102f0acb10bd9be == cache_frame_c9da538500192f015102f0acb10bd9be )
    {
        Py_DECREF( frame_c9da538500192f015102f0acb10bd9be );
    }
    cache_frame_c9da538500192f015102f0acb10bd9be = NULL;

    assertFrameObject( frame_c9da538500192f015102f0acb10bd9be );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_187_getTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_187_getTrueBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_188_getFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d7d44a047d7778e18ffd841c6272c8a7 = NULL;

    struct Nuitka_FrameObject *frame_d7d44a047d7778e18ffd841c6272c8a7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d7d44a047d7778e18ffd841c6272c8a7, codeobj_d7d44a047d7778e18ffd841c6272c8a7, module_codegen$Contexts, sizeof(void *) );
    frame_d7d44a047d7778e18ffd841c6272c8a7 = cache_frame_d7d44a047d7778e18ffd841c6272c8a7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d7d44a047d7778e18ffd841c6272c8a7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d7d44a047d7778e18ffd841c6272c8a7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1244;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_d7d44a047d7778e18ffd841c6272c8a7->m_frame.f_lineno = 1244;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFalseBranchTarget );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1244;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7d44a047d7778e18ffd841c6272c8a7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7d44a047d7778e18ffd841c6272c8a7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7d44a047d7778e18ffd841c6272c8a7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d7d44a047d7778e18ffd841c6272c8a7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d7d44a047d7778e18ffd841c6272c8a7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d7d44a047d7778e18ffd841c6272c8a7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d7d44a047d7778e18ffd841c6272c8a7,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d7d44a047d7778e18ffd841c6272c8a7 == cache_frame_d7d44a047d7778e18ffd841c6272c8a7 )
    {
        Py_DECREF( frame_d7d44a047d7778e18ffd841c6272c8a7 );
    }
    cache_frame_d7d44a047d7778e18ffd841c6272c8a7 = NULL;

    assertFrameObject( frame_d7d44a047d7778e18ffd841c6272c8a7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_188_getFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_188_getFalseBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_189_setTrueBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_8e47898037383dd96d5f512fcc78d56c = NULL;

    struct Nuitka_FrameObject *frame_8e47898037383dd96d5f512fcc78d56c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e47898037383dd96d5f512fcc78d56c, codeobj_8e47898037383dd96d5f512fcc78d56c, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_8e47898037383dd96d5f512fcc78d56c = cache_frame_8e47898037383dd96d5f512fcc78d56c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e47898037383dd96d5f512fcc78d56c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e47898037383dd96d5f512fcc78d56c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setTrueBranchTarget );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_8e47898037383dd96d5f512fcc78d56c->m_frame.f_lineno = 1247;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1247;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e47898037383dd96d5f512fcc78d56c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e47898037383dd96d5f512fcc78d56c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e47898037383dd96d5f512fcc78d56c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e47898037383dd96d5f512fcc78d56c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e47898037383dd96d5f512fcc78d56c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e47898037383dd96d5f512fcc78d56c,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_8e47898037383dd96d5f512fcc78d56c == cache_frame_8e47898037383dd96d5f512fcc78d56c )
    {
        Py_DECREF( frame_8e47898037383dd96d5f512fcc78d56c );
    }
    cache_frame_8e47898037383dd96d5f512fcc78d56c = NULL;

    assertFrameObject( frame_8e47898037383dd96d5f512fcc78d56c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_189_setTrueBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_189_setTrueBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_190_setFalseBranchTarget( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b960f5882c5ec8c26d803081a724846d = NULL;

    struct Nuitka_FrameObject *frame_b960f5882c5ec8c26d803081a724846d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b960f5882c5ec8c26d803081a724846d, codeobj_b960f5882c5ec8c26d803081a724846d, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_b960f5882c5ec8c26d803081a724846d = cache_frame_b960f5882c5ec8c26d803081a724846d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b960f5882c5ec8c26d803081a724846d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b960f5882c5ec8c26d803081a724846d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setFalseBranchTarget );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_label;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "label" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_b960f5882c5ec8c26d803081a724846d->m_frame.f_lineno = 1250;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b960f5882c5ec8c26d803081a724846d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b960f5882c5ec8c26d803081a724846d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b960f5882c5ec8c26d803081a724846d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b960f5882c5ec8c26d803081a724846d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b960f5882c5ec8c26d803081a724846d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b960f5882c5ec8c26d803081a724846d,
        type_description_1,
        par_self,
        par_label
    );


    // Release cached frame.
    if ( frame_b960f5882c5ec8c26d803081a724846d == cache_frame_b960f5882c5ec8c26d803081a724846d )
    {
        Py_DECREF( frame_b960f5882c5ec8c26d803081a724846d );
    }
    cache_frame_b960f5882c5ec8c26d803081a724846d = NULL;

    assertFrameObject( frame_b960f5882c5ec8c26d803081a724846d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_190_setFalseBranchTarget );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_190_setFalseBranchTarget );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_191_getFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_207104a18d78f5ed6b253d8b4b459bfc = NULL;

    struct Nuitka_FrameObject *frame_207104a18d78f5ed6b253d8b4b459bfc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_207104a18d78f5ed6b253d8b4b459bfc, codeobj_207104a18d78f5ed6b253d8b4b459bfc, module_codegen$Contexts, sizeof(void *) );
    frame_207104a18d78f5ed6b253d8b4b459bfc = cache_frame_207104a18d78f5ed6b253d8b4b459bfc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_207104a18d78f5ed6b253d8b4b459bfc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_207104a18d78f5ed6b253d8b4b459bfc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1253;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_207104a18d78f5ed6b253d8b4b459bfc->m_frame.f_lineno = 1253;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameHandle );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1253;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_207104a18d78f5ed6b253d8b4b459bfc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_207104a18d78f5ed6b253d8b4b459bfc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_207104a18d78f5ed6b253d8b4b459bfc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_207104a18d78f5ed6b253d8b4b459bfc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_207104a18d78f5ed6b253d8b4b459bfc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_207104a18d78f5ed6b253d8b4b459bfc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_207104a18d78f5ed6b253d8b4b459bfc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_207104a18d78f5ed6b253d8b4b459bfc == cache_frame_207104a18d78f5ed6b253d8b4b459bfc )
    {
        Py_DECREF( frame_207104a18d78f5ed6b253d8b4b459bfc );
    }
    cache_frame_207104a18d78f5ed6b253d8b4b459bfc = NULL;

    assertFrameObject( frame_207104a18d78f5ed6b253d8b4b459bfc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_191_getFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_191_getFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_192_pushFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_handle = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_1979d68cf3efafb6570219d9b631a4ae = NULL;

    struct Nuitka_FrameObject *frame_1979d68cf3efafb6570219d9b631a4ae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1979d68cf3efafb6570219d9b631a4ae, codeobj_1979d68cf3efafb6570219d9b631a4ae, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_1979d68cf3efafb6570219d9b631a4ae = cache_frame_1979d68cf3efafb6570219d9b631a4ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1979d68cf3efafb6570219d9b631a4ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1979d68cf3efafb6570219d9b631a4ae ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_pushFrameHandle );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_handle;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_handle" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_1979d68cf3efafb6570219d9b631a4ae->m_frame.f_lineno = 1256;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1256;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1979d68cf3efafb6570219d9b631a4ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1979d68cf3efafb6570219d9b631a4ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1979d68cf3efafb6570219d9b631a4ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1979d68cf3efafb6570219d9b631a4ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1979d68cf3efafb6570219d9b631a4ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1979d68cf3efafb6570219d9b631a4ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1979d68cf3efafb6570219d9b631a4ae,
        type_description_1,
        par_self,
        par_frame_handle
    );


    // Release cached frame.
    if ( frame_1979d68cf3efafb6570219d9b631a4ae == cache_frame_1979d68cf3efafb6570219d9b631a4ae )
    {
        Py_DECREF( frame_1979d68cf3efafb6570219d9b631a4ae );
    }
    cache_frame_1979d68cf3efafb6570219d9b631a4ae = NULL;

    assertFrameObject( frame_1979d68cf3efafb6570219d9b631a4ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_192_pushFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_handle );
    par_frame_handle = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_handle );
    par_frame_handle = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_192_pushFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_193_popFrameHandle( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_0635b043d9d9da0611a172be20832e3c = NULL;

    struct Nuitka_FrameObject *frame_0635b043d9d9da0611a172be20832e3c;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0635b043d9d9da0611a172be20832e3c, codeobj_0635b043d9d9da0611a172be20832e3c, module_codegen$Contexts, sizeof(void *) );
    frame_0635b043d9d9da0611a172be20832e3c = cache_frame_0635b043d9d9da0611a172be20832e3c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0635b043d9d9da0611a172be20832e3c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0635b043d9d9da0611a172be20832e3c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_0635b043d9d9da0611a172be20832e3c->m_frame.f_lineno = 1259;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_popFrameHandle );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0635b043d9d9da0611a172be20832e3c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0635b043d9d9da0611a172be20832e3c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0635b043d9d9da0611a172be20832e3c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0635b043d9d9da0611a172be20832e3c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0635b043d9d9da0611a172be20832e3c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0635b043d9d9da0611a172be20832e3c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0635b043d9d9da0611a172be20832e3c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0635b043d9d9da0611a172be20832e3c == cache_frame_0635b043d9d9da0611a172be20832e3c )
    {
        Py_DECREF( frame_0635b043d9d9da0611a172be20832e3c );
    }
    cache_frame_0635b043d9d9da0611a172be20832e3c = NULL;

    assertFrameObject( frame_0635b043d9d9da0611a172be20832e3c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_193_popFrameHandle );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_193_popFrameHandle );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_194_getExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_21f739fea84c01208bf5eb23a1cf98c5 = NULL;

    struct Nuitka_FrameObject *frame_21f739fea84c01208bf5eb23a1cf98c5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_21f739fea84c01208bf5eb23a1cf98c5, codeobj_21f739fea84c01208bf5eb23a1cf98c5, module_codegen$Contexts, sizeof(void *) );
    frame_21f739fea84c01208bf5eb23a1cf98c5 = cache_frame_21f739fea84c01208bf5eb23a1cf98c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_21f739fea84c01208bf5eb23a1cf98c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_21f739fea84c01208bf5eb23a1cf98c5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1262;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_21f739fea84c01208bf5eb23a1cf98c5->m_frame.f_lineno = 1262;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getExceptionKeeperVariables );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1262;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21f739fea84c01208bf5eb23a1cf98c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_21f739fea84c01208bf5eb23a1cf98c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21f739fea84c01208bf5eb23a1cf98c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_21f739fea84c01208bf5eb23a1cf98c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_21f739fea84c01208bf5eb23a1cf98c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_21f739fea84c01208bf5eb23a1cf98c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_21f739fea84c01208bf5eb23a1cf98c5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_21f739fea84c01208bf5eb23a1cf98c5 == cache_frame_21f739fea84c01208bf5eb23a1cf98c5 )
    {
        Py_DECREF( frame_21f739fea84c01208bf5eb23a1cf98c5 );
    }
    cache_frame_21f739fea84c01208bf5eb23a1cf98c5 = NULL;

    assertFrameObject( frame_21f739fea84c01208bf5eb23a1cf98c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_194_getExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_194_getExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_195_setExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_keeper_vars = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_e8c27ad0792b99a8ee8459e88b6a9011 = NULL;

    struct Nuitka_FrameObject *frame_e8c27ad0792b99a8ee8459e88b6a9011;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e8c27ad0792b99a8ee8459e88b6a9011, codeobj_e8c27ad0792b99a8ee8459e88b6a9011, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_e8c27ad0792b99a8ee8459e88b6a9011 = cache_frame_e8c27ad0792b99a8ee8459e88b6a9011;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e8c27ad0792b99a8ee8459e88b6a9011 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e8c27ad0792b99a8ee8459e88b6a9011 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setExceptionKeeperVariables );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_keeper_vars;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "keeper_vars" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1265;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_e8c27ad0792b99a8ee8459e88b6a9011->m_frame.f_lineno = 1265;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8c27ad0792b99a8ee8459e88b6a9011 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8c27ad0792b99a8ee8459e88b6a9011 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8c27ad0792b99a8ee8459e88b6a9011 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e8c27ad0792b99a8ee8459e88b6a9011, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e8c27ad0792b99a8ee8459e88b6a9011->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e8c27ad0792b99a8ee8459e88b6a9011, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e8c27ad0792b99a8ee8459e88b6a9011,
        type_description_1,
        par_self,
        par_keeper_vars
    );


    // Release cached frame.
    if ( frame_e8c27ad0792b99a8ee8459e88b6a9011 == cache_frame_e8c27ad0792b99a8ee8459e88b6a9011 )
    {
        Py_DECREF( frame_e8c27ad0792b99a8ee8459e88b6a9011 );
    }
    cache_frame_e8c27ad0792b99a8ee8459e88b6a9011 = NULL;

    assertFrameObject( frame_e8c27ad0792b99a8ee8459e88b6a9011 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_195_setExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_keeper_vars );
    par_keeper_vars = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_195_setExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_196_setVariableType( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_variable = python_pars[ 1 ];
    PyObject *par_variable_code_name = python_pars[ 2 ];
    PyObject *par_variable_c_type = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_87b218ddf91dac49519b4a8ec3f78958 = NULL;

    struct Nuitka_FrameObject *frame_87b218ddf91dac49519b4a8ec3f78958;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_87b218ddf91dac49519b4a8ec3f78958, codeobj_87b218ddf91dac49519b4a8ec3f78958, module_codegen$Contexts, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_87b218ddf91dac49519b4a8ec3f78958 = cache_frame_87b218ddf91dac49519b4a8ec3f78958;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_87b218ddf91dac49519b4a8ec3f78958 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_87b218ddf91dac49519b4a8ec3f78958 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setVariableType );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_variable;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_variable_code_name;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_code_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_variable_c_type;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "variable_c_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    frame_87b218ddf91dac49519b4a8ec3f78958->m_frame.f_lineno = 1268;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87b218ddf91dac49519b4a8ec3f78958 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87b218ddf91dac49519b4a8ec3f78958 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_87b218ddf91dac49519b4a8ec3f78958, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_87b218ddf91dac49519b4a8ec3f78958->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_87b218ddf91dac49519b4a8ec3f78958, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87b218ddf91dac49519b4a8ec3f78958,
        type_description_1,
        par_self,
        par_variable,
        par_variable_code_name,
        par_variable_c_type
    );


    // Release cached frame.
    if ( frame_87b218ddf91dac49519b4a8ec3f78958 == cache_frame_87b218ddf91dac49519b4a8ec3f78958 )
    {
        Py_DECREF( frame_87b218ddf91dac49519b4a8ec3f78958 );
    }
    cache_frame_87b218ddf91dac49519b4a8ec3f78958 = NULL;

    assertFrameObject( frame_87b218ddf91dac49519b4a8ec3f78958 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_196_setVariableType );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_variable );
    par_variable = NULL;

    Py_XDECREF( par_variable_code_name );
    par_variable_code_name = NULL;

    Py_XDECREF( par_variable_c_type );
    par_variable_c_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_variable );
    par_variable = NULL;

    Py_XDECREF( par_variable_code_name );
    par_variable_code_name = NULL;

    Py_XDECREF( par_variable_c_type );
    par_variable_c_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_196_setVariableType );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_197_getIntResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_63608cdfddc117fbbbd31d7e1d31905d = NULL;

    struct Nuitka_FrameObject *frame_63608cdfddc117fbbbd31d7e1d31905d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_63608cdfddc117fbbbd31d7e1d31905d, codeobj_63608cdfddc117fbbbd31d7e1d31905d, module_codegen$Contexts, sizeof(void *) );
    frame_63608cdfddc117fbbbd31d7e1d31905d = cache_frame_63608cdfddc117fbbbd31d7e1d31905d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_63608cdfddc117fbbbd31d7e1d31905d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_63608cdfddc117fbbbd31d7e1d31905d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_63608cdfddc117fbbbd31d7e1d31905d->m_frame.f_lineno = 1271;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getIntResName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63608cdfddc117fbbbd31d7e1d31905d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_63608cdfddc117fbbbd31d7e1d31905d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63608cdfddc117fbbbd31d7e1d31905d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_63608cdfddc117fbbbd31d7e1d31905d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_63608cdfddc117fbbbd31d7e1d31905d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_63608cdfddc117fbbbd31d7e1d31905d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_63608cdfddc117fbbbd31d7e1d31905d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_63608cdfddc117fbbbd31d7e1d31905d == cache_frame_63608cdfddc117fbbbd31d7e1d31905d )
    {
        Py_DECREF( frame_63608cdfddc117fbbbd31d7e1d31905d );
    }
    cache_frame_63608cdfddc117fbbbd31d7e1d31905d = NULL;

    assertFrameObject( frame_63608cdfddc117fbbbd31d7e1d31905d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_197_getIntResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_197_getIntResName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_198_getBoolResName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_3b679cd95e3a31562535f2691a8b80ed = NULL;

    struct Nuitka_FrameObject *frame_3b679cd95e3a31562535f2691a8b80ed;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3b679cd95e3a31562535f2691a8b80ed, codeobj_3b679cd95e3a31562535f2691a8b80ed, module_codegen$Contexts, sizeof(void *) );
    frame_3b679cd95e3a31562535f2691a8b80ed = cache_frame_3b679cd95e3a31562535f2691a8b80ed;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3b679cd95e3a31562535f2691a8b80ed );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3b679cd95e3a31562535f2691a8b80ed ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1274;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_3b679cd95e3a31562535f2691a8b80ed->m_frame.f_lineno = 1274;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getBoolResName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1274;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b679cd95e3a31562535f2691a8b80ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b679cd95e3a31562535f2691a8b80ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3b679cd95e3a31562535f2691a8b80ed );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3b679cd95e3a31562535f2691a8b80ed, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3b679cd95e3a31562535f2691a8b80ed->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3b679cd95e3a31562535f2691a8b80ed, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3b679cd95e3a31562535f2691a8b80ed,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3b679cd95e3a31562535f2691a8b80ed == cache_frame_3b679cd95e3a31562535f2691a8b80ed )
    {
        Py_DECREF( frame_3b679cd95e3a31562535f2691a8b80ed );
    }
    cache_frame_3b679cd95e3a31562535f2691a8b80ed = NULL;

    assertFrameObject( frame_3b679cd95e3a31562535f2691a8b80ed );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_198_getBoolResName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_198_getBoolResName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_199_needsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fd30e95d7240c9a202d3e86b9cc66759 = NULL;

    struct Nuitka_FrameObject *frame_fd30e95d7240c9a202d3e86b9cc66759;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fd30e95d7240c9a202d3e86b9cc66759, codeobj_fd30e95d7240c9a202d3e86b9cc66759, module_codegen$Contexts, sizeof(void *) );
    frame_fd30e95d7240c9a202d3e86b9cc66759 = cache_frame_fd30e95d7240c9a202d3e86b9cc66759;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fd30e95d7240c9a202d3e86b9cc66759 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fd30e95d7240c9a202d3e86b9cc66759 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1277;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_fd30e95d7240c9a202d3e86b9cc66759->m_frame.f_lineno = 1277;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_needsExceptionVariables );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1277;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd30e95d7240c9a202d3e86b9cc66759 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd30e95d7240c9a202d3e86b9cc66759 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd30e95d7240c9a202d3e86b9cc66759 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fd30e95d7240c9a202d3e86b9cc66759, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fd30e95d7240c9a202d3e86b9cc66759->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fd30e95d7240c9a202d3e86b9cc66759, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fd30e95d7240c9a202d3e86b9cc66759,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_fd30e95d7240c9a202d3e86b9cc66759 == cache_frame_fd30e95d7240c9a202d3e86b9cc66759 )
    {
        Py_DECREF( frame_fd30e95d7240c9a202d3e86b9cc66759 );
    }
    cache_frame_fd30e95d7240c9a202d3e86b9cc66759 = NULL;

    assertFrameObject( frame_fd30e95d7240c9a202d3e86b9cc66759 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_199_needsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_199_needsExceptionVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_200_markAsNeedsExceptionVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b565aa4c14f8fadd1cc440ee24825913 = NULL;

    struct Nuitka_FrameObject *frame_b565aa4c14f8fadd1cc440ee24825913;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b565aa4c14f8fadd1cc440ee24825913, codeobj_b565aa4c14f8fadd1cc440ee24825913, module_codegen$Contexts, sizeof(void *) );
    frame_b565aa4c14f8fadd1cc440ee24825913 = cache_frame_b565aa4c14f8fadd1cc440ee24825913;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b565aa4c14f8fadd1cc440ee24825913 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b565aa4c14f8fadd1cc440ee24825913 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1280;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_b565aa4c14f8fadd1cc440ee24825913->m_frame.f_lineno = 1280;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_markAsNeedsExceptionVariables );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1280;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b565aa4c14f8fadd1cc440ee24825913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b565aa4c14f8fadd1cc440ee24825913 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b565aa4c14f8fadd1cc440ee24825913, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b565aa4c14f8fadd1cc440ee24825913->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b565aa4c14f8fadd1cc440ee24825913, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b565aa4c14f8fadd1cc440ee24825913,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b565aa4c14f8fadd1cc440ee24825913 == cache_frame_b565aa4c14f8fadd1cc440ee24825913 )
    {
        Py_DECREF( frame_b565aa4c14f8fadd1cc440ee24825913 );
    }
    cache_frame_b565aa4c14f8fadd1cc440ee24825913 = NULL;

    assertFrameObject( frame_b565aa4c14f8fadd1cc440ee24825913 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_200_markAsNeedsExceptionVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_200_markAsNeedsExceptionVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_201_allocateExceptionKeeperVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e5debafd2ef2b4e74f48417bf9d35ade = NULL;

    struct Nuitka_FrameObject *frame_e5debafd2ef2b4e74f48417bf9d35ade;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e5debafd2ef2b4e74f48417bf9d35ade, codeobj_e5debafd2ef2b4e74f48417bf9d35ade, module_codegen$Contexts, sizeof(void *) );
    frame_e5debafd2ef2b4e74f48417bf9d35ade = cache_frame_e5debafd2ef2b4e74f48417bf9d35ade;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e5debafd2ef2b4e74f48417bf9d35ade );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e5debafd2ef2b4e74f48417bf9d35ade ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1283;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_e5debafd2ef2b4e74f48417bf9d35ade->m_frame.f_lineno = 1283;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_allocateExceptionKeeperVariables );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1283;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5debafd2ef2b4e74f48417bf9d35ade );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5debafd2ef2b4e74f48417bf9d35ade );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e5debafd2ef2b4e74f48417bf9d35ade );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e5debafd2ef2b4e74f48417bf9d35ade, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e5debafd2ef2b4e74f48417bf9d35ade->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e5debafd2ef2b4e74f48417bf9d35ade, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e5debafd2ef2b4e74f48417bf9d35ade,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e5debafd2ef2b4e74f48417bf9d35ade == cache_frame_e5debafd2ef2b4e74f48417bf9d35ade )
    {
        Py_DECREF( frame_e5debafd2ef2b4e74f48417bf9d35ade );
    }
    cache_frame_e5debafd2ef2b4e74f48417bf9d35ade = NULL;

    assertFrameObject( frame_e5debafd2ef2b4e74f48417bf9d35ade );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_201_allocateExceptionKeeperVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_201_allocateExceptionKeeperVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_202_addFrameDeclaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frame_decl = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_5db4abeaa8c0925e341eca632b344412 = NULL;

    struct Nuitka_FrameObject *frame_5db4abeaa8c0925e341eca632b344412;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5db4abeaa8c0925e341eca632b344412, codeobj_5db4abeaa8c0925e341eca632b344412, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_5db4abeaa8c0925e341eca632b344412 = cache_frame_5db4abeaa8c0925e341eca632b344412;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5db4abeaa8c0925e341eca632b344412 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5db4abeaa8c0925e341eca632b344412 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addFrameDeclaration );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_frame_decl;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "frame_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1286;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_5db4abeaa8c0925e341eca632b344412->m_frame.f_lineno = 1286;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5db4abeaa8c0925e341eca632b344412 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5db4abeaa8c0925e341eca632b344412 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5db4abeaa8c0925e341eca632b344412, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5db4abeaa8c0925e341eca632b344412->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5db4abeaa8c0925e341eca632b344412, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5db4abeaa8c0925e341eca632b344412,
        type_description_1,
        par_self,
        par_frame_decl
    );


    // Release cached frame.
    if ( frame_5db4abeaa8c0925e341eca632b344412 == cache_frame_5db4abeaa8c0925e341eca632b344412 )
    {
        Py_DECREF( frame_5db4abeaa8c0925e341eca632b344412 );
    }
    cache_frame_5db4abeaa8c0925e341eca632b344412 = NULL;

    assertFrameObject( frame_5db4abeaa8c0925e341eca632b344412 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_202_addFrameDeclaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_decl );
    par_frame_decl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_frame_decl );
    par_frame_decl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_202_addFrameDeclaration );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_203_isForDirectCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_32d328860bd7a4295a84b2f4aee8dc2b = NULL;

    struct Nuitka_FrameObject *frame_32d328860bd7a4295a84b2f4aee8dc2b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_32d328860bd7a4295a84b2f4aee8dc2b, codeobj_32d328860bd7a4295a84b2f4aee8dc2b, module_codegen$Contexts, sizeof(void *) );
    frame_32d328860bd7a4295a84b2f4aee8dc2b = cache_frame_32d328860bd7a4295a84b2f4aee8dc2b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_32d328860bd7a4295a84b2f4aee8dc2b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_32d328860bd7a4295a84b2f4aee8dc2b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_32d328860bd7a4295a84b2f4aee8dc2b->m_frame.f_lineno = 1289;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isForDirectCall );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32d328860bd7a4295a84b2f4aee8dc2b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_32d328860bd7a4295a84b2f4aee8dc2b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32d328860bd7a4295a84b2f4aee8dc2b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_32d328860bd7a4295a84b2f4aee8dc2b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_32d328860bd7a4295a84b2f4aee8dc2b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_32d328860bd7a4295a84b2f4aee8dc2b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32d328860bd7a4295a84b2f4aee8dc2b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_32d328860bd7a4295a84b2f4aee8dc2b == cache_frame_32d328860bd7a4295a84b2f4aee8dc2b )
    {
        Py_DECREF( frame_32d328860bd7a4295a84b2f4aee8dc2b );
    }
    cache_frame_32d328860bd7a4295a84b2f4aee8dc2b = NULL;

    assertFrameObject( frame_32d328860bd7a4295a84b2f4aee8dc2b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_203_isForDirectCall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_203_isForDirectCall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_204_mayRecurse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_204_mayRecurse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_204_mayRecurse );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_205_addLocalsDictName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_locals_dict_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c032e014639a5201ab6ce13b4ab904b1 = NULL;

    struct Nuitka_FrameObject *frame_c032e014639a5201ab6ce13b4ab904b1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c032e014639a5201ab6ce13b4ab904b1, codeobj_c032e014639a5201ab6ce13b4ab904b1, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_c032e014639a5201ab6ce13b4ab904b1 = cache_frame_c032e014639a5201ab6ce13b4ab904b1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c032e014639a5201ab6ce13b4ab904b1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c032e014639a5201ab6ce13b4ab904b1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1297;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addLocalsDictName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1297;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_locals_dict_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "locals_dict_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1297;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_c032e014639a5201ab6ce13b4ab904b1->m_frame.f_lineno = 1297;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1297;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c032e014639a5201ab6ce13b4ab904b1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c032e014639a5201ab6ce13b4ab904b1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c032e014639a5201ab6ce13b4ab904b1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c032e014639a5201ab6ce13b4ab904b1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c032e014639a5201ab6ce13b4ab904b1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c032e014639a5201ab6ce13b4ab904b1,
        type_description_1,
        par_self,
        par_locals_dict_name
    );


    // Release cached frame.
    if ( frame_c032e014639a5201ab6ce13b4ab904b1 == cache_frame_c032e014639a5201ab6ce13b4ab904b1 )
    {
        Py_DECREF( frame_c032e014639a5201ab6ce13b4ab904b1 );
    }
    cache_frame_c032e014639a5201ab6ce13b4ab904b1 = NULL;

    assertFrameObject( frame_c032e014639a5201ab6ce13b4ab904b1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_205_addLocalsDictName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_locals_dict_name );
    par_locals_dict_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_locals_dict_name );
    par_locals_dict_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_205_addLocalsDictName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_206_addExceptionPreserverVariables( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_count = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3ea37739a94a8673680bdc0143fe787d = NULL;

    struct Nuitka_FrameObject *frame_3ea37739a94a8673680bdc0143fe787d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ea37739a94a8673680bdc0143fe787d, codeobj_3ea37739a94a8673680bdc0143fe787d, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_3ea37739a94a8673680bdc0143fe787d = cache_frame_3ea37739a94a8673680bdc0143fe787d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ea37739a94a8673680bdc0143fe787d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ea37739a94a8673680bdc0143fe787d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1300;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addExceptionPreserverVariables );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1300;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_count;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1300;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_3ea37739a94a8673680bdc0143fe787d->m_frame.f_lineno = 1300;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1300;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ea37739a94a8673680bdc0143fe787d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ea37739a94a8673680bdc0143fe787d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ea37739a94a8673680bdc0143fe787d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ea37739a94a8673680bdc0143fe787d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ea37739a94a8673680bdc0143fe787d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ea37739a94a8673680bdc0143fe787d,
        type_description_1,
        par_self,
        par_count
    );


    // Release cached frame.
    if ( frame_3ea37739a94a8673680bdc0143fe787d == cache_frame_3ea37739a94a8673680bdc0143fe787d )
    {
        Py_DECREF( frame_3ea37739a94a8673680bdc0143fe787d );
    }
    cache_frame_3ea37739a94a8673680bdc0143fe787d = NULL;

    assertFrameObject( frame_3ea37739a94a8673680bdc0143fe787d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_206_addExceptionPreserverVariables );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_count );
    par_count = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_206_addExceptionPreserverVariables );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_207_getTempNameInfos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_44eb22fce37e611bb4f0e50131926be1 = NULL;

    struct Nuitka_FrameObject *frame_44eb22fce37e611bb4f0e50131926be1;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_44eb22fce37e611bb4f0e50131926be1, codeobj_44eb22fce37e611bb4f0e50131926be1, module_codegen$Contexts, sizeof(void *) );
    frame_44eb22fce37e611bb4f0e50131926be1 = cache_frame_44eb22fce37e611bb4f0e50131926be1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_44eb22fce37e611bb4f0e50131926be1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_44eb22fce37e611bb4f0e50131926be1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1303;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_44eb22fce37e611bb4f0e50131926be1->m_frame.f_lineno = 1303;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getTempNameInfos );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1303;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_44eb22fce37e611bb4f0e50131926be1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_44eb22fce37e611bb4f0e50131926be1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_44eb22fce37e611bb4f0e50131926be1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_44eb22fce37e611bb4f0e50131926be1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_44eb22fce37e611bb4f0e50131926be1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_44eb22fce37e611bb4f0e50131926be1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_44eb22fce37e611bb4f0e50131926be1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_44eb22fce37e611bb4f0e50131926be1 == cache_frame_44eb22fce37e611bb4f0e50131926be1 )
    {
        Py_DECREF( frame_44eb22fce37e611bb4f0e50131926be1 );
    }
    cache_frame_44eb22fce37e611bb4f0e50131926be1 = NULL;

    assertFrameObject( frame_44eb22fce37e611bb4f0e50131926be1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_207_getTempNameInfos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_207_getTempNameInfos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_208_forgetTempName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tmp_name = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_63fe25d792e86d16301c9159503968b8 = NULL;

    struct Nuitka_FrameObject *frame_63fe25d792e86d16301c9159503968b8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_63fe25d792e86d16301c9159503968b8, codeobj_63fe25d792e86d16301c9159503968b8, module_codegen$Contexts, sizeof(void *)+sizeof(void *) );
    frame_63fe25d792e86d16301c9159503968b8 = cache_frame_63fe25d792e86d16301c9159503968b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_63fe25d792e86d16301c9159503968b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_63fe25d792e86d16301c9159503968b8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_forgetTempName );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_tmp_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tmp_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    frame_63fe25d792e86d16301c9159503968b8->m_frame.f_lineno = 1306;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1306;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63fe25d792e86d16301c9159503968b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_63fe25d792e86d16301c9159503968b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_63fe25d792e86d16301c9159503968b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_63fe25d792e86d16301c9159503968b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_63fe25d792e86d16301c9159503968b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_63fe25d792e86d16301c9159503968b8,
        type_description_1,
        par_self,
        par_tmp_name
    );


    // Release cached frame.
    if ( frame_63fe25d792e86d16301c9159503968b8 == cache_frame_63fe25d792e86d16301c9159503968b8 )
    {
        Py_DECREF( frame_63fe25d792e86d16301c9159503968b8 );
    }
    cache_frame_63fe25d792e86d16301c9159503968b8 = NULL;

    assertFrameObject( frame_63fe25d792e86d16301c9159503968b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_208_forgetTempName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_tmp_name );
    par_tmp_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_208_forgetTempName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_codegen$Contexts$$$function_209_getContextObjectName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e34dd389195b9b5d05ef8e27ef774772 = NULL;

    struct Nuitka_FrameObject *frame_e34dd389195b9b5d05ef8e27ef774772;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e34dd389195b9b5d05ef8e27ef774772, codeobj_e34dd389195b9b5d05ef8e27ef774772, module_codegen$Contexts, sizeof(void *) );
    frame_e34dd389195b9b5d05ef8e27ef774772 = cache_frame_e34dd389195b9b5d05ef8e27ef774772;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e34dd389195b9b5d05ef8e27ef774772 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e34dd389195b9b5d05ef8e27ef774772 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1309;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_e34dd389195b9b5d05ef8e27ef774772->m_frame.f_lineno = 1309;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getContextObjectName );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1309;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e34dd389195b9b5d05ef8e27ef774772 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e34dd389195b9b5d05ef8e27ef774772 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e34dd389195b9b5d05ef8e27ef774772 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e34dd389195b9b5d05ef8e27ef774772, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e34dd389195b9b5d05ef8e27ef774772->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e34dd389195b9b5d05ef8e27ef774772, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e34dd389195b9b5d05ef8e27ef774772,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_e34dd389195b9b5d05ef8e27ef774772 == cache_frame_e34dd389195b9b5d05ef8e27ef774772 )
    {
        Py_DECREF( frame_e34dd389195b9b5d05ef8e27ef774772 );
    }
    cache_frame_e34dd389195b9b5d05ef8e27ef774772 = NULL;

    assertFrameObject( frame_e34dd389195b9b5d05ef8e27ef774772 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_209_getContextObjectName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts$$$function_209_getContextObjectName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_100___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_100___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_a775b336d71093bdc5cf5048acfcec01,
#endif
        codeobj_a0ef32db630ee7ffab650705f82949c8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_101_getConstantCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_101_getConstantCode,
        const_str_plain_getConstantCode,
#if PYTHON_VERSION >= 330
        const_str_digest_fdf085b4aa3db2edcb0ac6ec965d812f,
#endif
        codeobj_6f603200238b09ef26c50ca74a7a3ca3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_102_countConstantUse(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_102_countConstantUse,
        const_str_plain_countConstantUse,
#if PYTHON_VERSION >= 330
        const_str_digest_6d071d3109a8060fb2a971391a41d604,
#endif
        codeobj_77c61d5bd22dcc42f21df1f71a44aea1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_103_getConstantUseCount(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_103_getConstantUseCount,
        const_str_plain_getConstantUseCount,
#if PYTHON_VERSION >= 330
        const_str_digest_30c918915243af4a313afc42bd3579fb,
#endif
        codeobj_ab5f0102d0ffd0cd21a6d2012cd290dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_104_getConstants(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_104_getConstants,
        const_str_plain_getConstants,
#if PYTHON_VERSION >= 330
        const_str_digest_1bc5a106f93df28e7cb280601af927e9,
#endif
        codeobj_68228c0be8b8808971465d0a1408a345,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_105___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_105___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_8543c958c8b71f8e133f9a2beb608bc0,
#endif
        codeobj_59a17da53e33902710c637e22db4c9b1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_106_getFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_106_getFrameHandle,
        const_str_plain_getFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_15890cf826b7d30c52521be71e7a7eb9,
#endif
        codeobj_127c51962806469f83c7f9a0745fb87d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_107_pushFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_107_pushFrameHandle,
        const_str_plain_pushFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_13bac17eda8963a56732e7b8e7f99340,
#endif
        codeobj_c20a736617c75414f4021a5a879f2f04,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_108_popFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_108_popFrameHandle,
        const_str_plain_popFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_8b7296b8019bbdff3203b98f7065cc32,
#endif
        codeobj_279c6ac248d6c8229d505a9997d1a146,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_109_getFramesCount(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_109_getFramesCount,
        const_str_plain_getFramesCount,
#if PYTHON_VERSION >= 330
        const_str_digest_3d722941febc13409bb9dd17980dd7b2,
#endif
        codeobj_7ba49a81baaa679e56580a3c99359313,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_10_setExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_10_setExceptionEscape,
        const_str_plain_setExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_0c7a220bd34fb9c8798f0f2fec1cb0da,
#endif
        codeobj_56ffd0795b86a54640ed68201fec27ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_110_addFrameDeclaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_110_addFrameDeclaration,
        const_str_plain_addFrameDeclaration,
#if PYTHON_VERSION >= 330
        const_str_digest_e03d67f5a64017c14f12c063df2c2f06,
#endif
        codeobj_c7640666dea5664bfa1e5cf63b3c9d8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_111_getFrameDeclarations(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_111_getFrameDeclarations,
        const_str_plain_getFrameDeclarations,
#if PYTHON_VERSION >= 330
        const_str_digest_e50eac13be8c283248b1730bf779a98d,
#endif
        codeobj_75b89845119f8c8005f380471373e6dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_112_pushFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_112_pushFrameVariables,
        const_str_plain_pushFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_7d80a44ec359229267da8928be763699,
#endif
        codeobj_654b29fe95db02fc79a3d82f282749b2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        const_str_digest_2f4dfc429de3c23f0195ef78ce774a4d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_113_popFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_113_popFrameVariables,
        const_str_plain_popFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_ed69aa0bd5f577c19c3d0949f3e75d39,
#endif
        codeobj_ec6404e2172c5be8f927926822edfaae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        const_str_digest_46e207833d58a5607dcef01b6e0394ce,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_114_setVariableType(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_114_setVariableType,
        const_str_plain_setVariableType,
#if PYTHON_VERSION >= 330
        const_str_digest_a27dd0d7d26682190808a83e68f41a2f,
#endif
        codeobj_4fd0fc1c3c1f8c2a276b2b063220e476,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions,
        const_str_plain_getFrameVariableTypeDescriptions,
#if PYTHON_VERSION >= 330
        const_str_digest_c82c62837868c10d2b20ff2c8d4c12cc,
#endif
        codeobj_ca788999b2bab9557a685cdad355065e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName,
        const_str_plain_getFrameVariableTypeDescriptionName,
#if PYTHON_VERSION >= 330
        const_str_digest_9600a801bc9b6cd2b42e5aa9695c1a43,
#endif
        codeobj_7c8a5be6be74a118fe62e7b98ec5a9dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_117_getFrameVariableTypeDescription(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_117_getFrameVariableTypeDescription,
        const_str_plain_getFrameVariableTypeDescription,
#if PYTHON_VERSION >= 330
        const_str_digest_f69f05a54a53082c0c4af4066da595fb,
#endif
        codeobj_98cffa7b5c3321bba0e3b3b4dbdebdbc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_118_getFrameVariableCodeNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_118_getFrameVariableCodeNames,
        const_str_plain_getFrameVariableCodeNames,
#if PYTHON_VERSION >= 330
        const_str_digest_b64dbcae04a9beb7ea31b9fc66d1944e,
#endif
        codeobj_abb448aafa670c9e0c7e7828b119b318,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_119_getLocalsDictNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_119_getLocalsDictNames,
        const_str_plain_getLocalsDictNames,
#if PYTHON_VERSION >= 330
        const_str_digest_7557da68ac75e5b5557ba5ebbd1a40b4,
#endif
        codeobj_2940b3916d417f563bbc9fd5b3454d3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_11_getLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_11_getLoopBreakTarget,
        const_str_plain_getLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_f93c4804b3e85fff716e142bad8c063f,
#endif
        codeobj_110f78dca44d50f35817a88c63803340,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_120_addLocalsDictName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_120_addLocalsDictName,
        const_str_plain_addLocalsDictName,
#if PYTHON_VERSION >= 330
        const_str_digest_f3486d138092511205b103bca2ec7e88,
#endif
        codeobj_c930f80771924b211918f96bdbee2bdb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_121___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_121___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_ea30090a2dc6215e4003e6d4e0471dd2,
#endif
        codeobj_2777fa368a6d504ba4aea9a4f87a5412,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_122_setReturnReleaseMode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_122_setReturnReleaseMode,
        const_str_plain_setReturnReleaseMode,
#if PYTHON_VERSION >= 330
        const_str_digest_56356746a65eb210965718c6e0bad637,
#endif
        codeobj_d6fa1a058f407c200a6dfa1b40ebb1e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_123_getReturnReleaseMode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_123_getReturnReleaseMode,
        const_str_plain_getReturnReleaseMode,
#if PYTHON_VERSION >= 330
        const_str_digest_ab65be9aa3f9b0f8dac90010b8f2b7b1,
#endif
        codeobj_444dad8cfb1dc0e5631f164cb9cb7400,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_124_setReturnTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_124_setReturnTarget,
        const_str_plain_setReturnTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_23fe9b1819b59de888106e5ab17356ef,
#endif
        codeobj_d9b1ec8ba2549aca9e21f996e90c7f4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_125_getReturnTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_125_getReturnTarget,
        const_str_plain_getReturnTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_3785c5b02b975eee6bd504145377678f,
#endif
        codeobj_2a5236b378b84e3ed78714dd0cc21dbc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_126___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_126___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_edbae93d98459ae7c9eb8af7b7193e46,
#endif
        codeobj_08b55f1c830914b1c00bb1fbb8d5e0e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_127_getReturnValueName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_127_getReturnValueName,
        const_str_plain_getReturnValueName,
#if PYTHON_VERSION >= 330
        const_str_digest_1aaf40f2b11d352f255716a514436f34,
#endif
        codeobj_d775eb951e8acbf39f0107df6ba117a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_128_setReturnValueName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_128_setReturnValueName,
        const_str_plain_setReturnValueName,
#if PYTHON_VERSION >= 330
        const_str_digest_56d6f8d6f93635fba2f1d030ee12aad5,
#endif
        codeobj_c7a4bc4a6885f31a13c4655359e3c6fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_129___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_129___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_520108655c15407c4a5f87230dc28f7c,
#endif
        codeobj_a880a57d69225bd871448e0e669fbddb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_12_setLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_12_setLoopBreakTarget,
        const_str_plain_setLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_24cc62b22dd7e61b68f92530a4a782fb,
#endif
        codeobj_853421309d4f32df28d83b518c6517b1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_130___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_130___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        const_str_digest_9bb97bbdbc9682270fbd685cae14532d,
#endif
        codeobj_19354f51df5d22d64f453b358453021a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_131_getOwner(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_131_getOwner,
        const_str_plain_getOwner,
#if PYTHON_VERSION >= 330
        const_str_digest_9e9622c7c86655267970050134c8b362,
#endif
        codeobj_ac1b8b2a3510b8b6fb20c92646b3a0c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_132_getEntryPoint(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_132_getEntryPoint,
        const_str_plain_getEntryPoint,
#if PYTHON_VERSION >= 330
        const_str_digest_ef3595b39cc1b9509c09d092b025a8ee,
#endif
        codeobj_ecbb3e58cf1a324d3fee77f80485d062,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_133_isCompiledPythonModule(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_133_isCompiledPythonModule,
        const_str_plain_isCompiledPythonModule,
#if PYTHON_VERSION >= 330
        const_str_digest_fc7b837d9b6460c92a7a6b96b8c0c67d,
#endif
        codeobj_29f7c3b38e6d53a40a956a20b16d6a34,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_134_getName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_134_getName,
        const_str_plain_getName,
#if PYTHON_VERSION >= 330
        const_str_digest_77d01c4e03e31b15053cbf356c56c5d3,
#endif
        codeobj_95f24e5d6299d1570dfff6c07cb8ddc0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_135_getFilename(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_135_getFilename,
        const_str_plain_getFilename,
#if PYTHON_VERSION >= 330
        const_str_digest_bfa5790306fd6f4a7e7d764daae9c3d5,
#endif
        codeobj_31a12923b2304b2b93b956f8d0cb3abe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_136_mayRaiseException(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_136_mayRaiseException,
        const_str_plain_mayRaiseException,
#if PYTHON_VERSION >= 330
        const_str_digest_e8661d65ca161cb98d2f99c4e6dd1cf2,
#endif
        codeobj_13d2f0d69592eadd21dabc1c3ed96b0e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_137_getModuleCodeName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_137_getModuleCodeName,
        const_str_plain_getModuleCodeName,
#if PYTHON_VERSION >= 330
        const_str_digest_52f1ee247aa393ed2fd9ff32d9fe5948,
#endif
        codeobj_93fbb8e78e1c1e542ed28c23238b843a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_138_setFrameGuardMode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_138_setFrameGuardMode,
        const_str_plain_setFrameGuardMode,
#if PYTHON_VERSION >= 330
        const_str_digest_3a1700848fb92ee1dbb4cd16d7485b08,
#endif
        codeobj_67dfd733f52487a7c4d36642ce19b712,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_139_addHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_139_addHelperCode,
        const_str_plain_addHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_ee5d8bbbb96421bce0814b04537f4e5e,
#endif
        codeobj_1a6088137005dcdc22495df50b45ac40,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_13_getLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_13_getLoopContinueTarget,
        const_str_plain_getLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_4d4ad1d66c590948f14a486c230c1682,
#endif
        codeobj_e4a1a975a42152ea18e2086b7d1fa099,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_140_hasHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_140_hasHelperCode,
        const_str_plain_hasHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_b8f914007454fc95cbbaf34232adac0a,
#endif
        codeobj_2039fc5753d46c59ecc59d1e891b40f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_141_getHelperCodes(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_141_getHelperCodes,
        const_str_plain_getHelperCodes,
#if PYTHON_VERSION >= 330
        const_str_digest_86e31d797d4f791dbea48e73dc686425,
#endif
        codeobj_5ead817b54d2298e0d2090f7ad673419,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_142_addDeclaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_142_addDeclaration,
        const_str_plain_addDeclaration,
#if PYTHON_VERSION >= 330
        const_str_digest_a84eb8c4cf19a2079f3a5e6014ab3c4d,
#endif
        codeobj_123a6f951e965e6fb7230426dd617881,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_143_getDeclarations(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_143_getDeclarations,
        const_str_plain_getDeclarations,
#if PYTHON_VERSION >= 330
        const_str_digest_c22317b266ff5904776f5a58e1b9d77d,
#endif
        codeobj_fa62dfe2689c2cca55df838ea54b38f1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_144_mayRecurse(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_144_mayRecurse,
        const_str_plain_mayRecurse,
#if PYTHON_VERSION >= 330
        const_str_digest_57e1f5941d8ec27afcae5a2d53fc2ebf,
#endif
        codeobj_e7b576ee4c7a5c9fc0ce06af7f7931e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_145_getConstantCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_145_getConstantCode,
        const_str_plain_getConstantCode,
#if PYTHON_VERSION >= 330
        const_str_digest_e8a76356f3b9c8af74157ada4361c7e5,
#endif
        codeobj_f3b6ad571f323c66dedac13a51fcc3aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_146_getConstants(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_146_getConstants,
        const_str_plain_getConstants,
#if PYTHON_VERSION >= 330
        const_str_digest_3b43b7bb5d11bed0890d96709e396529,
#endif
        codeobj_08a0ffcb553873f9109c5535422adcc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject,
        const_str_plain_markAsNeedsModuleFilenameObject,
#if PYTHON_VERSION >= 330
        const_str_digest_e1ef4009c46be20ee12b49bd6fda02bf,
#endif
        codeobj_7bfaf8f94c79d7bb59ed1e69d078e4d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_148_needsModuleFilenameObject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_148_needsModuleFilenameObject,
        const_str_plain_needsModuleFilenameObject,
#if PYTHON_VERSION >= 330
        const_str_digest_20c727c82e5d28322108adc97821509b,
#endif
        codeobj_fbe2a55516c1146765544ec27bca7c43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_149___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_149___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_cb11a3d64d8c17af6ecf3ea5918cd8cf,
#endif
        codeobj_d53cfde73f72214ed37edab3336cb686,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_14_setLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_14_setLoopContinueTarget,
        const_str_plain_setLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_19b9cf24c12d3558fddc95d1485a0f2e,
#endif
        codeobj_621066726fe1091c06922280efd94ece,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_150___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_150___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        const_str_digest_83dbc6b4579376d5626364525918dafb,
#endif
        codeobj_ccf29b7ee74112863a6d491d6ec142c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_151_getFunction(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_151_getFunction,
        const_str_plain_getFunction,
#if PYTHON_VERSION >= 330
        const_str_digest_e6d81c4ac5540cfd7927cbc32a7fec8e,
#endif
        codeobj_9d77b296fdbd4ff057d1c68f0611810d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_152_getOwner(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_152_getOwner,
        const_str_plain_getOwner,
#if PYTHON_VERSION >= 330
        const_str_digest_1a6a0e81cf296c4b8867d45a8b58b1d3,
#endif
        codeobj_177a9713a5382a6b4e6ae137a3cc5bc8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_153_getEntryPoint(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_153_getEntryPoint,
        const_str_plain_getEntryPoint,
#if PYTHON_VERSION >= 330
        const_str_digest_912b4b1c7307c539a82a691f606660f5,
#endif
        codeobj_e8f19c2b9290c9456f79bbc3dfb9d448,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_154_mayRecurse(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_154_mayRecurse,
        const_str_plain_mayRecurse,
#if PYTHON_VERSION >= 330
        const_str_digest_300347c1384be8a8687478ff007256b9,
#endif
        codeobj_b0d590703165fda438f2da3aacbe7d2d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_155_getCodeObjectHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_155_getCodeObjectHandle,
        const_str_plain_getCodeObjectHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_d28c48e582387c3f5676f31b2d75ff04,
#endif
        codeobj_8ceab6ad3a6a956eae170d8b6b7a9594,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_156_isForDirectCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_156_isForDirectCall,
        const_str_plain_isForDirectCall,
#if PYTHON_VERSION >= 330
        const_str_digest_af3a2b1de0c6a92dacaae4dab7ac3804,
#endif
        codeobj_7ee471b65ba840a9274147fd818068ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_157_isForCrossModuleUsage(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_157_isForCrossModuleUsage,
        const_str_plain_isForCrossModuleUsage,
#if PYTHON_VERSION >= 330
        const_str_digest_fb9fc685100d5e403d5f70d0b394c80c,
#endif
        codeobj_7a2a8e63c9a4a219a6492c9a00590253,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_158_isForCreatedFunction(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_158_isForCreatedFunction,
        const_str_plain_isForCreatedFunction,
#if PYTHON_VERSION >= 330
        const_str_digest_747061db3f940444cb7e968024b55240,
#endif
        codeobj_9efc0faceb0e8844bc6c15dfe746edb6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_159_isForDirectCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_159_isForDirectCall,
        const_str_plain_isForDirectCall,
#if PYTHON_VERSION >= 330
        const_str_digest_45513e6ef9428f471b9854b48b23e391,
#endif
        codeobj_965b732c40016204a19a42cfa9fb8934,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_15_allocateLabel(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_15_allocateLabel,
        const_str_plain_allocateLabel,
#if PYTHON_VERSION >= 330
        const_str_digest_8afd3baaf3244cbcd3753c62c0705e40,
#endif
        codeobj_289d35c36f0d3170b0bfd7889bb96aec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_160_isForCrossModuleUsage(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_160_isForCrossModuleUsage,
        const_str_plain_isForCrossModuleUsage,
#if PYTHON_VERSION >= 330
        const_str_digest_5b977a8a3b26c127088d2ea95bff3dea,
#endif
        codeobj_fbe6e3f473c148ab130adb7dbc9a3930,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_161_isForCreatedFunction(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_161_isForCreatedFunction,
        const_str_plain_isForCreatedFunction,
#if PYTHON_VERSION >= 330
        const_str_digest_d8623eadc62eefd98b6505073e32fa96,
#endif
        codeobj_ae4b8267deb3d26ce0c7eb76803f3d17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_162_getContextObjectName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_162_getContextObjectName,
        const_str_plain_getContextObjectName,
#if PYTHON_VERSION >= 330
        const_str_digest_700c551f886c1e8bdb659afa747b8b81,
#endif
        codeobj_0720f22b9189e028227fd16c8ef29ce6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_163_getGeneratorReturnValueName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_163_getGeneratorReturnValueName,
        const_str_plain_getGeneratorReturnValueName,
#if PYTHON_VERSION >= 330
        const_str_digest_7092502eed67780baa4aed0d913d2d89,
#endif
        codeobj_04de0bdd770837d7f5241aa4307407c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_164_getContextObjectName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_164_getContextObjectName,
        const_str_plain_getContextObjectName,
#if PYTHON_VERSION >= 330
        const_str_digest_ca2d7dd6ed477bea25e0137f135c1964,
#endif
        codeobj_480190d8a56a895a45640015b8023065,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_165_getContextObjectName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_165_getContextObjectName,
        const_str_plain_getContextObjectName,
#if PYTHON_VERSION >= 330
        const_str_digest_87af14270b7513eece71f3edf77cf5ff,
#endif
        codeobj_b1892c8848832e71a89f357e844f61ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_166_isForDirectCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_166_isForDirectCall,
        const_str_plain_isForDirectCall,
#if PYTHON_VERSION >= 330
        const_str_digest_a0fb262c13dfb27f8fb32ef7135876e8,
#endif
        codeobj_03fe2f29eeaf1b6c13e3bbff28f413d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_167_isForCreatedFunction(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_167_isForCreatedFunction,
        const_str_plain_isForCreatedFunction,
#if PYTHON_VERSION >= 330
        const_str_digest_d7fd14742817cb89f9e613bc0578cd73,
#endif
        codeobj_dcf379d7f6b136958531782e123734ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_168___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_168___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_8f6d1ed1333c2b8e5ed75ae3469272bc,
#endif
        codeobj_d1140159ac5a2635ab9d67bd3668ed3d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_169_getOwner(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_169_getOwner,
        const_str_plain_getOwner,
#if PYTHON_VERSION >= 330
        const_str_digest_bd567e3b650e5693f901e634d214b47b,
#endif
        codeobj_dbbd5fda9f1254551c0fb70f409d3e16,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_16_getLabelCount(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_16_getLabelCount,
        const_str_plain_getLabelCount,
#if PYTHON_VERSION >= 330
        const_str_digest_037d332b1d32c0d5c23a1d56e4194dea,
#endif
        codeobj_6d1671c5ceb048fda74df856cbe3cb42,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_170_getEntryPoint(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_170_getEntryPoint,
        const_str_plain_getEntryPoint,
#if PYTHON_VERSION >= 330
        const_str_digest_294c218899092afd28db1da9d9795129,
#endif
        codeobj_a11729747c4562fc817aa06514420ea3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_171_allocateLabel(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_171_allocateLabel,
        const_str_plain_allocateLabel,
#if PYTHON_VERSION >= 330
        const_str_digest_a391e36881e14d55ceef68adbed6ce5c,
#endif
        codeobj_c41cb4a985460523df9fca9f52e03756,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_172_allocateTempName( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_172_allocateTempName,
        const_str_plain_allocateTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_a88fe8d1a8117948a3a9b364ecd8a9bc,
#endif
        codeobj_3ce00aefad6d38d30ea6233871152475,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_173_hasTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_173_hasTempName,
        const_str_plain_hasTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_885c88d4b9dcdc5ab5abe136b5e59ae4,
#endif
        codeobj_2044b140be824528f2820f598d0af4f7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_174_getCleanupTempnames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_174_getCleanupTempnames,
        const_str_plain_getCleanupTempnames,
#if PYTHON_VERSION >= 330
        const_str_digest_997a826f536e490ccc2a8614e5b3f2a2,
#endif
        codeobj_d695ea0bd890a59839886611b81768e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_175_addCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_175_addCleanupTempName,
        const_str_plain_addCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_cd5b021261404c37b8f61a632d02a733,
#endif
        codeobj_40d22dd518c0b73c1b417580ffaf0490,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_176_removeCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_176_removeCleanupTempName,
        const_str_plain_removeCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_2bfea02cce6dbb334c2151f2711d23f4,
#endif
        codeobj_992161e4a323a8379d54e03131a47bfc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_177_needsCleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_177_needsCleanup,
        const_str_plain_needsCleanup,
#if PYTHON_VERSION >= 330
        const_str_digest_c679c48f65d794c255401ec1bd4db6f2,
#endif
        codeobj_8dac2dd25f484b6fbafc57bac1df13f7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_178_pushCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_178_pushCleanupScope,
        const_str_plain_pushCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_afa6a7161e70a3534bb104f497fa36d9,
#endif
        codeobj_5edf0029e317204c2f87493cebac3dd6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_179_popCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_179_popCleanupScope,
        const_str_plain_popCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_64d2764f4789876e822950a3b60de617,
#endif
        codeobj_3418a410b97e4041bebb9c5903bf4509,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_17_needsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_17_needsExceptionVariables,
        const_str_plain_needsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_b847234509504f20fb53d89e47f5b400,
#endif
        codeobj_506b8e6a8b5a824731eeeb15d36723bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_180_getCodeObjectHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_180_getCodeObjectHandle,
        const_str_plain_getCodeObjectHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_b0277cdeccf88c8943f1f7d6f7793f34,
#endif
        codeobj_0775874c728351eae1d857552f127a9a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_181_getExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_181_getExceptionEscape,
        const_str_plain_getExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_ab158c26012931f78fcf5dac53834cf2,
#endif
        codeobj_ccbc97c6110016c7171355558be21fbd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_182_setExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_182_setExceptionEscape,
        const_str_plain_setExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_0847e49017f7c0928080d95a06596ea9,
#endif
        codeobj_4c6120df83a9dbf8ff1e54c044cc7f3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_183_getLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_183_getLoopBreakTarget,
        const_str_plain_getLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_6227df33b96fb24225f8e850bc7d5c6c,
#endif
        codeobj_cef9045d2b139705558e7cf485ca9fed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_184_setLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_184_setLoopBreakTarget,
        const_str_plain_setLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_ff09dec21711a14ba972c5c09dc0b08d,
#endif
        codeobj_18cf21dc66bd30fd6968cbd2e996eb14,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_185_getLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_185_getLoopContinueTarget,
        const_str_plain_getLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_e9b6d0895f57833457cbf9ab51367bb8,
#endif
        codeobj_0b8aff2b67bd850d7a94360575b83331,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_186_setLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_186_setLoopContinueTarget,
        const_str_plain_setLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_94d8409ce4a107d22339dc4807c738ed,
#endif
        codeobj_19d9a6aa5f8decfa87b27417a66f16d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_187_getTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_187_getTrueBranchTarget,
        const_str_plain_getTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_bd42d502b75375b7743b4f0e7e57275a,
#endif
        codeobj_c9da538500192f015102f0acb10bd9be,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_188_getFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_188_getFalseBranchTarget,
        const_str_plain_getFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_e8bf5486242e02fb6a0ece379cdbc2eb,
#endif
        codeobj_d7d44a047d7778e18ffd841c6272c8a7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_189_setTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_189_setTrueBranchTarget,
        const_str_plain_setTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_ad2f34e8e6f884bf5dc463a64a2860ac,
#endif
        codeobj_8e47898037383dd96d5f512fcc78d56c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_18_markAsNeedsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_18_markAsNeedsExceptionVariables,
        const_str_plain_markAsNeedsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_4f1b43ee1083d2d091afaee9410359a2,
#endif
        codeobj_481359ae921de5d7cd6a8e86fa6bab1d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_190_setFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_190_setFalseBranchTarget,
        const_str_plain_setFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_4ad35e0f2a19fb140fd91ad3f29da348,
#endif
        codeobj_b960f5882c5ec8c26d803081a724846d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_191_getFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_191_getFrameHandle,
        const_str_plain_getFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_f09cea3c42a5b06c37300a17fc8cc6c9,
#endif
        codeobj_207104a18d78f5ed6b253d8b4b459bfc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_192_pushFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_192_pushFrameHandle,
        const_str_plain_pushFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_9cf7759ec6f1caec3caa9daa738b0034,
#endif
        codeobj_1979d68cf3efafb6570219d9b631a4ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_193_popFrameHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_193_popFrameHandle,
        const_str_plain_popFrameHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_65ffc191fed0548aa882952f5e9c79f9,
#endif
        codeobj_0635b043d9d9da0611a172be20832e3c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_194_getExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_194_getExceptionKeeperVariables,
        const_str_plain_getExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_2cdb9fd17a48e31dd84ef597bf3b2f00,
#endif
        codeobj_21f739fea84c01208bf5eb23a1cf98c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_195_setExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_195_setExceptionKeeperVariables,
        const_str_plain_setExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_e886a7a5e26861ea3ac04b2519d56551,
#endif
        codeobj_e8c27ad0792b99a8ee8459e88b6a9011,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_196_setVariableType(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_196_setVariableType,
        const_str_plain_setVariableType,
#if PYTHON_VERSION >= 330
        const_str_digest_2968b90b27535ed2b21f551de0759d50,
#endif
        codeobj_87b218ddf91dac49519b4a8ec3f78958,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_197_getIntResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_197_getIntResName,
        const_str_plain_getIntResName,
#if PYTHON_VERSION >= 330
        const_str_digest_a7fb2ee40d1e8754e1b199d0a66ddbc5,
#endif
        codeobj_63608cdfddc117fbbbd31d7e1d31905d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_198_getBoolResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_198_getBoolResName,
        const_str_plain_getBoolResName,
#if PYTHON_VERSION >= 330
        const_str_digest_344fd1ad98611e569be84794445a3e7d,
#endif
        codeobj_3b679cd95e3a31562535f2691a8b80ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_199_needsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_199_needsExceptionVariables,
        const_str_plain_needsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_4cdb9bc00ce62e3ec47dc004a74507f3,
#endif
        codeobj_fd30e95d7240c9a202d3e86b9cc66759,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_19_allocateExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_19_allocateExceptionKeeperVariables,
        const_str_plain_allocateExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_b1b67715452f238441f19f172aeedfdd,
#endif
        codeobj_32e8717831f25acd24b268462c12b153,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_1___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_ab9b65d9f70dba202462db8cbd2bd3c4,
#endif
        codeobj_2206ecab54a182234641a463879cf13e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_200_markAsNeedsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_200_markAsNeedsExceptionVariables,
        const_str_plain_markAsNeedsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_36a950e7e63a9795ac03e8984bd01677,
#endif
        codeobj_b565aa4c14f8fadd1cc440ee24825913,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_201_allocateExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_201_allocateExceptionKeeperVariables,
        const_str_plain_allocateExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_a200173c4121e0bca2f471f7b42614e9,
#endif
        codeobj_e5debafd2ef2b4e74f48417bf9d35ade,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_202_addFrameDeclaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_202_addFrameDeclaration,
        const_str_plain_addFrameDeclaration,
#if PYTHON_VERSION >= 330
        const_str_digest_529a8ebf30aa338f0b011c2f8d4aab0b,
#endif
        codeobj_5db4abeaa8c0925e341eca632b344412,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_203_isForDirectCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_203_isForDirectCall,
        const_str_plain_isForDirectCall,
#if PYTHON_VERSION >= 330
        const_str_digest_b9654f9fe4b2af41c0086d216c9b3f57,
#endif
        codeobj_32d328860bd7a4295a84b2f4aee8dc2b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_204_mayRecurse(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_204_mayRecurse,
        const_str_plain_mayRecurse,
#if PYTHON_VERSION >= 330
        const_str_digest_c9f53fea3b1b946fc6f9ff2a3b44affd,
#endif
        codeobj_77c444ca8dca0610c5acf3f13bb1614a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_205_addLocalsDictName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_205_addLocalsDictName,
        const_str_plain_addLocalsDictName,
#if PYTHON_VERSION >= 330
        const_str_digest_3b82b1dd4c55cea38706e783ea34e248,
#endif
        codeobj_c032e014639a5201ab6ce13b4ab904b1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_206_addExceptionPreserverVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_206_addExceptionPreserverVariables,
        const_str_plain_addExceptionPreserverVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_1f833ba5473a81e2daec7c57c48cde0b,
#endif
        codeobj_3ea37739a94a8673680bdc0143fe787d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_207_getTempNameInfos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_207_getTempNameInfos,
        const_str_plain_getTempNameInfos,
#if PYTHON_VERSION >= 330
        const_str_digest_ce62965fd8eb5174bb4ca85b681bd0fc,
#endif
        codeobj_44eb22fce37e611bb4f0e50131926be1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_208_forgetTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_208_forgetTempName,
        const_str_plain_forgetTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_fb36bd46add94916696032032156928f,
#endif
        codeobj_63fe25d792e86d16301c9159503968b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_209_getContextObjectName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_209_getContextObjectName,
        const_str_plain_getContextObjectName,
#if PYTHON_VERSION >= 330
        const_str_digest_8d018b496b63fe3ca6c82d304f622d94,
#endif
        codeobj_e34dd389195b9b5d05ef8e27ef774772,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_20_getKeeperVariableCount(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_20_getKeeperVariableCount,
        const_str_plain_getKeeperVariableCount,
#if PYTHON_VERSION >= 330
        const_str_digest_d992b89f73bdb30671cdd8edd12f6005,
#endif
        codeobj_8f30b9d54479a733f44d394bf922d625,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_21_getExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_21_getExceptionKeeperVariables,
        const_str_plain_getExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_cfe6611d3194e04523d0733e7593071e,
#endif
        codeobj_c8d2336e16342fea05bbf0081149a358,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_22_setExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_22_setExceptionKeeperVariables,
        const_str_plain_setExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_7f297503a366843318e0255757663358,
#endif
        codeobj_02944e336bec971fc1e13809d923d826,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_23_getExceptionPreserverCounts(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_23_getExceptionPreserverCounts,
        const_str_plain_getExceptionPreserverCounts,
#if PYTHON_VERSION >= 330
        const_str_digest_54303a084c426f43301b7773090a790e,
#endif
        codeobj_0dffe05d8b6ce6b1c521696575d86a6e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_24_addExceptionPreserverVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_24_addExceptionPreserverVariables,
        const_str_plain_addExceptionPreserverVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_bf3bf38031c4163919d18c1364869e43,
#endif
        codeobj_0d6215760e5a9758515b53993f3d3c33,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_25_getTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_25_getTrueBranchTarget,
        const_str_plain_getTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_356c04499a5502c401c8fb4a5ef9e7f5,
#endif
        codeobj_3d90a84f25de934ac6d35312780bedee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_26_getFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_26_getFalseBranchTarget,
        const_str_plain_getFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_527ad68d726ffc2da2a6cfbd7aa23f42,
#endif
        codeobj_d54eb5ba5893d1ae05af5148e04a0656,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_27_setTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_27_setTrueBranchTarget,
        const_str_plain_setTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_948f61cf32e45d9aca768fd3a5bfde91,
#endif
        codeobj_f2e1337788de1cc3038b91d47ad9bb11,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_28_setFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_28_setFalseBranchTarget,
        const_str_plain_setFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_a49b3c30821d06d66b6b814c5228652e,
#endif
        codeobj_39aa69e44c2541146519c4855420db06,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_29_getCleanupTempnames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_29_getCleanupTempnames,
        const_str_plain_getCleanupTempnames,
#if PYTHON_VERSION >= 330
        const_str_digest_26f09ed9652d19fa65c7c2f38edc645f,
#endif
        codeobj_c7c67814bd691dfa70eb9aac797832b3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_2_formatTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_2_formatTempName,
        const_str_plain_formatTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_6377357bbc333a753ef615877cb70488,
#endif
        codeobj_41dcb69da7bdde8dd50557005a6d275e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_30_addCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_30_addCleanupTempName,
        const_str_plain_addCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_62a779267620479a42cca70c1212f7e4,
#endif
        codeobj_7eaad5cd6e9a3020f306eeeaadae319e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_31_removeCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_31_removeCleanupTempName,
        const_str_plain_removeCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_c253fc25926306e22a98281af8f9629a,
#endif
        codeobj_880b697f323251673cdcbabbac586b78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_32_needsCleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_32_needsCleanup,
        const_str_plain_needsCleanup,
#if PYTHON_VERSION >= 330
        const_str_digest_f0f79a5f9bfcf0fbb0c0effa9839520d,
#endif
        codeobj_60f4102fc3fe690ec05ebdd92da25085,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_33_pushCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_33_pushCleanupScope,
        const_str_plain_pushCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_ab07390ab07a9b5d7f2fc01935b20975,
#endif
        codeobj_f3b1d16b097f5d8492f39777ee3e5e98,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_34_popCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_34_popCleanupScope,
        const_str_plain_popCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_23422f93eb40a66425e75e64a3122a5e,
#endif
        codeobj_b278eb993f98bbc79fe6a60b92219ea8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_35___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_35___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_aeff4a5a9b47578a597233dc0f53d668,
#endif
        codeobj_1c666778cb70d20ac1d70782a03d8dbf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_36_getCodeObjects(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_36_getCodeObjects,
        const_str_plain_getCodeObjects,
#if PYTHON_VERSION >= 330
        const_str_digest_a17c2210ab6063e2443b17d15f0b7260,
#endif
        codeobj_fae54a9f06e0ed034c5de9b4ee7af97d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_37_getCodeObjectHandle(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_37_getCodeObjectHandle,
        const_str_plain_getCodeObjectHandle,
#if PYTHON_VERSION >= 330
        const_str_digest_10f90d9735fc507eae60ede4611ac1d5,
#endif
        codeobj_0d7b531e9016f557c16c8d652d9e7c59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_38__calcHash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_38__calcHash,
        const_str_plain__calcHash,
#if PYTHON_VERSION >= 330
        const_str_digest_8687966f175199d40968e4bfcf00bb4c,
#endif
        codeobj_e3c6e6d8bb7af7f501ea790a81f35acc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_39__calcHash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_39__calcHash,
        const_str_plain__calcHash,
#if PYTHON_VERSION >= 330
        const_str_digest_8687966f175199d40968e4bfcf00bb4c,
#endif
        codeobj_613a6bbb05a901dd8b334f4a997d5bc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_3_allocateTempName( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_3_allocateTempName,
        const_str_plain_allocateTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_c4ea70fe255da0d8650740590bc33b6f,
#endif
        codeobj_976dcc88b248a86fafc0bfcdfb26be3c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_40___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_40___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_29b780647c5454d52d6cc5ed97d4403c,
#endif
        codeobj_6616b03b6b092083572f0278ce78197f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_41_getCurrentSourceCodeReference(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_41_getCurrentSourceCodeReference,
        const_str_plain_getCurrentSourceCodeReference,
#if PYTHON_VERSION >= 330
        const_str_digest_fdc08637b74d20da15803737e5e9a07c,
#endif
        codeobj_246089cfed5fbe1fdb5587fa09925e84,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_42_setCurrentSourceCodeReference(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_42_setCurrentSourceCodeReference,
        const_str_plain_setCurrentSourceCodeReference,
#if PYTHON_VERSION >= 330
        const_str_digest_7dd74e6bd6d631103aa06d4fc73f4f11,
#endif
        codeobj_9cfed625fb66042ae350c88c741f7122,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_43_getLastSourceCodeReference(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_43_getLastSourceCodeReference,
        const_str_plain_getLastSourceCodeReference,
#if PYTHON_VERSION >= 330
        const_str_digest_382755dd9d7429a7072e416d429886f5,
#endif
        codeobj_1dc5c3c7f783016616c31176f5a18b1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_44_isUsed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_44_isUsed,
        const_str_plain_isUsed,
#if PYTHON_VERSION >= 330
        const_str_digest_f20acdafb2f595d6a6bd02e1596c02db,
#endif
        codeobj_d4fc9340eeaa4816566dd22c485b1649,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_45_getConstantCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_45_getConstantCode,
        const_str_plain_getConstantCode,
#if PYTHON_VERSION >= 330
        const_str_digest_de692aaf1a39dcc9add5cafcc90e7d3a,
#endif
        codeobj_a21b52799fd40d6cddeda3aff6401c83,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_46_getModuleCodeName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_46_getModuleCodeName,
        const_str_plain_getModuleCodeName,
#if PYTHON_VERSION >= 330
        const_str_digest_089ed70ff710455be48c44c3e522dd31,
#endif
        codeobj_7cf25d12e8eafbe4cc9261e4240505c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_47_getModuleName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_47_getModuleName,
        const_str_plain_getModuleName,
#if PYTHON_VERSION >= 330
        const_str_digest_36e53050e5752dd8dad8ca08da219dfc,
#endif
        codeobj_10153a387e306c78fb2c8f8c19993ab4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_48_addHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_48_addHelperCode,
        const_str_plain_addHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_bbc23540b36b5266f6535cbbe7b3e01d,
#endif
        codeobj_a8e8f43fad7d6a884e735dcde5ecdc85,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_49_hasHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_49_hasHelperCode,
        const_str_plain_hasHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_d3171e1be7daa27a0a9a18c82d0cadf6,
#endif
        codeobj_99cfb1922f7d39cea221a50095787761,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_4_getIntResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_4_getIntResName,
        const_str_plain_getIntResName,
#if PYTHON_VERSION >= 330
        const_str_digest_6ad77fd10d0c3b52171d2c1538e49ff8,
#endif
        codeobj_2897788a6282b03b8e14bfd7bf173c6c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_50_addDeclaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_50_addDeclaration,
        const_str_plain_addDeclaration,
#if PYTHON_VERSION >= 330
        const_str_digest_407dc23619580f584d7efe59a675c107,
#endif
        codeobj_93e628b68fd76d7a819dc42f0e39ccca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_51_pushFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_51_pushFrameVariables,
        const_str_plain_pushFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_a2cb47e4aa86836d571e4f1abc9bd3ea,
#endif
        codeobj_faf0faf3e3ec0767046b0fd2c7d2d995,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_52_popFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_52_popFrameVariables,
        const_str_plain_popFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_a4094bb766fe1066b2a681c4d9db5b2b,
#endif
        codeobj_8b7e56d94d9f72d48d449f61dca25c56,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions,
        const_str_plain_getFrameVariableTypeDescriptions,
#if PYTHON_VERSION >= 330
        const_str_digest_a3518bcf72de4035e2f10a911a38232c,
#endif
        codeobj_5873edf1802cd7b348b13d18cd21bd1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_54_getFrameVariableTypeDescription(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_54_getFrameVariableTypeDescription,
        const_str_plain_getFrameVariableTypeDescription,
#if PYTHON_VERSION >= 330
        const_str_digest_43f4366fb3942122b01fe9566b3de6f4,
#endif
        codeobj_16516945308d0a5395abe7708ab9ebb3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName,
        const_str_plain_getFrameVariableTypeDescriptionName,
#if PYTHON_VERSION >= 330
        const_str_digest_7ac96968a40e4b5f6dac1f4c9846a3ae,
#endif
        codeobj_28b5f5dfc9237b6e4c4c44c7cd214134,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_56_getFrameVariableCodeNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_56_getFrameVariableCodeNames,
        const_str_plain_getFrameVariableCodeNames,
#if PYTHON_VERSION >= 330
        const_str_digest_d034c43e11db00db602a81ced8fe964c,
#endif
        codeobj_a2f3e46eb4b8fab13824777627e278b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_57_allocateTempName( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_57_allocateTempName,
        const_str_plain_allocateTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_c70c81be0ee8686f88d0465dd01790d6,
#endif
        codeobj_18eac65d2d920f5f38b85e7f4ef610c7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_58_getIntResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_58_getIntResName,
        const_str_plain_getIntResName,
#if PYTHON_VERSION >= 330
        const_str_digest_ebe63b9b9d5ee0fb95a863e8a24bec5d,
#endif
        codeobj_aacc4e70971f38d612ad85ce26f10578,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_59_getBoolResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_59_getBoolResName,
        const_str_plain_getBoolResName,
#if PYTHON_VERSION >= 330
        const_str_digest_579f388010d12808b3eae0ac3161d269,
#endif
        codeobj_005a5c350706bb96d64cf7bfa995f5a7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_5_getBoolResName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_5_getBoolResName,
        const_str_plain_getBoolResName,
#if PYTHON_VERSION >= 330
        const_str_digest_e2fbdb696fac361cce9168658dbd2fc0,
#endif
        codeobj_fa6abd275388513d61e5b9c564027913,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_60_hasTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_60_hasTempName,
        const_str_plain_hasTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_78cb172fc37668311c09cddf0accd2d3,
#endif
        codeobj_5aced0946905314d67dc30b7cc4ba622,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_61_forgetTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_61_forgetTempName,
        const_str_plain_forgetTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_de6b1851ed9396300170bea9bd415e26,
#endif
        codeobj_510e6c497cbb49b08de7170063f94e4e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_62_getTempNameInfos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_62_getTempNameInfos,
        const_str_plain_getTempNameInfos,
#if PYTHON_VERSION >= 330
        const_str_digest_451683d32f1c59cad00789bc67c1d0fb,
#endif
        codeobj_48364e2a74d45ea733ddce4841f7fd1c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_63_getExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_63_getExceptionEscape,
        const_str_plain_getExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_aa8ecf91a23ffc01605bd0dbabd23bf4,
#endif
        codeobj_12167aea291207bc873ca5cc89cf807a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_64_setExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_64_setExceptionEscape,
        const_str_plain_setExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_c61cd5e57bbff781c7524c02fd1b3960,
#endif
        codeobj_724fba5810b7acf38fda1cc2f0b5c1e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_65_getLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_65_getLoopBreakTarget,
        const_str_plain_getLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_ef8f2e417acf45e2ce4f92f1b6f7c606,
#endif
        codeobj_e3bfb88b743c357810841524ae9a785b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_66_setLoopBreakTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_66_setLoopBreakTarget,
        const_str_plain_setLoopBreakTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_64923e0a83c0602664a31786d52a3e9d,
#endif
        codeobj_8a73adcf3cfe40ef45962ca8da9ad7b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_67_getLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_67_getLoopContinueTarget,
        const_str_plain_getLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_b0f2c883e4b2f3dc22cf5e95533a896c,
#endif
        codeobj_91c274ed8c779e361411af5e2a005341,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_68_setLoopContinueTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_68_setLoopContinueTarget,
        const_str_plain_setLoopContinueTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_3665173bc809a481f388f61ffa1b1bc1,
#endif
        codeobj_c57ff65d7609b04f11302060074276cb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_69_allocateLabel(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_69_allocateLabel,
        const_str_plain_allocateLabel,
#if PYTHON_VERSION >= 330
        const_str_digest_003e4a56d94b5e8606e65634d347a2ac,
#endif
        codeobj_18531e2c3df21d06d06b3440746610a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_6_hasTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_6_hasTempName,
        const_str_plain_hasTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_b0d0a5ae888b485232848ed0dd46de83,
#endif
        codeobj_cb055aa1fed9fd9bd4ae8d63750c7904,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_70_needsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_70_needsExceptionVariables,
        const_str_plain_needsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_e36decde46776641c89c99776519f544,
#endif
        codeobj_6ff4954f4c5834ba3a15403825cd3927,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_71_markAsNeedsExceptionVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_71_markAsNeedsExceptionVariables,
        const_str_plain_markAsNeedsExceptionVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_c0705a6cb9a01b5867fb8ce51e6e5e3b,
#endif
        codeobj_73a198267b8f72d47574b1f82e0719e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_72_allocateExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_72_allocateExceptionKeeperVariables,
        const_str_plain_allocateExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_c3d9479ee0697667cc53d6362864ca27,
#endif
        codeobj_aa625e5bde3b7485c41350c37ff67f2a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_73_getExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_73_getExceptionKeeperVariables,
        const_str_plain_getExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_651cc9fe74c654590f332f38cd72ffbe,
#endif
        codeobj_10f7bdb9ae2bc054a9c0c263ad83cc9a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_74_setExceptionKeeperVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_74_setExceptionKeeperVariables,
        const_str_plain_setExceptionKeeperVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_28e7af115baddb2a003debb0f477c4f1,
#endif
        codeobj_af763aa9b8f7990b27f16cc4e3308fdf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_75_addExceptionPreserverVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_75_addExceptionPreserverVariables,
        const_str_plain_addExceptionPreserverVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_4294787ad1c872e007fe67a2ec41f784,
#endif
        codeobj_48f8ffbaefbbfeea20a2a0e4cbdf97f6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_76_getTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_76_getTrueBranchTarget,
        const_str_plain_getTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_008caa6a1952819819f4e87b68280429,
#endif
        codeobj_c180803f2ed4cac44b4083fd3f86f6a5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_77_getFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_77_getFalseBranchTarget,
        const_str_plain_getFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_b1e60ea9ee7c3a8a50cd2755a17a5fe8,
#endif
        codeobj_d1388dd4214b2fc52f21d3b0d26f5934,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_78_setTrueBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_78_setTrueBranchTarget,
        const_str_plain_setTrueBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_0a9b4312244332263552dac3b72c914a,
#endif
        codeobj_4c820eb09910985e593218325029b18a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_79_setFalseBranchTarget(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_79_setFalseBranchTarget,
        const_str_plain_setFalseBranchTarget,
#if PYTHON_VERSION >= 330
        const_str_digest_1756d814b178aaae17abac3163d1a7e0,
#endif
        codeobj_27ec5ae7c651087046c1d05725307a23,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_7_forgetTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_7_forgetTempName,
        const_str_plain_forgetTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_1fa86cd2988d8c8a3034058c84b34c7c,
#endif
        codeobj_7258131e4814e657599d76c2db3de494,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_80_getCleanupTempnames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_80_getCleanupTempnames,
        const_str_plain_getCleanupTempnames,
#if PYTHON_VERSION >= 330
        const_str_digest_cfe69f84a1d3c34e08be1062e3949702,
#endif
        codeobj_5ad6fde19e8b5c9b68323260584b0de7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_81_addCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_81_addCleanupTempName,
        const_str_plain_addCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_67ca7d3d1f9da51471c81acdf3cc1989,
#endif
        codeobj_400a54fbda0b9175da9ab7297c4d8602,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_82_removeCleanupTempName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_82_removeCleanupTempName,
        const_str_plain_removeCleanupTempName,
#if PYTHON_VERSION >= 330
        const_str_digest_a2b1038979e363452b40a33002fa30b8,
#endif
        codeobj_6c45637dccab2f4fca178cc695aa3ea3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_83_needsCleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_83_needsCleanup,
        const_str_plain_needsCleanup,
#if PYTHON_VERSION >= 330
        const_str_digest_bb940c7f0f9217bc32eb90e6a338a738,
#endif
        codeobj_88e960102132df69b1bf74e42693142a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_84_pushCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_84_pushCleanupScope,
        const_str_plain_pushCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_b1a8cbbad04e282a28abd95e9224b578,
#endif
        codeobj_45d881e87ed34ede0a5375de19ee372a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_85_popCleanupScope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_85_popCleanupScope,
        const_str_plain_popCleanupScope,
#if PYTHON_VERSION >= 330
        const_str_digest_f970dec118dd032743ada440a4958864,
#endif
        codeobj_9e0a9ab898ad06ae88ce9151dade15d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_86___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_86___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_391e3f0d62b69d6a83d92e9ff1a571c6,
#endif
        codeobj_ff8880cfcc099c1b7f4d600a34e00055,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_87_getConstantCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_87_getConstantCode,
        const_str_plain_getConstantCode,
#if PYTHON_VERSION >= 330
        const_str_digest_c0326b9017891a796a85e065305d0ced,
#endif
        codeobj_d4a852c96da0e1bef940ac0123a460db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_88_getModuleCodeName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_88_getModuleCodeName,
        const_str_plain_getModuleCodeName,
#if PYTHON_VERSION >= 330
        const_str_digest_1fdbba2cfe613b198992c1895f52f6fb,
#endif
        codeobj_6a911389a85e2285f16b7e383cb2cc90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_89_getModuleName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_89_getModuleName,
        const_str_plain_getModuleName,
#if PYTHON_VERSION >= 330
        const_str_digest_30b0a365467fd86233ade42cedd7d4ef,
#endif
        codeobj_52265f0f9c5f7a05f5e1456e052b9e62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_8_getTempNameInfos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_8_getTempNameInfos,
        const_str_plain_getTempNameInfos,
#if PYTHON_VERSION >= 330
        const_str_digest_9f94c79a242f7988d834ffc98aa9eeb0,
#endif
        codeobj_c4f76c9457a95c8629cda68ea00fbd20,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_90_addHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_90_addHelperCode,
        const_str_plain_addHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_694c746215c69a034048b506a36cf7bf,
#endif
        codeobj_3ee379237e2305259cec4dab3e46caf3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_91_hasHelperCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_91_hasHelperCode,
        const_str_plain_hasHelperCode,
#if PYTHON_VERSION >= 330
        const_str_digest_9b3d45c97ffe4b9a67c136fb1c0d39c4,
#endif
        codeobj_effca39acf7537335eca7e16bd4108b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_92_addDeclaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_92_addDeclaration,
        const_str_plain_addDeclaration,
#if PYTHON_VERSION >= 330
        const_str_digest_7f0e64884a17d062eb6c8fc5669b4e09,
#endif
        codeobj_e0086fb7b6654192c83c3e220cf1b3aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_93_pushFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_93_pushFrameVariables,
        const_str_plain_pushFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_ed3da1d877103f471e67483c8b8f3267,
#endif
        codeobj_27b8f23b5afbde7937db11a3c1152e92,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_94_popFrameVariables(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_94_popFrameVariables,
        const_str_plain_popFrameVariables,
#if PYTHON_VERSION >= 330
        const_str_digest_bceddc19e3682969185c76cf95bc10d9,
#endif
        codeobj_02dfe0aee0348ef048c777d56d4a31b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions,
        const_str_plain_getFrameVariableTypeDescriptions,
#if PYTHON_VERSION >= 330
        const_str_digest_3be2622e090e0211db0e458055823ae8,
#endif
        codeobj_a8d22b33c3f6a04ca0441835b99858b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_96_getFrameVariableTypeDescription(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_96_getFrameVariableTypeDescription,
        const_str_plain_getFrameVariableTypeDescription,
#if PYTHON_VERSION >= 330
        const_str_digest_b05f079ee69fdf65b9326bf63aac023f,
#endif
        codeobj_8d42c686e4a517ffb33aa31922634976,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName,
        const_str_plain_getFrameVariableTypeDescriptionName,
#if PYTHON_VERSION >= 330
        const_str_digest_a9231837b104419978dcb04752802324,
#endif
        codeobj_9789c7a9a1b96341f824bcd892fd6fc8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_98_getFrameVariableCodeNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_98_getFrameVariableCodeNames,
        const_str_plain_getFrameVariableCodeNames,
#if PYTHON_VERSION >= 330
        const_str_digest_802fc6c27e355cb87c4659dfc7643939,
#endif
        codeobj_90e7eac2a5f70c5cb1e6755566df31af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_99__getConstantDefaultPopulation(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_99__getConstantDefaultPopulation,
        const_str_plain__getConstantDefaultPopulation,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_85e21af2194bee806e06cec22bd6a1aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_codegen$Contexts$$$function_9_getExceptionEscape(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_codegen$Contexts$$$function_9_getExceptionEscape,
        const_str_plain_getExceptionEscape,
#if PYTHON_VERSION >= 330
        const_str_digest_31d729e30f99251b4a1e18bea892374b,
#endif
        codeobj_baccea888939a034905427023ae07b09,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_codegen$Contexts,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_codegen$Contexts =
{
    PyModuleDef_HEAD_INIT,
    "codegen.Contexts",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___spec__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( codegen$Contexts )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_codegen$Contexts );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("codegen.Contexts: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("codegen.Contexts: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("codegen.Contexts: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initcodegen$Contexts" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_codegen$Contexts = Py_InitModule4(
        "codegen.Contexts",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_codegen$Contexts = PyModule_Create( &mdef_codegen$Contexts );
#endif

    moduledict_codegen$Contexts = MODULE_DICT( module_codegen$Contexts );

    // Update "__package__" value to what it ought to be.
    {
#if 0
#if PYTHON_VERSION < 300 || PYTHON_VERSION >= 330
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_codegen$Contexts,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#endif

#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_codegen$Contexts,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#elif PYTHON_VERSION < 330
        UPDATE_STRING_DICT1(
            moduledict_codegen$Contexts,
            (Nuitka_StringObject *)const_str_plain___package__,
            Py_None
        );
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_codegen$Contexts,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_codegen$Contexts );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2, module_codegen$Contexts );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 330
    UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___loader__, metapath_based_loader );
#endif

#if PYTHON_VERSION >= 340
#if 0
    UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___name__ ),
            metapath_based_loader
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );

        UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );

        Py_DECREF( module_spec_class );
    }
#endif
#endif


    // Temp variables if any
    PyObject *outline_0_var___class__ = NULL;
    PyObject *outline_1_var___class__ = NULL;
    PyObject *outline_2_var___class__ = NULL;
    PyObject *outline_3_var___class__ = NULL;
    PyObject *outline_4_var___class__ = NULL;
    PyObject *outline_5_var___class__ = NULL;
    PyObject *outline_6_var___class__ = NULL;
    PyObject *outline_7_var___class__ = NULL;
    PyObject *outline_8_var___class__ = NULL;
    PyObject *outline_9_var___class__ = NULL;
    PyObject *outline_10_var___class__ = NULL;
    PyObject *outline_11_var___class__ = NULL;
    PyObject *outline_12_var___class__ = NULL;
    PyObject *outline_13_var___class__ = NULL;
    PyObject *outline_14_var___class__ = NULL;
    PyObject *outline_15_var___class__ = NULL;
    PyObject *outline_16_var___class__ = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class_decl_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_10__prepared = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class_decl_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_11__prepared = NULL;
    PyObject *tmp_class_creation_12__bases = NULL;
    PyObject *tmp_class_creation_12__class_decl_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_12__prepared = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__class_decl_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_13__prepared = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__class_decl_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_14__prepared = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__class_decl_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_15__prepared = NULL;
    PyObject *tmp_class_creation_16__bases = NULL;
    PyObject *tmp_class_creation_16__class_decl_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_16__prepared = NULL;
    PyObject *tmp_class_creation_17__bases = NULL;
    PyObject *tmp_class_creation_17__class_decl_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_17__prepared = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__prepared = NULL;
    PyObject *tmp_class_creation_2__class_decl_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__prepared = NULL;
    PyObject *tmp_class_creation_3__class_decl_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_3__prepared = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class_decl_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_4__prepared = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class_decl_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_5__prepared = NULL;
    PyObject *tmp_class_creation_6__class_decl_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_6__prepared = NULL;
    PyObject *tmp_class_creation_7__class_decl_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_7__prepared = NULL;
    PyObject *tmp_class_creation_8__class_decl_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_8__prepared = NULL;
    PyObject *tmp_class_creation_9__class_decl_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_class_creation_9__prepared = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;
    PyObject *exception_keeper_type_39;
    PyObject *exception_keeper_value_39;
    PyTracebackObject *exception_keeper_tb_39;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_39;
    PyObject *exception_keeper_type_40;
    PyObject *exception_keeper_value_40;
    PyTracebackObject *exception_keeper_tb_40;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_40;
    PyObject *exception_keeper_type_41;
    PyObject *exception_keeper_value_41;
    PyTracebackObject *exception_keeper_tb_41;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_41;
    PyObject *exception_keeper_type_42;
    PyObject *exception_keeper_value_42;
    PyTracebackObject *exception_keeper_tb_42;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_42;
    PyObject *exception_keeper_type_43;
    PyObject *exception_keeper_value_43;
    PyTracebackObject *exception_keeper_tb_43;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_43;
    PyObject *exception_keeper_type_44;
    PyObject *exception_keeper_value_44;
    PyTracebackObject *exception_keeper_tb_44;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_44;
    PyObject *exception_keeper_type_45;
    PyObject *exception_keeper_value_45;
    PyTracebackObject *exception_keeper_tb_45;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_45;
    PyObject *exception_keeper_type_46;
    PyObject *exception_keeper_value_46;
    PyTracebackObject *exception_keeper_tb_46;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_46;
    PyObject *exception_keeper_type_47;
    PyObject *exception_keeper_value_47;
    PyTracebackObject *exception_keeper_tb_47;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_47;
    PyObject *exception_keeper_type_48;
    PyObject *exception_keeper_value_48;
    PyTracebackObject *exception_keeper_tb_48;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_48;
    PyObject *exception_keeper_type_49;
    PyObject *exception_keeper_value_49;
    PyTracebackObject *exception_keeper_tb_49;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_49;
    PyObject *exception_keeper_type_50;
    PyObject *exception_keeper_value_50;
    PyTracebackObject *exception_keeper_tb_50;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_50;
    PyObject *exception_keeper_type_51;
    PyObject *exception_keeper_value_51;
    PyTracebackObject *exception_keeper_tb_51;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_51;
    PyObject *exception_keeper_type_52;
    PyObject *exception_keeper_value_52;
    PyTracebackObject *exception_keeper_tb_52;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_52;
    PyObject *exception_keeper_type_53;
    PyObject *exception_keeper_value_53;
    PyTracebackObject *exception_keeper_tb_53;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_53;
    PyObject *exception_keeper_type_54;
    PyObject *exception_keeper_value_54;
    PyTracebackObject *exception_keeper_tb_54;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_54;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_args_name_3;
    PyObject *tmp_args_name_4;
    PyObject *tmp_args_name_5;
    PyObject *tmp_args_name_6;
    PyObject *tmp_args_name_7;
    PyObject *tmp_args_name_8;
    PyObject *tmp_args_name_9;
    PyObject *tmp_args_name_10;
    PyObject *tmp_args_name_11;
    PyObject *tmp_args_name_12;
    PyObject *tmp_args_name_13;
    PyObject *tmp_args_name_14;
    PyObject *tmp_args_name_15;
    PyObject *tmp_args_name_16;
    PyObject *tmp_args_name_17;
    PyObject *tmp_args_name_18;
    PyObject *tmp_args_name_19;
    PyObject *tmp_args_name_20;
    PyObject *tmp_args_name_21;
    PyObject *tmp_args_name_22;
    PyObject *tmp_args_name_23;
    PyObject *tmp_args_name_24;
    PyObject *tmp_args_name_25;
    PyObject *tmp_args_name_26;
    PyObject *tmp_args_name_27;
    PyObject *tmp_args_name_28;
    PyObject *tmp_args_name_29;
    PyObject *tmp_args_name_30;
    PyObject *tmp_args_name_31;
    PyObject *tmp_args_name_32;
    PyObject *tmp_args_name_33;
    PyObject *tmp_args_name_34;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_assign_source_100;
    PyObject *tmp_assign_source_101;
    PyObject *tmp_assign_source_102;
    PyObject *tmp_assign_source_103;
    PyObject *tmp_assign_source_104;
    PyObject *tmp_assign_source_105;
    PyObject *tmp_assign_source_106;
    PyObject *tmp_assign_source_107;
    PyObject *tmp_assign_source_108;
    PyObject *tmp_assign_source_109;
    PyObject *tmp_assign_source_110;
    PyObject *tmp_assign_source_111;
    PyObject *tmp_assign_source_112;
    PyObject *tmp_assign_source_113;
    PyObject *tmp_assign_source_114;
    PyObject *tmp_assign_source_115;
    PyObject *tmp_assign_source_116;
    PyObject *tmp_assign_source_117;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_bases_name_2;
    PyObject *tmp_bases_name_3;
    PyObject *tmp_bases_name_4;
    PyObject *tmp_bases_name_5;
    PyObject *tmp_bases_name_6;
    PyObject *tmp_bases_name_7;
    PyObject *tmp_bases_name_8;
    PyObject *tmp_bases_name_9;
    PyObject *tmp_bases_name_10;
    PyObject *tmp_bases_name_11;
    PyObject *tmp_bases_name_12;
    PyObject *tmp_bases_name_13;
    PyObject *tmp_bases_name_14;
    PyObject *tmp_bases_name_15;
    PyObject *tmp_bases_name_16;
    PyObject *tmp_bases_name_17;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_call_arg_element_2;
    PyObject *tmp_call_arg_element_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_called_name_32;
    PyObject *tmp_called_name_33;
    PyObject *tmp_called_name_34;
    PyObject *tmp_called_name_35;
    PyObject *tmp_called_name_36;
    PyObject *tmp_called_name_37;
    PyObject *tmp_called_name_38;
    PyObject *tmp_called_name_39;
    PyObject *tmp_called_name_40;
    PyObject *tmp_called_name_41;
    PyObject *tmp_called_name_42;
    PyObject *tmp_called_name_43;
    PyObject *tmp_called_name_44;
    PyObject *tmp_called_name_45;
    PyObject *tmp_called_name_46;
    PyObject *tmp_called_name_47;
    PyObject *tmp_called_name_48;
    PyObject *tmp_called_name_49;
    PyObject *tmp_called_name_50;
    PyObject *tmp_called_name_51;
    PyObject *tmp_called_name_52;
    PyObject *tmp_called_name_53;
    PyObject *tmp_called_name_54;
    PyObject *tmp_called_name_55;
    PyObject *tmp_called_name_56;
    PyObject *tmp_called_name_57;
    PyObject *tmp_called_name_58;
    PyObject *tmp_called_name_59;
    PyObject *tmp_called_name_60;
    PyObject *tmp_called_name_61;
    PyObject *tmp_called_name_62;
    PyObject *tmp_called_name_63;
    PyObject *tmp_called_name_64;
    PyObject *tmp_called_name_65;
    PyObject *tmp_called_name_66;
    PyObject *tmp_called_name_67;
    PyObject *tmp_called_name_68;
    PyObject *tmp_called_name_69;
    PyObject *tmp_called_name_70;
    PyObject *tmp_called_name_71;
    PyObject *tmp_called_name_72;
    PyObject *tmp_called_name_73;
    PyObject *tmp_called_name_74;
    PyObject *tmp_called_name_75;
    PyObject *tmp_called_name_76;
    PyObject *tmp_called_name_77;
    PyObject *tmp_called_name_78;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    int tmp_cond_truth_10;
    int tmp_cond_truth_11;
    int tmp_cond_truth_12;
    int tmp_cond_truth_13;
    int tmp_cond_truth_14;
    int tmp_cond_truth_15;
    int tmp_cond_truth_16;
    int tmp_cond_truth_17;
    int tmp_cond_truth_18;
    int tmp_cond_truth_19;
    int tmp_cond_truth_20;
    int tmp_cond_truth_21;
    int tmp_cond_truth_22;
    int tmp_cond_truth_23;
    int tmp_cond_truth_24;
    int tmp_cond_truth_25;
    int tmp_cond_truth_26;
    int tmp_cond_truth_27;
    int tmp_cond_truth_28;
    int tmp_cond_truth_29;
    int tmp_cond_truth_30;
    int tmp_cond_truth_31;
    int tmp_cond_truth_32;
    int tmp_cond_truth_33;
    int tmp_cond_truth_34;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_cond_value_10;
    PyObject *tmp_cond_value_11;
    PyObject *tmp_cond_value_12;
    PyObject *tmp_cond_value_13;
    PyObject *tmp_cond_value_14;
    PyObject *tmp_cond_value_15;
    PyObject *tmp_cond_value_16;
    PyObject *tmp_cond_value_17;
    PyObject *tmp_cond_value_18;
    PyObject *tmp_cond_value_19;
    PyObject *tmp_cond_value_20;
    PyObject *tmp_cond_value_21;
    PyObject *tmp_cond_value_22;
    PyObject *tmp_cond_value_23;
    PyObject *tmp_cond_value_24;
    PyObject *tmp_cond_value_25;
    PyObject *tmp_cond_value_26;
    PyObject *tmp_cond_value_27;
    PyObject *tmp_cond_value_28;
    PyObject *tmp_cond_value_29;
    PyObject *tmp_cond_value_30;
    PyObject *tmp_cond_value_31;
    PyObject *tmp_cond_value_32;
    PyObject *tmp_cond_value_33;
    PyObject *tmp_cond_value_34;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_name_3;
    PyObject *tmp_dict_name_4;
    PyObject *tmp_dict_name_5;
    PyObject *tmp_dict_name_6;
    PyObject *tmp_dict_name_7;
    PyObject *tmp_dict_name_8;
    PyObject *tmp_dict_name_9;
    PyObject *tmp_dict_name_10;
    PyObject *tmp_dict_name_11;
    PyObject *tmp_dict_name_12;
    PyObject *tmp_dict_name_13;
    PyObject *tmp_dict_name_14;
    PyObject *tmp_dict_name_15;
    PyObject *tmp_dict_name_16;
    PyObject *tmp_dict_name_17;
    PyObject *tmp_dict_name_18;
    PyObject *tmp_dict_name_19;
    PyObject *tmp_dict_name_20;
    PyObject *tmp_dict_name_21;
    PyObject *tmp_dict_name_22;
    PyObject *tmp_dict_name_23;
    PyObject *tmp_dict_name_24;
    PyObject *tmp_dict_name_25;
    PyObject *tmp_dict_name_26;
    PyObject *tmp_dict_name_27;
    PyObject *tmp_dict_name_28;
    PyObject *tmp_dict_name_29;
    PyObject *tmp_dict_name_30;
    PyObject *tmp_dict_name_31;
    PyObject *tmp_dict_name_32;
    PyObject *tmp_dict_name_33;
    PyObject *tmp_dict_name_34;
    PyObject *tmp_dict_name_35;
    PyObject *tmp_dict_name_36;
    PyObject *tmp_dict_name_37;
    PyObject *tmp_dict_name_38;
    PyObject *tmp_dict_name_39;
    PyObject *tmp_dict_name_40;
    PyObject *tmp_dict_name_41;
    PyObject *tmp_dict_name_42;
    PyObject *tmp_dict_name_43;
    PyObject *tmp_dict_name_44;
    PyObject *tmp_dict_name_45;
    PyObject *tmp_dict_name_46;
    PyObject *tmp_dict_name_47;
    PyObject *tmp_dict_name_48;
    PyObject *tmp_dict_name_49;
    PyObject *tmp_dict_name_50;
    PyObject *tmp_dict_name_51;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *tmp_dictset_value;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_fromlist_name_8;
    PyObject *tmp_fromlist_name_9;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_globals_name_8;
    PyObject *tmp_globals_name_9;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_attr_2;
    PyObject *tmp_hasattr_attr_3;
    PyObject *tmp_hasattr_attr_4;
    PyObject *tmp_hasattr_attr_5;
    PyObject *tmp_hasattr_attr_6;
    PyObject *tmp_hasattr_attr_7;
    PyObject *tmp_hasattr_attr_8;
    PyObject *tmp_hasattr_attr_9;
    PyObject *tmp_hasattr_attr_10;
    PyObject *tmp_hasattr_attr_11;
    PyObject *tmp_hasattr_attr_12;
    PyObject *tmp_hasattr_attr_13;
    PyObject *tmp_hasattr_attr_14;
    PyObject *tmp_hasattr_attr_15;
    PyObject *tmp_hasattr_attr_16;
    PyObject *tmp_hasattr_attr_17;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_hasattr_source_2;
    PyObject *tmp_hasattr_source_3;
    PyObject *tmp_hasattr_source_4;
    PyObject *tmp_hasattr_source_5;
    PyObject *tmp_hasattr_source_6;
    PyObject *tmp_hasattr_source_7;
    PyObject *tmp_hasattr_source_8;
    PyObject *tmp_hasattr_source_9;
    PyObject *tmp_hasattr_source_10;
    PyObject *tmp_hasattr_source_11;
    PyObject *tmp_hasattr_source_12;
    PyObject *tmp_hasattr_source_13;
    PyObject *tmp_hasattr_source_14;
    PyObject *tmp_hasattr_source_15;
    PyObject *tmp_hasattr_source_16;
    PyObject *tmp_hasattr_source_17;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_import_name_from_10;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_key_name_3;
    PyObject *tmp_key_name_4;
    PyObject *tmp_key_name_5;
    PyObject *tmp_key_name_6;
    PyObject *tmp_key_name_7;
    PyObject *tmp_key_name_8;
    PyObject *tmp_key_name_9;
    PyObject *tmp_key_name_10;
    PyObject *tmp_key_name_11;
    PyObject *tmp_key_name_12;
    PyObject *tmp_key_name_13;
    PyObject *tmp_key_name_14;
    PyObject *tmp_key_name_15;
    PyObject *tmp_key_name_16;
    PyObject *tmp_key_name_17;
    PyObject *tmp_key_name_18;
    PyObject *tmp_key_name_19;
    PyObject *tmp_key_name_20;
    PyObject *tmp_key_name_21;
    PyObject *tmp_key_name_22;
    PyObject *tmp_key_name_23;
    PyObject *tmp_key_name_24;
    PyObject *tmp_key_name_25;
    PyObject *tmp_key_name_26;
    PyObject *tmp_key_name_27;
    PyObject *tmp_key_name_28;
    PyObject *tmp_key_name_29;
    PyObject *tmp_key_name_30;
    PyObject *tmp_key_name_31;
    PyObject *tmp_key_name_32;
    PyObject *tmp_key_name_33;
    PyObject *tmp_key_name_34;
    PyObject *tmp_key_name_35;
    PyObject *tmp_key_name_36;
    PyObject *tmp_key_name_37;
    PyObject *tmp_key_name_38;
    PyObject *tmp_key_name_39;
    PyObject *tmp_key_name_40;
    PyObject *tmp_key_name_41;
    PyObject *tmp_key_name_42;
    PyObject *tmp_key_name_43;
    PyObject *tmp_key_name_44;
    PyObject *tmp_key_name_45;
    PyObject *tmp_key_name_46;
    PyObject *tmp_key_name_47;
    PyObject *tmp_key_name_48;
    PyObject *tmp_key_name_49;
    PyObject *tmp_key_name_50;
    PyObject *tmp_key_name_51;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_kw_name_4;
    PyObject *tmp_kw_name_5;
    PyObject *tmp_kw_name_6;
    PyObject *tmp_kw_name_7;
    PyObject *tmp_kw_name_8;
    PyObject *tmp_kw_name_9;
    PyObject *tmp_kw_name_10;
    PyObject *tmp_kw_name_11;
    PyObject *tmp_kw_name_12;
    PyObject *tmp_kw_name_13;
    PyObject *tmp_kw_name_14;
    PyObject *tmp_kw_name_15;
    PyObject *tmp_kw_name_16;
    PyObject *tmp_kw_name_17;
    PyObject *tmp_kw_name_18;
    PyObject *tmp_kw_name_19;
    PyObject *tmp_kw_name_20;
    PyObject *tmp_kw_name_21;
    PyObject *tmp_kw_name_22;
    PyObject *tmp_kw_name_23;
    PyObject *tmp_kw_name_24;
    PyObject *tmp_kw_name_25;
    PyObject *tmp_kw_name_26;
    PyObject *tmp_kw_name_27;
    PyObject *tmp_kw_name_28;
    PyObject *tmp_kw_name_29;
    PyObject *tmp_kw_name_30;
    PyObject *tmp_kw_name_31;
    PyObject *tmp_kw_name_32;
    PyObject *tmp_kw_name_33;
    PyObject *tmp_kw_name_34;
    PyObject *tmp_level_name_1;
    PyObject *tmp_level_name_2;
    PyObject *tmp_level_name_3;
    PyObject *tmp_level_name_4;
    PyObject *tmp_level_name_5;
    PyObject *tmp_level_name_6;
    PyObject *tmp_level_name_7;
    PyObject *tmp_level_name_8;
    PyObject *tmp_level_name_9;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_locals_name_8;
    PyObject *tmp_locals_name_9;
    PyObject *tmp_metaclass_name_1;
    PyObject *tmp_metaclass_name_2;
    PyObject *tmp_metaclass_name_3;
    PyObject *tmp_metaclass_name_4;
    PyObject *tmp_metaclass_name_5;
    PyObject *tmp_metaclass_name_6;
    PyObject *tmp_metaclass_name_7;
    PyObject *tmp_metaclass_name_8;
    PyObject *tmp_metaclass_name_9;
    PyObject *tmp_metaclass_name_10;
    PyObject *tmp_metaclass_name_11;
    PyObject *tmp_metaclass_name_12;
    PyObject *tmp_metaclass_name_13;
    PyObject *tmp_metaclass_name_14;
    PyObject *tmp_metaclass_name_15;
    PyObject *tmp_metaclass_name_16;
    PyObject *tmp_metaclass_name_17;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    PyObject *tmp_name_name_8;
    PyObject *tmp_name_name_9;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_outline_return_value_2;
    PyObject *tmp_outline_return_value_3;
    PyObject *tmp_outline_return_value_4;
    PyObject *tmp_outline_return_value_5;
    PyObject *tmp_outline_return_value_6;
    PyObject *tmp_outline_return_value_7;
    PyObject *tmp_outline_return_value_8;
    PyObject *tmp_outline_return_value_9;
    PyObject *tmp_outline_return_value_10;
    PyObject *tmp_outline_return_value_11;
    PyObject *tmp_outline_return_value_12;
    PyObject *tmp_outline_return_value_13;
    PyObject *tmp_outline_return_value_14;
    PyObject *tmp_outline_return_value_15;
    PyObject *tmp_outline_return_value_16;
    PyObject *tmp_outline_return_value_17;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_set_locals;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscribed_name_11;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_subscript_name_11;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyObject *tmp_tuple_element_9;
    PyObject *tmp_tuple_element_10;
    PyObject *tmp_tuple_element_11;
    PyObject *tmp_tuple_element_12;
    PyObject *tmp_tuple_element_13;
    PyObject *tmp_tuple_element_14;
    PyObject *tmp_tuple_element_15;
    PyObject *tmp_tuple_element_16;
    PyObject *tmp_tuple_element_17;
    PyObject *tmp_tuple_element_18;
    PyObject *tmp_tuple_element_19;
    PyObject *tmp_tuple_element_20;
    PyObject *tmp_tuple_element_21;
    PyObject *tmp_tuple_element_22;
    PyObject *tmp_tuple_element_23;
    PyObject *tmp_tuple_element_24;
    PyObject *tmp_tuple_element_25;
    PyObject *tmp_tuple_element_26;
    PyObject *tmp_tuple_element_27;
    PyObject *tmp_tuple_element_28;
    PyObject *tmp_tuple_element_29;
    PyObject *tmp_tuple_element_30;
    PyObject *tmp_tuple_element_31;
    PyObject *tmp_tuple_element_32;
    PyObject *tmp_tuple_element_33;
    PyObject *tmp_tuple_element_34;
    PyObject *tmp_tuple_element_35;
    PyObject *tmp_tuple_element_36;
    PyObject *tmp_tuple_element_37;
    PyObject *tmp_tuple_element_38;
    PyObject *tmp_tuple_element_39;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    PyObject *tmp_type_arg_3;
    PyObject *tmp_type_arg_4;
    PyObject *tmp_type_arg_5;
    PyObject *tmp_type_arg_6;
    PyObject *tmp_type_arg_7;
    PyObject *tmp_type_arg_8;
    PyObject *tmp_type_arg_9;
    PyObject *tmp_type_arg_10;
    PyObject *tmp_type_arg_11;
    static struct Nuitka_FrameObject *cache_frame_d04ebf6bd401874fd48b1c7091e8d919_2 = NULL;

    struct Nuitka_FrameObject *frame_d04ebf6bd401874fd48b1c7091e8d919_2;

    static struct Nuitka_FrameObject *cache_frame_e964a1438f89be085a632221056be03e_3 = NULL;

    struct Nuitka_FrameObject *frame_e964a1438f89be085a632221056be03e_3;

    static struct Nuitka_FrameObject *cache_frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 = NULL;

    struct Nuitka_FrameObject *frame_ce8dbbdab23e99501a4f8b8d0c44e890_4;

    static struct Nuitka_FrameObject *cache_frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 = NULL;

    struct Nuitka_FrameObject *frame_45c666bd5eb5ec6b1395dd9b61ec9933_5;

    static struct Nuitka_FrameObject *cache_frame_799ed93275cf11ee83e5b7ceb08f85d2_6 = NULL;

    struct Nuitka_FrameObject *frame_799ed93275cf11ee83e5b7ceb08f85d2_6;

    static struct Nuitka_FrameObject *cache_frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 = NULL;

    struct Nuitka_FrameObject *frame_40cf1bb35fdb9c8653d4a2c9734319c3_7;

    static struct Nuitka_FrameObject *cache_frame_6c7e42fc2655943f084285a0d2beca7a_8 = NULL;

    struct Nuitka_FrameObject *frame_6c7e42fc2655943f084285a0d2beca7a_8;

    static struct Nuitka_FrameObject *cache_frame_486b646812c00d76f05648102465b41b_9 = NULL;

    struct Nuitka_FrameObject *frame_486b646812c00d76f05648102465b41b_9;

    static struct Nuitka_FrameObject *cache_frame_fae641ec8eec5d068fe3d2c09c05647e_10 = NULL;

    struct Nuitka_FrameObject *frame_fae641ec8eec5d068fe3d2c09c05647e_10;

    static struct Nuitka_FrameObject *cache_frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 = NULL;

    struct Nuitka_FrameObject *frame_d392c7b9f3b90fb3dd6cdc42524742b3_11;

    static struct Nuitka_FrameObject *cache_frame_b594da56adba1a1498a3a92440907540_12 = NULL;

    struct Nuitka_FrameObject *frame_b594da56adba1a1498a3a92440907540_12;

    static struct Nuitka_FrameObject *cache_frame_3d3abe187d18270ac2a8ce626f258fc6_13 = NULL;

    struct Nuitka_FrameObject *frame_3d3abe187d18270ac2a8ce626f258fc6_13;

    static struct Nuitka_FrameObject *cache_frame_ab26b52d74ca01bee050b92a01449059_14 = NULL;

    struct Nuitka_FrameObject *frame_ab26b52d74ca01bee050b92a01449059_14;

    static struct Nuitka_FrameObject *cache_frame_421a1e46a9e9caad65d20098cf3f5960_15 = NULL;

    struct Nuitka_FrameObject *frame_421a1e46a9e9caad65d20098cf3f5960_15;

    static struct Nuitka_FrameObject *cache_frame_27fa39f491c05c261c623c66b96c4cc1_16 = NULL;

    struct Nuitka_FrameObject *frame_27fa39f491c05c261c623c66b96c4cc1_16;

    static struct Nuitka_FrameObject *cache_frame_b0a85f471c9ed507afddbbd59b8dec86_17 = NULL;

    struct Nuitka_FrameObject *frame_b0a85f471c9ed507afddbbd59b8dec86_17;

    struct Nuitka_FrameObject *frame_f4ce2351b00e0ce552f4c14d83c392e3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_12 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_13 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_14 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_15 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_16 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_17 = NULL;
    tmp_outline_return_value_1 = NULL;
    tmp_outline_return_value_2 = NULL;
    tmp_outline_return_value_3 = NULL;
    tmp_outline_return_value_4 = NULL;
    tmp_outline_return_value_5 = NULL;
    tmp_outline_return_value_6 = NULL;
    tmp_outline_return_value_7 = NULL;
    tmp_outline_return_value_8 = NULL;
    tmp_outline_return_value_9 = NULL;
    tmp_outline_return_value_10 = NULL;
    tmp_outline_return_value_11 = NULL;
    tmp_outline_return_value_12 = NULL;
    tmp_outline_return_value_13 = NULL;
    tmp_outline_return_value_14 = NULL;
    tmp_outline_return_value_15 = NULL;
    tmp_outline_return_value_16 = NULL;
    tmp_outline_return_value_17 = NULL;
    PyObject *locals_PythonModuleContext_968 = NULL;
    PyObject *locals_PythonCoroutineObjectContext_1154 = NULL;
    PyObject *locals_PythonFunctionContext_1073 = NULL;
    PyObject *locals_PythonGlobalContext_738 = NULL;
    PyObject *locals_PythonFunctionOutlineContext_1173 = NULL;
    PyObject *locals_ReturnValueNameMixin_950 = NULL;
    PyObject *locals_PythonGeneratorObjectContext_1126 = NULL;
    PyObject *locals_FrameDeclarationsMixin_823 = NULL;
    PyObject *locals_PythonFunctionDirectContext_1115 = NULL;
    PyObject *locals_PythonContextBase_312 = NULL;
    PyObject *locals_TempMixin_54 = NULL;
    PyObject *locals_PythonAsyncgenObjectContext_1159 = NULL;
    PyObject *locals_CodeObjectsMixin_266 = NULL;
    PyObject *locals_PythonFunctionCreatedContext_1164 = NULL;
    PyObject *locals_ContextMetaClass_39 = NULL;
    PyObject *locals_ReturnReleaseModeMixin_927 = NULL;
    PyObject *locals_PythonChildContextBase_511 = NULL;

    // Module code.
    tmp_assign_source_1 = const_str_digest_da77da2d11ac0ddda33bbdac37d07f77;
    UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = const_str_digest_125f5277815f5b7d7e6feb17e062156d;
    UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = Py_None;
    UPDATE_STRING_DICT0( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    // Frame without reuse.
    frame_f4ce2351b00e0ce552f4c14d83c392e3 = MAKE_MODULE_FRAME( codeobj_f4ce2351b00e0ce552f4c14d83c392e3, module_codegen$Contexts );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_f4ce2351b00e0ce552f4c14d83c392e3 );
    assert( Py_REFCNT( frame_f4ce2351b00e0ce552f4c14d83c392e3 ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_plain_hashlib;
    tmp_globals_name_1 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_level_name_1 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 22;
    tmp_assign_source_4 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_hashlib, tmp_assign_source_4 );
    tmp_name_name_2 = const_str_plain_sys;
    tmp_globals_name_2 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    tmp_level_name_2 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 23;
    tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
    assert( !(tmp_assign_source_5 == NULL) );
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_5 );
    tmp_name_name_3 = const_str_plain_abc;
    tmp_globals_name_3 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = const_tuple_str_plain_ABCMeta_str_plain_abstractmethod_tuple;
    tmp_level_name_3 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 24;
    tmp_assign_source_6 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_1__module == NULL );
    tmp_import_from_1__module = tmp_assign_source_6;

    // Tried code:
    tmp_import_name_from_1 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_1 );
    tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_ABCMeta );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ABCMeta, tmp_assign_source_7 );
    tmp_import_name_from_2 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_2 );
    tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_abstractmethod );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 24;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod, tmp_assign_source_8 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_4 = const_str_plain_Options;
    tmp_globals_name_4 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = Py_None;
    tmp_level_name_4 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 26;
    tmp_assign_source_9 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_Options, tmp_assign_source_9 );
    tmp_name_name_5 = const_str_plain___past__;
    tmp_globals_name_5 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = const_tuple_str_plain_iterItems_tuple;
    tmp_level_name_5 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 27;
    tmp_import_name_from_3 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_iterItems );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_iterItems, tmp_assign_source_10 );
    tmp_name_name_6 = const_str_plain_Builtins;
    tmp_globals_name_6 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_a77361b75a55275a61cd96f2f33a2e20_tuple;
    tmp_level_name_6 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 28;
    tmp_assign_source_11 = IMPORT_MODULE5( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_2__module == NULL );
    tmp_import_from_2__module = tmp_assign_source_11;

    // Tried code:
    tmp_import_name_from_4 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_4 );
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_builtin_anon_codes );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_anon_codes, tmp_assign_source_12 );
    tmp_import_name_from_5 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_5 );
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_builtin_anon_values );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_anon_values, tmp_assign_source_13 );
    tmp_import_name_from_6 = tmp_import_from_2__module;

    CHECK_OBJECT( tmp_import_name_from_6 );
    tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_builtin_exception_values_list );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_builtin_exception_values_list, tmp_assign_source_14 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    tmp_name_name_7 = const_str_plain_PythonVersions;
    tmp_globals_name_7 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = const_tuple_str_plain_python_version_tuple;
    tmp_level_name_7 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 33;
    tmp_import_name_from_7 = IMPORT_MODULE5( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7 );
    if ( tmp_import_name_from_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 33;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_python_version );
    Py_DECREF( tmp_import_name_from_7 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 33;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version, tmp_assign_source_15 );
    tmp_name_name_8 = const_str_digest_534defdde7328da4dd3495117f2acbaf;
    tmp_globals_name_8 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_8 = Py_None;
    tmp_fromlist_name_8 = const_tuple_str_plain_counted_del_str_plain_counted_init_tuple;
    tmp_level_name_8 = const_int_0;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 34;
    tmp_assign_source_16 = IMPORT_MODULE5( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8, tmp_level_name_8 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_3__module == NULL );
    tmp_import_from_3__module = tmp_assign_source_16;

    // Tried code:
    tmp_import_name_from_8 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_8 );
    tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_counted_del );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_counted_del, tmp_assign_source_17 );
    tmp_import_name_from_9 = tmp_import_from_3__module;

    CHECK_OBJECT( tmp_import_name_from_9 );
    tmp_assign_source_18 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_counted_init );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;

        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_counted_init, tmp_assign_source_18 );
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    tmp_name_name_9 = const_str_plain_Namify;
    tmp_globals_name_9 = (PyObject *)moduledict_codegen$Contexts;
    tmp_locals_name_9 = Py_None;
    tmp_fromlist_name_9 = const_tuple_str_plain_namifyConstant_tuple;
    tmp_level_name_9 = const_int_pos_1;
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 36;
    tmp_import_name_from_10 = IMPORT_MODULE5( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9, tmp_level_name_9 );
    if ( tmp_import_name_from_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 36;

        goto frame_exception_exit_1;
    }
    if ( PyModule_Check( tmp_import_name_from_10 ) )
    {
       tmp_assign_source_19 = IMPORT_NAME_OR_MODULE(
            tmp_import_name_from_10,
            (PyObject *)MODULE_DICT(tmp_import_name_from_10),
            const_str_plain_namifyConstant,
            const_int_pos_1
        );
    }
    else
    {
       tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_namifyConstant );
    }

    Py_DECREF( tmp_import_name_from_10 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 36;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_namifyConstant, tmp_assign_source_19 );
    // Tried code:
    tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ABCMeta );

    if (unlikely( tmp_tuple_element_1 == NULL ))
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ABCMeta );
    }

    if ( tmp_tuple_element_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ABCMeta" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 39;

        goto try_except_handler_4;
    }

    tmp_assign_source_20 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_20, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_20;

    tmp_assign_source_21 = PyDict_New();
    assert( tmp_class_creation_1__class_decl_dict == NULL );
    tmp_class_creation_1__class_decl_dict = tmp_assign_source_21;

    tmp_key_name_1 = const_str_plain_metaclass;
    tmp_dict_name_1 = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    tmp_cond_value_1 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_2 = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_2 );
    tmp_key_name_2 = const_str_plain_metaclass;
    tmp_metaclass_name_1 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_metaclass_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_1 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_type_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_type_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    tmp_metaclass_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    Py_DECREF( tmp_type_arg_1 );
    if ( tmp_metaclass_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    condexpr_end_1:;
    tmp_bases_name_1 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_bases_name_1 );
    tmp_assign_source_22 = SELECT_METACLASS( tmp_metaclass_name_1, tmp_bases_name_1 );
    Py_DECREF( tmp_metaclass_name_1 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_22;

    tmp_key_name_3 = const_str_plain_metaclass;
    tmp_dict_name_3 = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_3 );
    tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    tmp_cond_value_2 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_dictdel_dict = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    branch_no_1:;
    tmp_hasattr_source_1 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_1 );
    tmp_hasattr_attr_1 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_source_name_1 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___prepare__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    tmp_tuple_element_2 = const_str_plain_ContextMetaClass;
    tmp_args_name_1 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
    tmp_kw_name_1 = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_1 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 39;
    tmp_assign_source_23 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_4;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_assign_source_23 = PyDict_New();
    condexpr_end_2:;
    assert( tmp_class_creation_1__prepared == NULL );
    tmp_class_creation_1__prepared = tmp_assign_source_23;

    tmp_set_locals = tmp_class_creation_1__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_ContextMetaClass_39 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_ContextMetaClass_39, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_6;
    }
    tmp_dictset_value = const_str_plain_ContextMetaClass;
    tmp_res = PyObject_SetItem( locals_ContextMetaClass_39, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_6;
    }
    tmp_called_name_2 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_tuple_element_3 = const_str_plain_ContextMetaClass;
    tmp_args_name_2 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_3 );
    tmp_tuple_element_3 = locals_ContextMetaClass_39;
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_2, 2, tmp_tuple_element_3 );
    tmp_kw_name_2 = tmp_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_2 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 39;
    tmp_assign_source_25 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_args_name_2 );
    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;

        goto try_except_handler_6;
    }
    assert( outline_0_var___class__ == NULL );
    outline_0_var___class__ = tmp_assign_source_25;

    tmp_outline_return_value_1 = outline_0_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_6;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_6:;
    Py_DECREF( locals_ContextMetaClass_39 );
    locals_ContextMetaClass_39 = NULL;
    goto try_return_handler_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_ContextMetaClass_39 );
    locals_ContextMetaClass_39 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_5;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_5:;
    CHECK_OBJECT( (PyObject *)outline_0_var___class__ );
    Py_DECREF( outline_0_var___class__ );
    outline_0_var___class__ = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_1:;
    exception_lineno = 39;
    goto try_except_handler_4;
    outline_result_1:;
    tmp_assign_source_24 = tmp_outline_return_value_1;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ContextMetaClass, tmp_assign_source_24 );
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    Py_XDECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_decl_dict );
    Py_DECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__prepared );
    Py_DECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ContextMetaClass );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ContextMetaClass );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ContextMetaClass" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 45;

        goto frame_exception_exit_1;
    }

    tmp_call_arg_element_1 = const_str_plain_ContextMetaClassBase;
    tmp_call_arg_element_2 = const_tuple_type_object_tuple;
    tmp_call_arg_element_3 = PyDict_New();
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 45;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1, tmp_call_arg_element_2, tmp_call_arg_element_3 };
        tmp_assign_source_26 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_call_arg_element_3 );
    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 45;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ContextMetaClassBase, tmp_assign_source_26 );
    tmp_assign_source_27 = PyDict_New();
    assert( tmp_class_creation_2__class_decl_dict == NULL );
    tmp_class_creation_2__class_decl_dict = tmp_assign_source_27;

    // Tried code:
    tmp_key_name_4 = const_str_plain_metaclass;
    tmp_dict_name_4 = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_4 );
    tmp_res = PyDict_Contains( tmp_dict_name_4, tmp_key_name_4 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    tmp_cond_value_3 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_dict_name_5 = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_5 );
    tmp_key_name_5 = const_str_plain_metaclass;
    tmp_metaclass_name_2 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
    if ( tmp_metaclass_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_metaclass_name_2 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_2 != NULL );
    Py_INCREF( tmp_metaclass_name_2 );
    condexpr_end_3:;
    tmp_bases_name_2 = const_tuple_type_object_tuple;
    tmp_assign_source_28 = SELECT_METACLASS( tmp_metaclass_name_2, tmp_bases_name_2 );
    Py_DECREF( tmp_metaclass_name_2 );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_28;

    tmp_key_name_6 = const_str_plain_metaclass;
    tmp_dict_name_6 = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_6 );
    tmp_res = PyDict_Contains( tmp_dict_name_6, tmp_key_name_6 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    tmp_cond_value_4 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_dictdel_dict = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    branch_no_2:;
    tmp_hasattr_source_2 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_2 );
    tmp_hasattr_attr_2 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_2, tmp_hasattr_attr_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_4;
    }
    else
    {
        goto condexpr_false_4;
    }
    condexpr_true_4:;
    tmp_source_name_2 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___prepare__ );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    tmp_args_name_3 = const_tuple_str_plain_TempMixin_tuple_type_object_tuple_tuple;
    tmp_kw_name_3 = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_3 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 54;
    tmp_assign_source_29 = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_3, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_4 );
    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_7;
    }
    goto condexpr_end_4;
    condexpr_false_4:;
    tmp_assign_source_29 = PyDict_New();
    condexpr_end_4:;
    assert( tmp_class_creation_2__prepared == NULL );
    tmp_class_creation_2__prepared = tmp_assign_source_29;

    tmp_set_locals = tmp_class_creation_2__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_TempMixin_54 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_9;
    }
    tmp_dictset_value = const_str_plain_TempMixin;
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_9;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_d04ebf6bd401874fd48b1c7091e8d919_2, codeobj_d04ebf6bd401874fd48b1c7091e8d919, module_codegen$Contexts, sizeof(void *) );
    frame_d04ebf6bd401874fd48b1c7091e8d919_2 = cache_frame_d04ebf6bd401874fd48b1c7091e8d919_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d04ebf6bd401874fd48b1c7091e8d919_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d04ebf6bd401874fd48b1c7091e8d919_2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_1___init__(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_2_formatTempName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_formatTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 82;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_defaults_1 = const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple;
    Py_INCREF( tmp_defaults_1 );
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_3_allocateTempName( tmp_defaults_1 );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_allocateTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 93;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_4_getIntResName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getIntResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_5_getBoolResName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getBoolResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_6_hasTempName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_hasTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 120;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_7_forgetTempName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_forgetTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 123;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_8_getTempNameInfos(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getTempNameInfos, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_9_getExceptionEscape(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 160;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_10_setExceptionEscape(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 163;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_11_getLoopBreakTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 168;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_12_setLoopBreakTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_13_getLoopContinueTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_14_setLoopContinueTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 179;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_15_allocateLabel(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_allocateLabel, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 184;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_16_getLabelCount(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getLabelCount, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_17_needsExceptionVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_needsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_18_markAsNeedsExceptionVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_markAsNeedsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 200;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_19_allocateExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_allocateExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_20_getKeeperVariableCount(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getKeeperVariableCount, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_21_getExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 216;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_22_setExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_23_getExceptionPreserverCounts(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getExceptionPreserverCounts, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 224;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_24_addExceptionPreserverVariables(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_addExceptionPreserverVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 227;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_25_getTrueBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 231;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_26_getFalseBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 234;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_27_setTrueBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 237;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_28_setFalseBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_setFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 240;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_29_getCleanupTempnames(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_getCleanupTempnames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 243;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_30_addCleanupTempName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_addCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 246;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_31_removeCleanupTempName(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_removeCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_32_needsCleanup(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_needsCleanup, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 255;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_33_pushCleanupScope(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_pushCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 258;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_34_popCleanupScope(  );
    tmp_res = PyObject_SetItem( locals_TempMixin_54, const_str_plain_popCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description_2 = "N";
        goto frame_exception_exit_2;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d04ebf6bd401874fd48b1c7091e8d919_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d04ebf6bd401874fd48b1c7091e8d919_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d04ebf6bd401874fd48b1c7091e8d919_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d04ebf6bd401874fd48b1c7091e8d919_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d04ebf6bd401874fd48b1c7091e8d919_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d04ebf6bd401874fd48b1c7091e8d919_2,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_d04ebf6bd401874fd48b1c7091e8d919_2 == cache_frame_d04ebf6bd401874fd48b1c7091e8d919_2 )
    {
        Py_DECREF( frame_d04ebf6bd401874fd48b1c7091e8d919_2 );
    }
    cache_frame_d04ebf6bd401874fd48b1c7091e8d919_2 = NULL;

    assertFrameObject( frame_d04ebf6bd401874fd48b1c7091e8d919_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_9;
    skip_nested_handling_1:;
    tmp_called_name_5 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_called_name_5 );
    tmp_tuple_element_4 = const_str_plain_TempMixin;
    tmp_args_name_4 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_4 );
    tmp_tuple_element_4 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_args_name_4, 1, tmp_tuple_element_4 );
    tmp_tuple_element_4 = locals_TempMixin_54;
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_args_name_4, 2, tmp_tuple_element_4 );
    tmp_kw_name_4 = tmp_class_creation_2__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_4 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 54;
    tmp_assign_source_31 = CALL_FUNCTION( tmp_called_name_5, tmp_args_name_4, tmp_kw_name_4 );
    Py_DECREF( tmp_args_name_4 );
    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 54;

        goto try_except_handler_9;
    }
    assert( outline_1_var___class__ == NULL );
    outline_1_var___class__ = tmp_assign_source_31;

    tmp_outline_return_value_2 = outline_1_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_2 );
    Py_INCREF( tmp_outline_return_value_2 );
    goto try_return_handler_9;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_9:;
    Py_DECREF( locals_TempMixin_54 );
    locals_TempMixin_54 = NULL;
    goto try_return_handler_8;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_TempMixin_54 );
    locals_TempMixin_54 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto try_except_handler_8;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_8:;
    CHECK_OBJECT( (PyObject *)outline_1_var___class__ );
    Py_DECREF( outline_1_var___class__ );
    outline_1_var___class__ = NULL;

    goto outline_result_2;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto outline_exception_2;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_2:;
    exception_lineno = 54;
    goto try_except_handler_7;
    outline_result_2:;
    tmp_assign_source_30 = tmp_outline_return_value_2;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_TempMixin, tmp_assign_source_30 );
    goto try_end_5;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_decl_dict );
    Py_DECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_decl_dict );
    Py_DECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__prepared );
    Py_DECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    tmp_assign_source_32 = PyDict_New();
    assert( tmp_class_creation_3__class_decl_dict == NULL );
    tmp_class_creation_3__class_decl_dict = tmp_assign_source_32;

    // Tried code:
    tmp_key_name_7 = const_str_plain_metaclass;
    tmp_dict_name_7 = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_7 );
    tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    tmp_cond_value_5 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    if ( tmp_cond_truth_5 == 1 )
    {
        goto condexpr_true_5;
    }
    else
    {
        goto condexpr_false_5;
    }
    condexpr_true_5:;
    tmp_dict_name_8 = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_8 );
    tmp_key_name_8 = const_str_plain_metaclass;
    tmp_metaclass_name_3 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
    if ( tmp_metaclass_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    goto condexpr_end_5;
    condexpr_false_5:;
    tmp_metaclass_name_3 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_3 != NULL );
    Py_INCREF( tmp_metaclass_name_3 );
    condexpr_end_5:;
    tmp_bases_name_3 = const_tuple_type_object_tuple;
    tmp_assign_source_33 = SELECT_METACLASS( tmp_metaclass_name_3, tmp_bases_name_3 );
    Py_DECREF( tmp_metaclass_name_3 );
    if ( tmp_assign_source_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    assert( tmp_class_creation_3__metaclass == NULL );
    tmp_class_creation_3__metaclass = tmp_assign_source_33;

    tmp_key_name_9 = const_str_plain_metaclass;
    tmp_dict_name_9 = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_9 );
    tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    tmp_cond_value_6 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_dictdel_dict = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    branch_no_3:;
    tmp_hasattr_source_3 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_3 );
    tmp_hasattr_attr_3 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_3, tmp_hasattr_attr_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_6;
    }
    else
    {
        goto condexpr_false_6;
    }
    condexpr_true_6:;
    tmp_source_name_3 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___prepare__ );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    tmp_args_name_5 = const_tuple_str_plain_CodeObjectsMixin_tuple_type_object_tuple_tuple;
    tmp_kw_name_5 = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_5 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 266;
    tmp_assign_source_34 = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_5, tmp_kw_name_5 );
    Py_DECREF( tmp_called_name_6 );
    if ( tmp_assign_source_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_10;
    }
    goto condexpr_end_6;
    condexpr_false_6:;
    tmp_assign_source_34 = PyDict_New();
    condexpr_end_6:;
    assert( tmp_class_creation_3__prepared == NULL );
    tmp_class_creation_3__prepared = tmp_assign_source_34;

    tmp_set_locals = tmp_class_creation_3__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_CodeObjectsMixin_266 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_12;
    }
    tmp_dictset_value = const_str_plain_CodeObjectsMixin;
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_12;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_e964a1438f89be085a632221056be03e_3, codeobj_e964a1438f89be085a632221056be03e, module_codegen$Contexts, sizeof(void *) );
    frame_e964a1438f89be085a632221056be03e_3 = cache_frame_e964a1438f89be085a632221056be03e_3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e964a1438f89be085a632221056be03e_3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e964a1438f89be085a632221056be03e_3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_35___init__(  );
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_36_getCodeObjects(  );
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain_getCodeObjects, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 271;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_37_getCodeObjectHandle(  );
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain_getCodeObjectHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    tmp_compare_left_1 = PyObject_GetItem( locals_CodeObjectsMixin_266, const_str_plain_python_version );

    if ( tmp_compare_left_1 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_compare_left_1 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_python_version );

        if (unlikely( tmp_compare_left_1 == NULL ))
        {
            tmp_compare_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_python_version );
        }

        if ( tmp_compare_left_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "python_version" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 296;
            type_description_2 = "N";
            goto frame_exception_exit_3;
        }

        }
    }

    tmp_compare_right_1 = const_int_pos_300;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_38__calcHash(  );
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain__calcHash, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 297;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    goto branch_end_4;
    branch_no_4:;
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_39__calcHash(  );
    tmp_res = PyObject_SetItem( locals_CodeObjectsMixin_266, const_str_plain__calcHash, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;
        type_description_2 = "N";
        goto frame_exception_exit_3;
    }
    branch_end_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e964a1438f89be085a632221056be03e_3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_exception_exit_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e964a1438f89be085a632221056be03e_3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e964a1438f89be085a632221056be03e_3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e964a1438f89be085a632221056be03e_3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e964a1438f89be085a632221056be03e_3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e964a1438f89be085a632221056be03e_3,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_e964a1438f89be085a632221056be03e_3 == cache_frame_e964a1438f89be085a632221056be03e_3 )
    {
        Py_DECREF( frame_e964a1438f89be085a632221056be03e_3 );
    }
    cache_frame_e964a1438f89be085a632221056be03e_3 = NULL;

    assertFrameObject( frame_e964a1438f89be085a632221056be03e_3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_2;

    frame_no_exception_2:;

    goto skip_nested_handling_2;
    nested_frame_exit_2:;

    goto try_except_handler_12;
    skip_nested_handling_2:;
    tmp_called_name_7 = tmp_class_creation_3__metaclass;

    CHECK_OBJECT( tmp_called_name_7 );
    tmp_tuple_element_5 = const_str_plain_CodeObjectsMixin;
    tmp_args_name_6 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_args_name_6, 0, tmp_tuple_element_5 );
    tmp_tuple_element_5 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_args_name_6, 1, tmp_tuple_element_5 );
    tmp_tuple_element_5 = locals_CodeObjectsMixin_266;
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_args_name_6, 2, tmp_tuple_element_5 );
    tmp_kw_name_6 = tmp_class_creation_3__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_6 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 266;
    tmp_assign_source_36 = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_6, tmp_kw_name_6 );
    Py_DECREF( tmp_args_name_6 );
    if ( tmp_assign_source_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 266;

        goto try_except_handler_12;
    }
    assert( outline_2_var___class__ == NULL );
    outline_2_var___class__ = tmp_assign_source_36;

    tmp_outline_return_value_3 = outline_2_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_3 );
    Py_INCREF( tmp_outline_return_value_3 );
    goto try_return_handler_12;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_12:;
    Py_DECREF( locals_CodeObjectsMixin_266 );
    locals_CodeObjectsMixin_266 = NULL;
    goto try_return_handler_11;
    // Exception handler code:
    try_except_handler_12:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_CodeObjectsMixin_266 );
    locals_CodeObjectsMixin_266 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto try_except_handler_11;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_11:;
    CHECK_OBJECT( (PyObject *)outline_2_var___class__ );
    Py_DECREF( outline_2_var___class__ );
    outline_2_var___class__ = NULL;

    goto outline_result_3;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto outline_exception_3;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_3:;
    exception_lineno = 266;
    goto try_except_handler_10;
    outline_result_3:;
    tmp_assign_source_35 = tmp_outline_return_value_3;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_CodeObjectsMixin, tmp_assign_source_35 );
    goto try_end_6;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_decl_dict );
    Py_DECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_decl_dict );
    Py_DECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__prepared );
    Py_DECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    // Tried code:
    tmp_tuple_element_6 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ContextMetaClassBase );

    if (unlikely( tmp_tuple_element_6 == NULL ))
    {
        tmp_tuple_element_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ContextMetaClassBase );
    }

    if ( tmp_tuple_element_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ContextMetaClassBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 312;

        goto try_except_handler_13;
    }

    tmp_assign_source_37 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_assign_source_37, 0, tmp_tuple_element_6 );
    assert( tmp_class_creation_4__bases == NULL );
    tmp_class_creation_4__bases = tmp_assign_source_37;

    tmp_assign_source_38 = PyDict_New();
    assert( tmp_class_creation_4__class_decl_dict == NULL );
    tmp_class_creation_4__class_decl_dict = tmp_assign_source_38;

    tmp_key_name_10 = const_str_plain_metaclass;
    tmp_dict_name_10 = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_10 );
    tmp_res = PyDict_Contains( tmp_dict_name_10, tmp_key_name_10 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    tmp_cond_value_7 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    if ( tmp_cond_truth_7 == 1 )
    {
        goto condexpr_true_7;
    }
    else
    {
        goto condexpr_false_7;
    }
    condexpr_true_7:;
    tmp_dict_name_11 = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_11 );
    tmp_key_name_11 = const_str_plain_metaclass;
    tmp_metaclass_name_4 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
    if ( tmp_metaclass_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    goto condexpr_end_7;
    condexpr_false_7:;
    tmp_subscribed_name_2 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_type_arg_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_type_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    tmp_metaclass_name_4 = BUILTIN_TYPE1( tmp_type_arg_2 );
    Py_DECREF( tmp_type_arg_2 );
    if ( tmp_metaclass_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    condexpr_end_7:;
    tmp_bases_name_4 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_bases_name_4 );
    tmp_assign_source_39 = SELECT_METACLASS( tmp_metaclass_name_4, tmp_bases_name_4 );
    Py_DECREF( tmp_metaclass_name_4 );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    assert( tmp_class_creation_4__metaclass == NULL );
    tmp_class_creation_4__metaclass = tmp_assign_source_39;

    tmp_key_name_12 = const_str_plain_metaclass;
    tmp_dict_name_12 = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_12 );
    tmp_res = PyDict_Contains( tmp_dict_name_12, tmp_key_name_12 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    tmp_cond_value_8 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_dictdel_dict = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    branch_no_5:;
    tmp_hasattr_source_4 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_4 );
    tmp_hasattr_attr_4 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_4, tmp_hasattr_attr_4 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_8;
    }
    else
    {
        goto condexpr_false_8;
    }
    condexpr_true_8:;
    tmp_source_name_4 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___prepare__ );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    tmp_tuple_element_7 = const_str_plain_PythonContextBase;
    tmp_args_name_7 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_7, 0, tmp_tuple_element_7 );
    tmp_tuple_element_7 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_tuple_element_7 );
    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_7, 1, tmp_tuple_element_7 );
    tmp_kw_name_7 = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_7 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 312;
    tmp_assign_source_40 = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_7, tmp_kw_name_7 );
    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_name_7 );
    if ( tmp_assign_source_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_13;
    }
    goto condexpr_end_8;
    condexpr_false_8:;
    tmp_assign_source_40 = PyDict_New();
    condexpr_end_8:;
    assert( tmp_class_creation_4__prepared == NULL );
    tmp_class_creation_4__prepared = tmp_assign_source_40;

    tmp_set_locals = tmp_class_creation_4__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonContextBase_312 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_15;
    }
    tmp_dictset_value = const_str_plain_PythonContextBase;
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_15;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_ce8dbbdab23e99501a4f8b8d0c44e890_4, codeobj_ce8dbbdab23e99501a4f8b8d0c44e890, module_codegen$Contexts, sizeof(void *) );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 = cache_frame_ce8dbbdab23e99501a4f8b8d0c44e890_4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_9 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_counted_init );

    if ( tmp_called_name_9 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_counted_init );

        if (unlikely( tmp_called_name_9 == NULL ))
        {
            tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_counted_init );
        }

        if ( tmp_called_name_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "counted_init" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 313;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_1 = MAKE_FUNCTION_codegen$Contexts$$$function_40___init__(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 313;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_10 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_counted_del );

    if ( tmp_called_name_10 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_counted_del );

        if (unlikely( tmp_called_name_10 == NULL ))
        {
            tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_counted_del );
        }

        if ( tmp_called_name_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "counted_del" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 320;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 320;
    tmp_dictset_value = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 320;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain___del__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 320;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_41_getCurrentSourceCodeReference(  );
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getCurrentSourceCodeReference, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_42_setCurrentSourceCodeReference(  );
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setCurrentSourceCodeReference, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_43_getLastSourceCodeReference(  );
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getLastSourceCodeReference, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_44_isUsed(  );
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_isUsed, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_11 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_11 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_11 == NULL ))
        {
            tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 345;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_2 = MAKE_FUNCTION_codegen$Contexts$$$function_45_getConstantCode(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 345;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 345;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getConstantCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 345;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_12 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_12 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_12 == NULL ))
        {
            tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 349;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_3 = MAKE_FUNCTION_codegen$Contexts$$$function_46_getModuleCodeName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 349;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 349;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getModuleCodeName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 349;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_13 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_13 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_13 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_13 == NULL ))
        {
            tmp_called_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 353;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_4 = MAKE_FUNCTION_codegen$Contexts$$$function_47_getModuleName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 353;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 353;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getModuleName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 353;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_14 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_14 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_14 == NULL ))
        {
            tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 357;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_5 = MAKE_FUNCTION_codegen$Contexts$$$function_48_addHelperCode(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 357;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_addHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_15 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_15 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_15 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_15 == NULL ))
        {
            tmp_called_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 361;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_6 = MAKE_FUNCTION_codegen$Contexts$$$function_49_hasHelperCode(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 361;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_hasHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 361;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_16 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_16 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_16 == NULL ))
        {
            tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 365;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_7 = MAKE_FUNCTION_codegen$Contexts$$$function_50_addDeclaration(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 365;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
    }

    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_addDeclaration, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_17 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_17 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_17 == NULL ))
        {
            tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_17 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 369;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_8 = MAKE_FUNCTION_codegen$Contexts$$$function_51_pushFrameVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 369;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_pushFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_18 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_18 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_18 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_18 == NULL ))
        {
            tmp_called_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 373;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_9 = MAKE_FUNCTION_codegen$Contexts$$$function_52_popFrameVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 373;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 373;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_popFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 373;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_19 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_19 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_19 == NULL ))
        {
            tmp_called_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 377;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_10 = MAKE_FUNCTION_codegen$Contexts$$$function_53_getFrameVariableTypeDescriptions(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 377;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 377;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getFrameVariableTypeDescriptions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 377;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_20 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_20 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_20 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_20 == NULL ))
        {
            tmp_called_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_20 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 381;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_11 = MAKE_FUNCTION_codegen$Contexts$$$function_54_getFrameVariableTypeDescription(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 381;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 381;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getFrameVariableTypeDescription, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 381;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_21 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_21 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_21 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_21 == NULL ))
        {
            tmp_called_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 385;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_12 = MAKE_FUNCTION_codegen$Contexts$$$function_55_getFrameVariableTypeDescriptionName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 385;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
    }

    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 385;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getFrameVariableTypeDescriptionName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 385;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_22 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_22 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_22 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_22 == NULL ))
        {
            tmp_called_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_22 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 389;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_13 = MAKE_FUNCTION_codegen$Contexts$$$function_56_getFrameVariableCodeNames(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 389;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getFrameVariableCodeNames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_23 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_23 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_23 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_23 == NULL ))
        {
            tmp_called_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_23 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 393;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_defaults_2 = const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_args_element_name_14 = MAKE_FUNCTION_codegen$Contexts$$$function_57_allocateTempName( tmp_defaults_2 );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 393;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
    }

    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_allocateTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_24 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_24 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_24 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_24 == NULL ))
        {
            tmp_called_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_24 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 398;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_15 = MAKE_FUNCTION_codegen$Contexts$$$function_58_getIntResName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 398;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
    }

    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getIntResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_25 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_25 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_25 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_25 == NULL ))
        {
            tmp_called_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_25 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 402;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_16 = MAKE_FUNCTION_codegen$Contexts$$$function_59_getBoolResName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 402;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_25, call_args );
    }

    Py_DECREF( tmp_args_element_name_16 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 402;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getBoolResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 402;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_26 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_26 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_26 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_26 == NULL ))
        {
            tmp_called_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_26 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 406;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_17 = MAKE_FUNCTION_codegen$Contexts$$$function_60_hasTempName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 406;
    {
        PyObject *call_args[] = { tmp_args_element_name_17 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
    }

    Py_DECREF( tmp_args_element_name_17 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_hasTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_27 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_27 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_27 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_27 == NULL ))
        {
            tmp_called_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_27 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 410;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_18 = MAKE_FUNCTION_codegen$Contexts$$$function_61_forgetTempName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 410;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
    }

    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 410;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_forgetTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 410;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_28 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_28 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_28 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_28 == NULL ))
        {
            tmp_called_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 414;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_19 = MAKE_FUNCTION_codegen$Contexts$$$function_62_getTempNameInfos(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 414;
    {
        PyObject *call_args[] = { tmp_args_element_name_19 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
    }

    Py_DECREF( tmp_args_element_name_19 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getTempNameInfos, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_29 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_29 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_29 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_29 == NULL ))
        {
            tmp_called_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 418;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_20 = MAKE_FUNCTION_codegen$Contexts$$$function_63_getExceptionEscape(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 418;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_29, call_args );
    }

    Py_DECREF( tmp_args_element_name_20 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 418;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 418;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_30 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_30 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_30 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_30 == NULL ))
        {
            tmp_called_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 422;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_21 = MAKE_FUNCTION_codegen$Contexts$$$function_64_setExceptionEscape(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 422;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_30, call_args );
    }

    Py_DECREF( tmp_args_element_name_21 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_31 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_31 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_31 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_31 == NULL ))
        {
            tmp_called_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 426;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_22 = MAKE_FUNCTION_codegen$Contexts$$$function_65_getLoopBreakTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 426;
    {
        PyObject *call_args[] = { tmp_args_element_name_22 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_31, call_args );
    }

    Py_DECREF( tmp_args_element_name_22 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 426;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 426;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_32 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_32 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_32 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_32 == NULL ))
        {
            tmp_called_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 430;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_23 = MAKE_FUNCTION_codegen$Contexts$$$function_66_setLoopBreakTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 430;
    {
        PyObject *call_args[] = { tmp_args_element_name_23 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, call_args );
    }

    Py_DECREF( tmp_args_element_name_23 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 430;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 430;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_33 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_33 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_33 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_33 == NULL ))
        {
            tmp_called_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 434;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_24 = MAKE_FUNCTION_codegen$Contexts$$$function_67_getLoopContinueTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 434;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_33, call_args );
    }

    Py_DECREF( tmp_args_element_name_24 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 434;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 434;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_34 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_34 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_34 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_34 == NULL ))
        {
            tmp_called_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 438;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_25 = MAKE_FUNCTION_codegen$Contexts$$$function_68_setLoopContinueTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 438;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_34, call_args );
    }

    Py_DECREF( tmp_args_element_name_25 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 438;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 438;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_35 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_35 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_35 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_35 == NULL ))
        {
            tmp_called_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_35 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 442;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_26 = MAKE_FUNCTION_codegen$Contexts$$$function_69_allocateLabel(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 442;
    {
        PyObject *call_args[] = { tmp_args_element_name_26 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_35, call_args );
    }

    Py_DECREF( tmp_args_element_name_26 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_allocateLabel, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_36 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_36 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_36 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_36 == NULL ))
        {
            tmp_called_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_36 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 446;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_27 = MAKE_FUNCTION_codegen$Contexts$$$function_70_needsExceptionVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 446;
    {
        PyObject *call_args[] = { tmp_args_element_name_27 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_36, call_args );
    }

    Py_DECREF( tmp_args_element_name_27 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 446;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_needsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 446;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_37 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_37 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_37 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_37 == NULL ))
        {
            tmp_called_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_37 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 450;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_28 = MAKE_FUNCTION_codegen$Contexts$$$function_71_markAsNeedsExceptionVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 450;
    {
        PyObject *call_args[] = { tmp_args_element_name_28 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_37, call_args );
    }

    Py_DECREF( tmp_args_element_name_28 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 450;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_markAsNeedsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 450;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_38 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_38 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_38 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_38 == NULL ))
        {
            tmp_called_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_38 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 454;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_29 = MAKE_FUNCTION_codegen$Contexts$$$function_72_allocateExceptionKeeperVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 454;
    {
        PyObject *call_args[] = { tmp_args_element_name_29 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_38, call_args );
    }

    Py_DECREF( tmp_args_element_name_29 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_allocateExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_39 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_39 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_39 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_39 == NULL ))
        {
            tmp_called_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_39 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 458;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_30 = MAKE_FUNCTION_codegen$Contexts$$$function_73_getExceptionKeeperVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 458;
    {
        PyObject *call_args[] = { tmp_args_element_name_30 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_39, call_args );
    }

    Py_DECREF( tmp_args_element_name_30 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_40 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_40 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_40 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_40 == NULL ))
        {
            tmp_called_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_40 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 462;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_31 = MAKE_FUNCTION_codegen$Contexts$$$function_74_setExceptionKeeperVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 462;
    {
        PyObject *call_args[] = { tmp_args_element_name_31 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_40, call_args );
    }

    Py_DECREF( tmp_args_element_name_31 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 462;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 462;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_41 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_41 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_41 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_41 == NULL ))
        {
            tmp_called_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_41 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 466;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_32 = MAKE_FUNCTION_codegen$Contexts$$$function_75_addExceptionPreserverVariables(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 466;
    {
        PyObject *call_args[] = { tmp_args_element_name_32 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_41, call_args );
    }

    Py_DECREF( tmp_args_element_name_32 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 466;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_addExceptionPreserverVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 466;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_42 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_42 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_42 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_42 == NULL ))
        {
            tmp_called_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_42 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 470;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_33 = MAKE_FUNCTION_codegen$Contexts$$$function_76_getTrueBranchTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 470;
    {
        PyObject *call_args[] = { tmp_args_element_name_33 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_42, call_args );
    }

    Py_DECREF( tmp_args_element_name_33 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_43 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_43 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_43 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_43 == NULL ))
        {
            tmp_called_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_43 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 474;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_34 = MAKE_FUNCTION_codegen$Contexts$$$function_77_getFalseBranchTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 474;
    {
        PyObject *call_args[] = { tmp_args_element_name_34 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
    }

    Py_DECREF( tmp_args_element_name_34 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_44 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_44 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_44 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_44 == NULL ))
        {
            tmp_called_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_44 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 478;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_35 = MAKE_FUNCTION_codegen$Contexts$$$function_78_setTrueBranchTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 478;
    {
        PyObject *call_args[] = { tmp_args_element_name_35 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_44, call_args );
    }

    Py_DECREF( tmp_args_element_name_35 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 478;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 478;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_45 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_45 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_45 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_45 == NULL ))
        {
            tmp_called_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_45 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 482;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_36 = MAKE_FUNCTION_codegen$Contexts$$$function_79_setFalseBranchTarget(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 482;
    {
        PyObject *call_args[] = { tmp_args_element_name_36 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_45, call_args );
    }

    Py_DECREF( tmp_args_element_name_36 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_setFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_46 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_46 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_46 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_46 == NULL ))
        {
            tmp_called_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_46 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 486;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_37 = MAKE_FUNCTION_codegen$Contexts$$$function_80_getCleanupTempnames(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 486;
    {
        PyObject *call_args[] = { tmp_args_element_name_37 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_46, call_args );
    }

    Py_DECREF( tmp_args_element_name_37 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 486;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_getCleanupTempnames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 486;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_47 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_47 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_47 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_47 == NULL ))
        {
            tmp_called_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_47 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 490;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_38 = MAKE_FUNCTION_codegen$Contexts$$$function_81_addCleanupTempName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 490;
    {
        PyObject *call_args[] = { tmp_args_element_name_38 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_47, call_args );
    }

    Py_DECREF( tmp_args_element_name_38 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 490;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_addCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 490;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_48 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_48 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_48 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_48 == NULL ))
        {
            tmp_called_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_48 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 494;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_39 = MAKE_FUNCTION_codegen$Contexts$$$function_82_removeCleanupTempName(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 494;
    {
        PyObject *call_args[] = { tmp_args_element_name_39 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_48, call_args );
    }

    Py_DECREF( tmp_args_element_name_39 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 494;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_removeCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 494;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_49 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_49 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_49 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_49 == NULL ))
        {
            tmp_called_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_49 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 498;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_40 = MAKE_FUNCTION_codegen$Contexts$$$function_83_needsCleanup(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 498;
    {
        PyObject *call_args[] = { tmp_args_element_name_40 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_49, call_args );
    }

    Py_DECREF( tmp_args_element_name_40 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 498;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_needsCleanup, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 498;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_50 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_50 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_50 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_50 == NULL ))
        {
            tmp_called_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_50 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 502;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_41 = MAKE_FUNCTION_codegen$Contexts$$$function_84_pushCleanupScope(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 502;
    {
        PyObject *call_args[] = { tmp_args_element_name_41 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_50, call_args );
    }

    Py_DECREF( tmp_args_element_name_41 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 502;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_pushCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 502;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_called_name_51 = PyObject_GetItem( locals_PythonContextBase_312, const_str_plain_abstractmethod );

    if ( tmp_called_name_51 == NULL )
    {
        if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {
        tmp_called_name_51 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_abstractmethod );

        if (unlikely( tmp_called_name_51 == NULL ))
        {
            tmp_called_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abstractmethod );
        }

        if ( tmp_called_name_51 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abstractmethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 506;
            type_description_2 = "N";
            goto frame_exception_exit_4;
        }

        }
    }

    tmp_args_element_name_42 = MAKE_FUNCTION_codegen$Contexts$$$function_85_popCleanupScope(  );
    frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame.f_lineno = 506;
    {
        PyObject *call_args[] = { tmp_args_element_name_42 };
        tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_51, call_args );
    }

    Py_DECREF( tmp_args_element_name_42 );
    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }
    tmp_res = PyObject_SetItem( locals_PythonContextBase_312, const_str_plain_popCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description_2 = "N";
        goto frame_exception_exit_4;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_3;

    frame_exception_exit_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce8dbbdab23e99501a4f8b8d0c44e890_4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce8dbbdab23e99501a4f8b8d0c44e890_4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce8dbbdab23e99501a4f8b8d0c44e890_4,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 == cache_frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 )
    {
        Py_DECREF( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 );
    }
    cache_frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 = NULL;

    assertFrameObject( frame_ce8dbbdab23e99501a4f8b8d0c44e890_4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_3;

    frame_no_exception_3:;

    goto skip_nested_handling_3;
    nested_frame_exit_3:;

    goto try_except_handler_15;
    skip_nested_handling_3:;
    tmp_called_name_52 = tmp_class_creation_4__metaclass;

    CHECK_OBJECT( tmp_called_name_52 );
    tmp_tuple_element_8 = const_str_plain_PythonContextBase;
    tmp_args_name_8 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_args_name_8, 0, tmp_tuple_element_8 );
    tmp_tuple_element_8 = tmp_class_creation_4__bases;

    CHECK_OBJECT( tmp_tuple_element_8 );
    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_args_name_8, 1, tmp_tuple_element_8 );
    tmp_tuple_element_8 = locals_PythonContextBase_312;
    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_args_name_8, 2, tmp_tuple_element_8 );
    tmp_kw_name_8 = tmp_class_creation_4__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_8 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 312;
    tmp_assign_source_42 = CALL_FUNCTION( tmp_called_name_52, tmp_args_name_8, tmp_kw_name_8 );
    Py_DECREF( tmp_args_name_8 );
    if ( tmp_assign_source_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;

        goto try_except_handler_15;
    }
    assert( outline_3_var___class__ == NULL );
    outline_3_var___class__ = tmp_assign_source_42;

    tmp_outline_return_value_4 = outline_3_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_4 );
    Py_INCREF( tmp_outline_return_value_4 );
    goto try_return_handler_15;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_15:;
    Py_DECREF( locals_PythonContextBase_312 );
    locals_PythonContextBase_312 = NULL;
    goto try_return_handler_14;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonContextBase_312 );
    locals_PythonContextBase_312 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto try_except_handler_14;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_14:;
    CHECK_OBJECT( (PyObject *)outline_3_var___class__ );
    Py_DECREF( outline_3_var___class__ );
    outline_3_var___class__ = NULL;

    goto outline_result_4;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto outline_exception_4;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_4:;
    exception_lineno = 312;
    goto try_except_handler_13;
    outline_result_4:;
    tmp_assign_source_41 = tmp_outline_return_value_4;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonContextBase, tmp_assign_source_41 );
    goto try_end_7;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_decl_dict );
    Py_DECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__prepared );
    Py_DECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    // Tried code:
    tmp_tuple_element_9 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonContextBase );

    if (unlikely( tmp_tuple_element_9 == NULL ))
    {
        tmp_tuple_element_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonContextBase );
    }

    if ( tmp_tuple_element_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 511;

        goto try_except_handler_16;
    }

    tmp_assign_source_43 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_9 );
    PyTuple_SET_ITEM( tmp_assign_source_43, 0, tmp_tuple_element_9 );
    assert( tmp_class_creation_5__bases == NULL );
    tmp_class_creation_5__bases = tmp_assign_source_43;

    tmp_assign_source_44 = PyDict_New();
    assert( tmp_class_creation_5__class_decl_dict == NULL );
    tmp_class_creation_5__class_decl_dict = tmp_assign_source_44;

    tmp_key_name_13 = const_str_plain_metaclass;
    tmp_dict_name_13 = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_13 );
    tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    tmp_cond_value_9 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    if ( tmp_cond_truth_9 == 1 )
    {
        goto condexpr_true_9;
    }
    else
    {
        goto condexpr_false_9;
    }
    condexpr_true_9:;
    tmp_dict_name_14 = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_14 );
    tmp_key_name_14 = const_str_plain_metaclass;
    tmp_metaclass_name_5 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
    if ( tmp_metaclass_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    goto condexpr_end_9;
    condexpr_false_9:;
    tmp_subscribed_name_3 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_type_arg_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_type_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    tmp_metaclass_name_5 = BUILTIN_TYPE1( tmp_type_arg_3 );
    Py_DECREF( tmp_type_arg_3 );
    if ( tmp_metaclass_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    condexpr_end_9:;
    tmp_bases_name_5 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_bases_name_5 );
    tmp_assign_source_45 = SELECT_METACLASS( tmp_metaclass_name_5, tmp_bases_name_5 );
    Py_DECREF( tmp_metaclass_name_5 );
    if ( tmp_assign_source_45 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    assert( tmp_class_creation_5__metaclass == NULL );
    tmp_class_creation_5__metaclass = tmp_assign_source_45;

    tmp_key_name_15 = const_str_plain_metaclass;
    tmp_dict_name_15 = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_15 );
    tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    tmp_cond_value_10 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_10 = CHECK_IF_TRUE( tmp_cond_value_10 );
    if ( tmp_cond_truth_10 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    if ( tmp_cond_truth_10 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_dictdel_dict = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    branch_no_6:;
    tmp_hasattr_source_5 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_5 );
    tmp_hasattr_attr_5 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_5, tmp_hasattr_attr_5 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_10;
    }
    else
    {
        goto condexpr_false_10;
    }
    condexpr_true_10:;
    tmp_source_name_5 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_53 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___prepare__ );
    if ( tmp_called_name_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    tmp_tuple_element_10 = const_str_plain_PythonChildContextBase;
    tmp_args_name_9 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_args_name_9, 0, tmp_tuple_element_10 );
    tmp_tuple_element_10 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_tuple_element_10 );
    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_args_name_9, 1, tmp_tuple_element_10 );
    tmp_kw_name_9 = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_9 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 511;
    tmp_assign_source_46 = CALL_FUNCTION( tmp_called_name_53, tmp_args_name_9, tmp_kw_name_9 );
    Py_DECREF( tmp_called_name_53 );
    Py_DECREF( tmp_args_name_9 );
    if ( tmp_assign_source_46 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_16;
    }
    goto condexpr_end_10;
    condexpr_false_10:;
    tmp_assign_source_46 = PyDict_New();
    condexpr_end_10:;
    assert( tmp_class_creation_5__prepared == NULL );
    tmp_class_creation_5__prepared = tmp_assign_source_46;

    tmp_set_locals = tmp_class_creation_5__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonChildContextBase_511 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_18;
    }
    tmp_dictset_value = const_str_plain_PythonChildContextBase;
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_18;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_45c666bd5eb5ec6b1395dd9b61ec9933_5, codeobj_45c666bd5eb5ec6b1395dd9b61ec9933, module_codegen$Contexts, sizeof(void *) );
    frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 = cache_frame_45c666bd5eb5ec6b1395dd9b61ec9933_5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_86___init__(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_87_getConstantCode(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getConstantCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 519;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_88_getModuleCodeName(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getModuleCodeName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_89_getModuleName(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getModuleName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 525;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_90_addHelperCode(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_addHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 528;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_91_hasHelperCode(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_hasHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 531;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_92_addDeclaration(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_addDeclaration, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_93_pushFrameVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_pushFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 537;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_94_popFrameVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_popFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_95_getFrameVariableTypeDescriptions(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getFrameVariableTypeDescriptions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 543;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_96_getFrameVariableTypeDescription(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getFrameVariableTypeDescription, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 546;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_97_getFrameVariableTypeDescriptionName(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getFrameVariableTypeDescriptionName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 549;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_98_getFrameVariableCodeNames(  );
    tmp_res = PyObject_SetItem( locals_PythonChildContextBase_511, const_str_plain_getFrameVariableCodeNames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;
        type_description_2 = "N";
        goto frame_exception_exit_5;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_4;

    frame_exception_exit_5:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_45c666bd5eb5ec6b1395dd9b61ec9933_5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_45c666bd5eb5ec6b1395dd9b61ec9933_5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_45c666bd5eb5ec6b1395dd9b61ec9933_5,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 == cache_frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 )
    {
        Py_DECREF( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 );
    }
    cache_frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 = NULL;

    assertFrameObject( frame_45c666bd5eb5ec6b1395dd9b61ec9933_5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_4;

    frame_no_exception_4:;

    goto skip_nested_handling_4;
    nested_frame_exit_4:;

    goto try_except_handler_18;
    skip_nested_handling_4:;
    tmp_called_name_54 = tmp_class_creation_5__metaclass;

    CHECK_OBJECT( tmp_called_name_54 );
    tmp_tuple_element_11 = const_str_plain_PythonChildContextBase;
    tmp_args_name_10 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_args_name_10, 0, tmp_tuple_element_11 );
    tmp_tuple_element_11 = tmp_class_creation_5__bases;

    CHECK_OBJECT( tmp_tuple_element_11 );
    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_args_name_10, 1, tmp_tuple_element_11 );
    tmp_tuple_element_11 = locals_PythonChildContextBase_511;
    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_args_name_10, 2, tmp_tuple_element_11 );
    tmp_kw_name_10 = tmp_class_creation_5__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_10 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 511;
    tmp_assign_source_48 = CALL_FUNCTION( tmp_called_name_54, tmp_args_name_10, tmp_kw_name_10 );
    Py_DECREF( tmp_args_name_10 );
    if ( tmp_assign_source_48 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;

        goto try_except_handler_18;
    }
    assert( outline_4_var___class__ == NULL );
    outline_4_var___class__ = tmp_assign_source_48;

    tmp_outline_return_value_5 = outline_4_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_5 );
    Py_INCREF( tmp_outline_return_value_5 );
    goto try_return_handler_18;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_18:;
    Py_DECREF( locals_PythonChildContextBase_511 );
    locals_PythonChildContextBase_511 = NULL;
    goto try_return_handler_17;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonChildContextBase_511 );
    locals_PythonChildContextBase_511 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto try_except_handler_17;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_17:;
    CHECK_OBJECT( (PyObject *)outline_4_var___class__ );
    Py_DECREF( outline_4_var___class__ );
    outline_4_var___class__ = NULL;

    goto outline_result_5;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto outline_exception_5;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_5:;
    exception_lineno = 511;
    goto try_except_handler_16;
    outline_result_5:;
    tmp_assign_source_47 = tmp_outline_return_value_5;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase, tmp_assign_source_47 );
    goto try_end_8;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_decl_dict );
    Py_DECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__prepared );
    Py_DECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    tmp_assign_source_49 = MAKE_FUNCTION_codegen$Contexts$$$function_99__getConstantDefaultPopulation(  );
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain__getConstantDefaultPopulation, tmp_assign_source_49 );
    tmp_assign_source_50 = PyDict_New();
    assert( tmp_class_creation_6__class_decl_dict == NULL );
    tmp_class_creation_6__class_decl_dict = tmp_assign_source_50;

    // Tried code:
    tmp_key_name_16 = const_str_plain_metaclass;
    tmp_dict_name_16 = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_16 );
    tmp_res = PyDict_Contains( tmp_dict_name_16, tmp_key_name_16 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    tmp_cond_value_11 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_11 = CHECK_IF_TRUE( tmp_cond_value_11 );
    if ( tmp_cond_truth_11 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    if ( tmp_cond_truth_11 == 1 )
    {
        goto condexpr_true_11;
    }
    else
    {
        goto condexpr_false_11;
    }
    condexpr_true_11:;
    tmp_dict_name_17 = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_17 );
    tmp_key_name_17 = const_str_plain_metaclass;
    tmp_metaclass_name_6 = DICT_GET_ITEM( tmp_dict_name_17, tmp_key_name_17 );
    if ( tmp_metaclass_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    goto condexpr_end_11;
    condexpr_false_11:;
    tmp_metaclass_name_6 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_6 != NULL );
    Py_INCREF( tmp_metaclass_name_6 );
    condexpr_end_11:;
    tmp_bases_name_6 = const_tuple_type_object_tuple;
    tmp_assign_source_51 = SELECT_METACLASS( tmp_metaclass_name_6, tmp_bases_name_6 );
    Py_DECREF( tmp_metaclass_name_6 );
    if ( tmp_assign_source_51 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    assert( tmp_class_creation_6__metaclass == NULL );
    tmp_class_creation_6__metaclass = tmp_assign_source_51;

    tmp_key_name_18 = const_str_plain_metaclass;
    tmp_dict_name_18 = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_18 );
    tmp_res = PyDict_Contains( tmp_dict_name_18, tmp_key_name_18 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    tmp_cond_value_12 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_12 = CHECK_IF_TRUE( tmp_cond_value_12 );
    if ( tmp_cond_truth_12 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    if ( tmp_cond_truth_12 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_dictdel_dict = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    branch_no_7:;
    tmp_hasattr_source_6 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_6 );
    tmp_hasattr_attr_6 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_6, tmp_hasattr_attr_6 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_12;
    }
    else
    {
        goto condexpr_false_12;
    }
    condexpr_true_12:;
    tmp_source_name_6 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_55 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___prepare__ );
    if ( tmp_called_name_55 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    tmp_args_name_11 = const_tuple_str_plain_PythonGlobalContext_tuple_type_object_tuple_tuple;
    tmp_kw_name_11 = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_11 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 738;
    tmp_assign_source_52 = CALL_FUNCTION( tmp_called_name_55, tmp_args_name_11, tmp_kw_name_11 );
    Py_DECREF( tmp_called_name_55 );
    if ( tmp_assign_source_52 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_19;
    }
    goto condexpr_end_12;
    condexpr_false_12:;
    tmp_assign_source_52 = PyDict_New();
    condexpr_end_12:;
    assert( tmp_class_creation_6__prepared == NULL );
    tmp_class_creation_6__prepared = tmp_assign_source_52;

    tmp_set_locals = tmp_class_creation_6__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonGlobalContext_738 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_21;
    }
    tmp_dictset_value = const_str_plain_PythonGlobalContext;
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_21;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_799ed93275cf11ee83e5b7ceb08f85d2_6, codeobj_799ed93275cf11ee83e5b7ceb08f85d2, module_codegen$Contexts, sizeof(void *) );
    frame_799ed93275cf11ee83e5b7ceb08f85d2_6 = cache_frame_799ed93275cf11ee83e5b7ceb08f85d2_6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_100___init__(  );
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 739;
        type_description_2 = "N";
        goto frame_exception_exit_6;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_101_getConstantCode(  );
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain_getConstantCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description_2 = "N";
        goto frame_exception_exit_6;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_102_countConstantUse(  );
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain_countConstantUse, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description_2 = "N";
        goto frame_exception_exit_6;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_103_getConstantUseCount(  );
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain_getConstantUseCount, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_2 = "N";
        goto frame_exception_exit_6;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_104_getConstants(  );
    tmp_res = PyObject_SetItem( locals_PythonGlobalContext_738, const_str_plain_getConstants, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description_2 = "N";
        goto frame_exception_exit_6;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_5;

    frame_exception_exit_6:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_799ed93275cf11ee83e5b7ceb08f85d2_6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_799ed93275cf11ee83e5b7ceb08f85d2_6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_799ed93275cf11ee83e5b7ceb08f85d2_6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_799ed93275cf11ee83e5b7ceb08f85d2_6,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 == cache_frame_799ed93275cf11ee83e5b7ceb08f85d2_6 )
    {
        Py_DECREF( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 );
    }
    cache_frame_799ed93275cf11ee83e5b7ceb08f85d2_6 = NULL;

    assertFrameObject( frame_799ed93275cf11ee83e5b7ceb08f85d2_6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_5;

    frame_no_exception_5:;

    goto skip_nested_handling_5;
    nested_frame_exit_5:;

    goto try_except_handler_21;
    skip_nested_handling_5:;
    tmp_called_name_56 = tmp_class_creation_6__metaclass;

    CHECK_OBJECT( tmp_called_name_56 );
    tmp_tuple_element_12 = const_str_plain_PythonGlobalContext;
    tmp_args_name_12 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_args_name_12, 0, tmp_tuple_element_12 );
    tmp_tuple_element_12 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_args_name_12, 1, tmp_tuple_element_12 );
    tmp_tuple_element_12 = locals_PythonGlobalContext_738;
    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_args_name_12, 2, tmp_tuple_element_12 );
    tmp_kw_name_12 = tmp_class_creation_6__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_12 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 738;
    tmp_assign_source_54 = CALL_FUNCTION( tmp_called_name_56, tmp_args_name_12, tmp_kw_name_12 );
    Py_DECREF( tmp_args_name_12 );
    if ( tmp_assign_source_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 738;

        goto try_except_handler_21;
    }
    assert( outline_5_var___class__ == NULL );
    outline_5_var___class__ = tmp_assign_source_54;

    tmp_outline_return_value_6 = outline_5_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_6 );
    Py_INCREF( tmp_outline_return_value_6 );
    goto try_return_handler_21;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_21:;
    Py_DECREF( locals_PythonGlobalContext_738 );
    locals_PythonGlobalContext_738 = NULL;
    goto try_return_handler_20;
    // Exception handler code:
    try_except_handler_21:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonGlobalContext_738 );
    locals_PythonGlobalContext_738 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto try_except_handler_20;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_20:;
    CHECK_OBJECT( (PyObject *)outline_5_var___class__ );
    Py_DECREF( outline_5_var___class__ );
    outline_5_var___class__ = NULL;

    goto outline_result_6;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto outline_exception_6;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_6:;
    exception_lineno = 738;
    goto try_except_handler_19;
    outline_result_6:;
    tmp_assign_source_53 = tmp_outline_return_value_6;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonGlobalContext, tmp_assign_source_53 );
    goto try_end_9;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_decl_dict );
    Py_DECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_decl_dict );
    Py_DECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__prepared );
    Py_DECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    tmp_assign_source_55 = PyDict_New();
    assert( tmp_class_creation_7__class_decl_dict == NULL );
    tmp_class_creation_7__class_decl_dict = tmp_assign_source_55;

    // Tried code:
    tmp_key_name_19 = const_str_plain_metaclass;
    tmp_dict_name_19 = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_19 );
    tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    tmp_cond_value_13 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_13 = CHECK_IF_TRUE( tmp_cond_value_13 );
    if ( tmp_cond_truth_13 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    if ( tmp_cond_truth_13 == 1 )
    {
        goto condexpr_true_13;
    }
    else
    {
        goto condexpr_false_13;
    }
    condexpr_true_13:;
    tmp_dict_name_20 = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_20 );
    tmp_key_name_20 = const_str_plain_metaclass;
    tmp_metaclass_name_7 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
    if ( tmp_metaclass_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    goto condexpr_end_13;
    condexpr_false_13:;
    tmp_metaclass_name_7 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_7 != NULL );
    Py_INCREF( tmp_metaclass_name_7 );
    condexpr_end_13:;
    tmp_bases_name_7 = const_tuple_type_object_tuple;
    tmp_assign_source_56 = SELECT_METACLASS( tmp_metaclass_name_7, tmp_bases_name_7 );
    Py_DECREF( tmp_metaclass_name_7 );
    if ( tmp_assign_source_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    assert( tmp_class_creation_7__metaclass == NULL );
    tmp_class_creation_7__metaclass = tmp_assign_source_56;

    tmp_key_name_21 = const_str_plain_metaclass;
    tmp_dict_name_21 = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_21 );
    tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    tmp_cond_value_14 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_14 = CHECK_IF_TRUE( tmp_cond_value_14 );
    if ( tmp_cond_truth_14 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    if ( tmp_cond_truth_14 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_dictdel_dict = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    branch_no_8:;
    tmp_hasattr_source_7 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_7 );
    tmp_hasattr_attr_7 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_7, tmp_hasattr_attr_7 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_14;
    }
    else
    {
        goto condexpr_false_14;
    }
    condexpr_true_14:;
    tmp_source_name_7 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_57 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___prepare__ );
    if ( tmp_called_name_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    tmp_args_name_13 = const_tuple_str_plain_FrameDeclarationsMixin_tuple_type_object_tuple_tuple;
    tmp_kw_name_13 = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_13 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 823;
    tmp_assign_source_57 = CALL_FUNCTION( tmp_called_name_57, tmp_args_name_13, tmp_kw_name_13 );
    Py_DECREF( tmp_called_name_57 );
    if ( tmp_assign_source_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_22;
    }
    goto condexpr_end_14;
    condexpr_false_14:;
    tmp_assign_source_57 = PyDict_New();
    condexpr_end_14:;
    assert( tmp_class_creation_7__prepared == NULL );
    tmp_class_creation_7__prepared = tmp_assign_source_57;

    tmp_set_locals = tmp_class_creation_7__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_FrameDeclarationsMixin_823 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_24;
    }
    tmp_dictset_value = const_str_plain_FrameDeclarationsMixin;
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_24;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_40cf1bb35fdb9c8653d4a2c9734319c3_7, codeobj_40cf1bb35fdb9c8653d4a2c9734319c3, module_codegen$Contexts, sizeof(void *) );
    frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 = cache_frame_40cf1bb35fdb9c8653d4a2c9734319c3_7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_105___init__(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_106_getFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 843;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_107_pushFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_pushFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 846;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_108_popFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_popFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 855;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_109_getFramesCount(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFramesCount, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 861;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_110_addFrameDeclaration(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_addFrameDeclaration, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 864;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_111_getFrameDeclarations(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameDeclarations, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_112_pushFrameVariables(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_pushFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 874;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_113_popFrameVariables(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_popFrameVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_114_setVariableType(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_setVariableType, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 884;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_115_getFrameVariableTypeDescriptions(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameVariableTypeDescriptions, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 889;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_116_getFrameVariableTypeDescriptionName(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameVariableTypeDescriptionName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 892;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_117_getFrameVariableTypeDescription(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameVariableTypeDescription, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 895;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_118_getFrameVariableCodeNames(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getFrameVariableCodeNames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 907;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_119_getLocalsDictNames(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_getLocalsDictNames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_120_addLocalsDictName(  );
    tmp_res = PyObject_SetItem( locals_FrameDeclarationsMixin_823, const_str_plain_addLocalsDictName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 923;
        type_description_2 = "N";
        goto frame_exception_exit_7;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_6;

    frame_exception_exit_7:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40cf1bb35fdb9c8653d4a2c9734319c3_7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40cf1bb35fdb9c8653d4a2c9734319c3_7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40cf1bb35fdb9c8653d4a2c9734319c3_7,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 == cache_frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 )
    {
        Py_DECREF( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 );
    }
    cache_frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 = NULL;

    assertFrameObject( frame_40cf1bb35fdb9c8653d4a2c9734319c3_7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_6;

    frame_no_exception_6:;

    goto skip_nested_handling_6;
    nested_frame_exit_6:;

    goto try_except_handler_24;
    skip_nested_handling_6:;
    tmp_called_name_58 = tmp_class_creation_7__metaclass;

    CHECK_OBJECT( tmp_called_name_58 );
    tmp_tuple_element_13 = const_str_plain_FrameDeclarationsMixin;
    tmp_args_name_14 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_args_name_14, 0, tmp_tuple_element_13 );
    tmp_tuple_element_13 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_args_name_14, 1, tmp_tuple_element_13 );
    tmp_tuple_element_13 = locals_FrameDeclarationsMixin_823;
    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_args_name_14, 2, tmp_tuple_element_13 );
    tmp_kw_name_14 = tmp_class_creation_7__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_14 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 823;
    tmp_assign_source_59 = CALL_FUNCTION( tmp_called_name_58, tmp_args_name_14, tmp_kw_name_14 );
    Py_DECREF( tmp_args_name_14 );
    if ( tmp_assign_source_59 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;

        goto try_except_handler_24;
    }
    assert( outline_6_var___class__ == NULL );
    outline_6_var___class__ = tmp_assign_source_59;

    tmp_outline_return_value_7 = outline_6_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_7 );
    Py_INCREF( tmp_outline_return_value_7 );
    goto try_return_handler_24;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_24:;
    Py_DECREF( locals_FrameDeclarationsMixin_823 );
    locals_FrameDeclarationsMixin_823 = NULL;
    goto try_return_handler_23;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_FrameDeclarationsMixin_823 );
    locals_FrameDeclarationsMixin_823 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto try_except_handler_23;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_23:;
    CHECK_OBJECT( (PyObject *)outline_6_var___class__ );
    Py_DECREF( outline_6_var___class__ );
    outline_6_var___class__ = NULL;

    goto outline_result_7;
    // Exception handler code:
    try_except_handler_23:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto outline_exception_7;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_7:;
    exception_lineno = 823;
    goto try_except_handler_22;
    outline_result_7:;
    tmp_assign_source_58 = tmp_outline_return_value_7;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin, tmp_assign_source_58 );
    goto try_end_10;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_decl_dict );
    Py_DECREF( tmp_class_creation_7__class_decl_dict );
    tmp_class_creation_7__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_7__prepared );
    tmp_class_creation_7__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_decl_dict );
    Py_DECREF( tmp_class_creation_7__class_decl_dict );
    tmp_class_creation_7__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__prepared );
    Py_DECREF( tmp_class_creation_7__prepared );
    tmp_class_creation_7__prepared = NULL;

    tmp_assign_source_60 = PyDict_New();
    assert( tmp_class_creation_8__class_decl_dict == NULL );
    tmp_class_creation_8__class_decl_dict = tmp_assign_source_60;

    // Tried code:
    tmp_key_name_22 = const_str_plain_metaclass;
    tmp_dict_name_22 = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_22 );
    tmp_res = PyDict_Contains( tmp_dict_name_22, tmp_key_name_22 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    tmp_cond_value_15 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_15 = CHECK_IF_TRUE( tmp_cond_value_15 );
    if ( tmp_cond_truth_15 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    if ( tmp_cond_truth_15 == 1 )
    {
        goto condexpr_true_15;
    }
    else
    {
        goto condexpr_false_15;
    }
    condexpr_true_15:;
    tmp_dict_name_23 = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_23 );
    tmp_key_name_23 = const_str_plain_metaclass;
    tmp_metaclass_name_8 = DICT_GET_ITEM( tmp_dict_name_23, tmp_key_name_23 );
    if ( tmp_metaclass_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    goto condexpr_end_15;
    condexpr_false_15:;
    tmp_metaclass_name_8 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_8 != NULL );
    Py_INCREF( tmp_metaclass_name_8 );
    condexpr_end_15:;
    tmp_bases_name_8 = const_tuple_type_object_tuple;
    tmp_assign_source_61 = SELECT_METACLASS( tmp_metaclass_name_8, tmp_bases_name_8 );
    Py_DECREF( tmp_metaclass_name_8 );
    if ( tmp_assign_source_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    assert( tmp_class_creation_8__metaclass == NULL );
    tmp_class_creation_8__metaclass = tmp_assign_source_61;

    tmp_key_name_24 = const_str_plain_metaclass;
    tmp_dict_name_24 = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_24 );
    tmp_res = PyDict_Contains( tmp_dict_name_24, tmp_key_name_24 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    tmp_cond_value_16 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_16 = CHECK_IF_TRUE( tmp_cond_value_16 );
    if ( tmp_cond_truth_16 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    if ( tmp_cond_truth_16 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_dictdel_dict = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    branch_no_9:;
    tmp_hasattr_source_8 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_8 );
    tmp_hasattr_attr_8 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_8, tmp_hasattr_attr_8 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_16;
    }
    else
    {
        goto condexpr_false_16;
    }
    condexpr_true_16:;
    tmp_source_name_8 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_called_name_59 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___prepare__ );
    if ( tmp_called_name_59 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    tmp_args_name_15 = const_tuple_str_plain_ReturnReleaseModeMixin_tuple_type_object_tuple_tuple;
    tmp_kw_name_15 = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_15 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 927;
    tmp_assign_source_62 = CALL_FUNCTION( tmp_called_name_59, tmp_args_name_15, tmp_kw_name_15 );
    Py_DECREF( tmp_called_name_59 );
    if ( tmp_assign_source_62 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_25;
    }
    goto condexpr_end_16;
    condexpr_false_16:;
    tmp_assign_source_62 = PyDict_New();
    condexpr_end_16:;
    assert( tmp_class_creation_8__prepared == NULL );
    tmp_class_creation_8__prepared = tmp_assign_source_62;

    tmp_set_locals = tmp_class_creation_8__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_ReturnReleaseModeMixin_927 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_27;
    }
    tmp_dictset_value = const_str_plain_ReturnReleaseModeMixin;
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_27;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_6c7e42fc2655943f084285a0d2beca7a_8, codeobj_6c7e42fc2655943f084285a0d2beca7a, module_codegen$Contexts, sizeof(void *) );
    frame_6c7e42fc2655943f084285a0d2beca7a_8 = cache_frame_6c7e42fc2655943f084285a0d2beca7a_8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c7e42fc2655943f084285a0d2beca7a_8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c7e42fc2655943f084285a0d2beca7a_8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_121___init__(  );
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 928;
        type_description_2 = "N";
        goto frame_exception_exit_8;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_122_setReturnReleaseMode(  );
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain_setReturnReleaseMode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 933;
        type_description_2 = "N";
        goto frame_exception_exit_8;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_123_getReturnReleaseMode(  );
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain_getReturnReleaseMode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 938;
        type_description_2 = "N";
        goto frame_exception_exit_8;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_124_setReturnTarget(  );
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain_setReturnTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 941;
        type_description_2 = "N";
        goto frame_exception_exit_8;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_125_getReturnTarget(  );
    tmp_res = PyObject_SetItem( locals_ReturnReleaseModeMixin_927, const_str_plain_getReturnTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description_2 = "N";
        goto frame_exception_exit_8;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c7e42fc2655943f084285a0d2beca7a_8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_7;

    frame_exception_exit_8:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c7e42fc2655943f084285a0d2beca7a_8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c7e42fc2655943f084285a0d2beca7a_8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c7e42fc2655943f084285a0d2beca7a_8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c7e42fc2655943f084285a0d2beca7a_8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c7e42fc2655943f084285a0d2beca7a_8,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_6c7e42fc2655943f084285a0d2beca7a_8 == cache_frame_6c7e42fc2655943f084285a0d2beca7a_8 )
    {
        Py_DECREF( frame_6c7e42fc2655943f084285a0d2beca7a_8 );
    }
    cache_frame_6c7e42fc2655943f084285a0d2beca7a_8 = NULL;

    assertFrameObject( frame_6c7e42fc2655943f084285a0d2beca7a_8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_7;

    frame_no_exception_7:;

    goto skip_nested_handling_7;
    nested_frame_exit_7:;

    goto try_except_handler_27;
    skip_nested_handling_7:;
    tmp_called_name_60 = tmp_class_creation_8__metaclass;

    CHECK_OBJECT( tmp_called_name_60 );
    tmp_tuple_element_14 = const_str_plain_ReturnReleaseModeMixin;
    tmp_args_name_16 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_16, 0, tmp_tuple_element_14 );
    tmp_tuple_element_14 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_16, 1, tmp_tuple_element_14 );
    tmp_tuple_element_14 = locals_ReturnReleaseModeMixin_927;
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_16, 2, tmp_tuple_element_14 );
    tmp_kw_name_16 = tmp_class_creation_8__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_16 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 927;
    tmp_assign_source_64 = CALL_FUNCTION( tmp_called_name_60, tmp_args_name_16, tmp_kw_name_16 );
    Py_DECREF( tmp_args_name_16 );
    if ( tmp_assign_source_64 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 927;

        goto try_except_handler_27;
    }
    assert( outline_7_var___class__ == NULL );
    outline_7_var___class__ = tmp_assign_source_64;

    tmp_outline_return_value_8 = outline_7_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_8 );
    Py_INCREF( tmp_outline_return_value_8 );
    goto try_return_handler_27;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_27:;
    Py_DECREF( locals_ReturnReleaseModeMixin_927 );
    locals_ReturnReleaseModeMixin_927 = NULL;
    goto try_return_handler_26;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_ReturnReleaseModeMixin_927 );
    locals_ReturnReleaseModeMixin_927 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto try_except_handler_26;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_26:;
    CHECK_OBJECT( (PyObject *)outline_7_var___class__ );
    Py_DECREF( outline_7_var___class__ );
    outline_7_var___class__ = NULL;

    goto outline_result_8;
    // Exception handler code:
    try_except_handler_26:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto outline_exception_8;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_8:;
    exception_lineno = 927;
    goto try_except_handler_25;
    outline_result_8:;
    tmp_assign_source_63 = tmp_outline_return_value_8;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin, tmp_assign_source_63 );
    goto try_end_11;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_decl_dict );
    Py_DECREF( tmp_class_creation_8__class_decl_dict );
    tmp_class_creation_8__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_8__prepared );
    tmp_class_creation_8__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_decl_dict );
    Py_DECREF( tmp_class_creation_8__class_decl_dict );
    tmp_class_creation_8__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__prepared );
    Py_DECREF( tmp_class_creation_8__prepared );
    tmp_class_creation_8__prepared = NULL;

    tmp_assign_source_65 = PyDict_New();
    assert( tmp_class_creation_9__class_decl_dict == NULL );
    tmp_class_creation_9__class_decl_dict = tmp_assign_source_65;

    // Tried code:
    tmp_key_name_25 = const_str_plain_metaclass;
    tmp_dict_name_25 = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_25 );
    tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    tmp_cond_value_17 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_17 = CHECK_IF_TRUE( tmp_cond_value_17 );
    if ( tmp_cond_truth_17 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    if ( tmp_cond_truth_17 == 1 )
    {
        goto condexpr_true_17;
    }
    else
    {
        goto condexpr_false_17;
    }
    condexpr_true_17:;
    tmp_dict_name_26 = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_26 );
    tmp_key_name_26 = const_str_plain_metaclass;
    tmp_metaclass_name_9 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
    if ( tmp_metaclass_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    goto condexpr_end_17;
    condexpr_false_17:;
    tmp_metaclass_name_9 = LOOKUP_BUILTIN( const_str_plain_type );
    assert( tmp_metaclass_name_9 != NULL );
    Py_INCREF( tmp_metaclass_name_9 );
    condexpr_end_17:;
    tmp_bases_name_9 = const_tuple_type_object_tuple;
    tmp_assign_source_66 = SELECT_METACLASS( tmp_metaclass_name_9, tmp_bases_name_9 );
    Py_DECREF( tmp_metaclass_name_9 );
    if ( tmp_assign_source_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    assert( tmp_class_creation_9__metaclass == NULL );
    tmp_class_creation_9__metaclass = tmp_assign_source_66;

    tmp_key_name_27 = const_str_plain_metaclass;
    tmp_dict_name_27 = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_27 );
    tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    tmp_cond_value_18 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_18 = CHECK_IF_TRUE( tmp_cond_value_18 );
    if ( tmp_cond_truth_18 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    if ( tmp_cond_truth_18 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_dictdel_dict = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    branch_no_10:;
    tmp_hasattr_source_9 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_9 );
    tmp_hasattr_attr_9 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_9, tmp_hasattr_attr_9 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_18;
    }
    else
    {
        goto condexpr_false_18;
    }
    condexpr_true_18:;
    tmp_source_name_9 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_called_name_61 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain___prepare__ );
    if ( tmp_called_name_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    tmp_args_name_17 = const_tuple_str_plain_ReturnValueNameMixin_tuple_type_object_tuple_tuple;
    tmp_kw_name_17 = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_17 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 950;
    tmp_assign_source_67 = CALL_FUNCTION( tmp_called_name_61, tmp_args_name_17, tmp_kw_name_17 );
    Py_DECREF( tmp_called_name_61 );
    if ( tmp_assign_source_67 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_28;
    }
    goto condexpr_end_18;
    condexpr_false_18:;
    tmp_assign_source_67 = PyDict_New();
    condexpr_end_18:;
    assert( tmp_class_creation_9__prepared == NULL );
    tmp_class_creation_9__prepared = tmp_assign_source_67;

    tmp_set_locals = tmp_class_creation_9__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_ReturnValueNameMixin_950 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_ReturnValueNameMixin_950, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_30;
    }
    tmp_dictset_value = const_str_plain_ReturnValueNameMixin;
    tmp_res = PyObject_SetItem( locals_ReturnValueNameMixin_950, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_30;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_486b646812c00d76f05648102465b41b_9, codeobj_486b646812c00d76f05648102465b41b, module_codegen$Contexts, sizeof(void *) );
    frame_486b646812c00d76f05648102465b41b_9 = cache_frame_486b646812c00d76f05648102465b41b_9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_486b646812c00d76f05648102465b41b_9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_486b646812c00d76f05648102465b41b_9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_126___init__(  );
    tmp_res = PyObject_SetItem( locals_ReturnValueNameMixin_950, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;
        type_description_2 = "N";
        goto frame_exception_exit_9;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_127_getReturnValueName(  );
    tmp_res = PyObject_SetItem( locals_ReturnValueNameMixin_950, const_str_plain_getReturnValueName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 954;
        type_description_2 = "N";
        goto frame_exception_exit_9;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_128_setReturnValueName(  );
    tmp_res = PyObject_SetItem( locals_ReturnValueNameMixin_950, const_str_plain_setReturnValueName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description_2 = "N";
        goto frame_exception_exit_9;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_486b646812c00d76f05648102465b41b_9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_8;

    frame_exception_exit_9:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_486b646812c00d76f05648102465b41b_9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_486b646812c00d76f05648102465b41b_9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_486b646812c00d76f05648102465b41b_9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_486b646812c00d76f05648102465b41b_9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_486b646812c00d76f05648102465b41b_9,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_486b646812c00d76f05648102465b41b_9 == cache_frame_486b646812c00d76f05648102465b41b_9 )
    {
        Py_DECREF( frame_486b646812c00d76f05648102465b41b_9 );
    }
    cache_frame_486b646812c00d76f05648102465b41b_9 = NULL;

    assertFrameObject( frame_486b646812c00d76f05648102465b41b_9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_8;

    frame_no_exception_8:;

    goto skip_nested_handling_8;
    nested_frame_exit_8:;

    goto try_except_handler_30;
    skip_nested_handling_8:;
    tmp_called_name_62 = tmp_class_creation_9__metaclass;

    CHECK_OBJECT( tmp_called_name_62 );
    tmp_tuple_element_15 = const_str_plain_ReturnValueNameMixin;
    tmp_args_name_18 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_15 );
    PyTuple_SET_ITEM( tmp_args_name_18, 0, tmp_tuple_element_15 );
    tmp_tuple_element_15 = const_tuple_type_object_tuple;
    Py_INCREF( tmp_tuple_element_15 );
    PyTuple_SET_ITEM( tmp_args_name_18, 1, tmp_tuple_element_15 );
    tmp_tuple_element_15 = locals_ReturnValueNameMixin_950;
    Py_INCREF( tmp_tuple_element_15 );
    PyTuple_SET_ITEM( tmp_args_name_18, 2, tmp_tuple_element_15 );
    tmp_kw_name_18 = tmp_class_creation_9__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_18 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 950;
    tmp_assign_source_69 = CALL_FUNCTION( tmp_called_name_62, tmp_args_name_18, tmp_kw_name_18 );
    Py_DECREF( tmp_args_name_18 );
    if ( tmp_assign_source_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 950;

        goto try_except_handler_30;
    }
    assert( outline_8_var___class__ == NULL );
    outline_8_var___class__ = tmp_assign_source_69;

    tmp_outline_return_value_9 = outline_8_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_9 );
    Py_INCREF( tmp_outline_return_value_9 );
    goto try_return_handler_30;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_30:;
    Py_DECREF( locals_ReturnValueNameMixin_950 );
    locals_ReturnValueNameMixin_950 = NULL;
    goto try_return_handler_29;
    // Exception handler code:
    try_except_handler_30:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_ReturnValueNameMixin_950 );
    locals_ReturnValueNameMixin_950 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto try_except_handler_29;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_29:;
    CHECK_OBJECT( (PyObject *)outline_8_var___class__ );
    Py_DECREF( outline_8_var___class__ );
    outline_8_var___class__ = NULL;

    goto outline_result_9;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto outline_exception_9;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_9:;
    exception_lineno = 950;
    goto try_except_handler_28;
    outline_result_9:;
    tmp_assign_source_68 = tmp_outline_return_value_9;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin, tmp_assign_source_68 );
    goto try_end_12;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_decl_dict );
    Py_DECREF( tmp_class_creation_9__class_decl_dict );
    tmp_class_creation_9__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_9__prepared );
    tmp_class_creation_9__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_decl_dict );
    Py_DECREF( tmp_class_creation_9__class_decl_dict );
    tmp_class_creation_9__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__prepared );
    Py_DECREF( tmp_class_creation_9__prepared );
    tmp_class_creation_9__prepared = NULL;

    // Tried code:
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_TempMixin );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TempMixin );
    }

    if ( tmp_tuple_element_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TempMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 966;

        goto try_except_handler_31;
    }

    tmp_assign_source_70 = PyTuple_New( 6 );
    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 0, tmp_tuple_element_16 );
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_CodeObjectsMixin );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CodeObjectsMixin );
    }

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_assign_source_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CodeObjectsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 966;

        goto try_except_handler_31;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 1, tmp_tuple_element_16 );
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );
    }

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_assign_source_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "FrameDeclarationsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;

        goto try_except_handler_31;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 2, tmp_tuple_element_16 );
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_assign_source_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;

        goto try_except_handler_31;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 3, tmp_tuple_element_16 );
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_assign_source_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 968;

        goto try_except_handler_31;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 4, tmp_tuple_element_16 );
    tmp_tuple_element_16 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonContextBase );

    if (unlikely( tmp_tuple_element_16 == NULL ))
    {
        tmp_tuple_element_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonContextBase );
    }

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_assign_source_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 968;

        goto try_except_handler_31;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_assign_source_70, 5, tmp_tuple_element_16 );
    assert( tmp_class_creation_10__bases == NULL );
    tmp_class_creation_10__bases = tmp_assign_source_70;

    tmp_assign_source_71 = PyDict_New();
    assert( tmp_class_creation_10__class_decl_dict == NULL );
    tmp_class_creation_10__class_decl_dict = tmp_assign_source_71;

    tmp_key_name_28 = const_str_plain_metaclass;
    tmp_dict_name_28 = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_28 );
    tmp_res = PyDict_Contains( tmp_dict_name_28, tmp_key_name_28 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    tmp_cond_value_19 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_19 = CHECK_IF_TRUE( tmp_cond_value_19 );
    if ( tmp_cond_truth_19 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    if ( tmp_cond_truth_19 == 1 )
    {
        goto condexpr_true_19;
    }
    else
    {
        goto condexpr_false_19;
    }
    condexpr_true_19:;
    tmp_dict_name_29 = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_29 );
    tmp_key_name_29 = const_str_plain_metaclass;
    tmp_metaclass_name_10 = DICT_GET_ITEM( tmp_dict_name_29, tmp_key_name_29 );
    if ( tmp_metaclass_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    goto condexpr_end_19;
    condexpr_false_19:;
    tmp_subscribed_name_4 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_type_arg_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_type_arg_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    tmp_metaclass_name_10 = BUILTIN_TYPE1( tmp_type_arg_4 );
    Py_DECREF( tmp_type_arg_4 );
    if ( tmp_metaclass_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    condexpr_end_19:;
    tmp_bases_name_10 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_bases_name_10 );
    tmp_assign_source_72 = SELECT_METACLASS( tmp_metaclass_name_10, tmp_bases_name_10 );
    Py_DECREF( tmp_metaclass_name_10 );
    if ( tmp_assign_source_72 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    assert( tmp_class_creation_10__metaclass == NULL );
    tmp_class_creation_10__metaclass = tmp_assign_source_72;

    tmp_key_name_30 = const_str_plain_metaclass;
    tmp_dict_name_30 = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_30 );
    tmp_res = PyDict_Contains( tmp_dict_name_30, tmp_key_name_30 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    tmp_cond_value_20 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_20 = CHECK_IF_TRUE( tmp_cond_value_20 );
    if ( tmp_cond_truth_20 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    if ( tmp_cond_truth_20 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_dictdel_dict = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    branch_no_11:;
    tmp_hasattr_source_10 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_10 );
    tmp_hasattr_attr_10 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_10, tmp_hasattr_attr_10 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_20;
    }
    else
    {
        goto condexpr_false_20;
    }
    condexpr_true_20:;
    tmp_source_name_10 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_called_name_63 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___prepare__ );
    if ( tmp_called_name_63 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    tmp_tuple_element_17 = const_str_plain_PythonModuleContext;
    tmp_args_name_19 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_args_name_19, 0, tmp_tuple_element_17 );
    tmp_tuple_element_17 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_tuple_element_17 );
    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_args_name_19, 1, tmp_tuple_element_17 );
    tmp_kw_name_19 = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_19 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 968;
    tmp_assign_source_73 = CALL_FUNCTION( tmp_called_name_63, tmp_args_name_19, tmp_kw_name_19 );
    Py_DECREF( tmp_called_name_63 );
    Py_DECREF( tmp_args_name_19 );
    if ( tmp_assign_source_73 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_31;
    }
    goto condexpr_end_20;
    condexpr_false_20:;
    tmp_assign_source_73 = PyDict_New();
    condexpr_end_20:;
    assert( tmp_class_creation_10__prepared == NULL );
    tmp_class_creation_10__prepared = tmp_assign_source_73;

    tmp_set_locals = tmp_class_creation_10__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonModuleContext_968 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_33;
    }
    tmp_dictset_value = const_str_plain_PythonModuleContext;
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_33;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_fae641ec8eec5d068fe3d2c09c05647e_10, codeobj_fae641ec8eec5d068fe3d2c09c05647e, module_codegen$Contexts, sizeof(void *) );
    frame_fae641ec8eec5d068fe3d2c09c05647e_10 = cache_frame_fae641ec8eec5d068fe3d2c09c05647e_10;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fae641ec8eec5d068fe3d2c09c05647e_10 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fae641ec8eec5d068fe3d2c09c05647e_10 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_129___init__(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 972;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_130___repr__(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_131_getOwner(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getOwner, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1002;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_132_getEntryPoint(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getEntryPoint, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1005;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_133_isCompiledPythonModule(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_isCompiledPythonModule, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_134_getName(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1011;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_135_getFilename(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getFilename, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1014;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_136_mayRaiseException(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_mayRaiseException, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = PyObject_GetItem( locals_PythonModuleContext_968, const_str_plain_getName );

    if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getName" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1022;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }

    if ( tmp_dictset_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getModuleName, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_137_getModuleCodeName(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getModuleCodeName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1024;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_138_setFrameGuardMode(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_setFrameGuardMode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_139_addHelperCode(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_addHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1030;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_140_hasHelperCode(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_hasHelperCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1035;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_141_getHelperCodes(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getHelperCodes, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1038;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_142_addDeclaration(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_addDeclaration, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1041;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_143_getDeclarations(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getDeclarations, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1046;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_144_mayRecurse(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_mayRecurse, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1049;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_145_getConstantCode(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getConstantCode, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_146_getConstants(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_getConstants, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_147_markAsNeedsModuleFilenameObject(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_markAsNeedsModuleFilenameObject, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1064;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_148_needsModuleFilenameObject(  );
    tmp_res = PyObject_SetItem( locals_PythonModuleContext_968, const_str_plain_needsModuleFilenameObject, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1067;
        type_description_2 = "N";
        goto frame_exception_exit_10;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae641ec8eec5d068fe3d2c09c05647e_10 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_9;

    frame_exception_exit_10:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae641ec8eec5d068fe3d2c09c05647e_10 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fae641ec8eec5d068fe3d2c09c05647e_10, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fae641ec8eec5d068fe3d2c09c05647e_10->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fae641ec8eec5d068fe3d2c09c05647e_10, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fae641ec8eec5d068fe3d2c09c05647e_10,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_fae641ec8eec5d068fe3d2c09c05647e_10 == cache_frame_fae641ec8eec5d068fe3d2c09c05647e_10 )
    {
        Py_DECREF( frame_fae641ec8eec5d068fe3d2c09c05647e_10 );
    }
    cache_frame_fae641ec8eec5d068fe3d2c09c05647e_10 = NULL;

    assertFrameObject( frame_fae641ec8eec5d068fe3d2c09c05647e_10 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_9;

    frame_no_exception_9:;

    goto skip_nested_handling_9;
    nested_frame_exit_9:;

    goto try_except_handler_33;
    skip_nested_handling_9:;
    tmp_called_name_64 = tmp_class_creation_10__metaclass;

    CHECK_OBJECT( tmp_called_name_64 );
    tmp_tuple_element_18 = const_str_plain_PythonModuleContext;
    tmp_args_name_20 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_args_name_20, 0, tmp_tuple_element_18 );
    tmp_tuple_element_18 = tmp_class_creation_10__bases;

    CHECK_OBJECT( tmp_tuple_element_18 );
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_args_name_20, 1, tmp_tuple_element_18 );
    tmp_tuple_element_18 = locals_PythonModuleContext_968;
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_args_name_20, 2, tmp_tuple_element_18 );
    tmp_kw_name_20 = tmp_class_creation_10__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_20 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 968;
    tmp_assign_source_75 = CALL_FUNCTION( tmp_called_name_64, tmp_args_name_20, tmp_kw_name_20 );
    Py_DECREF( tmp_args_name_20 );
    if ( tmp_assign_source_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 968;

        goto try_except_handler_33;
    }
    assert( outline_9_var___class__ == NULL );
    outline_9_var___class__ = tmp_assign_source_75;

    tmp_outline_return_value_10 = outline_9_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_10 );
    Py_INCREF( tmp_outline_return_value_10 );
    goto try_return_handler_33;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_33:;
    Py_DECREF( locals_PythonModuleContext_968 );
    locals_PythonModuleContext_968 = NULL;
    goto try_return_handler_32;
    // Exception handler code:
    try_except_handler_33:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonModuleContext_968 );
    locals_PythonModuleContext_968 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto try_except_handler_32;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_32:;
    CHECK_OBJECT( (PyObject *)outline_9_var___class__ );
    Py_DECREF( outline_9_var___class__ );
    outline_9_var___class__ = NULL;

    goto outline_result_10;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_32 = exception_type;
    exception_keeper_value_32 = exception_value;
    exception_keeper_tb_32 = exception_tb;
    exception_keeper_lineno_32 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_32;
    exception_value = exception_keeper_value_32;
    exception_tb = exception_keeper_tb_32;
    exception_lineno = exception_keeper_lineno_32;

    goto outline_exception_10;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_10:;
    exception_lineno = 968;
    goto try_except_handler_31;
    outline_result_10:;
    tmp_assign_source_74 = tmp_outline_return_value_10;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonModuleContext, tmp_assign_source_74 );
    goto try_end_13;
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_decl_dict );
    tmp_class_creation_10__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_10__prepared );
    tmp_class_creation_10__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_decl_dict );
    Py_DECREF( tmp_class_creation_10__class_decl_dict );
    tmp_class_creation_10__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__prepared );
    Py_DECREF( tmp_class_creation_10__prepared );
    tmp_class_creation_10__prepared = NULL;

    // Tried code:
    tmp_tuple_element_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );

    if (unlikely( tmp_tuple_element_19 == NULL ))
    {
        tmp_tuple_element_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FrameDeclarationsMixin );
    }

    if ( tmp_tuple_element_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "FrameDeclarationsMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1071;

        goto try_except_handler_34;
    }

    tmp_assign_source_76 = PyTuple_New( 5 );
    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_assign_source_76, 0, tmp_tuple_element_19 );
    tmp_tuple_element_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_TempMixin );

    if (unlikely( tmp_tuple_element_19 == NULL ))
    {
        tmp_tuple_element_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TempMixin );
    }

    if ( tmp_tuple_element_19 == NULL )
    {
        Py_DECREF( tmp_assign_source_76 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TempMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1072;

        goto try_except_handler_34;
    }

    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_assign_source_76, 1, tmp_tuple_element_19 );
    tmp_tuple_element_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_tuple_element_19 == NULL ))
    {
        tmp_tuple_element_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_tuple_element_19 == NULL )
    {
        Py_DECREF( tmp_assign_source_76 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1072;

        goto try_except_handler_34;
    }

    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_assign_source_76, 2, tmp_tuple_element_19 );
    tmp_tuple_element_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_tuple_element_19 == NULL ))
    {
        tmp_tuple_element_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_tuple_element_19 == NULL )
    {
        Py_DECREF( tmp_assign_source_76 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1073;

        goto try_except_handler_34;
    }

    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_assign_source_76, 3, tmp_tuple_element_19 );
    tmp_tuple_element_19 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );

    if (unlikely( tmp_tuple_element_19 == NULL ))
    {
        tmp_tuple_element_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );
    }

    if ( tmp_tuple_element_19 == NULL )
    {
        Py_DECREF( tmp_assign_source_76 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonChildContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1073;

        goto try_except_handler_34;
    }

    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_assign_source_76, 4, tmp_tuple_element_19 );
    assert( tmp_class_creation_11__bases == NULL );
    tmp_class_creation_11__bases = tmp_assign_source_76;

    tmp_assign_source_77 = PyDict_New();
    assert( tmp_class_creation_11__class_decl_dict == NULL );
    tmp_class_creation_11__class_decl_dict = tmp_assign_source_77;

    tmp_key_name_31 = const_str_plain_metaclass;
    tmp_dict_name_31 = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_31 );
    tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    tmp_cond_value_21 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_21 = CHECK_IF_TRUE( tmp_cond_value_21 );
    if ( tmp_cond_truth_21 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    if ( tmp_cond_truth_21 == 1 )
    {
        goto condexpr_true_21;
    }
    else
    {
        goto condexpr_false_21;
    }
    condexpr_true_21:;
    tmp_dict_name_32 = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_32 );
    tmp_key_name_32 = const_str_plain_metaclass;
    tmp_metaclass_name_11 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
    if ( tmp_metaclass_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    goto condexpr_end_21;
    condexpr_false_21:;
    tmp_subscribed_name_5 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_0;
    tmp_type_arg_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_type_arg_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    tmp_metaclass_name_11 = BUILTIN_TYPE1( tmp_type_arg_5 );
    Py_DECREF( tmp_type_arg_5 );
    if ( tmp_metaclass_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    condexpr_end_21:;
    tmp_bases_name_11 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_bases_name_11 );
    tmp_assign_source_78 = SELECT_METACLASS( tmp_metaclass_name_11, tmp_bases_name_11 );
    Py_DECREF( tmp_metaclass_name_11 );
    if ( tmp_assign_source_78 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    assert( tmp_class_creation_11__metaclass == NULL );
    tmp_class_creation_11__metaclass = tmp_assign_source_78;

    tmp_key_name_33 = const_str_plain_metaclass;
    tmp_dict_name_33 = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_33 );
    tmp_res = PyDict_Contains( tmp_dict_name_33, tmp_key_name_33 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    tmp_cond_value_22 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_22 = CHECK_IF_TRUE( tmp_cond_value_22 );
    if ( tmp_cond_truth_22 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    if ( tmp_cond_truth_22 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_dictdel_dict = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    branch_no_12:;
    tmp_hasattr_source_11 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_11 );
    tmp_hasattr_attr_11 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_11, tmp_hasattr_attr_11 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_22;
    }
    else
    {
        goto condexpr_false_22;
    }
    condexpr_true_22:;
    tmp_source_name_11 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_called_name_65 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain___prepare__ );
    if ( tmp_called_name_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    tmp_tuple_element_20 = const_str_plain_PythonFunctionContext;
    tmp_args_name_21 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_args_name_21, 0, tmp_tuple_element_20 );
    tmp_tuple_element_20 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_tuple_element_20 );
    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_args_name_21, 1, tmp_tuple_element_20 );
    tmp_kw_name_21 = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_21 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1073;
    tmp_assign_source_79 = CALL_FUNCTION( tmp_called_name_65, tmp_args_name_21, tmp_kw_name_21 );
    Py_DECREF( tmp_called_name_65 );
    Py_DECREF( tmp_args_name_21 );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_34;
    }
    goto condexpr_end_22;
    condexpr_false_22:;
    tmp_assign_source_79 = PyDict_New();
    condexpr_end_22:;
    assert( tmp_class_creation_11__prepared == NULL );
    tmp_class_creation_11__prepared = tmp_assign_source_79;

    tmp_set_locals = tmp_class_creation_11__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonFunctionContext_1073 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_36;
    }
    tmp_dictset_value = const_str_plain_PythonFunctionContext;
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_36;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_d392c7b9f3b90fb3dd6cdc42524742b3_11, codeobj_d392c7b9f3b90fb3dd6cdc42524742b3, module_codegen$Contexts, sizeof(void *) );
    frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 = cache_frame_d392c7b9f3b90fb3dd6cdc42524742b3_11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_149___init__(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1074;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_150___repr__(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain___repr__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_151_getFunction(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain_getFunction, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1098;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_152_getOwner(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain_getOwner, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1101;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_153_getEntryPoint(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain_getEntryPoint, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1104;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_154_mayRecurse(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain_mayRecurse, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1107;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_155_getCodeObjectHandle(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionContext_1073, const_str_plain_getCodeObjectHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1111;
        type_description_2 = "N";
        goto frame_exception_exit_11;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_10;

    frame_exception_exit_11:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d392c7b9f3b90fb3dd6cdc42524742b3_11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d392c7b9f3b90fb3dd6cdc42524742b3_11, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d392c7b9f3b90fb3dd6cdc42524742b3_11,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 == cache_frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 )
    {
        Py_DECREF( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 );
    }
    cache_frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 = NULL;

    assertFrameObject( frame_d392c7b9f3b90fb3dd6cdc42524742b3_11 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_10;

    frame_no_exception_10:;

    goto skip_nested_handling_10;
    nested_frame_exit_10:;

    goto try_except_handler_36;
    skip_nested_handling_10:;
    tmp_called_name_66 = tmp_class_creation_11__metaclass;

    CHECK_OBJECT( tmp_called_name_66 );
    tmp_tuple_element_21 = const_str_plain_PythonFunctionContext;
    tmp_args_name_22 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_args_name_22, 0, tmp_tuple_element_21 );
    tmp_tuple_element_21 = tmp_class_creation_11__bases;

    CHECK_OBJECT( tmp_tuple_element_21 );
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_args_name_22, 1, tmp_tuple_element_21 );
    tmp_tuple_element_21 = locals_PythonFunctionContext_1073;
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_args_name_22, 2, tmp_tuple_element_21 );
    tmp_kw_name_22 = tmp_class_creation_11__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_22 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1073;
    tmp_assign_source_81 = CALL_FUNCTION( tmp_called_name_66, tmp_args_name_22, tmp_kw_name_22 );
    Py_DECREF( tmp_args_name_22 );
    if ( tmp_assign_source_81 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1073;

        goto try_except_handler_36;
    }
    assert( outline_10_var___class__ == NULL );
    outline_10_var___class__ = tmp_assign_source_81;

    tmp_outline_return_value_11 = outline_10_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_11 );
    Py_INCREF( tmp_outline_return_value_11 );
    goto try_return_handler_36;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_36:;
    Py_DECREF( locals_PythonFunctionContext_1073 );
    locals_PythonFunctionContext_1073 = NULL;
    goto try_return_handler_35;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_34 = exception_type;
    exception_keeper_value_34 = exception_value;
    exception_keeper_tb_34 = exception_tb;
    exception_keeper_lineno_34 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonFunctionContext_1073 );
    locals_PythonFunctionContext_1073 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_34;
    exception_value = exception_keeper_value_34;
    exception_tb = exception_keeper_tb_34;
    exception_lineno = exception_keeper_lineno_34;

    goto try_except_handler_35;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_35:;
    CHECK_OBJECT( (PyObject *)outline_10_var___class__ );
    Py_DECREF( outline_10_var___class__ );
    outline_10_var___class__ = NULL;

    goto outline_result_11;
    // Exception handler code:
    try_except_handler_35:;
    exception_keeper_type_35 = exception_type;
    exception_keeper_value_35 = exception_value;
    exception_keeper_tb_35 = exception_tb;
    exception_keeper_lineno_35 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_35;
    exception_value = exception_keeper_value_35;
    exception_tb = exception_keeper_tb_35;
    exception_lineno = exception_keeper_lineno_35;

    goto outline_exception_11;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_11:;
    exception_lineno = 1073;
    goto try_except_handler_34;
    outline_result_11:;
    tmp_assign_source_80 = tmp_outline_return_value_11;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext, tmp_assign_source_80 );
    goto try_end_14;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF( tmp_class_creation_11__class_decl_dict );
    tmp_class_creation_11__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_11__prepared );
    tmp_class_creation_11__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_decl_dict );
    Py_DECREF( tmp_class_creation_11__class_decl_dict );
    tmp_class_creation_11__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__prepared );
    Py_DECREF( tmp_class_creation_11__prepared );
    tmp_class_creation_11__prepared = NULL;

    // Tried code:
    tmp_tuple_element_22 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );

    if (unlikely( tmp_tuple_element_22 == NULL ))
    {
        tmp_tuple_element_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );
    }

    if ( tmp_tuple_element_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonFunctionContext" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1115;

        goto try_except_handler_37;
    }

    tmp_assign_source_82 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_assign_source_82, 0, tmp_tuple_element_22 );
    assert( tmp_class_creation_12__bases == NULL );
    tmp_class_creation_12__bases = tmp_assign_source_82;

    tmp_assign_source_83 = PyDict_New();
    assert( tmp_class_creation_12__class_decl_dict == NULL );
    tmp_class_creation_12__class_decl_dict = tmp_assign_source_83;

    tmp_key_name_34 = const_str_plain_metaclass;
    tmp_dict_name_34 = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_34 );
    tmp_res = PyDict_Contains( tmp_dict_name_34, tmp_key_name_34 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    tmp_cond_value_23 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_23 = CHECK_IF_TRUE( tmp_cond_value_23 );
    if ( tmp_cond_truth_23 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    if ( tmp_cond_truth_23 == 1 )
    {
        goto condexpr_true_23;
    }
    else
    {
        goto condexpr_false_23;
    }
    condexpr_true_23:;
    tmp_dict_name_35 = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_35 );
    tmp_key_name_35 = const_str_plain_metaclass;
    tmp_metaclass_name_12 = DICT_GET_ITEM( tmp_dict_name_35, tmp_key_name_35 );
    if ( tmp_metaclass_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    goto condexpr_end_23;
    condexpr_false_23:;
    tmp_subscribed_name_6 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_0;
    tmp_type_arg_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_type_arg_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    tmp_metaclass_name_12 = BUILTIN_TYPE1( tmp_type_arg_6 );
    Py_DECREF( tmp_type_arg_6 );
    if ( tmp_metaclass_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    condexpr_end_23:;
    tmp_bases_name_12 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_bases_name_12 );
    tmp_assign_source_84 = SELECT_METACLASS( tmp_metaclass_name_12, tmp_bases_name_12 );
    Py_DECREF( tmp_metaclass_name_12 );
    if ( tmp_assign_source_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    assert( tmp_class_creation_12__metaclass == NULL );
    tmp_class_creation_12__metaclass = tmp_assign_source_84;

    tmp_key_name_36 = const_str_plain_metaclass;
    tmp_dict_name_36 = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_36 );
    tmp_res = PyDict_Contains( tmp_dict_name_36, tmp_key_name_36 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    tmp_cond_value_24 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_24 = CHECK_IF_TRUE( tmp_cond_value_24 );
    if ( tmp_cond_truth_24 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    if ( tmp_cond_truth_24 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_dictdel_dict = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    branch_no_13:;
    tmp_hasattr_source_12 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_12 );
    tmp_hasattr_attr_12 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_12, tmp_hasattr_attr_12 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_24;
    }
    else
    {
        goto condexpr_false_24;
    }
    condexpr_true_24:;
    tmp_source_name_12 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_called_name_67 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain___prepare__ );
    if ( tmp_called_name_67 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    tmp_tuple_element_23 = const_str_plain_PythonFunctionDirectContext;
    tmp_args_name_23 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_23 );
    PyTuple_SET_ITEM( tmp_args_name_23, 0, tmp_tuple_element_23 );
    tmp_tuple_element_23 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_tuple_element_23 );
    Py_INCREF( tmp_tuple_element_23 );
    PyTuple_SET_ITEM( tmp_args_name_23, 1, tmp_tuple_element_23 );
    tmp_kw_name_23 = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_23 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1115;
    tmp_assign_source_85 = CALL_FUNCTION( tmp_called_name_67, tmp_args_name_23, tmp_kw_name_23 );
    Py_DECREF( tmp_called_name_67 );
    Py_DECREF( tmp_args_name_23 );
    if ( tmp_assign_source_85 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_37;
    }
    goto condexpr_end_24;
    condexpr_false_24:;
    tmp_assign_source_85 = PyDict_New();
    condexpr_end_24:;
    assert( tmp_class_creation_12__prepared == NULL );
    tmp_class_creation_12__prepared = tmp_assign_source_85;

    tmp_set_locals = tmp_class_creation_12__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonFunctionDirectContext_1115 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonFunctionDirectContext_1115, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_39;
    }
    tmp_dictset_value = const_str_plain_PythonFunctionDirectContext;
    tmp_res = PyObject_SetItem( locals_PythonFunctionDirectContext_1115, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_39;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_b594da56adba1a1498a3a92440907540_12, codeobj_b594da56adba1a1498a3a92440907540, module_codegen$Contexts, sizeof(void *) );
    frame_b594da56adba1a1498a3a92440907540_12 = cache_frame_b594da56adba1a1498a3a92440907540_12;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b594da56adba1a1498a3a92440907540_12 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b594da56adba1a1498a3a92440907540_12 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_156_isForDirectCall(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionDirectContext_1115, const_str_plain_isForDirectCall, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1116;
        type_description_2 = "N";
        goto frame_exception_exit_12;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_157_isForCrossModuleUsage(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionDirectContext_1115, const_str_plain_isForCrossModuleUsage, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description_2 = "N";
        goto frame_exception_exit_12;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_158_isForCreatedFunction(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionDirectContext_1115, const_str_plain_isForCreatedFunction, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;
        type_description_2 = "N";
        goto frame_exception_exit_12;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b594da56adba1a1498a3a92440907540_12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_11;

    frame_exception_exit_12:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b594da56adba1a1498a3a92440907540_12 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b594da56adba1a1498a3a92440907540_12, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b594da56adba1a1498a3a92440907540_12->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b594da56adba1a1498a3a92440907540_12, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b594da56adba1a1498a3a92440907540_12,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_b594da56adba1a1498a3a92440907540_12 == cache_frame_b594da56adba1a1498a3a92440907540_12 )
    {
        Py_DECREF( frame_b594da56adba1a1498a3a92440907540_12 );
    }
    cache_frame_b594da56adba1a1498a3a92440907540_12 = NULL;

    assertFrameObject( frame_b594da56adba1a1498a3a92440907540_12 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_11;

    frame_no_exception_11:;

    goto skip_nested_handling_11;
    nested_frame_exit_11:;

    goto try_except_handler_39;
    skip_nested_handling_11:;
    tmp_called_name_68 = tmp_class_creation_12__metaclass;

    CHECK_OBJECT( tmp_called_name_68 );
    tmp_tuple_element_24 = const_str_plain_PythonFunctionDirectContext;
    tmp_args_name_24 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_args_name_24, 0, tmp_tuple_element_24 );
    tmp_tuple_element_24 = tmp_class_creation_12__bases;

    CHECK_OBJECT( tmp_tuple_element_24 );
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_args_name_24, 1, tmp_tuple_element_24 );
    tmp_tuple_element_24 = locals_PythonFunctionDirectContext_1115;
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_args_name_24, 2, tmp_tuple_element_24 );
    tmp_kw_name_24 = tmp_class_creation_12__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_24 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1115;
    tmp_assign_source_87 = CALL_FUNCTION( tmp_called_name_68, tmp_args_name_24, tmp_kw_name_24 );
    Py_DECREF( tmp_args_name_24 );
    if ( tmp_assign_source_87 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;

        goto try_except_handler_39;
    }
    assert( outline_11_var___class__ == NULL );
    outline_11_var___class__ = tmp_assign_source_87;

    tmp_outline_return_value_12 = outline_11_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_12 );
    Py_INCREF( tmp_outline_return_value_12 );
    goto try_return_handler_39;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_39:;
    Py_DECREF( locals_PythonFunctionDirectContext_1115 );
    locals_PythonFunctionDirectContext_1115 = NULL;
    goto try_return_handler_38;
    // Exception handler code:
    try_except_handler_39:;
    exception_keeper_type_37 = exception_type;
    exception_keeper_value_37 = exception_value;
    exception_keeper_tb_37 = exception_tb;
    exception_keeper_lineno_37 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonFunctionDirectContext_1115 );
    locals_PythonFunctionDirectContext_1115 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_37;
    exception_value = exception_keeper_value_37;
    exception_tb = exception_keeper_tb_37;
    exception_lineno = exception_keeper_lineno_37;

    goto try_except_handler_38;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_38:;
    CHECK_OBJECT( (PyObject *)outline_11_var___class__ );
    Py_DECREF( outline_11_var___class__ );
    outline_11_var___class__ = NULL;

    goto outline_result_12;
    // Exception handler code:
    try_except_handler_38:;
    exception_keeper_type_38 = exception_type;
    exception_keeper_value_38 = exception_value;
    exception_keeper_tb_38 = exception_tb;
    exception_keeper_lineno_38 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_38;
    exception_value = exception_keeper_value_38;
    exception_tb = exception_keeper_tb_38;
    exception_lineno = exception_keeper_lineno_38;

    goto outline_exception_12;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_12:;
    exception_lineno = 1115;
    goto try_except_handler_37;
    outline_result_12:;
    tmp_assign_source_86 = tmp_outline_return_value_12;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionDirectContext, tmp_assign_source_86 );
    goto try_end_15;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_39 = exception_type;
    exception_keeper_value_39 = exception_value;
    exception_keeper_tb_39 = exception_tb;
    exception_keeper_lineno_39 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    Py_XDECREF( tmp_class_creation_12__class_decl_dict );
    tmp_class_creation_12__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_12__prepared );
    tmp_class_creation_12__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_39;
    exception_value = exception_keeper_value_39;
    exception_tb = exception_keeper_tb_39;
    exception_lineno = exception_keeper_lineno_39;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__bases );
    Py_DECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_decl_dict );
    Py_DECREF( tmp_class_creation_12__class_decl_dict );
    tmp_class_creation_12__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__prepared );
    Py_DECREF( tmp_class_creation_12__prepared );
    tmp_class_creation_12__prepared = NULL;

    // Tried code:
    tmp_tuple_element_25 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );

    if (unlikely( tmp_tuple_element_25 == NULL ))
    {
        tmp_tuple_element_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );
    }

    if ( tmp_tuple_element_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonFunctionContext" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1126;

        goto try_except_handler_40;
    }

    tmp_assign_source_88 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_25 );
    PyTuple_SET_ITEM( tmp_assign_source_88, 0, tmp_tuple_element_25 );
    assert( tmp_class_creation_13__bases == NULL );
    tmp_class_creation_13__bases = tmp_assign_source_88;

    tmp_assign_source_89 = PyDict_New();
    assert( tmp_class_creation_13__class_decl_dict == NULL );
    tmp_class_creation_13__class_decl_dict = tmp_assign_source_89;

    tmp_key_name_37 = const_str_plain_metaclass;
    tmp_dict_name_37 = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_37 );
    tmp_res = PyDict_Contains( tmp_dict_name_37, tmp_key_name_37 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    tmp_cond_value_25 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_25 = CHECK_IF_TRUE( tmp_cond_value_25 );
    if ( tmp_cond_truth_25 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    if ( tmp_cond_truth_25 == 1 )
    {
        goto condexpr_true_25;
    }
    else
    {
        goto condexpr_false_25;
    }
    condexpr_true_25:;
    tmp_dict_name_38 = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_38 );
    tmp_key_name_38 = const_str_plain_metaclass;
    tmp_metaclass_name_13 = DICT_GET_ITEM( tmp_dict_name_38, tmp_key_name_38 );
    if ( tmp_metaclass_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    goto condexpr_end_25;
    condexpr_false_25:;
    tmp_subscribed_name_7 = tmp_class_creation_13__bases;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_type_arg_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_type_arg_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    tmp_metaclass_name_13 = BUILTIN_TYPE1( tmp_type_arg_7 );
    Py_DECREF( tmp_type_arg_7 );
    if ( tmp_metaclass_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    condexpr_end_25:;
    tmp_bases_name_13 = tmp_class_creation_13__bases;

    CHECK_OBJECT( tmp_bases_name_13 );
    tmp_assign_source_90 = SELECT_METACLASS( tmp_metaclass_name_13, tmp_bases_name_13 );
    Py_DECREF( tmp_metaclass_name_13 );
    if ( tmp_assign_source_90 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    assert( tmp_class_creation_13__metaclass == NULL );
    tmp_class_creation_13__metaclass = tmp_assign_source_90;

    tmp_key_name_39 = const_str_plain_metaclass;
    tmp_dict_name_39 = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_39 );
    tmp_res = PyDict_Contains( tmp_dict_name_39, tmp_key_name_39 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    tmp_cond_value_26 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_26 = CHECK_IF_TRUE( tmp_cond_value_26 );
    if ( tmp_cond_truth_26 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    if ( tmp_cond_truth_26 == 1 )
    {
        goto branch_yes_14;
    }
    else
    {
        goto branch_no_14;
    }
    branch_yes_14:;
    tmp_dictdel_dict = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    branch_no_14:;
    tmp_hasattr_source_13 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_13 );
    tmp_hasattr_attr_13 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_13, tmp_hasattr_attr_13 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_26;
    }
    else
    {
        goto condexpr_false_26;
    }
    condexpr_true_26:;
    tmp_source_name_13 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_called_name_69 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain___prepare__ );
    if ( tmp_called_name_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    tmp_tuple_element_26 = const_str_plain_PythonGeneratorObjectContext;
    tmp_args_name_25 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_args_name_25, 0, tmp_tuple_element_26 );
    tmp_tuple_element_26 = tmp_class_creation_13__bases;

    CHECK_OBJECT( tmp_tuple_element_26 );
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_args_name_25, 1, tmp_tuple_element_26 );
    tmp_kw_name_25 = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_25 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1126;
    tmp_assign_source_91 = CALL_FUNCTION( tmp_called_name_69, tmp_args_name_25, tmp_kw_name_25 );
    Py_DECREF( tmp_called_name_69 );
    Py_DECREF( tmp_args_name_25 );
    if ( tmp_assign_source_91 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_40;
    }
    goto condexpr_end_26;
    condexpr_false_26:;
    tmp_assign_source_91 = PyDict_New();
    condexpr_end_26:;
    assert( tmp_class_creation_13__prepared == NULL );
    tmp_class_creation_13__prepared = tmp_assign_source_91;

    tmp_set_locals = tmp_class_creation_13__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonGeneratorObjectContext_1126 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_42;
    }
    tmp_dictset_value = const_str_plain_PythonGeneratorObjectContext;
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_42;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_3d3abe187d18270ac2a8ce626f258fc6_13, codeobj_3d3abe187d18270ac2a8ce626f258fc6, module_codegen$Contexts, sizeof(void *) );
    frame_3d3abe187d18270ac2a8ce626f258fc6_13 = cache_frame_3d3abe187d18270ac2a8ce626f258fc6_13;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3d3abe187d18270ac2a8ce626f258fc6_13 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3d3abe187d18270ac2a8ce626f258fc6_13 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_159_isForDirectCall(  );
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain_isForDirectCall, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1127;
        type_description_2 = "N";
        goto frame_exception_exit_13;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_160_isForCrossModuleUsage(  );
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain_isForCrossModuleUsage, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1130;
        type_description_2 = "N";
        goto frame_exception_exit_13;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_161_isForCreatedFunction(  );
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain_isForCreatedFunction, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1133;
        type_description_2 = "N";
        goto frame_exception_exit_13;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_162_getContextObjectName(  );
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain_getContextObjectName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1136;
        type_description_2 = "N";
        goto frame_exception_exit_13;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_163_getGeneratorReturnValueName(  );
    tmp_res = PyObject_SetItem( locals_PythonGeneratorObjectContext_1126, const_str_plain_getGeneratorReturnValueName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1139;
        type_description_2 = "N";
        goto frame_exception_exit_13;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d3abe187d18270ac2a8ce626f258fc6_13 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_12;

    frame_exception_exit_13:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d3abe187d18270ac2a8ce626f258fc6_13 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3d3abe187d18270ac2a8ce626f258fc6_13, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3d3abe187d18270ac2a8ce626f258fc6_13->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3d3abe187d18270ac2a8ce626f258fc6_13, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d3abe187d18270ac2a8ce626f258fc6_13,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_3d3abe187d18270ac2a8ce626f258fc6_13 == cache_frame_3d3abe187d18270ac2a8ce626f258fc6_13 )
    {
        Py_DECREF( frame_3d3abe187d18270ac2a8ce626f258fc6_13 );
    }
    cache_frame_3d3abe187d18270ac2a8ce626f258fc6_13 = NULL;

    assertFrameObject( frame_3d3abe187d18270ac2a8ce626f258fc6_13 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_12;

    frame_no_exception_12:;

    goto skip_nested_handling_12;
    nested_frame_exit_12:;

    goto try_except_handler_42;
    skip_nested_handling_12:;
    tmp_called_name_70 = tmp_class_creation_13__metaclass;

    CHECK_OBJECT( tmp_called_name_70 );
    tmp_tuple_element_27 = const_str_plain_PythonGeneratorObjectContext;
    tmp_args_name_26 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_26, 0, tmp_tuple_element_27 );
    tmp_tuple_element_27 = tmp_class_creation_13__bases;

    CHECK_OBJECT( tmp_tuple_element_27 );
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_26, 1, tmp_tuple_element_27 );
    tmp_tuple_element_27 = locals_PythonGeneratorObjectContext_1126;
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_26, 2, tmp_tuple_element_27 );
    tmp_kw_name_26 = tmp_class_creation_13__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_26 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1126;
    tmp_assign_source_93 = CALL_FUNCTION( tmp_called_name_70, tmp_args_name_26, tmp_kw_name_26 );
    Py_DECREF( tmp_args_name_26 );
    if ( tmp_assign_source_93 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;

        goto try_except_handler_42;
    }
    assert( outline_12_var___class__ == NULL );
    outline_12_var___class__ = tmp_assign_source_93;

    tmp_outline_return_value_13 = outline_12_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_13 );
    Py_INCREF( tmp_outline_return_value_13 );
    goto try_return_handler_42;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_42:;
    Py_DECREF( locals_PythonGeneratorObjectContext_1126 );
    locals_PythonGeneratorObjectContext_1126 = NULL;
    goto try_return_handler_41;
    // Exception handler code:
    try_except_handler_42:;
    exception_keeper_type_40 = exception_type;
    exception_keeper_value_40 = exception_value;
    exception_keeper_tb_40 = exception_tb;
    exception_keeper_lineno_40 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonGeneratorObjectContext_1126 );
    locals_PythonGeneratorObjectContext_1126 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_40;
    exception_value = exception_keeper_value_40;
    exception_tb = exception_keeper_tb_40;
    exception_lineno = exception_keeper_lineno_40;

    goto try_except_handler_41;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_41:;
    CHECK_OBJECT( (PyObject *)outline_12_var___class__ );
    Py_DECREF( outline_12_var___class__ );
    outline_12_var___class__ = NULL;

    goto outline_result_13;
    // Exception handler code:
    try_except_handler_41:;
    exception_keeper_type_41 = exception_type;
    exception_keeper_value_41 = exception_value;
    exception_keeper_tb_41 = exception_tb;
    exception_keeper_lineno_41 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_41;
    exception_value = exception_keeper_value_41;
    exception_tb = exception_keeper_tb_41;
    exception_lineno = exception_keeper_lineno_41;

    goto outline_exception_13;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_13:;
    exception_lineno = 1126;
    goto try_except_handler_40;
    outline_result_13:;
    tmp_assign_source_92 = tmp_outline_return_value_13;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonGeneratorObjectContext, tmp_assign_source_92 );
    goto try_end_16;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_42 = exception_type;
    exception_keeper_value_42 = exception_value;
    exception_keeper_tb_42 = exception_tb;
    exception_keeper_lineno_42 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF( tmp_class_creation_13__class_decl_dict );
    tmp_class_creation_13__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_13__prepared );
    tmp_class_creation_13__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_42;
    exception_value = exception_keeper_value_42;
    exception_tb = exception_keeper_tb_42;
    exception_lineno = exception_keeper_lineno_42;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases );
    Py_DECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_decl_dict );
    Py_DECREF( tmp_class_creation_13__class_decl_dict );
    tmp_class_creation_13__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__prepared );
    Py_DECREF( tmp_class_creation_13__prepared );
    tmp_class_creation_13__prepared = NULL;

    // Tried code:
    tmp_tuple_element_28 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonGeneratorObjectContext );

    if (unlikely( tmp_tuple_element_28 == NULL ))
    {
        tmp_tuple_element_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonGeneratorObjectContext );
    }

    if ( tmp_tuple_element_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonGeneratorObjectContext" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1154;

        goto try_except_handler_43;
    }

    tmp_assign_source_94 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_assign_source_94, 0, tmp_tuple_element_28 );
    assert( tmp_class_creation_14__bases == NULL );
    tmp_class_creation_14__bases = tmp_assign_source_94;

    tmp_assign_source_95 = PyDict_New();
    assert( tmp_class_creation_14__class_decl_dict == NULL );
    tmp_class_creation_14__class_decl_dict = tmp_assign_source_95;

    tmp_key_name_40 = const_str_plain_metaclass;
    tmp_dict_name_40 = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_40 );
    tmp_res = PyDict_Contains( tmp_dict_name_40, tmp_key_name_40 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    tmp_cond_value_27 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_27 = CHECK_IF_TRUE( tmp_cond_value_27 );
    if ( tmp_cond_truth_27 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    if ( tmp_cond_truth_27 == 1 )
    {
        goto condexpr_true_27;
    }
    else
    {
        goto condexpr_false_27;
    }
    condexpr_true_27:;
    tmp_dict_name_41 = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_41 );
    tmp_key_name_41 = const_str_plain_metaclass;
    tmp_metaclass_name_14 = DICT_GET_ITEM( tmp_dict_name_41, tmp_key_name_41 );
    if ( tmp_metaclass_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    goto condexpr_end_27;
    condexpr_false_27:;
    tmp_subscribed_name_8 = tmp_class_creation_14__bases;

    CHECK_OBJECT( tmp_subscribed_name_8 );
    tmp_subscript_name_8 = const_int_0;
    tmp_type_arg_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_type_arg_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    tmp_metaclass_name_14 = BUILTIN_TYPE1( tmp_type_arg_8 );
    Py_DECREF( tmp_type_arg_8 );
    if ( tmp_metaclass_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    condexpr_end_27:;
    tmp_bases_name_14 = tmp_class_creation_14__bases;

    CHECK_OBJECT( tmp_bases_name_14 );
    tmp_assign_source_96 = SELECT_METACLASS( tmp_metaclass_name_14, tmp_bases_name_14 );
    Py_DECREF( tmp_metaclass_name_14 );
    if ( tmp_assign_source_96 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    assert( tmp_class_creation_14__metaclass == NULL );
    tmp_class_creation_14__metaclass = tmp_assign_source_96;

    tmp_key_name_42 = const_str_plain_metaclass;
    tmp_dict_name_42 = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_42 );
    tmp_res = PyDict_Contains( tmp_dict_name_42, tmp_key_name_42 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    tmp_cond_value_28 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_28 = CHECK_IF_TRUE( tmp_cond_value_28 );
    if ( tmp_cond_truth_28 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    if ( tmp_cond_truth_28 == 1 )
    {
        goto branch_yes_15;
    }
    else
    {
        goto branch_no_15;
    }
    branch_yes_15:;
    tmp_dictdel_dict = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    branch_no_15:;
    tmp_hasattr_source_14 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_14 );
    tmp_hasattr_attr_14 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_14, tmp_hasattr_attr_14 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_28;
    }
    else
    {
        goto condexpr_false_28;
    }
    condexpr_true_28:;
    tmp_source_name_14 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_called_name_71 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain___prepare__ );
    if ( tmp_called_name_71 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    tmp_tuple_element_29 = const_str_plain_PythonCoroutineObjectContext;
    tmp_args_name_27 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_29 );
    PyTuple_SET_ITEM( tmp_args_name_27, 0, tmp_tuple_element_29 );
    tmp_tuple_element_29 = tmp_class_creation_14__bases;

    CHECK_OBJECT( tmp_tuple_element_29 );
    Py_INCREF( tmp_tuple_element_29 );
    PyTuple_SET_ITEM( tmp_args_name_27, 1, tmp_tuple_element_29 );
    tmp_kw_name_27 = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_27 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1154;
    tmp_assign_source_97 = CALL_FUNCTION( tmp_called_name_71, tmp_args_name_27, tmp_kw_name_27 );
    Py_DECREF( tmp_called_name_71 );
    Py_DECREF( tmp_args_name_27 );
    if ( tmp_assign_source_97 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_43;
    }
    goto condexpr_end_28;
    condexpr_false_28:;
    tmp_assign_source_97 = PyDict_New();
    condexpr_end_28:;
    assert( tmp_class_creation_14__prepared == NULL );
    tmp_class_creation_14__prepared = tmp_assign_source_97;

    tmp_set_locals = tmp_class_creation_14__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonCoroutineObjectContext_1154 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonCoroutineObjectContext_1154, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_45;
    }
    tmp_dictset_value = const_str_plain_PythonCoroutineObjectContext;
    tmp_res = PyObject_SetItem( locals_PythonCoroutineObjectContext_1154, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_45;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_ab26b52d74ca01bee050b92a01449059_14, codeobj_ab26b52d74ca01bee050b92a01449059, module_codegen$Contexts, sizeof(void *) );
    frame_ab26b52d74ca01bee050b92a01449059_14 = cache_frame_ab26b52d74ca01bee050b92a01449059_14;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab26b52d74ca01bee050b92a01449059_14 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab26b52d74ca01bee050b92a01449059_14 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_164_getContextObjectName(  );
    tmp_res = PyObject_SetItem( locals_PythonCoroutineObjectContext_1154, const_str_plain_getContextObjectName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1155;
        type_description_2 = "N";
        goto frame_exception_exit_14;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab26b52d74ca01bee050b92a01449059_14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_13;

    frame_exception_exit_14:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab26b52d74ca01bee050b92a01449059_14 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab26b52d74ca01bee050b92a01449059_14, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab26b52d74ca01bee050b92a01449059_14->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab26b52d74ca01bee050b92a01449059_14, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab26b52d74ca01bee050b92a01449059_14,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_ab26b52d74ca01bee050b92a01449059_14 == cache_frame_ab26b52d74ca01bee050b92a01449059_14 )
    {
        Py_DECREF( frame_ab26b52d74ca01bee050b92a01449059_14 );
    }
    cache_frame_ab26b52d74ca01bee050b92a01449059_14 = NULL;

    assertFrameObject( frame_ab26b52d74ca01bee050b92a01449059_14 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_13;

    frame_no_exception_13:;

    goto skip_nested_handling_13;
    nested_frame_exit_13:;

    goto try_except_handler_45;
    skip_nested_handling_13:;
    tmp_called_name_72 = tmp_class_creation_14__metaclass;

    CHECK_OBJECT( tmp_called_name_72 );
    tmp_tuple_element_30 = const_str_plain_PythonCoroutineObjectContext;
    tmp_args_name_28 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_args_name_28, 0, tmp_tuple_element_30 );
    tmp_tuple_element_30 = tmp_class_creation_14__bases;

    CHECK_OBJECT( tmp_tuple_element_30 );
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_args_name_28, 1, tmp_tuple_element_30 );
    tmp_tuple_element_30 = locals_PythonCoroutineObjectContext_1154;
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_args_name_28, 2, tmp_tuple_element_30 );
    tmp_kw_name_28 = tmp_class_creation_14__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_28 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1154;
    tmp_assign_source_99 = CALL_FUNCTION( tmp_called_name_72, tmp_args_name_28, tmp_kw_name_28 );
    Py_DECREF( tmp_args_name_28 );
    if ( tmp_assign_source_99 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;

        goto try_except_handler_45;
    }
    assert( outline_13_var___class__ == NULL );
    outline_13_var___class__ = tmp_assign_source_99;

    tmp_outline_return_value_14 = outline_13_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_14 );
    Py_INCREF( tmp_outline_return_value_14 );
    goto try_return_handler_45;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_45:;
    Py_DECREF( locals_PythonCoroutineObjectContext_1154 );
    locals_PythonCoroutineObjectContext_1154 = NULL;
    goto try_return_handler_44;
    // Exception handler code:
    try_except_handler_45:;
    exception_keeper_type_43 = exception_type;
    exception_keeper_value_43 = exception_value;
    exception_keeper_tb_43 = exception_tb;
    exception_keeper_lineno_43 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonCoroutineObjectContext_1154 );
    locals_PythonCoroutineObjectContext_1154 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_43;
    exception_value = exception_keeper_value_43;
    exception_tb = exception_keeper_tb_43;
    exception_lineno = exception_keeper_lineno_43;

    goto try_except_handler_44;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_44:;
    CHECK_OBJECT( (PyObject *)outline_13_var___class__ );
    Py_DECREF( outline_13_var___class__ );
    outline_13_var___class__ = NULL;

    goto outline_result_14;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_44 = exception_type;
    exception_keeper_value_44 = exception_value;
    exception_keeper_tb_44 = exception_tb;
    exception_keeper_lineno_44 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_44;
    exception_value = exception_keeper_value_44;
    exception_tb = exception_keeper_tb_44;
    exception_lineno = exception_keeper_lineno_44;

    goto outline_exception_14;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_14:;
    exception_lineno = 1154;
    goto try_except_handler_43;
    outline_result_14:;
    tmp_assign_source_98 = tmp_outline_return_value_14;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonCoroutineObjectContext, tmp_assign_source_98 );
    goto try_end_17;
    // Exception handler code:
    try_except_handler_43:;
    exception_keeper_type_45 = exception_type;
    exception_keeper_value_45 = exception_value;
    exception_keeper_tb_45 = exception_tb;
    exception_keeper_lineno_45 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF( tmp_class_creation_14__class_decl_dict );
    tmp_class_creation_14__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_14__prepared );
    tmp_class_creation_14__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_45;
    exception_value = exception_keeper_value_45;
    exception_tb = exception_keeper_tb_45;
    exception_lineno = exception_keeper_lineno_45;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases );
    Py_DECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_decl_dict );
    Py_DECREF( tmp_class_creation_14__class_decl_dict );
    tmp_class_creation_14__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__prepared );
    Py_DECREF( tmp_class_creation_14__prepared );
    tmp_class_creation_14__prepared = NULL;

    // Tried code:
    tmp_tuple_element_31 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonGeneratorObjectContext );

    if (unlikely( tmp_tuple_element_31 == NULL ))
    {
        tmp_tuple_element_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonGeneratorObjectContext );
    }

    if ( tmp_tuple_element_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonGeneratorObjectContext" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1159;

        goto try_except_handler_46;
    }

    tmp_assign_source_100 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_31 );
    PyTuple_SET_ITEM( tmp_assign_source_100, 0, tmp_tuple_element_31 );
    assert( tmp_class_creation_15__bases == NULL );
    tmp_class_creation_15__bases = tmp_assign_source_100;

    tmp_assign_source_101 = PyDict_New();
    assert( tmp_class_creation_15__class_decl_dict == NULL );
    tmp_class_creation_15__class_decl_dict = tmp_assign_source_101;

    tmp_key_name_43 = const_str_plain_metaclass;
    tmp_dict_name_43 = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_43 );
    tmp_res = PyDict_Contains( tmp_dict_name_43, tmp_key_name_43 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    tmp_cond_value_29 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_29 = CHECK_IF_TRUE( tmp_cond_value_29 );
    if ( tmp_cond_truth_29 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    if ( tmp_cond_truth_29 == 1 )
    {
        goto condexpr_true_29;
    }
    else
    {
        goto condexpr_false_29;
    }
    condexpr_true_29:;
    tmp_dict_name_44 = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_44 );
    tmp_key_name_44 = const_str_plain_metaclass;
    tmp_metaclass_name_15 = DICT_GET_ITEM( tmp_dict_name_44, tmp_key_name_44 );
    if ( tmp_metaclass_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    goto condexpr_end_29;
    condexpr_false_29:;
    tmp_subscribed_name_9 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_subscribed_name_9 );
    tmp_subscript_name_9 = const_int_0;
    tmp_type_arg_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_type_arg_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    tmp_metaclass_name_15 = BUILTIN_TYPE1( tmp_type_arg_9 );
    Py_DECREF( tmp_type_arg_9 );
    if ( tmp_metaclass_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    condexpr_end_29:;
    tmp_bases_name_15 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_bases_name_15 );
    tmp_assign_source_102 = SELECT_METACLASS( tmp_metaclass_name_15, tmp_bases_name_15 );
    Py_DECREF( tmp_metaclass_name_15 );
    if ( tmp_assign_source_102 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    assert( tmp_class_creation_15__metaclass == NULL );
    tmp_class_creation_15__metaclass = tmp_assign_source_102;

    tmp_key_name_45 = const_str_plain_metaclass;
    tmp_dict_name_45 = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_45 );
    tmp_res = PyDict_Contains( tmp_dict_name_45, tmp_key_name_45 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    tmp_cond_value_30 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_30 = CHECK_IF_TRUE( tmp_cond_value_30 );
    if ( tmp_cond_truth_30 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    if ( tmp_cond_truth_30 == 1 )
    {
        goto branch_yes_16;
    }
    else
    {
        goto branch_no_16;
    }
    branch_yes_16:;
    tmp_dictdel_dict = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    branch_no_16:;
    tmp_hasattr_source_15 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_15 );
    tmp_hasattr_attr_15 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_15, tmp_hasattr_attr_15 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_30;
    }
    else
    {
        goto condexpr_false_30;
    }
    condexpr_true_30:;
    tmp_source_name_15 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_called_name_73 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain___prepare__ );
    if ( tmp_called_name_73 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    tmp_tuple_element_32 = const_str_plain_PythonAsyncgenObjectContext;
    tmp_args_name_29 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_args_name_29, 0, tmp_tuple_element_32 );
    tmp_tuple_element_32 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_tuple_element_32 );
    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_args_name_29, 1, tmp_tuple_element_32 );
    tmp_kw_name_29 = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_29 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1159;
    tmp_assign_source_103 = CALL_FUNCTION( tmp_called_name_73, tmp_args_name_29, tmp_kw_name_29 );
    Py_DECREF( tmp_called_name_73 );
    Py_DECREF( tmp_args_name_29 );
    if ( tmp_assign_source_103 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_46;
    }
    goto condexpr_end_30;
    condexpr_false_30:;
    tmp_assign_source_103 = PyDict_New();
    condexpr_end_30:;
    assert( tmp_class_creation_15__prepared == NULL );
    tmp_class_creation_15__prepared = tmp_assign_source_103;

    tmp_set_locals = tmp_class_creation_15__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonAsyncgenObjectContext_1159 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonAsyncgenObjectContext_1159, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_48;
    }
    tmp_dictset_value = const_str_plain_PythonAsyncgenObjectContext;
    tmp_res = PyObject_SetItem( locals_PythonAsyncgenObjectContext_1159, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_48;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_421a1e46a9e9caad65d20098cf3f5960_15, codeobj_421a1e46a9e9caad65d20098cf3f5960, module_codegen$Contexts, sizeof(void *) );
    frame_421a1e46a9e9caad65d20098cf3f5960_15 = cache_frame_421a1e46a9e9caad65d20098cf3f5960_15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_421a1e46a9e9caad65d20098cf3f5960_15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_421a1e46a9e9caad65d20098cf3f5960_15 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_165_getContextObjectName(  );
    tmp_res = PyObject_SetItem( locals_PythonAsyncgenObjectContext_1159, const_str_plain_getContextObjectName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        type_description_2 = "N";
        goto frame_exception_exit_15;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_421a1e46a9e9caad65d20098cf3f5960_15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_14;

    frame_exception_exit_15:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_421a1e46a9e9caad65d20098cf3f5960_15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_421a1e46a9e9caad65d20098cf3f5960_15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_421a1e46a9e9caad65d20098cf3f5960_15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_421a1e46a9e9caad65d20098cf3f5960_15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_421a1e46a9e9caad65d20098cf3f5960_15,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_421a1e46a9e9caad65d20098cf3f5960_15 == cache_frame_421a1e46a9e9caad65d20098cf3f5960_15 )
    {
        Py_DECREF( frame_421a1e46a9e9caad65d20098cf3f5960_15 );
    }
    cache_frame_421a1e46a9e9caad65d20098cf3f5960_15 = NULL;

    assertFrameObject( frame_421a1e46a9e9caad65d20098cf3f5960_15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_14;

    frame_no_exception_14:;

    goto skip_nested_handling_14;
    nested_frame_exit_14:;

    goto try_except_handler_48;
    skip_nested_handling_14:;
    tmp_called_name_74 = tmp_class_creation_15__metaclass;

    CHECK_OBJECT( tmp_called_name_74 );
    tmp_tuple_element_33 = const_str_plain_PythonAsyncgenObjectContext;
    tmp_args_name_30 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_33 );
    PyTuple_SET_ITEM( tmp_args_name_30, 0, tmp_tuple_element_33 );
    tmp_tuple_element_33 = tmp_class_creation_15__bases;

    CHECK_OBJECT( tmp_tuple_element_33 );
    Py_INCREF( tmp_tuple_element_33 );
    PyTuple_SET_ITEM( tmp_args_name_30, 1, tmp_tuple_element_33 );
    tmp_tuple_element_33 = locals_PythonAsyncgenObjectContext_1159;
    Py_INCREF( tmp_tuple_element_33 );
    PyTuple_SET_ITEM( tmp_args_name_30, 2, tmp_tuple_element_33 );
    tmp_kw_name_30 = tmp_class_creation_15__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_30 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1159;
    tmp_assign_source_105 = CALL_FUNCTION( tmp_called_name_74, tmp_args_name_30, tmp_kw_name_30 );
    Py_DECREF( tmp_args_name_30 );
    if ( tmp_assign_source_105 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;

        goto try_except_handler_48;
    }
    assert( outline_14_var___class__ == NULL );
    outline_14_var___class__ = tmp_assign_source_105;

    tmp_outline_return_value_15 = outline_14_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_15 );
    Py_INCREF( tmp_outline_return_value_15 );
    goto try_return_handler_48;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_48:;
    Py_DECREF( locals_PythonAsyncgenObjectContext_1159 );
    locals_PythonAsyncgenObjectContext_1159 = NULL;
    goto try_return_handler_47;
    // Exception handler code:
    try_except_handler_48:;
    exception_keeper_type_46 = exception_type;
    exception_keeper_value_46 = exception_value;
    exception_keeper_tb_46 = exception_tb;
    exception_keeper_lineno_46 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonAsyncgenObjectContext_1159 );
    locals_PythonAsyncgenObjectContext_1159 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_46;
    exception_value = exception_keeper_value_46;
    exception_tb = exception_keeper_tb_46;
    exception_lineno = exception_keeper_lineno_46;

    goto try_except_handler_47;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_47:;
    CHECK_OBJECT( (PyObject *)outline_14_var___class__ );
    Py_DECREF( outline_14_var___class__ );
    outline_14_var___class__ = NULL;

    goto outline_result_15;
    // Exception handler code:
    try_except_handler_47:;
    exception_keeper_type_47 = exception_type;
    exception_keeper_value_47 = exception_value;
    exception_keeper_tb_47 = exception_tb;
    exception_keeper_lineno_47 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_47;
    exception_value = exception_keeper_value_47;
    exception_tb = exception_keeper_tb_47;
    exception_lineno = exception_keeper_lineno_47;

    goto outline_exception_15;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_15:;
    exception_lineno = 1159;
    goto try_except_handler_46;
    outline_result_15:;
    tmp_assign_source_104 = tmp_outline_return_value_15;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonAsyncgenObjectContext, tmp_assign_source_104 );
    goto try_end_18;
    // Exception handler code:
    try_except_handler_46:;
    exception_keeper_type_48 = exception_type;
    exception_keeper_value_48 = exception_value;
    exception_keeper_tb_48 = exception_tb;
    exception_keeper_lineno_48 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF( tmp_class_creation_15__class_decl_dict );
    tmp_class_creation_15__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_15__prepared );
    tmp_class_creation_15__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_48;
    exception_value = exception_keeper_value_48;
    exception_tb = exception_keeper_tb_48;
    exception_lineno = exception_keeper_lineno_48;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases );
    Py_DECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_decl_dict );
    Py_DECREF( tmp_class_creation_15__class_decl_dict );
    tmp_class_creation_15__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__prepared );
    Py_DECREF( tmp_class_creation_15__prepared );
    tmp_class_creation_15__prepared = NULL;

    // Tried code:
    tmp_tuple_element_34 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );

    if (unlikely( tmp_tuple_element_34 == NULL ))
    {
        tmp_tuple_element_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonFunctionContext );
    }

    if ( tmp_tuple_element_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonFunctionContext" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;

        goto try_except_handler_49;
    }

    tmp_assign_source_106 = PyTuple_New( 1 );
    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_assign_source_106, 0, tmp_tuple_element_34 );
    assert( tmp_class_creation_16__bases == NULL );
    tmp_class_creation_16__bases = tmp_assign_source_106;

    tmp_assign_source_107 = PyDict_New();
    assert( tmp_class_creation_16__class_decl_dict == NULL );
    tmp_class_creation_16__class_decl_dict = tmp_assign_source_107;

    tmp_key_name_46 = const_str_plain_metaclass;
    tmp_dict_name_46 = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_46 );
    tmp_res = PyDict_Contains( tmp_dict_name_46, tmp_key_name_46 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    tmp_cond_value_31 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_31 = CHECK_IF_TRUE( tmp_cond_value_31 );
    if ( tmp_cond_truth_31 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    if ( tmp_cond_truth_31 == 1 )
    {
        goto condexpr_true_31;
    }
    else
    {
        goto condexpr_false_31;
    }
    condexpr_true_31:;
    tmp_dict_name_47 = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_47 );
    tmp_key_name_47 = const_str_plain_metaclass;
    tmp_metaclass_name_16 = DICT_GET_ITEM( tmp_dict_name_47, tmp_key_name_47 );
    if ( tmp_metaclass_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    goto condexpr_end_31;
    condexpr_false_31:;
    tmp_subscribed_name_10 = tmp_class_creation_16__bases;

    CHECK_OBJECT( tmp_subscribed_name_10 );
    tmp_subscript_name_10 = const_int_0;
    tmp_type_arg_10 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_10 );
    if ( tmp_type_arg_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    tmp_metaclass_name_16 = BUILTIN_TYPE1( tmp_type_arg_10 );
    Py_DECREF( tmp_type_arg_10 );
    if ( tmp_metaclass_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    condexpr_end_31:;
    tmp_bases_name_16 = tmp_class_creation_16__bases;

    CHECK_OBJECT( tmp_bases_name_16 );
    tmp_assign_source_108 = SELECT_METACLASS( tmp_metaclass_name_16, tmp_bases_name_16 );
    Py_DECREF( tmp_metaclass_name_16 );
    if ( tmp_assign_source_108 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    assert( tmp_class_creation_16__metaclass == NULL );
    tmp_class_creation_16__metaclass = tmp_assign_source_108;

    tmp_key_name_48 = const_str_plain_metaclass;
    tmp_dict_name_48 = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_48 );
    tmp_res = PyDict_Contains( tmp_dict_name_48, tmp_key_name_48 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    tmp_cond_value_32 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_32 = CHECK_IF_TRUE( tmp_cond_value_32 );
    if ( tmp_cond_truth_32 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    if ( tmp_cond_truth_32 == 1 )
    {
        goto branch_yes_17;
    }
    else
    {
        goto branch_no_17;
    }
    branch_yes_17:;
    tmp_dictdel_dict = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    branch_no_17:;
    tmp_hasattr_source_16 = tmp_class_creation_16__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_16 );
    tmp_hasattr_attr_16 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_16, tmp_hasattr_attr_16 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_32;
    }
    else
    {
        goto condexpr_false_32;
    }
    condexpr_true_32:;
    tmp_source_name_16 = tmp_class_creation_16__metaclass;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_called_name_75 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain___prepare__ );
    if ( tmp_called_name_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    tmp_tuple_element_35 = const_str_plain_PythonFunctionCreatedContext;
    tmp_args_name_31 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_35 );
    PyTuple_SET_ITEM( tmp_args_name_31, 0, tmp_tuple_element_35 );
    tmp_tuple_element_35 = tmp_class_creation_16__bases;

    CHECK_OBJECT( tmp_tuple_element_35 );
    Py_INCREF( tmp_tuple_element_35 );
    PyTuple_SET_ITEM( tmp_args_name_31, 1, tmp_tuple_element_35 );
    tmp_kw_name_31 = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_31 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1164;
    tmp_assign_source_109 = CALL_FUNCTION( tmp_called_name_75, tmp_args_name_31, tmp_kw_name_31 );
    Py_DECREF( tmp_called_name_75 );
    Py_DECREF( tmp_args_name_31 );
    if ( tmp_assign_source_109 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_49;
    }
    goto condexpr_end_32;
    condexpr_false_32:;
    tmp_assign_source_109 = PyDict_New();
    condexpr_end_32:;
    assert( tmp_class_creation_16__prepared == NULL );
    tmp_class_creation_16__prepared = tmp_assign_source_109;

    tmp_set_locals = tmp_class_creation_16__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonFunctionCreatedContext_1164 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonFunctionCreatedContext_1164, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_51;
    }
    tmp_dictset_value = const_str_plain_PythonFunctionCreatedContext;
    tmp_res = PyObject_SetItem( locals_PythonFunctionCreatedContext_1164, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_51;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_27fa39f491c05c261c623c66b96c4cc1_16, codeobj_27fa39f491c05c261c623c66b96c4cc1, module_codegen$Contexts, sizeof(void *) );
    frame_27fa39f491c05c261c623c66b96c4cc1_16 = cache_frame_27fa39f491c05c261c623c66b96c4cc1_16;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27fa39f491c05c261c623c66b96c4cc1_16 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27fa39f491c05c261c623c66b96c4cc1_16 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_166_isForDirectCall(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionCreatedContext_1164, const_str_plain_isForDirectCall, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1165;
        type_description_2 = "N";
        goto frame_exception_exit_16;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_167_isForCreatedFunction(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionCreatedContext_1164, const_str_plain_isForCreatedFunction, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description_2 = "N";
        goto frame_exception_exit_16;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27fa39f491c05c261c623c66b96c4cc1_16 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_15;

    frame_exception_exit_16:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27fa39f491c05c261c623c66b96c4cc1_16 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27fa39f491c05c261c623c66b96c4cc1_16, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27fa39f491c05c261c623c66b96c4cc1_16->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27fa39f491c05c261c623c66b96c4cc1_16, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27fa39f491c05c261c623c66b96c4cc1_16,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_27fa39f491c05c261c623c66b96c4cc1_16 == cache_frame_27fa39f491c05c261c623c66b96c4cc1_16 )
    {
        Py_DECREF( frame_27fa39f491c05c261c623c66b96c4cc1_16 );
    }
    cache_frame_27fa39f491c05c261c623c66b96c4cc1_16 = NULL;

    assertFrameObject( frame_27fa39f491c05c261c623c66b96c4cc1_16 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_15;

    frame_no_exception_15:;

    goto skip_nested_handling_15;
    nested_frame_exit_15:;

    goto try_except_handler_51;
    skip_nested_handling_15:;
    tmp_called_name_76 = tmp_class_creation_16__metaclass;

    CHECK_OBJECT( tmp_called_name_76 );
    tmp_tuple_element_36 = const_str_plain_PythonFunctionCreatedContext;
    tmp_args_name_32 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_32, 0, tmp_tuple_element_36 );
    tmp_tuple_element_36 = tmp_class_creation_16__bases;

    CHECK_OBJECT( tmp_tuple_element_36 );
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_32, 1, tmp_tuple_element_36 );
    tmp_tuple_element_36 = locals_PythonFunctionCreatedContext_1164;
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_32, 2, tmp_tuple_element_36 );
    tmp_kw_name_32 = tmp_class_creation_16__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_32 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1164;
    tmp_assign_source_111 = CALL_FUNCTION( tmp_called_name_76, tmp_args_name_32, tmp_kw_name_32 );
    Py_DECREF( tmp_args_name_32 );
    if ( tmp_assign_source_111 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;

        goto try_except_handler_51;
    }
    assert( outline_15_var___class__ == NULL );
    outline_15_var___class__ = tmp_assign_source_111;

    tmp_outline_return_value_16 = outline_15_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_16 );
    Py_INCREF( tmp_outline_return_value_16 );
    goto try_return_handler_51;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_51:;
    Py_DECREF( locals_PythonFunctionCreatedContext_1164 );
    locals_PythonFunctionCreatedContext_1164 = NULL;
    goto try_return_handler_50;
    // Exception handler code:
    try_except_handler_51:;
    exception_keeper_type_49 = exception_type;
    exception_keeper_value_49 = exception_value;
    exception_keeper_tb_49 = exception_tb;
    exception_keeper_lineno_49 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonFunctionCreatedContext_1164 );
    locals_PythonFunctionCreatedContext_1164 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_49;
    exception_value = exception_keeper_value_49;
    exception_tb = exception_keeper_tb_49;
    exception_lineno = exception_keeper_lineno_49;

    goto try_except_handler_50;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_50:;
    CHECK_OBJECT( (PyObject *)outline_15_var___class__ );
    Py_DECREF( outline_15_var___class__ );
    outline_15_var___class__ = NULL;

    goto outline_result_16;
    // Exception handler code:
    try_except_handler_50:;
    exception_keeper_type_50 = exception_type;
    exception_keeper_value_50 = exception_value;
    exception_keeper_tb_50 = exception_tb;
    exception_keeper_lineno_50 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_50;
    exception_value = exception_keeper_value_50;
    exception_tb = exception_keeper_tb_50;
    exception_lineno = exception_keeper_lineno_50;

    goto outline_exception_16;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_16:;
    exception_lineno = 1164;
    goto try_except_handler_49;
    outline_result_16:;
    tmp_assign_source_110 = tmp_outline_return_value_16;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionCreatedContext, tmp_assign_source_110 );
    goto try_end_19;
    // Exception handler code:
    try_except_handler_49:;
    exception_keeper_type_51 = exception_type;
    exception_keeper_value_51 = exception_value;
    exception_keeper_tb_51 = exception_tb;
    exception_keeper_lineno_51 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_16__bases );
    tmp_class_creation_16__bases = NULL;

    Py_XDECREF( tmp_class_creation_16__class_decl_dict );
    tmp_class_creation_16__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_16__prepared );
    tmp_class_creation_16__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_51;
    exception_value = exception_keeper_value_51;
    exception_tb = exception_keeper_tb_51;
    exception_lineno = exception_keeper_lineno_51;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__bases );
    Py_DECREF( tmp_class_creation_16__bases );
    tmp_class_creation_16__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_decl_dict );
    Py_DECREF( tmp_class_creation_16__class_decl_dict );
    tmp_class_creation_16__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__prepared );
    Py_DECREF( tmp_class_creation_16__prepared );
    tmp_class_creation_16__prepared = NULL;

    // Tried code:
    tmp_tuple_element_37 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );

    if (unlikely( tmp_tuple_element_37 == NULL ))
    {
        tmp_tuple_element_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnReleaseModeMixin );
    }

    if ( tmp_tuple_element_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnReleaseModeMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1172;

        goto try_except_handler_52;
    }

    tmp_assign_source_112 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_37 );
    PyTuple_SET_ITEM( tmp_assign_source_112, 0, tmp_tuple_element_37 );
    tmp_tuple_element_37 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );

    if (unlikely( tmp_tuple_element_37 == NULL ))
    {
        tmp_tuple_element_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ReturnValueNameMixin );
    }

    if ( tmp_tuple_element_37 == NULL )
    {
        Py_DECREF( tmp_assign_source_112 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ReturnValueNameMixin" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;

        goto try_except_handler_52;
    }

    Py_INCREF( tmp_tuple_element_37 );
    PyTuple_SET_ITEM( tmp_assign_source_112, 1, tmp_tuple_element_37 );
    tmp_tuple_element_37 = GET_STRING_DICT_VALUE( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );

    if (unlikely( tmp_tuple_element_37 == NULL ))
    {
        tmp_tuple_element_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonChildContextBase );
    }

    if ( tmp_tuple_element_37 == NULL )
    {
        Py_DECREF( tmp_assign_source_112 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PythonChildContextBase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;

        goto try_except_handler_52;
    }

    Py_INCREF( tmp_tuple_element_37 );
    PyTuple_SET_ITEM( tmp_assign_source_112, 2, tmp_tuple_element_37 );
    assert( tmp_class_creation_17__bases == NULL );
    tmp_class_creation_17__bases = tmp_assign_source_112;

    tmp_assign_source_113 = PyDict_New();
    assert( tmp_class_creation_17__class_decl_dict == NULL );
    tmp_class_creation_17__class_decl_dict = tmp_assign_source_113;

    tmp_key_name_49 = const_str_plain_metaclass;
    tmp_dict_name_49 = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_49 );
    tmp_res = PyDict_Contains( tmp_dict_name_49, tmp_key_name_49 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    tmp_cond_value_33 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_33 = CHECK_IF_TRUE( tmp_cond_value_33 );
    if ( tmp_cond_truth_33 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    if ( tmp_cond_truth_33 == 1 )
    {
        goto condexpr_true_33;
    }
    else
    {
        goto condexpr_false_33;
    }
    condexpr_true_33:;
    tmp_dict_name_50 = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_50 );
    tmp_key_name_50 = const_str_plain_metaclass;
    tmp_metaclass_name_17 = DICT_GET_ITEM( tmp_dict_name_50, tmp_key_name_50 );
    if ( tmp_metaclass_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    goto condexpr_end_33;
    condexpr_false_33:;
    tmp_subscribed_name_11 = tmp_class_creation_17__bases;

    CHECK_OBJECT( tmp_subscribed_name_11 );
    tmp_subscript_name_11 = const_int_0;
    tmp_type_arg_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_11, tmp_subscript_name_11 );
    if ( tmp_type_arg_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    tmp_metaclass_name_17 = BUILTIN_TYPE1( tmp_type_arg_11 );
    Py_DECREF( tmp_type_arg_11 );
    if ( tmp_metaclass_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    condexpr_end_33:;
    tmp_bases_name_17 = tmp_class_creation_17__bases;

    CHECK_OBJECT( tmp_bases_name_17 );
    tmp_assign_source_114 = SELECT_METACLASS( tmp_metaclass_name_17, tmp_bases_name_17 );
    Py_DECREF( tmp_metaclass_name_17 );
    if ( tmp_assign_source_114 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    assert( tmp_class_creation_17__metaclass == NULL );
    tmp_class_creation_17__metaclass = tmp_assign_source_114;

    tmp_key_name_51 = const_str_plain_metaclass;
    tmp_dict_name_51 = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_51 );
    tmp_res = PyDict_Contains( tmp_dict_name_51, tmp_key_name_51 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    tmp_cond_value_34 = BOOL_FROM( tmp_res == 1 );
    tmp_cond_truth_34 = CHECK_IF_TRUE( tmp_cond_value_34 );
    if ( tmp_cond_truth_34 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    if ( tmp_cond_truth_34 == 1 )
    {
        goto branch_yes_18;
    }
    else
    {
        goto branch_no_18;
    }
    branch_yes_18:;
    tmp_dictdel_dict = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    branch_no_18:;
    tmp_hasattr_source_17 = tmp_class_creation_17__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_17 );
    tmp_hasattr_attr_17 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_17, tmp_hasattr_attr_17 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_34;
    }
    else
    {
        goto condexpr_false_34;
    }
    condexpr_true_34:;
    tmp_source_name_17 = tmp_class_creation_17__metaclass;

    CHECK_OBJECT( tmp_source_name_17 );
    tmp_called_name_77 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain___prepare__ );
    if ( tmp_called_name_77 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    tmp_tuple_element_38 = const_str_plain_PythonFunctionOutlineContext;
    tmp_args_name_33 = PyTuple_New( 2 );
    Py_INCREF( tmp_tuple_element_38 );
    PyTuple_SET_ITEM( tmp_args_name_33, 0, tmp_tuple_element_38 );
    tmp_tuple_element_38 = tmp_class_creation_17__bases;

    CHECK_OBJECT( tmp_tuple_element_38 );
    Py_INCREF( tmp_tuple_element_38 );
    PyTuple_SET_ITEM( tmp_args_name_33, 1, tmp_tuple_element_38 );
    tmp_kw_name_33 = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_33 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1173;
    tmp_assign_source_115 = CALL_FUNCTION( tmp_called_name_77, tmp_args_name_33, tmp_kw_name_33 );
    Py_DECREF( tmp_called_name_77 );
    Py_DECREF( tmp_args_name_33 );
    if ( tmp_assign_source_115 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_52;
    }
    goto condexpr_end_34;
    condexpr_false_34:;
    tmp_assign_source_115 = PyDict_New();
    condexpr_end_34:;
    assert( tmp_class_creation_17__prepared == NULL );
    tmp_class_creation_17__prepared = tmp_assign_source_115;

    tmp_set_locals = tmp_class_creation_17__prepared;

    CHECK_OBJECT( tmp_set_locals );
    locals_PythonFunctionOutlineContext_1173 = tmp_set_locals;
    Py_INCREF( tmp_set_locals );
    // Tried code:
    // Tried code:
    tmp_dictset_value = const_str_digest_32b6f9bd6c8766692c776fc8064f9cf2;
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain___module__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_54;
    }
    tmp_dictset_value = const_str_plain_PythonFunctionOutlineContext;
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain___qualname__, tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_54;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_b0a85f471c9ed507afddbbd59b8dec86_17, codeobj_b0a85f471c9ed507afddbbd59b8dec86, module_codegen$Contexts, sizeof(void *) );
    frame_b0a85f471c9ed507afddbbd59b8dec86_17 = cache_frame_b0a85f471c9ed507afddbbd59b8dec86_17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b0a85f471c9ed507afddbbd59b8dec86_17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b0a85f471c9ed507afddbbd59b8dec86_17 ) == 2 ); // Frame stack

    // Framed code:
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_168___init__(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain___init__, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1174;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_169_getOwner(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getOwner, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1185;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_170_getEntryPoint(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getEntryPoint, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1188;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_171_allocateLabel(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_allocateLabel, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1191;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_defaults_3 = const_tuple_str_digest_fd57353dc0a31a7daca8fb2ea030dee2_false_tuple;
    Py_INCREF( tmp_defaults_3 );
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_172_allocateTempName( tmp_defaults_3 );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_allocateTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1194;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_173_hasTempName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_hasTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1198;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_174_getCleanupTempnames(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getCleanupTempnames, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1201;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_175_addCleanupTempName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_addCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_176_removeCleanupTempName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_removeCleanupTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1207;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_177_needsCleanup(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_needsCleanup, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1210;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_178_pushCleanupScope(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_pushCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_179_popCleanupScope(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_popCleanupScope, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1216;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_180_getCodeObjectHandle(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getCodeObjectHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_181_getExceptionEscape(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_182_setExceptionEscape(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setExceptionEscape, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1225;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_183_getLoopBreakTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1228;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_184_setLoopBreakTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setLoopBreakTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1231;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_185_getLoopContinueTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1234;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_186_setLoopContinueTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setLoopContinueTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1237;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_187_getTrueBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1240;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_188_getFalseBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1243;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_189_setTrueBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setTrueBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1246;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_190_setFalseBranchTarget(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setFalseBranchTarget, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1249;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_191_getFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1252;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_192_pushFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_pushFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1255;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_193_popFrameHandle(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_popFrameHandle, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1258;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_194_getExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_195_setExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_196_setVariableType(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_setVariableType, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_197_getIntResName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getIntResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_198_getBoolResName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getBoolResName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_199_needsExceptionVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_needsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1276;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_200_markAsNeedsExceptionVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_markAsNeedsExceptionVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_201_allocateExceptionKeeperVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_allocateExceptionKeeperVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_202_addFrameDeclaration(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_addFrameDeclaration, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1285;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_203_isForDirectCall(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_isForDirectCall, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1288;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_204_mayRecurse(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_mayRecurse, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1291;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_205_addLocalsDictName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_addLocalsDictName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_206_addExceptionPreserverVariables(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_addExceptionPreserverVariables, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1299;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_207_getTempNameInfos(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getTempNameInfos, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1302;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_208_forgetTempName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_forgetTempName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1305;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }
    tmp_dictset_value = MAKE_FUNCTION_codegen$Contexts$$$function_209_getContextObjectName(  );
    tmp_res = PyObject_SetItem( locals_PythonFunctionOutlineContext_1173, const_str_plain_getContextObjectName, tmp_dictset_value );
    Py_DECREF( tmp_dictset_value );
    if ( tmp_res != 0 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1308;
        type_description_2 = "N";
        goto frame_exception_exit_17;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0a85f471c9ed507afddbbd59b8dec86_17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_16;

    frame_exception_exit_17:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0a85f471c9ed507afddbbd59b8dec86_17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b0a85f471c9ed507afddbbd59b8dec86_17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b0a85f471c9ed507afddbbd59b8dec86_17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b0a85f471c9ed507afddbbd59b8dec86_17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b0a85f471c9ed507afddbbd59b8dec86_17,
        type_description_2,
        NULL
    );


    // Release cached frame.
    if ( frame_b0a85f471c9ed507afddbbd59b8dec86_17 == cache_frame_b0a85f471c9ed507afddbbd59b8dec86_17 )
    {
        Py_DECREF( frame_b0a85f471c9ed507afddbbd59b8dec86_17 );
    }
    cache_frame_b0a85f471c9ed507afddbbd59b8dec86_17 = NULL;

    assertFrameObject( frame_b0a85f471c9ed507afddbbd59b8dec86_17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_16;

    frame_no_exception_16:;

    goto skip_nested_handling_16;
    nested_frame_exit_16:;

    goto try_except_handler_54;
    skip_nested_handling_16:;
    tmp_called_name_78 = tmp_class_creation_17__metaclass;

    CHECK_OBJECT( tmp_called_name_78 );
    tmp_tuple_element_39 = const_str_plain_PythonFunctionOutlineContext;
    tmp_args_name_34 = PyTuple_New( 3 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_args_name_34, 0, tmp_tuple_element_39 );
    tmp_tuple_element_39 = tmp_class_creation_17__bases;

    CHECK_OBJECT( tmp_tuple_element_39 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_args_name_34, 1, tmp_tuple_element_39 );
    tmp_tuple_element_39 = locals_PythonFunctionOutlineContext_1173;
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_args_name_34, 2, tmp_tuple_element_39 );
    tmp_kw_name_34 = tmp_class_creation_17__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_34 );
    frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame.f_lineno = 1173;
    tmp_assign_source_117 = CALL_FUNCTION( tmp_called_name_78, tmp_args_name_34, tmp_kw_name_34 );
    Py_DECREF( tmp_args_name_34 );
    if ( tmp_assign_source_117 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;

        goto try_except_handler_54;
    }
    assert( outline_16_var___class__ == NULL );
    outline_16_var___class__ = tmp_assign_source_117;

    tmp_outline_return_value_17 = outline_16_var___class__;

    CHECK_OBJECT( tmp_outline_return_value_17 );
    Py_INCREF( tmp_outline_return_value_17 );
    goto try_return_handler_54;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_54:;
    Py_DECREF( locals_PythonFunctionOutlineContext_1173 );
    locals_PythonFunctionOutlineContext_1173 = NULL;
    goto try_return_handler_53;
    // Exception handler code:
    try_except_handler_54:;
    exception_keeper_type_52 = exception_type;
    exception_keeper_value_52 = exception_value;
    exception_keeper_tb_52 = exception_tb;
    exception_keeper_lineno_52 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_DECREF( locals_PythonFunctionOutlineContext_1173 );
    locals_PythonFunctionOutlineContext_1173 = NULL;
    // Re-raise.
    exception_type = exception_keeper_type_52;
    exception_value = exception_keeper_value_52;
    exception_tb = exception_keeper_tb_52;
    exception_lineno = exception_keeper_lineno_52;

    goto try_except_handler_53;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    // Return handler code:
    try_return_handler_53:;
    CHECK_OBJECT( (PyObject *)outline_16_var___class__ );
    Py_DECREF( outline_16_var___class__ );
    outline_16_var___class__ = NULL;

    goto outline_result_17;
    // Exception handler code:
    try_except_handler_53:;
    exception_keeper_type_53 = exception_type;
    exception_keeper_value_53 = exception_value;
    exception_keeper_tb_53 = exception_tb;
    exception_keeper_lineno_53 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_53;
    exception_value = exception_keeper_value_53;
    exception_tb = exception_keeper_tb_53;
    exception_lineno = exception_keeper_lineno_53;

    goto outline_exception_17;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( codegen$Contexts );
    return MOD_RETURN_VALUE( NULL );
    outline_exception_17:;
    exception_lineno = 1173;
    goto try_except_handler_52;
    outline_result_17:;
    tmp_assign_source_116 = tmp_outline_return_value_17;
    UPDATE_STRING_DICT1( moduledict_codegen$Contexts, (Nuitka_StringObject *)const_str_plain_PythonFunctionOutlineContext, tmp_assign_source_116 );
    goto try_end_20;
    // Exception handler code:
    try_except_handler_52:;
    exception_keeper_type_54 = exception_type;
    exception_keeper_value_54 = exception_value;
    exception_keeper_tb_54 = exception_tb;
    exception_keeper_lineno_54 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_17__bases );
    tmp_class_creation_17__bases = NULL;

    Py_XDECREF( tmp_class_creation_17__class_decl_dict );
    tmp_class_creation_17__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_17__prepared );
    tmp_class_creation_17__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_54;
    exception_value = exception_keeper_value_54;
    exception_tb = exception_keeper_tb_54;
    exception_lineno = exception_keeper_lineno_54;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4ce2351b00e0ce552f4c14d83c392e3 );
#endif
    popFrameStack();

    assertFrameObject( frame_f4ce2351b00e0ce552f4c14d83c392e3 );

    goto frame_no_exception_17;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4ce2351b00e0ce552f4c14d83c392e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f4ce2351b00e0ce552f4c14d83c392e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f4ce2351b00e0ce552f4c14d83c392e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f4ce2351b00e0ce552f4c14d83c392e3, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_17:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__bases );
    Py_DECREF( tmp_class_creation_17__bases );
    tmp_class_creation_17__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_decl_dict );
    Py_DECREF( tmp_class_creation_17__class_decl_dict );
    tmp_class_creation_17__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__prepared );
    Py_DECREF( tmp_class_creation_17__prepared );
    tmp_class_creation_17__prepared = NULL;


    return MOD_RETURN_VALUE( module_codegen$Contexts );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
