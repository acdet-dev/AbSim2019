/* Generated code for Python source for module 'Options'
 * created by Nuitka version 0.5.31
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_Options is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_Options;
PyDictObject *moduledict_Options;

/* The module constants used, if any. */
extern PyObject *const_str_plain_setLevel;
static PyObject *const_str_digest_0730bf20647f4f8106e68afba7d49131;
static PyObject *const_tuple_str_digest_3b894041eea82e2fea9b741aeeedf865_tuple;
extern PyObject *const_str_plain_getPythonPathForScons;
extern PyObject *const_dict_empty;
static PyObject *const_str_digest_e0e0f50e90b11d04627e07e5e534115c;
extern PyObject *const_str_plain_PYTHONHASHSEED;
static PyObject *const_str_digest_06cc1079d55905af7b68e7a756b22d05;
extern PyObject *const_tuple_str_plain_value_tuple;
extern PyObject *const_str_plain_show_scons;
extern PyObject *const_str_angle_listcontraction;
static PyObject *const_str_digest_7b529154659ec358155e1d1de105842b;
extern PyObject *const_str_plain_default;
static PyObject *const_dict_a9101022469a764fe6b4acd01bb22355;
static PyObject *const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple;
static PyObject *const_str_digest_e83450d8f459f012a8e64edb69727742;
static PyObject *const_str_plain_update_dependency_cache;
extern PyObject *const_str_plain_getPythonFlags;
static PyObject *const_str_plain_scons_python;
extern PyObject *const_str_plain_assumeYesForDownloads;
static PyObject *const_str_plain_c_compiler_group;
extern PyObject *const_str_plain_OptionParser;
static PyObject *const_str_plain_warn_unusual_code;
extern PyObject *const_str_plain_os;
extern PyObject *const_str_plain_None;
static PyObject *const_str_digest_2066ce09ec83a0da05ffee69f6f232a2;
extern PyObject *const_str_plain_python_debug;
static PyObject *const_str_digest_008a0a017baee6aff43344720dc02ad9;
static PyObject *const_str_plain_ICON_PATH;
static PyObject *const_str_digest_ff29ba6accba7bf3bc585f9666d1f472;
extern PyObject *const_str_plain_Options;
static PyObject *const_str_plain_file_reference_mode;
static PyObject *const_str_digest_e8b095c0d61a542b5771967680c01e67;
static PyObject *const_tuple_dfa13117464e5f55a384729e762e1638_tuple;
static PyObject *const_tuple_str_digest_d180296833a757be816b5fcab44e0347_tuple;
extern PyObject *const_str_plain_plugin_name;
extern PyObject *const_str_plain_utils;
static PyObject *const_str_digest_a13bdb5e65543fe6e94f114a56984c5c;
static PyObject *const_dict_9968416de4b8eb40646f6388041eec5a;
extern PyObject *const_str_plain_disabled;
static PyObject *const_str_plain_list_plugins;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_digest_a4fc5193531b6150e42d718b392fd227;
extern PyObject *const_str_plain_flags;
extern PyObject *const_str_plain_isExperimental;
static PyObject *const_str_digest_6f223af97602dbde04d0ea3a5add6869;
static PyObject *const_tuple_str_digest_2353a1b7be128da2615d51f9a4ca3dbe_tuple;
static PyObject *const_tuple_str_plain_no_warnings_tuple;
extern PyObject *const_str_plain_shallDetectMissingPlugins;
static PyObject *const_str_plain_plugins_enabled;
extern PyObject *const_str_plain_path;
static PyObject *const_dict_75ac81846735ba336e897a41798a025c;
extern PyObject *const_str_chr_45;
static PyObject *const_str_digest_253e8c634e852449d2d79967508bf91d;
static PyObject *const_dict_0ad4788675528d8982a04cde68621006;
static PyObject *const_tuple_7ffab47799d19814b98636af0b44a932_tuple;
static PyObject *const_str_digest_31730815375f0e787899dcd04cc30aa0;
static PyObject *const_str_digest_df2c7df2c8191b7413ae4192dda59b2f;
extern PyObject *const_str_plain_normpath;
static PyObject *const_str_digest_348f668e21b79db9e8ad525164de0ee1;
extern PyObject *const_str_plain_choices;
static PyObject *const_str_plain_execute_group;
static PyObject *const_dict_4806082570b3d4a3b572377edcbcb3bb;
static PyObject *const_str_digest_29f22d31e2612090153f2d0b53f05d17;
static PyObject *const_str_digest_a46d5c83bf50369817004d0ae3068212;
extern PyObject *const_tuple_str_dot_tuple;
extern PyObject *const_str_plain_no_asserts;
static PyObject *const_str_digest_d180296833a757be816b5fcab44e0347;
extern PyObject *const_str_plain_isFullCompat;
static PyObject *const_dict_b6567d48878bd6a564df12f2792ed412;
extern PyObject *const_str_plain_getPluginsDisabled;
extern PyObject *const_str_plain_runtime;
static PyObject *const_str_plain_bad;
static PyObject *const_tuple_str_digest_1e0691616d687838fcfcf9e105cb4f2c_tuple;
extern PyObject *const_str_plain_getShallFollowExtra;
static PyObject *const_str_digest_77b02a1a563d330fd51e8c9e7358129e;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_0038a88d36dd7b18556a93f0b96f344c;
extern PyObject *const_str_plain_endswith;
static PyObject *const_str_digest_d90c6f9059bfbf9b701e35af76eb7e66;
static PyObject *const_str_digest_1763e4d4cad050cb477b4075c12e61b9;
static PyObject *const_tuple_str_plain_listPlugins_tuple;
static PyObject *const_str_digest_9f25c19858b77b731128c72d40e5f5b1;
static PyObject *const_str_plain_norandomization;
static PyObject *const_str_digest_1166ed4ea02e252b349ea20821361e49;
static PyObject *const_str_digest_a8790475190f78aa2acabac27744f407;
extern PyObject *const_str_plain_False;
static PyObject *const_tuple_b6d47a1fac0ac1116306d2c778fc7fa0_tuple;
extern PyObject *const_str_digest_7681cf7d12f55a4b4df9fcde1b3e30bb;
static PyObject *const_str_plain_jobs;
extern PyObject *const_str_plain_getNuitkaVersion;
static PyObject *const_tuple_fc33f4d4eefe708c7f5fade18f710ac3_tuple;
static PyObject *const_tuple_str_plain_result_str_plain_plugin_enabled_tuple;
extern PyObject *const_str_plain_extra_args;
static PyObject *const_str_digest_99c99677a4e4e5551851722475466536;
extern PyObject *const_int_0;
static PyObject *const_str_digest_2353a1b7be128da2615d51f9a4ca3dbe;
static PyObject *const_tuple_str_digest_d622909c277871892b649806560e5ee9_tuple;
static PyObject *const_str_digest_46f785c15c72b806f29a68d8dfd47979;
extern PyObject *const_str_digest_59bdb53e22971cd7d7e7b286d1104da6;
static PyObject *const_tuple_str_digest_18e517f9850452ab3cf33b46e8bcada9_tuple;
extern PyObject *const_str_plain_getIntendedPythonArch;
static PyObject *const_str_digest_1e0691616d687838fcfcf9e105cb4f2c;
extern PyObject *const_str_plain_graph;
static PyObject *const_str_digest_3f6200677f4db8f5d868225a76599c65;
static PyObject *const_str_plain_plugins_disabled;
extern PyObject *const_str_plain_isMingw;
static PyObject *const_str_digest_3ac6a5b1ddeef4b1cc6a93178eede16e;
static PyObject *const_tuple_str_digest_b18a177c45550b4f3f516a11bf101257_tuple;
extern PyObject *const_str_digest_85fe97af08c9a213aa891dc673aeaa3e;
static PyObject *const_str_digest_b18a177c45550b4f3f516a11bf101257;
extern PyObject *const_str_plain_shallCreateGraph;
static PyObject *const_str_plain_display_tree;
static PyObject *const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple;
extern PyObject *const_tuple_str_chr_61_int_pos_1_tuple;
extern PyObject *const_str_plain_shallMakeModule;
extern PyObject *const_str_plain_metavar;
extern PyObject *const_str_plain_on;
static PyObject *const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple;
static PyObject *const_dict_f9dec362e3826b89bc423d0a382669c5;
static PyObject *const_tuple_str_digest_49ad4f31d937fb275eae6082ce4c2f7e_tuple;
extern PyObject *const_str_plain___cached__;
static PyObject *const_dict_8051a9b4950f7a98676f92b125b0a5a9;
extern PyObject *const_str_plain_exit;
static PyObject *const_str_digest_00c314cfeb398027009e203584943dfb;
static PyObject *const_dict_9698778f5c679af1b643e7cc72ba60e3;
extern PyObject *const_str_plain_basename;
extern PyObject *const_str_plain_isProfile;
static PyObject *const_str_digest_9ac1ed25c92f3ebd3d47fc83855c6798;
static PyObject *const_str_digest_268bd5cadede0ba0322c51dab58060ed;
extern PyObject *const_str_plain_isClang;
static PyObject *const_str_digest_00d395acfd6f5a59596c56db84b18679;
static PyObject *const_str_plain_include_group;
extern PyObject *const_str_plain_shallRunInDebugger;
static PyObject *const_str_digest_8ad9a10a20aa1e5f8014eb0eae178c2f;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_070be269e5c34380728f9fc12e47c2bf;
static PyObject *const_str_digest_3196075a13d9c8ad6a5ded309a38562c;
static PyObject *const_tuple_str_plain_trace_imports_tuple;
static PyObject *const_dict_90a95198da96374edd136a324cfe2551;
static PyObject *const_tuple_str_digest_93035a62de394da955eafe810adcb94a_tuple;
static PyObject *const_str_digest_a87c6594d01a42101f3bfdae3f09902a;
static PyObject *const_tuple_str_digest_ef48d902fc32bf8f11ba290ed22dfe84_tuple;
static PyObject *const_str_digest_6eb625ebe8945450e4fac63cdf07efd0;
static PyObject *const_dict_68bef2472fa0693d2e9cde3165230e7e;
static PyObject *const_str_digest_9556b4546b4577c6523da3578179b9b4;
static PyObject *const_str_plain_recurse_extra_files;
static PyObject *const_str_digest_89159a5dbad3f2fb2e8b857c60946590;
extern PyObject *const_str_plain_startswith;
extern PyObject *const_str_plain_help;
extern PyObject *const_str_plain_shallNotDoExecCCompilerCall;
extern PyObject *const_str_plain_shallFollowNoImports;
static PyObject *const_str_digest_07c984f555862c5fe07a79469d5a22eb;
static PyObject *const_str_digest_b6f7031b7e2bccd0ab51d368f37477f8;
extern PyObject *const_str_plain_shallFollowAllImports;
static PyObject *const_str_digest_5f92110962dad42b6e9f8718847150da;
extern PyObject *const_str_plain_action;
static PyObject *const_tuple_str_digest_07c984f555862c5fe07a79469d5a22eb_tuple;
static PyObject *const_str_digest_ef48d902fc32bf8f11ba290ed22dfe84;
extern PyObject *const_tuple_str_plain_path_tuple;
static PyObject *const_str_digest_905a0ca1360b0a5bb2b938cdcab0da3d;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_positional_args;
static PyObject *const_tuple_str_digest_0038a88d36dd7b18556a93f0b96f344c_tuple;
static PyObject *const_str_plain_shallOptimizeStringExec;
static PyObject *const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple;
extern PyObject *const_tuple_str_chr_44_tuple;
static PyObject *const_str_plain_python_scons;
extern PyObject *const_str_plain_shallDumpBuiltTreeXML;
extern PyObject *const_str_chr_61;
extern PyObject *const_str_plain_frozen;
static PyObject *const_str_plain_include_packages;
static PyObject *const_str_plain_indication;
extern PyObject *const_str_plain_lower;
static PyObject *const_dict_d08467263ea7a279b4a5e664b6eb12c4;
static PyObject *const_str_plain_codegen_group;
extern PyObject *const_str_chr_123;
static PyObject *const_str_plain_allow_reexecute;
static PyObject *const_tuple_str_digest_00d395acfd6f5a59596c56db84b18679_tuple;
extern PyObject *const_str_plain_getOutputDir;
static PyObject *const_dict_a2e498776be6cd82fda35028659b0622;
static PyObject *const_str_digest_1999b862fee169df7201f15bd1e9bcad;
static PyObject *const_str_digest_274157aee680c8eed59b3be6f77587cd;
static PyObject *const_str_digest_7b113117fd237deaef422d3a4d7e9c32;
static PyObject *const_str_digest_ea57b1d8c130aaa1d4daa0d4f3dbdac0;
extern PyObject *const_str_plain_getOS;
static PyObject *const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6;
static PyObject *const_str_digest_e5b51f99fd3c31b98c248d48e7574b16;
extern PyObject *const_str_digest_68e779b074842129991baeb4e329e7d3;
extern PyObject *const_str_plain_value;
static PyObject *const_str_digest_63956f13172d297e8502409fdc42b709;
extern PyObject *const_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60;
extern PyObject *const_str_plain_isAllowedToReexecute;
static PyObject *const_tuple_str_digest_268bd5cadede0ba0322c51dab58060ed_tuple;
extern PyObject *const_str_plain_isShowProgress;
static PyObject *const_str_digest_caae9f31bca5fbe5610d39e1657be0f0;
static PyObject *const_str_plain_show_inclusion;
static PyObject *const_str_plain_obsolete_executable;
static PyObject *const_str_plain_DIRECTORY;
static PyObject *const_tuple_str_digest_182801ca351e48a7ac147d78d9a5a172_tuple;
extern PyObject *const_str_plain_shallDisableConsoleWindow;
static PyObject *const_str_digest_1fbf263a160f21148f892a1b15932c5a;
extern PyObject *const_str_plain_enumerate;
extern PyObject *const_str_plain_isRemoveBuildDir;
static PyObject *const_tuple_6a4e2a16b6c2151a91df21cd0a488536_tuple;
static PyObject *const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5;
static PyObject *const_str_plain_recurse_all;
extern PyObject *const_str_plain_mingw;
static PyObject *const_str_digest_9a09f3be7c40522696df04272854d4ad;
static PyObject *const_str_plain_recurse_modules;
static PyObject *const_tuple_str_digest_44da9cf7d063a682915b28e16c190ea6_tuple;
static PyObject *const_tuple_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6_tuple;
static PyObject *const_tuple_str_digest_919dfec0da52245e2d2f6edeae5a1142_tuple;
static PyObject *const_str_digest_82960d53279f2e14c78ad04687d8edf2;
static PyObject *const_str_digest_2adad11ced0222182a3bde8b4673464b;
extern PyObject *const_str_plain_x86;
extern PyObject *const_str_plain_nt;
extern PyObject *const_str_plain_verbose;
static PyObject *const_dict_b81c98a4816e9ddb7651bd033b7215d2;
static PyObject *const_str_digest_3ccf4aedec4bac5727cc0c1b289964ab;
static PyObject *const_str_digest_2d81e4659ed7ee05a20b1259b3fd971b;
extern PyObject *const_str_plain_add_option_group;
static PyObject *const_str_digest_2e24eb0be25ec092a3baa722dc55b330;
static PyObject *const_tuple_str_digest_63956f13172d297e8502409fdc42b709_tuple;
static PyObject *const_str_digest_20cbdfa9ffc9f9c39bdd7d5fd94cd769;
static PyObject *const_str_digest_218df1a0cc5a4ceaffc69395c4609ab7;
extern PyObject *const_str_plain_part;
static PyObject *const_str_digest_f13acabca636d4d483b3d53e84c3d766;
static PyObject *const_str_plain_improved;
static PyObject *const_tuple_str_digest_0e4e79a120d8772251ce3088f7d11248_tuple;
extern PyObject *const_str_plain_experimental;
extern PyObject *const_str_plain_warning;
static PyObject *const_str_plain_recurse_extra;
static PyObject *const_str_digest_a36e77b7d0a3758e6a6afc584106002f;
static PyObject *const_str_plain_recurse_group;
static PyObject *const_dict_ab01781f7bc15d0cb66d375a405a8c23;
static PyObject *const_str_plain_debug_group;
static PyObject *const_str_digest_182801ca351e48a7ac147d78d9a5a172;
static PyObject *const_str_digest_20c9a2ec3b9bc0c10958122412cc775c;
static PyObject *const_str_digest_000f2dcd6617662a5ec06cf266d5aede;
static PyObject *const_str_digest_ca95b6fd7bd310521598a1589c336a8c;
extern PyObject *const_str_plain_isPythonDebug;
static PyObject *const_str_plain_assume_yes_for_downloads;
static PyObject *const_str_plain_detect_missing_plugins;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_plain_recurse_not_modules;
extern PyObject *const_str_plain_x86_64;
static PyObject *const_str_digest_aad42f6a047197f6f82d5ac59172233d;
static PyObject *const_tuple_str_digest_e0e0f50e90b11d04627e07e5e534115c_tuple;
static PyObject *const_str_plain_msvc;
static PyObject *const_tuple_94e9cfb72d94240569769ed9b57cf011_tuple;
static PyObject *const_str_digest_fdbf2a6dc5371272d02916acacd348df;
static PyObject *const_str_digest_ef0f2c1fc3eeca798ea70271ec5741e1;
static PyObject *const_dict_d1f0ccc2f13cc00c28313115feff62ba;
static PyObject *const_str_plain__splitShellPattern;
static PyObject *const_dict_d46f58cd09bb8f0399ff079ba57dd7f0;
static PyObject *const_str_digest_60916d45686821dae42b81cd8917e3ba;
static PyObject *const_dict_0db29dd5ce570108641e26279aa1d6bb;
static PyObject *const_str_digest_25433114711138da4c9f37c122d5a3e0;
static PyObject *const_str_plain_recompile_c_only;
static PyObject *const_str_digest_44da9cf7d063a682915b28e16c190ea6;
extern PyObject *const_str_plain_isStandaloneMode;
extern PyObject *const_str_plain_original;
extern PyObject *const_str_plain_DEBUG;
extern PyObject *const_str_plain_print_help;
static PyObject *const_str_digest_c34f9489814ce6dde9158d32b1df6898;
static PyObject *const_str_digest_d3391bc5505627a621ab17af42b5e153;
extern PyObject *const_str_plain_version;
static PyObject *const_str_digest_76a20e0434f49c589f5f87e961db8fd3;
extern PyObject *const_str_plain_getJobLimit;
static PyObject *const_str_digest_18e517f9850452ab3cf33b46e8bcada9;
extern PyObject *const_str_empty;
static PyObject *const_dict_f7ee065b4f969f810663b09dfe85cb24;
static PyObject *const_str_plain_no_case_module;
extern PyObject *const_str_plain_python_version;
static PyObject *const_tuple_919a9acd13336714b04cc11908b85505_tuple;
static PyObject *const_str_plain_nowarnings;
static PyObject *const_str_digest_3b894041eea82e2fea9b741aeeedf865;
static PyObject *const_tuple_str_digest_df2c7df2c8191b7413ae4192dda59b2f_tuple;
extern PyObject *const_str_plain_shallCreatePyiFile;
static PyObject *const_str_plain_MODULE;
extern PyObject *const_str_plain_result;
static PyObject *const_str_digest_0f684c542ec93bce2df505f518c4b1b8;
extern PyObject *const_str_plain_getLogger;
static PyObject *const_str_digest_f5da5fd9e2df79997f1c0724df55d569;
extern PyObject *const_str_plain_getCoreCount;
static PyObject *const_str_digest_7c20112af2aeaa07afafa72120d096df;
static PyObject *const_str_digest_baff1759a20c9a5acf6cc580f2ed0149;
static PyObject *const_str_plain_windows_group;
extern PyObject *const_tuple_str_plain_Utils_tuple;
extern PyObject *const_str_plain_shallHaveStatementLines;
static PyObject *const_str_digest_a85c1bd4a7e7b3e2eae7b4253bfefb6c;
extern PyObject *const_str_plain_isShowInclusion;
static PyObject *const_dict_95ccfece433c6f6c934c3808a3f69f19;
static PyObject *const_dict_f53f2b68bdeb8b2acc2b479d67a53074;
extern PyObject *const_str_plain_N;
extern PyObject *const_str_plain_add_option;
static PyObject *const_dict_6fdb311d2c4c6508c918d2fe1b337bd3;
extern PyObject *const_str_digest_c46232c53d9f9936cf8242ca32901592;
extern PyObject *const_str_plain_getShallFollowExtraFilePatterns;
extern PyObject *const_str_plain_Version;
static PyObject *const_str_digest_507e1544d34f3449cefc7e95aa4e43f6;
extern PyObject *const_str_plain_getPluginOptions;
static PyObject *const_dict_1f7fbc2dabea4a09516283b4d4bc14e4;
static PyObject *const_dict_d65576168a837f10db67bdd0d5297d28;
static PyObject *const_tuple_str_digest_9a09f3be7c40522696df04272854d4ad_tuple;
static PyObject *const_str_digest_0f13e1f8236e0a56a570aea0b454e3b3;
extern PyObject *const_str_plain_getPluginsEnabled;
static PyObject *const_str_plain_output_dir;
extern PyObject *const_str_plain_argv;
static PyObject *const_str_digest_4913f61cf652f6bfa0f584ea4716697a;
extern PyObject *const_str_plain_getIconPath;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_digest_5369445afe6ad40445ccdb0facd01155;
static PyObject *const_tuple_str_digest_77b02a1a563d330fd51e8c9e7358129e_tuple;
static PyObject *const_dict_570f8765b523a6b072016db58acd7292;
extern PyObject *const_str_plain_options;
static PyObject *const_tuple_str_plain_no_asserts_tuple;
extern PyObject *const_str_plain_store_false;
static PyObject *const_str_digest_61101efb938893ea1508b70b172b5677;
extern PyObject *const_str_plain_add;
static PyObject *const_str_digest_0c22f7af7b0a4fa33a79410137285596;
static PyObject *const_str_digest_e22d9173bccdc16d4477eee43c8497ac;
static PyObject *const_str_digest_a94f5f3ab2b42ad0afcf959f0497fce7;
static PyObject *const_str_digest_3cb499860ad4d7639999eef254575b78;
static PyObject *const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple;
static PyObject *const_str_plain_recurse_stdlib;
static PyObject *const_dict_d80a95aa8a24826f03f1bbcb02e0d877;
static PyObject *const_str_plain_plugin_group;
static PyObject *const_tuple_str_digest_ca95b6fd7bd310521598a1589c336a8c_tuple;
static PyObject *const_dict_982e5273ca0a6d2d38c9e565a691c0f2;
static PyObject *const_str_plain_no_dependency_cache;
static PyObject *const_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1;
static PyObject *const_str_plain_python_arch;
static PyObject *const_dict_f6a84467671671bed9a729c01faf6eb0;
static PyObject *const_tuple_d6bdf977d7cdf572f474b619c9d47469_tuple;
static PyObject *const_str_digest_6120fea2456c84f26fd70306fee05e56;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_915928a8f3046246eea03ff37578bdf9;
static PyObject *const_tuple_str_digest_9556b4546b4577c6523da3578179b9b4_tuple;
extern PyObject *const_str_plain_isLto;
static PyObject *const_tuple_str_digest_d26c39e8ed4ddb2171e43f32074c3668_tuple;
static PyObject *const_tuple_str_plain_no_warnings_str_plain_nowarnings_tuple;
static PyObject *const_tuple_str_digest_46f785c15c72b806f29a68d8dfd47979_tuple;
extern PyObject *const_str_plain_shallFreezeAllStdlib;
extern PyObject *const_str_plain_is_nuitka_run;
extern PyObject *const_str_plain_append;
static PyObject *const_tuple_str_digest_749d64834db4e74f339318a144653b9a_tuple;
extern PyObject *const_str_plain_shallFollowStandardLibrary;
static PyObject *const_str_digest_083b5be111f4c8b31dfefd70a7615875;
static PyObject *const_str_plain_python_flags;
static PyObject *const_str_digest_2628b2da7143e7e835e536f6f73483c8;
static PyObject *const_dict_963aa946b3440440fe76b2e311636977;
extern PyObject *const_str_digest_f1c6c9be039474fe95893251fd2b4000;
static PyObject *const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79;
static PyObject *const_str_digest_2af64c3ed3ff95fc82dfce1598612dc1;
static PyObject *const_str_digest_0a0aff9f62f0d1e8c59663305c25a371;
extern PyObject *const_str_plain_parser;
static PyObject *const_str_digest_3504384c8cd44eb120046939212bf7ed;
static PyObject *const_str_digest_a1b73434dde6ef4b54439b149420d10b;
static PyObject *const_str_digest_e6537e54fa67ccea5df1625ee9d37760;
static PyObject *const_str_digest_0f64d43d9cf5e40fb886257fa3b28964;
static PyObject *const_str_plain_generate_c_only;
static PyObject *const_str_plain_outputdir_group;
extern PyObject *const_str_plain_split;
static PyObject *const_dict_e05c9b973b11029e09a99d8142ddfc93;
static PyObject *const_tuple_1c0e6ffbbde28de054c77c94763a9e2b_tuple;
static PyObject *const_str_plain_warn_implicit_exceptions;
static PyObject *const_str_digest_23e2e20ef56f951794853554a3a508d6;
extern PyObject *const_str_plain_getArchitecture;
static PyObject *const_str_plain_explain_imports;
extern PyObject *const_str_plain_off;
extern PyObject *const_str_plain_exists;
static PyObject *const_tuple_str_plain_getSupportedPythonVersions_tuple;
static PyObject *const_str_plain_dump_group;
static PyObject *const_str_digest_198d919a5e9e449d5ecf81dddac77d20;
extern PyObject *const_str_plain_dest;
extern PyObject *const_str_plain_optparse;
static PyObject *const_dict_f55c75937f11f826e31f0719c4fa9c96;
static PyObject *const_str_digest_ef9ef4fcd0a4bcb04d473d0419686be6;
static PyObject *const_str_plain_trace_import;
static PyObject *const_str_plain_statement_lines;
extern PyObject *const_str_plain_x;
static PyObject *const_str_digest_2b0af2d25c2533b6a07c1aacbaa63eba;
static PyObject *const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple;
static PyObject *const_tuple_7f868864dcb1dd0c7268cc60bfcfc142_tuple;
static PyObject *const_str_digest_91374e86cd95854fdf69256ea2446159;
static PyObject *const_str_digest_ab3213453d8827b171e098b981d71b36;
static PyObject *const_dict_d8084db55bb0173b66ca83cf5be4a1f7;
static PyObject *const_tuple_str_plain_parts_str_plain_part_tuple;
extern PyObject *const_str_plain_Utils;
static PyObject *const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple;
static PyObject *const_str_digest_77fb617d8001d38b07d7c0c49950ac49;
extern PyObject *const_str_plain_clang;
extern PyObject *const_str_plain_getOutputPath;
extern PyObject *const_str_plain_any_case_module;
static PyObject *const_dict_ae7bb8b561973c8d04445137aad11631;
extern PyObject *const_str_plain_debug;
static PyObject *const_str_digest_4404820c6f10802a609c05d4a136e6ee;
extern PyObject *const_str_plain_getMustIncludeModules;
extern PyObject *const_str_plain_shallNotStoreDependsExeCachedResults;
static PyObject *const_dict_012a9328b79bad885d5993fdc0b796e8;
extern PyObject *const_str_plain_getShallFollowInNoCase;
static PyObject *const_dict_a9a03b40ba8f26cdbb333b87799dc921;
static PyObject *const_dict_ccf05bbd6062a341ea16977d08e4ace1;
static PyObject *const_str_digest_d1976a1121a27393007d081974bf5ae9;
static PyObject *const_dict_55b3309b164506bd83a51d039ef1179d;
static PyObject *const_str_digest_e7f72fc9244df68bd25d314dd4dbc74b;
extern PyObject *const_str_plain_getMustIncludePackages;
extern PyObject *const_str_plain_PythonVersions;
static PyObject *const_str_digest_fc7c671d949f20fb52f85659d7080b39;
extern PyObject *const_str_plain_shallExecuteImmediately;
static PyObject *const_dict_1f72f6528b11a15cfc32a55abad3e2f5;
extern PyObject *const_list_empty;
static PyObject *const_str_plain_recurse_none;
static PyObject *const_str_digest_aaf340b09aa648ed0e35d7b8fed1e68b;
static PyObject *const_tuple_fd9bd18abc843709bbdfa4939c29306e_tuple;
extern PyObject *const_str_plain_win_disable_console;
extern PyObject *const_str_plain_no_site;
static PyObject *const_str_plain_plugin_enabled;
static PyObject *const_str_plain_is_standalone;
extern PyObject *const_str_plain_logging;
extern PyObject *const_str_plain_INFO;
static PyObject *const_str_digest_49ad4f31d937fb275eae6082ce4c2f7e;
static PyObject *const_tuple_f8c54c1f3d7d17e6cf8e8b9532e0158f_tuple;
extern PyObject *const_str_plain_executable;
static PyObject *const_str_digest_f4b77416467901cc990dc8ee3500f4ba;
static PyObject *const_tuple_str_digest_1fbf263a160f21148f892a1b15932c5a_tuple;
static PyObject *const_str_digest_978105f0338b08759e4337ceca390cd9;
static PyObject *const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple;
static PyObject *const_str_digest_3cd4325f1e1f69e4ec5f33696a01c94f;
static PyObject *const_str_digest_c0a9a1b70f20f0ce5361de894d3db75d;
extern PyObject *const_str_plain_parseArgs;
static PyObject *const_str_plain_show_memory;
extern PyObject *const_str_plain_shallExplainImports;
extern PyObject *const_str_plain_arg;
static PyObject *const_tuple_25f13a07532615ebccd7a031a6fe2ed5_tuple;
extern PyObject *const_str_plain_args;
static PyObject *const_str_digest_749d64834db4e74f339318a144653b9a;
static PyObject *const_tuple_4a1f625c7edc4f9009ea9412f2eb7ca6_tuple;
static PyObject *const_str_digest_b22b6a8fbe4f1eb24d47c1182e8594be;
static PyObject *const_tuple_str_digest_181925cc600ef7846f4fc9b1da40c033_tuple;
static PyObject *const_str_digest_d226a3eaf71353ef4246518ce9a7bf20;
static PyObject *const_tuple_str_digest_d3391bc5505627a621ab17af42b5e153_tuple;
static PyObject *const_dict_ded7ced2e817eaed7d9d3482108130c5;
static PyObject *const_str_plain_keep_pythonpath;
extern PyObject *const_str_plain_SUPPRESS_HELP;
extern PyObject *const_str_plain_shallDisplayBuiltTree;
static PyObject *const_str_plain_trace_execution;
static PyObject *const_tuple_str_digest_a4fc5193531b6150e42d718b392fd227_tuple;
static PyObject *const_str_digest_3493e1419f00062da30c5054eace3ba0;
static PyObject *const_str_digest_05f186fedc8558d8f48fe769c4a7504f;
static PyObject *const_tuple_str_plain_getNuitkaVersion_tuple;
static PyObject *const_str_digest_93035a62de394da955eafe810adcb94a;
extern PyObject *const_str_plain_shallWarnImplicitRaises;
static PyObject *const_str_plain_include_modules;
extern PyObject *const_str_plain_join;
static PyObject *const_str_digest_1df1930ead0b5e1f7163c1225a06fa07;
static PyObject *const_dict_cd2f10c233c60e843dc94e0ca3fff447;
extern PyObject *const_str_plain_isUnstripped;
static PyObject *const_str_digest_d78eaf819b148cd0ed4de8a87366220a;
extern PyObject *const_str_digest_ebf31cb8a295537cdd204a85dd2b13f2;
static PyObject *const_str_plain_PATTERN;
static PyObject *const_str_plain_shallListPlugins;
extern PyObject *const_str_plain_getShallFollowModules;
extern PyObject *const_str_dot;
extern PyObject *const_str_plain_listPlugins;
extern PyObject *const_str_plain_environ;
extern PyObject *const_str_plain_getPositionalArgs;
static PyObject *const_tuple_str_digest_eb2a748be8fdd84357bb51822fa7dd48_tuple;
static PyObject *const_tuple_str_digest_0a0aff9f62f0d1e8c59663305c25a371_tuple;
extern PyObject *const_str_chr_44;
static PyObject *const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple;
static PyObject *const_str_plain_dump_xml;
static PyObject *const_dict_3f4bd6c51d5048274ce90a44405017b0;
static PyObject *const_str_digest_096be9a55acdb9f027de49b047bd228d;
extern PyObject *const_str_plain_getIntendedPythonVersion;
static PyObject *const_dict_48a12ca9025ab4ff10c795867c5ba0bb;
extern PyObject *const_str_plain_no_warnings;
static PyObject *const_tuple_str_digest_348f668e21b79db9e8ad525164de0ee1_tuple;
extern PyObject *const_str_plain_getMsvcVersion;
static PyObject *const_str_plain_PACKAGE;
extern PyObject *const_str_plain_shallNotUseDependsExeCachedResults;
extern PyObject *const_str_plain_parts;
static PyObject *const_str_digest_019250c3dabb431ea6145ba8daa3611e;
static PyObject *const_str_digest_8074300badc2e1a18e0504a3633df880;
static PyObject *const_dict_f38a879f43bf713c7195c04e0d245695;
static PyObject *const_str_plain_unstripped;
static PyObject *const_str_digest_ea23ff8606bc48a7cd2ae9210fd4a7d3;
static PyObject *const_tuple_str_digest_2628b2da7143e7e835e536f6f73483c8_tuple;
extern PyObject *const_str_plain_getSupportedPythonVersions;
static PyObject *const_str_digest_919dfec0da52245e2d2f6edeae5a1142;
static PyObject *const_str_digest_126a85cfeb4a081042e66eeac95137b9;
extern PyObject *const_str_plain_store;
extern PyObject *const_str_plain_isShowScons;
static PyObject *const_tuple_str_plain_indication_tuple;
extern PyObject *const_tuple_str_plain_x_tuple;
static PyObject *const_dict_aa8231dd4f6fdaa06dbf5512dde88796;
extern PyObject *const_str_plain_getExperimentalIndications;
extern PyObject *const_str_plain_pyi_file;
static PyObject *const_str_plain_remove_build;
static PyObject *const_str_plain_static_hashes;
extern PyObject *const_str_plain_shallClearPythonPathEnvironment;
static PyObject *const_str_digest_181925cc600ef7846f4fc9b1da40c033;
static PyObject *const_str_plain_immediate_execution;
extern PyObject *const_str_plain_char;
extern PyObject *const_str_plain_parse_args;
static PyObject *const_str_digest_a9457866f2f1e7c8e79d32e1131be86b;
static PyObject *const_str_digest_ef2ed6d9473fc26d981c5602152fe549;
static PyObject *const_tuple_str_plain_x86_str_plain_x86_64_tuple;
extern PyObject *const_str_plain_count;
static PyObject *const_tuple_bf3176bee2556beb326253fa06ee2b45_tuple;
extern PyObject *const_str_plain_shallTraceExecution;
static PyObject *const_tuple_str_digest_4913f61cf652f6bfa0f584ea4716697a_tuple;
static PyObject *const_str_digest_7b6bde9c6b044c89b857f7ac6f019324;
static PyObject *const_str_digest_d26c39e8ed4ddb2171e43f32074c3668;
static PyObject *const_tuple_str_digest_000f2dcd6617662a5ec06cf266d5aede_tuple;
static PyObject *const_tuple_str_digest_ef2ed6d9473fc26d981c5602152fe549_tuple;
extern PyObject *const_str_plain_isVerbose;
extern PyObject *const_str_plain_icon_path;
static PyObject *const_str_digest_7ea974d5c00bf28ba60cbe3a4cc1d4d5;
extern PyObject *const_str_plain_NetBSD;
static PyObject *const_str_plain_nosite;
static PyObject *const_str_digest_80a4f2b52193f7cd325dd8a9bb318274;
static PyObject *const_tuple_e4cb1538d3263a5929c47e9b9ad8e0ca_tuple;
static PyObject *const_str_plain_profile;
static PyObject *const_tuple_str_digest_6120fea2456c84f26fd70306fee05e56_tuple;
static PyObject *const_tuple_str_digest_096be9a55acdb9f027de49b047bd228d_tuple;
extern PyObject *const_str_plain_getFileReferenceMode;
extern PyObject *const_str_plain_isShowMemory;
extern PyObject *const_str_plain_isDebug;
static PyObject *const_tuple_str_digest_76a20e0434f49c589f5f87e961db8fd3_tuple;
static PyObject *const_str_plain_no_randomization;
static PyObject *const_str_digest_7d4652e457bb729a32f57d1e066a5d67;
static PyObject *const_str_digest_6ffff9871e7a9049cdcc39ccb0332ee2;
extern PyObject *const_str_plain_shallWarnUnusualCode;
static PyObject *const_dict_5050b44d40c50f56cd13e9ad189ccc0e;
static PyObject *const_str_plain_tracing_group;
extern PyObject *const_str_plain_store_true;
extern PyObject *const_str_plain_shallOnlyExecCCompilerCall;
extern PyObject *const_str_plain_debugger;
static PyObject *const_tuple_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60_tuple;
static PyObject *const_tuple_str_digest_e83450d8f459f012a8e64edb69727742_tuple;
static PyObject *const_str_digest_0e4e79a120d8772251ce3088f7d11248;
static PyObject *const_str_plain_show_progress;
static PyObject *const_str_digest_eb2a748be8fdd84357bb51822fa7dd48;
static PyObject *const_tuple_str_plain_no_randomization_tuple;
static PyObject *const_tuple_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1_tuple;
static PyObject *const_tuple_str_digest_25433114711138da4c9f37c122d5a3e0_tuple;
static PyObject *const_str_plain__python_flags;
extern PyObject *const_str_newline;
static PyObject *const_str_digest_7cd5b8590b982e2d81ae96b374f786b4;
static PyObject *const_str_digest_59a7509ad2b012191ee0b981113c58d4;
static PyObject *const_str_plain_lto;
extern PyObject *const_str_plain_trace_imports;
static PyObject *const_dict_a3622bcc2795e0b4e6bb780eab3dc833;
static PyObject *const_str_digest_d8dcdf10fdb1fba87127786483514851;
static PyObject *const_str_digest_f43543d711c3365acaf0c7514490ba0f;
static PyObject *const_tuple_str_plain_no_site_tuple;
static PyObject *const_str_digest_733603cf65360204826c57d7ec02deed;
static PyObject *const_dict_0902eb40bd31bd25b3bae9ef7176fa85;
static PyObject *const_str_digest_f265ec4f445f7dafa56a7c60cf81c5b9;
static PyObject *const_str_digest_e87c1164c808877bf2c4be689574292e;
static PyObject *const_str_digest_aa4fe1cd654c351d323b097fb681dd9f;
extern PyObject *const_str_plain_getMainArgs;
extern PyObject *const_str_plain_usage;
extern PyObject *const_str_plain_OptionGroup;
static PyObject *const_dict_45062a32a0550745ae06f84c5860b292;
static PyObject *const_str_digest_e48e8408e1e689620d63cb57dcd8c5bd;
static PyObject *const_str_plain_noasserts;
static PyObject *const_tuple_str_digest_f13acabca636d4d483b3d53e84c3d766_tuple;
static PyObject *const_str_digest_d622909c277871892b649806560e5ee9;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_digest_0730bf20647f4f8106e68afba7d49131 = UNSTREAM_STRING( &constant_bin[ 6613 ], 61, 0 );
    const_tuple_str_digest_3b894041eea82e2fea9b741aeeedf865_tuple = PyTuple_New( 1 );
    const_str_digest_3b894041eea82e2fea9b741aeeedf865 = UNSTREAM_STRING( &constant_bin[ 6674 ], 13, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_3b894041eea82e2fea9b741aeeedf865_tuple, 0, const_str_digest_3b894041eea82e2fea9b741aeeedf865 ); Py_INCREF( const_str_digest_3b894041eea82e2fea9b741aeeedf865 );
    const_str_digest_e0e0f50e90b11d04627e07e5e534115c = UNSTREAM_STRING( &constant_bin[ 6687 ], 7, 0 );
    const_str_digest_06cc1079d55905af7b68e7a756b22d05 = UNSTREAM_STRING( &constant_bin[ 6694 ], 205, 0 );
    const_str_digest_7b529154659ec358155e1d1de105842b = UNSTREAM_STRING( &constant_bin[ 6899 ], 16, 0 );
    const_dict_a9101022469a764fe6b4acd01bb22355 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_a9101022469a764fe6b4acd01bb22355, const_str_plain_action, const_str_plain_append );
    const_str_plain_recurse_not_modules = UNSTREAM_STRING( &constant_bin[ 6915 ], 19, 1 );
    PyDict_SetItem( const_dict_a9101022469a764fe6b4acd01bb22355, const_str_plain_dest, const_str_plain_recurse_not_modules );
    const_str_digest_2d81e4659ed7ee05a20b1259b3fd971b = UNSTREAM_STRING( &constant_bin[ 6934 ], 14, 0 );
    PyDict_SetItem( const_dict_a9101022469a764fe6b4acd01bb22355, const_str_plain_metavar, const_str_digest_2d81e4659ed7ee05a20b1259b3fd971b );
    PyDict_SetItem( const_dict_a9101022469a764fe6b4acd01bb22355, const_str_plain_default, const_list_empty );
    const_str_digest_ef0f2c1fc3eeca798ea70271ec5741e1 = UNSTREAM_STRING( &constant_bin[ 6948 ], 154, 0 );
    PyDict_SetItem( const_dict_a9101022469a764fe6b4acd01bb22355, const_str_plain_help, const_str_digest_ef0f2c1fc3eeca798ea70271ec5741e1 );
    assert( PyDict_Size( const_dict_a9101022469a764fe6b4acd01bb22355 ) == 5 );
    const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple = PyTuple_New( 3 );
    const_str_digest_198d919a5e9e449d5ecf81dddac77d20 = UNSTREAM_STRING( &constant_bin[ 7102 ], 12, 0 );
    PyTuple_SET_ITEM( const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple, 0, const_str_digest_198d919a5e9e449d5ecf81dddac77d20 ); Py_INCREF( const_str_digest_198d919a5e9e449d5ecf81dddac77d20 );
    const_str_digest_e7f72fc9244df68bd25d314dd4dbc74b = UNSTREAM_STRING( &constant_bin[ 7114 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple, 1, const_str_digest_e7f72fc9244df68bd25d314dd4dbc74b ); Py_INCREF( const_str_digest_e7f72fc9244df68bd25d314dd4dbc74b );
    const_str_digest_7ea974d5c00bf28ba60cbe3a4cc1d4d5 = UNSTREAM_STRING( &constant_bin[ 7124 ], 11, 0 );
    PyTuple_SET_ITEM( const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple, 2, const_str_digest_7ea974d5c00bf28ba60cbe3a4cc1d4d5 ); Py_INCREF( const_str_digest_7ea974d5c00bf28ba60cbe3a4cc1d4d5 );
    const_str_digest_e83450d8f459f012a8e64edb69727742 = UNSTREAM_STRING( &constant_bin[ 7135 ], 16, 0 );
    const_str_plain_update_dependency_cache = UNSTREAM_STRING( &constant_bin[ 7151 ], 23, 1 );
    const_str_plain_scons_python = UNSTREAM_STRING( &constant_bin[ 7174 ], 12, 1 );
    const_str_plain_c_compiler_group = UNSTREAM_STRING( &constant_bin[ 7186 ], 16, 1 );
    const_str_plain_warn_unusual_code = UNSTREAM_STRING( &constant_bin[ 7202 ], 17, 1 );
    const_str_digest_2066ce09ec83a0da05ffee69f6f232a2 = UNSTREAM_STRING( &constant_bin[ 7219 ], 61, 0 );
    const_str_digest_008a0a017baee6aff43344720dc02ad9 = UNSTREAM_STRING( &constant_bin[ 7280 ], 104, 0 );
    const_str_plain_ICON_PATH = UNSTREAM_STRING( &constant_bin[ 7384 ], 9, 1 );
    const_str_digest_ff29ba6accba7bf3bc585f9666d1f472 = UNSTREAM_STRING( &constant_bin[ 7393 ], 17, 0 );
    const_str_plain_file_reference_mode = UNSTREAM_STRING( &constant_bin[ 7410 ], 19, 1 );
    const_str_digest_e8b095c0d61a542b5771967680c01e67 = UNSTREAM_STRING( &constant_bin[ 7429 ], 10, 0 );
    const_tuple_dfa13117464e5f55a384729e762e1638_tuple = PyTuple_New( 2 );
    const_str_digest_d8dcdf10fdb1fba87127786483514851 = UNSTREAM_STRING( &constant_bin[ 7439 ], 12, 0 );
    PyTuple_SET_ITEM( const_tuple_dfa13117464e5f55a384729e762e1638_tuple, 0, const_str_digest_d8dcdf10fdb1fba87127786483514851 ); Py_INCREF( const_str_digest_d8dcdf10fdb1fba87127786483514851 );
    const_str_digest_61101efb938893ea1508b70b172b5677 = UNSTREAM_STRING( &constant_bin[ 7451 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_dfa13117464e5f55a384729e762e1638_tuple, 1, const_str_digest_61101efb938893ea1508b70b172b5677 ); Py_INCREF( const_str_digest_61101efb938893ea1508b70b172b5677 );
    const_tuple_str_digest_d180296833a757be816b5fcab44e0347_tuple = PyTuple_New( 1 );
    const_str_digest_d180296833a757be816b5fcab44e0347 = UNSTREAM_STRING( &constant_bin[ 7461 ], 17, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d180296833a757be816b5fcab44e0347_tuple, 0, const_str_digest_d180296833a757be816b5fcab44e0347 ); Py_INCREF( const_str_digest_d180296833a757be816b5fcab44e0347 );
    const_str_digest_a13bdb5e65543fe6e94f114a56984c5c = UNSTREAM_STRING( &constant_bin[ 7478 ], 56, 0 );
    const_dict_9968416de4b8eb40646f6388041eec5a = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_9968416de4b8eb40646f6388041eec5a, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_recurse_stdlib = UNSTREAM_STRING( &constant_bin[ 7534 ], 14, 1 );
    PyDict_SetItem( const_dict_9968416de4b8eb40646f6388041eec5a, const_str_plain_dest, const_str_plain_recurse_stdlib );
    PyDict_SetItem( const_dict_9968416de4b8eb40646f6388041eec5a, const_str_plain_default, Py_False );
    const_str_digest_ef9ef4fcd0a4bcb04d473d0419686be6 = UNSTREAM_STRING( &constant_bin[ 7548 ], 124, 0 );
    PyDict_SetItem( const_dict_9968416de4b8eb40646f6388041eec5a, const_str_plain_help, const_str_digest_ef9ef4fcd0a4bcb04d473d0419686be6 );
    assert( PyDict_Size( const_dict_9968416de4b8eb40646f6388041eec5a ) == 4 );
    const_str_plain_list_plugins = UNSTREAM_STRING( &constant_bin[ 7672 ], 12, 1 );
    const_str_digest_a4fc5193531b6150e42d718b392fd227 = UNSTREAM_STRING( &constant_bin[ 7684 ], 15, 0 );
    const_str_digest_6f223af97602dbde04d0ea3a5add6869 = UNSTREAM_STRING( &constant_bin[ 7699 ], 65, 0 );
    const_tuple_str_digest_2353a1b7be128da2615d51f9a4ca3dbe_tuple = PyTuple_New( 1 );
    const_str_digest_2353a1b7be128da2615d51f9a4ca3dbe = UNSTREAM_STRING( &constant_bin[ 7764 ], 6, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_2353a1b7be128da2615d51f9a4ca3dbe_tuple, 0, const_str_digest_2353a1b7be128da2615d51f9a4ca3dbe ); Py_INCREF( const_str_digest_2353a1b7be128da2615d51f9a4ca3dbe );
    const_tuple_str_plain_no_warnings_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_warnings_tuple, 0, const_str_plain_no_warnings ); Py_INCREF( const_str_plain_no_warnings );
    const_str_plain_plugins_enabled = UNSTREAM_STRING( &constant_bin[ 7770 ], 15, 1 );
    const_dict_75ac81846735ba336e897a41798a025c = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_75ac81846735ba336e897a41798a025c, const_str_plain_action, const_str_plain_append );
    const_str_plain_include_packages = UNSTREAM_STRING( &constant_bin[ 7785 ], 16, 1 );
    PyDict_SetItem( const_dict_75ac81846735ba336e897a41798a025c, const_str_plain_dest, const_str_plain_include_packages );
    const_str_plain_PACKAGE = UNSTREAM_STRING( &constant_bin[ 6941 ], 7, 1 );
    PyDict_SetItem( const_dict_75ac81846735ba336e897a41798a025c, const_str_plain_metavar, const_str_plain_PACKAGE );
    PyDict_SetItem( const_dict_75ac81846735ba336e897a41798a025c, const_str_plain_default, const_list_empty );
    const_str_digest_c0a9a1b70f20f0ce5361de894d3db75d = UNSTREAM_STRING( &constant_bin[ 7801 ], 288, 0 );
    PyDict_SetItem( const_dict_75ac81846735ba336e897a41798a025c, const_str_plain_help, const_str_digest_c0a9a1b70f20f0ce5361de894d3db75d );
    assert( PyDict_Size( const_dict_75ac81846735ba336e897a41798a025c ) == 5 );
    const_str_digest_253e8c634e852449d2d79967508bf91d = UNSTREAM_STRING( &constant_bin[ 8089 ], 14, 0 );
    const_dict_0ad4788675528d8982a04cde68621006 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_0ad4788675528d8982a04cde68621006, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_0ad4788675528d8982a04cde68621006, const_str_plain_dest, const_str_plain_win_disable_console );
    PyDict_SetItem( const_dict_0ad4788675528d8982a04cde68621006, const_str_plain_default, Py_False );
    const_str_digest_aad42f6a047197f6f82d5ac59172233d = UNSTREAM_STRING( &constant_bin[ 8103 ], 72, 0 );
    PyDict_SetItem( const_dict_0ad4788675528d8982a04cde68621006, const_str_plain_help, const_str_digest_aad42f6a047197f6f82d5ac59172233d );
    assert( PyDict_Size( const_dict_0ad4788675528d8982a04cde68621006 ) == 4 );
    const_tuple_7ffab47799d19814b98636af0b44a932_tuple = PyTuple_New( 2 );
    const_str_digest_80a4f2b52193f7cd325dd8a9bb318274 = UNSTREAM_STRING( &constant_bin[ 8175 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_7ffab47799d19814b98636af0b44a932_tuple, 0, const_str_digest_80a4f2b52193f7cd325dd8a9bb318274 ); Py_INCREF( const_str_digest_80a4f2b52193f7cd325dd8a9bb318274 );
    const_str_digest_f4b77416467901cc990dc8ee3500f4ba = UNSTREAM_STRING( &constant_bin[ 8185 ], 5, 0 );
    PyTuple_SET_ITEM( const_tuple_7ffab47799d19814b98636af0b44a932_tuple, 1, const_str_digest_f4b77416467901cc990dc8ee3500f4ba ); Py_INCREF( const_str_digest_f4b77416467901cc990dc8ee3500f4ba );
    const_str_digest_31730815375f0e787899dcd04cc30aa0 = UNSTREAM_STRING( &constant_bin[ 8190 ], 334, 0 );
    const_str_digest_df2c7df2c8191b7413ae4192dda59b2f = UNSTREAM_STRING( &constant_bin[ 8524 ], 35, 0 );
    const_str_digest_348f668e21b79db9e8ad525164de0ee1 = UNSTREAM_STRING( &constant_bin[ 8559 ], 29, 0 );
    const_str_plain_execute_group = UNSTREAM_STRING( &constant_bin[ 8588 ], 13, 1 );
    const_dict_4806082570b3d4a3b572377edcbcb3bb = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_4806082570b3d4a3b572377edcbcb3bb, const_str_plain_action, const_str_plain_store );
    const_str_plain_output_dir = UNSTREAM_STRING( &constant_bin[ 8601 ], 10, 1 );
    PyDict_SetItem( const_dict_4806082570b3d4a3b572377edcbcb3bb, const_str_plain_dest, const_str_plain_output_dir );
    const_str_plain_DIRECTORY = UNSTREAM_STRING( &constant_bin[ 8611 ], 9, 1 );
    PyDict_SetItem( const_dict_4806082570b3d4a3b572377edcbcb3bb, const_str_plain_metavar, const_str_plain_DIRECTORY );
    PyDict_SetItem( const_dict_4806082570b3d4a3b572377edcbcb3bb, const_str_plain_default, const_str_empty );
    const_str_digest_82960d53279f2e14c78ad04687d8edf2 = UNSTREAM_STRING( &constant_bin[ 8620 ], 161, 0 );
    PyDict_SetItem( const_dict_4806082570b3d4a3b572377edcbcb3bb, const_str_plain_help, const_str_digest_82960d53279f2e14c78ad04687d8edf2 );
    assert( PyDict_Size( const_dict_4806082570b3d4a3b572377edcbcb3bb ) == 5 );
    const_str_digest_29f22d31e2612090153f2d0b53f05d17 = UNSTREAM_STRING( &constant_bin[ 8781 ], 37, 0 );
    const_str_digest_a46d5c83bf50369817004d0ae3068212 = UNSTREAM_STRING( &constant_bin[ 8818 ], 16, 0 );
    const_dict_b6567d48878bd6a564df12f2792ed412 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_b6567d48878bd6a564df12f2792ed412, const_str_plain_action, const_str_plain_append );
    const_str_plain_recurse_extra = UNSTREAM_STRING( &constant_bin[ 8834 ], 13, 1 );
    PyDict_SetItem( const_dict_b6567d48878bd6a564df12f2792ed412, const_str_plain_dest, const_str_plain_recurse_extra );
    PyDict_SetItem( const_dict_b6567d48878bd6a564df12f2792ed412, const_str_plain_metavar, const_str_digest_2d81e4659ed7ee05a20b1259b3fd971b );
    PyDict_SetItem( const_dict_b6567d48878bd6a564df12f2792ed412, const_str_plain_default, const_list_empty );
    const_str_digest_f43543d711c3365acaf0c7514490ba0f = UNSTREAM_STRING( &constant_bin[ 8847 ], 179, 0 );
    PyDict_SetItem( const_dict_b6567d48878bd6a564df12f2792ed412, const_str_plain_help, const_str_digest_f43543d711c3365acaf0c7514490ba0f );
    assert( PyDict_Size( const_dict_b6567d48878bd6a564df12f2792ed412 ) == 5 );
    const_str_plain_bad = UNSTREAM_STRING( &constant_bin[ 9026 ], 3, 1 );
    const_tuple_str_digest_1e0691616d687838fcfcf9e105cb4f2c_tuple = PyTuple_New( 1 );
    const_str_digest_1e0691616d687838fcfcf9e105cb4f2c = UNSTREAM_STRING( &constant_bin[ 9029 ], 7, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_1e0691616d687838fcfcf9e105cb4f2c_tuple, 0, const_str_digest_1e0691616d687838fcfcf9e105cb4f2c ); Py_INCREF( const_str_digest_1e0691616d687838fcfcf9e105cb4f2c );
    const_str_digest_77b02a1a563d330fd51e8c9e7358129e = UNSTREAM_STRING( &constant_bin[ 9036 ], 26, 0 );
    const_str_digest_0038a88d36dd7b18556a93f0b96f344c = UNSTREAM_STRING( &constant_bin[ 9062 ], 25, 0 );
    const_str_digest_d90c6f9059bfbf9b701e35af76eb7e66 = UNSTREAM_STRING( &constant_bin[ 9087 ], 6, 0 );
    const_str_digest_1763e4d4cad050cb477b4075c12e61b9 = UNSTREAM_STRING( &constant_bin[ 9093 ], 59, 0 );
    const_tuple_str_plain_listPlugins_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_listPlugins_tuple, 0, const_str_plain_listPlugins ); Py_INCREF( const_str_plain_listPlugins );
    const_str_digest_9f25c19858b77b731128c72d40e5f5b1 = UNSTREAM_STRING( &constant_bin[ 9152 ], 52, 0 );
    const_str_plain_norandomization = UNSTREAM_STRING( &constant_bin[ 9204 ], 15, 1 );
    const_str_digest_1166ed4ea02e252b349ea20821361e49 = UNSTREAM_STRING( &constant_bin[ 9219 ], 347, 0 );
    const_str_digest_a8790475190f78aa2acabac27744f407 = UNSTREAM_STRING( &constant_bin[ 9566 ], 76, 0 );
    const_tuple_b6d47a1fac0ac1116306d2c778fc7fa0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_b6d47a1fac0ac1116306d2c778fc7fa0_tuple, 0, const_str_digest_253e8c634e852449d2d79967508bf91d ); Py_INCREF( const_str_digest_253e8c634e852449d2d79967508bf91d );
    PyTuple_SET_ITEM( const_tuple_b6d47a1fac0ac1116306d2c778fc7fa0_tuple, 1, const_str_digest_d90c6f9059bfbf9b701e35af76eb7e66 ); Py_INCREF( const_str_digest_d90c6f9059bfbf9b701e35af76eb7e66 );
    const_str_plain_jobs = UNSTREAM_STRING( &constant_bin[ 9642 ], 4, 1 );
    const_tuple_fc33f4d4eefe708c7f5fade18f710ac3_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_fc33f4d4eefe708c7f5fade18f710ac3_tuple, 0, const_str_digest_a46d5c83bf50369817004d0ae3068212 ); Py_INCREF( const_str_digest_a46d5c83bf50369817004d0ae3068212 );
    const_str_digest_0f13e1f8236e0a56a570aea0b454e3b3 = UNSTREAM_STRING( &constant_bin[ 9646 ], 16, 0 );
    PyTuple_SET_ITEM( const_tuple_fc33f4d4eefe708c7f5fade18f710ac3_tuple, 1, const_str_digest_0f13e1f8236e0a56a570aea0b454e3b3 ); Py_INCREF( const_str_digest_0f13e1f8236e0a56a570aea0b454e3b3 );
    const_tuple_str_plain_result_str_plain_plugin_enabled_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_result_str_plain_plugin_enabled_tuple, 0, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_plugin_enabled = UNSTREAM_STRING( &constant_bin[ 9662 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_result_str_plain_plugin_enabled_tuple, 1, const_str_plain_plugin_enabled ); Py_INCREF( const_str_plain_plugin_enabled );
    const_str_digest_99c99677a4e4e5551851722475466536 = UNSTREAM_STRING( &constant_bin[ 9676 ], 61, 0 );
    const_tuple_str_digest_d622909c277871892b649806560e5ee9_tuple = PyTuple_New( 1 );
    const_str_digest_d622909c277871892b649806560e5ee9 = UNSTREAM_STRING( &constant_bin[ 9737 ], 13, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d622909c277871892b649806560e5ee9_tuple, 0, const_str_digest_d622909c277871892b649806560e5ee9 ); Py_INCREF( const_str_digest_d622909c277871892b649806560e5ee9 );
    const_str_digest_46f785c15c72b806f29a68d8dfd47979 = UNSTREAM_STRING( &constant_bin[ 9750 ], 14, 0 );
    const_tuple_str_digest_18e517f9850452ab3cf33b46e8bcada9_tuple = PyTuple_New( 1 );
    const_str_digest_18e517f9850452ab3cf33b46e8bcada9 = UNSTREAM_STRING( &constant_bin[ 8411 ], 13, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_18e517f9850452ab3cf33b46e8bcada9_tuple, 0, const_str_digest_18e517f9850452ab3cf33b46e8bcada9 ); Py_INCREF( const_str_digest_18e517f9850452ab3cf33b46e8bcada9 );
    const_str_digest_3f6200677f4db8f5d868225a76599c65 = UNSTREAM_STRING( &constant_bin[ 9764 ], 170, 0 );
    const_str_plain_plugins_disabled = UNSTREAM_STRING( &constant_bin[ 9934 ], 16, 1 );
    const_str_digest_3ac6a5b1ddeef4b1cc6a93178eede16e = UNSTREAM_STRING( &constant_bin[ 9950 ], 227, 0 );
    const_tuple_str_digest_b18a177c45550b4f3f516a11bf101257_tuple = PyTuple_New( 1 );
    const_str_digest_b18a177c45550b4f3f516a11bf101257 = UNSTREAM_STRING( &constant_bin[ 10177 ], 7, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b18a177c45550b4f3f516a11bf101257_tuple, 0, const_str_digest_b18a177c45550b4f3f516a11bf101257 ); Py_INCREF( const_str_digest_b18a177c45550b4f3f516a11bf101257 );
    const_str_plain_display_tree = UNSTREAM_STRING( &constant_bin[ 10184 ], 12, 1 );
    const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple = PyTuple_New( 3 );
    const_str_plain_static_hashes = UNSTREAM_STRING( &constant_bin[ 9428 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple, 0, const_str_plain_static_hashes ); Py_INCREF( const_str_plain_static_hashes );
    PyTuple_SET_ITEM( const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple, 1, const_str_plain_norandomization ); Py_INCREF( const_str_plain_norandomization );
    const_str_plain_no_randomization = UNSTREAM_STRING( &constant_bin[ 10196 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple, 2, const_str_plain_no_randomization ); Py_INCREF( const_str_plain_no_randomization );
    const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple, 0, const_str_digest_68e779b074842129991baeb4e329e7d3 ); Py_INCREF( const_str_digest_68e779b074842129991baeb4e329e7d3 );
    PyTuple_SET_ITEM( const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple, 1, const_str_plain_trace_imports ); Py_INCREF( const_str_plain_trace_imports );
    const_str_plain_trace_import = UNSTREAM_STRING( &constant_bin[ 10212 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple, 2, const_str_plain_trace_import ); Py_INCREF( const_str_plain_trace_import );
    const_dict_f9dec362e3826b89bc423d0a382669c5 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_f9dec362e3826b89bc423d0a382669c5, const_str_plain_action, const_str_plain_append );
    const_str_plain_recurse_extra_files = UNSTREAM_STRING( &constant_bin[ 10224 ], 19, 1 );
    PyDict_SetItem( const_dict_f9dec362e3826b89bc423d0a382669c5, const_str_plain_dest, const_str_plain_recurse_extra_files );
    const_str_plain_PATTERN = UNSTREAM_STRING( &constant_bin[ 10243 ], 7, 1 );
    PyDict_SetItem( const_dict_f9dec362e3826b89bc423d0a382669c5, const_str_plain_metavar, const_str_plain_PATTERN );
    PyDict_SetItem( const_dict_f9dec362e3826b89bc423d0a382669c5, const_str_plain_default, const_list_empty );
    const_str_digest_ab3213453d8827b171e098b981d71b36 = UNSTREAM_STRING( &constant_bin[ 10250 ], 123, 0 );
    PyDict_SetItem( const_dict_f9dec362e3826b89bc423d0a382669c5, const_str_plain_help, const_str_digest_ab3213453d8827b171e098b981d71b36 );
    assert( PyDict_Size( const_dict_f9dec362e3826b89bc423d0a382669c5 ) == 5 );
    const_tuple_str_digest_49ad4f31d937fb275eae6082ce4c2f7e_tuple = PyTuple_New( 1 );
    const_str_digest_49ad4f31d937fb275eae6082ce4c2f7e = UNSTREAM_STRING( &constant_bin[ 10373 ], 15, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_49ad4f31d937fb275eae6082ce4c2f7e_tuple, 0, const_str_digest_49ad4f31d937fb275eae6082ce4c2f7e ); Py_INCREF( const_str_digest_49ad4f31d937fb275eae6082ce4c2f7e );
    const_dict_8051a9b4950f7a98676f92b125b0a5a9 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_8051a9b4950f7a98676f92b125b0a5a9, const_str_plain_action, const_str_plain_append );
    const_str_plain_recurse_modules = UNSTREAM_STRING( &constant_bin[ 10388 ], 15, 1 );
    PyDict_SetItem( const_dict_8051a9b4950f7a98676f92b125b0a5a9, const_str_plain_dest, const_str_plain_recurse_modules );
    PyDict_SetItem( const_dict_8051a9b4950f7a98676f92b125b0a5a9, const_str_plain_metavar, const_str_digest_2d81e4659ed7ee05a20b1259b3fd971b );
    PyDict_SetItem( const_dict_8051a9b4950f7a98676f92b125b0a5a9, const_str_plain_default, const_list_empty );
    const_str_digest_a9457866f2f1e7c8e79d32e1131be86b = UNSTREAM_STRING( &constant_bin[ 10403 ], 106, 0 );
    PyDict_SetItem( const_dict_8051a9b4950f7a98676f92b125b0a5a9, const_str_plain_help, const_str_digest_a9457866f2f1e7c8e79d32e1131be86b );
    assert( PyDict_Size( const_dict_8051a9b4950f7a98676f92b125b0a5a9 ) == 5 );
    const_str_digest_00c314cfeb398027009e203584943dfb = UNSTREAM_STRING( &constant_bin[ 10509 ], 9, 0 );
    const_dict_9698778f5c679af1b643e7cc72ba60e3 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_9698778f5c679af1b643e7cc72ba60e3, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_9698778f5c679af1b643e7cc72ba60e3, const_str_plain_dest, const_str_plain_list_plugins );
    PyDict_SetItem( const_dict_9698778f5c679af1b643e7cc72ba60e3, const_str_plain_default, Py_False );
    const_str_digest_3504384c8cd44eb120046939212bf7ed = UNSTREAM_STRING( &constant_bin[ 10518 ], 61, 0 );
    PyDict_SetItem( const_dict_9698778f5c679af1b643e7cc72ba60e3, const_str_plain_help, const_str_digest_3504384c8cd44eb120046939212bf7ed );
    assert( PyDict_Size( const_dict_9698778f5c679af1b643e7cc72ba60e3 ) == 4 );
    const_str_digest_9ac1ed25c92f3ebd3d47fc83855c6798 = UNSTREAM_STRING( &constant_bin[ 10579 ], 12, 0 );
    const_str_digest_268bd5cadede0ba0322c51dab58060ed = UNSTREAM_STRING( &constant_bin[ 10591 ], 13, 0 );
    const_str_digest_00d395acfd6f5a59596c56db84b18679 = UNSTREAM_STRING( &constant_bin[ 10604 ], 5, 0 );
    const_str_plain_include_group = UNSTREAM_STRING( &constant_bin[ 10609 ], 13, 1 );
    const_str_digest_8ad9a10a20aa1e5f8014eb0eae178c2f = UNSTREAM_STRING( &constant_bin[ 10622 ], 133, 0 );
    const_str_digest_070be269e5c34380728f9fc12e47c2bf = UNSTREAM_STRING( &constant_bin[ 8369 ], 13, 0 );
    const_str_digest_3196075a13d9c8ad6a5ded309a38562c = UNSTREAM_STRING( &constant_bin[ 10755 ], 84, 0 );
    const_tuple_str_plain_trace_imports_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_trace_imports_tuple, 0, const_str_plain_trace_imports ); Py_INCREF( const_str_plain_trace_imports );
    const_dict_90a95198da96374edd136a324cfe2551 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_90a95198da96374edd136a324cfe2551, const_str_plain_action, const_str_plain_append );
    PyDict_SetItem( const_dict_90a95198da96374edd136a324cfe2551, const_str_plain_dest, const_str_plain_plugins_enabled );
    PyDict_SetItem( const_dict_90a95198da96374edd136a324cfe2551, const_str_plain_default, const_list_empty );
    const_str_digest_c34f9489814ce6dde9158d32b1df6898 = UNSTREAM_STRING( &constant_bin[ 10839 ], 105, 0 );
    PyDict_SetItem( const_dict_90a95198da96374edd136a324cfe2551, const_str_plain_help, const_str_digest_c34f9489814ce6dde9158d32b1df6898 );
    assert( PyDict_Size( const_dict_90a95198da96374edd136a324cfe2551 ) == 4 );
    const_tuple_str_digest_93035a62de394da955eafe810adcb94a_tuple = PyTuple_New( 1 );
    const_str_digest_93035a62de394da955eafe810adcb94a = UNSTREAM_STRING( &constant_bin[ 10944 ], 9, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_93035a62de394da955eafe810adcb94a_tuple, 0, const_str_digest_93035a62de394da955eafe810adcb94a ); Py_INCREF( const_str_digest_93035a62de394da955eafe810adcb94a );
    const_str_digest_a87c6594d01a42101f3bfdae3f09902a = UNSTREAM_STRING( &constant_bin[ 10953 ], 18, 0 );
    const_tuple_str_digest_ef48d902fc32bf8f11ba290ed22dfe84_tuple = PyTuple_New( 1 );
    const_str_digest_ef48d902fc32bf8f11ba290ed22dfe84 = UNSTREAM_STRING( &constant_bin[ 10971 ], 19, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_ef48d902fc32bf8f11ba290ed22dfe84_tuple, 0, const_str_digest_ef48d902fc32bf8f11ba290ed22dfe84 ); Py_INCREF( const_str_digest_ef48d902fc32bf8f11ba290ed22dfe84 );
    const_str_digest_6eb625ebe8945450e4fac63cdf07efd0 = UNSTREAM_STRING( &constant_bin[ 10990 ], 237, 0 );
    const_dict_68bef2472fa0693d2e9cde3165230e7e = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_68bef2472fa0693d2e9cde3165230e7e, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_trace_execution = UNSTREAM_STRING( &constant_bin[ 11227 ], 15, 1 );
    PyDict_SetItem( const_dict_68bef2472fa0693d2e9cde3165230e7e, const_str_plain_dest, const_str_plain_trace_execution );
    PyDict_SetItem( const_dict_68bef2472fa0693d2e9cde3165230e7e, const_str_plain_default, Py_False );
    const_str_digest_fc7c671d949f20fb52f85659d7080b39 = UNSTREAM_STRING( &constant_bin[ 11242 ], 86, 0 );
    PyDict_SetItem( const_dict_68bef2472fa0693d2e9cde3165230e7e, const_str_plain_help, const_str_digest_fc7c671d949f20fb52f85659d7080b39 );
    assert( PyDict_Size( const_dict_68bef2472fa0693d2e9cde3165230e7e ) == 4 );
    const_str_digest_9556b4546b4577c6523da3578179b9b4 = UNSTREAM_STRING( &constant_bin[ 11328 ], 75, 0 );
    const_str_digest_89159a5dbad3f2fb2e8b857c60946590 = UNSTREAM_STRING( &constant_bin[ 11403 ], 5, 0 );
    const_str_digest_07c984f555862c5fe07a79469d5a22eb = UNSTREAM_STRING( &constant_bin[ 7504 ], 4, 0 );
    const_str_digest_b6f7031b7e2bccd0ab51d368f37477f8 = UNSTREAM_STRING( &constant_bin[ 11408 ], 17, 0 );
    const_str_digest_5f92110962dad42b6e9f8718847150da = UNSTREAM_STRING( &constant_bin[ 11425 ], 15, 0 );
    const_tuple_str_digest_07c984f555862c5fe07a79469d5a22eb_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_07c984f555862c5fe07a79469d5a22eb_tuple, 0, const_str_digest_07c984f555862c5fe07a79469d5a22eb ); Py_INCREF( const_str_digest_07c984f555862c5fe07a79469d5a22eb );
    const_str_digest_905a0ca1360b0a5bb2b938cdcab0da3d = UNSTREAM_STRING( &constant_bin[ 11440 ], 31, 0 );
    const_tuple_str_digest_0038a88d36dd7b18556a93f0b96f344c_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_0038a88d36dd7b18556a93f0b96f344c_tuple, 0, const_str_digest_0038a88d36dd7b18556a93f0b96f344c ); Py_INCREF( const_str_digest_0038a88d36dd7b18556a93f0b96f344c );
    const_str_plain_shallOptimizeStringExec = UNSTREAM_STRING( &constant_bin[ 11471 ], 23, 1 );
    const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 0, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 1, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 2, const_str_plain_listPlugins ); Py_INCREF( const_str_plain_listPlugins );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 3, const_str_plain_any_case_module ); Py_INCREF( const_str_plain_any_case_module );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 4, const_str_plain_bad ); Py_INCREF( const_str_plain_bad );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 5, const_str_plain_char ); Py_INCREF( const_str_plain_char );
    const_str_plain_no_case_module = UNSTREAM_STRING( &constant_bin[ 11494 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 6, const_str_plain_no_case_module ); Py_INCREF( const_str_plain_no_case_module );
    PyTuple_SET_ITEM( const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 7, const_str_plain_scons_python ); Py_INCREF( const_str_plain_scons_python );
    const_str_plain_python_scons = UNSTREAM_STRING( &constant_bin[ 11508 ], 12, 1 );
    const_str_plain_indication = UNSTREAM_STRING( &constant_bin[ 11520 ], 10, 1 );
    const_dict_d08467263ea7a279b4a5e664b6eb12c4 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d08467263ea7a279b4a5e664b6eb12c4, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_recompile_c_only = UNSTREAM_STRING( &constant_bin[ 11530 ], 16, 1 );
    PyDict_SetItem( const_dict_d08467263ea7a279b4a5e664b6eb12c4, const_str_plain_dest, const_str_plain_recompile_c_only );
    PyDict_SetItem( const_dict_d08467263ea7a279b4a5e664b6eb12c4, const_str_plain_default, Py_False );
    const_str_digest_fdbf2a6dc5371272d02916acacd348df = UNSTREAM_STRING( &constant_bin[ 11546 ], 244, 0 );
    PyDict_SetItem( const_dict_d08467263ea7a279b4a5e664b6eb12c4, const_str_plain_help, const_str_digest_fdbf2a6dc5371272d02916acacd348df );
    assert( PyDict_Size( const_dict_d08467263ea7a279b4a5e664b6eb12c4 ) == 4 );
    const_str_plain_codegen_group = UNSTREAM_STRING( &constant_bin[ 11790 ], 13, 1 );
    const_str_plain_allow_reexecute = UNSTREAM_STRING( &constant_bin[ 11803 ], 15, 1 );
    const_tuple_str_digest_00d395acfd6f5a59596c56db84b18679_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_00d395acfd6f5a59596c56db84b18679_tuple, 0, const_str_digest_00d395acfd6f5a59596c56db84b18679 ); Py_INCREF( const_str_digest_00d395acfd6f5a59596c56db84b18679 );
    const_dict_a2e498776be6cd82fda35028659b0622 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_a2e498776be6cd82fda35028659b0622, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_a2e498776be6cd82fda35028659b0622, const_str_plain_dest, const_str_plain_debugger );
    PyDict_SetItem( const_dict_a2e498776be6cd82fda35028659b0622, const_str_plain_default, Py_False );
    const_str_digest_e6537e54fa67ccea5df1625ee9d37760 = UNSTREAM_STRING( &constant_bin[ 11818 ], 73, 0 );
    PyDict_SetItem( const_dict_a2e498776be6cd82fda35028659b0622, const_str_plain_help, const_str_digest_e6537e54fa67ccea5df1625ee9d37760 );
    assert( PyDict_Size( const_dict_a2e498776be6cd82fda35028659b0622 ) == 4 );
    const_str_digest_1999b862fee169df7201f15bd1e9bcad = UNSTREAM_STRING( &constant_bin[ 11891 ], 61, 0 );
    const_str_digest_274157aee680c8eed59b3be6f77587cd = UNSTREAM_STRING( &constant_bin[ 11952 ], 46, 0 );
    const_str_digest_7b113117fd237deaef422d3a4d7e9c32 = UNSTREAM_STRING( &constant_bin[ 11998 ], 92, 0 );
    const_str_digest_ea57b1d8c130aaa1d4daa0d4f3dbdac0 = UNSTREAM_STRING( &constant_bin[ 12090 ], 37, 0 );
    const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_unstripped = UNSTREAM_STRING( &constant_bin[ 2539 ], 10, 1 );
    PyDict_SetItem( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6, const_str_plain_dest, const_str_plain_unstripped );
    PyDict_SetItem( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6, const_str_plain_default, Py_False );
    const_str_digest_e5b51f99fd3c31b98c248d48e7574b16 = UNSTREAM_STRING( &constant_bin[ 12127 ], 94, 0 );
    PyDict_SetItem( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6, const_str_plain_help, const_str_digest_e5b51f99fd3c31b98c248d48e7574b16 );
    assert( PyDict_Size( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6 ) == 4 );
    const_str_digest_63956f13172d297e8502409fdc42b709 = UNSTREAM_STRING( &constant_bin[ 12221 ], 14, 0 );
    const_tuple_str_digest_268bd5cadede0ba0322c51dab58060ed_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_268bd5cadede0ba0322c51dab58060ed_tuple, 0, const_str_digest_268bd5cadede0ba0322c51dab58060ed ); Py_INCREF( const_str_digest_268bd5cadede0ba0322c51dab58060ed );
    const_str_digest_caae9f31bca5fbe5610d39e1657be0f0 = UNSTREAM_STRING( &constant_bin[ 12235 ], 334, 0 );
    const_str_plain_show_inclusion = UNSTREAM_STRING( &constant_bin[ 12569 ], 14, 1 );
    const_str_plain_obsolete_executable = UNSTREAM_STRING( &constant_bin[ 12583 ], 19, 1 );
    const_tuple_str_digest_182801ca351e48a7ac147d78d9a5a172_tuple = PyTuple_New( 1 );
    const_str_digest_182801ca351e48a7ac147d78d9a5a172 = UNSTREAM_STRING( &constant_bin[ 12602 ], 12, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_182801ca351e48a7ac147d78d9a5a172_tuple, 0, const_str_digest_182801ca351e48a7ac147d78d9a5a172 ); Py_INCREF( const_str_digest_182801ca351e48a7ac147d78d9a5a172 );
    const_str_digest_1fbf263a160f21148f892a1b15932c5a = UNSTREAM_STRING( &constant_bin[ 12614 ], 12, 0 );
    const_tuple_6a4e2a16b6c2151a91df21cd0a488536_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_6a4e2a16b6c2151a91df21cd0a488536_tuple, 0, const_str_digest_a87c6594d01a42101f3bfdae3f09902a ); Py_INCREF( const_str_digest_a87c6594d01a42101f3bfdae3f09902a );
    const_str_digest_083b5be111f4c8b31dfefd70a7615875 = UNSTREAM_STRING( &constant_bin[ 12626 ], 19, 0 );
    PyTuple_SET_ITEM( const_tuple_6a4e2a16b6c2151a91df21cd0a488536_tuple, 1, const_str_digest_083b5be111f4c8b31dfefd70a7615875 ); Py_INCREF( const_str_digest_083b5be111f4c8b31dfefd70a7615875 );
    const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_dump_xml = UNSTREAM_STRING( &constant_bin[ 12645 ], 8, 1 );
    PyDict_SetItem( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5, const_str_plain_dest, const_str_plain_dump_xml );
    PyDict_SetItem( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5, const_str_plain_default, Py_False );
    const_str_digest_baff1759a20c9a5acf6cc580f2ed0149 = UNSTREAM_STRING( &constant_bin[ 12653 ], 56, 0 );
    PyDict_SetItem( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5, const_str_plain_help, const_str_digest_baff1759a20c9a5acf6cc580f2ed0149 );
    assert( PyDict_Size( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5 ) == 4 );
    const_str_plain_recurse_all = UNSTREAM_STRING( &constant_bin[ 12709 ], 11, 1 );
    const_str_digest_9a09f3be7c40522696df04272854d4ad = UNSTREAM_STRING( &constant_bin[ 12720 ], 26, 0 );
    const_tuple_str_digest_44da9cf7d063a682915b28e16c190ea6_tuple = PyTuple_New( 1 );
    const_str_digest_44da9cf7d063a682915b28e16c190ea6 = UNSTREAM_STRING( &constant_bin[ 12746 ], 13, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_44da9cf7d063a682915b28e16c190ea6_tuple, 0, const_str_digest_44da9cf7d063a682915b28e16c190ea6 ); Py_INCREF( const_str_digest_44da9cf7d063a682915b28e16c190ea6 );
    const_tuple_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6_tuple = PyTuple_New( 1 );
    const_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6 = UNSTREAM_STRING( &constant_bin[ 7492 ], 8, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6_tuple, 0, const_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6 ); Py_INCREF( const_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6 );
    const_tuple_str_digest_919dfec0da52245e2d2f6edeae5a1142_tuple = PyTuple_New( 1 );
    const_str_digest_919dfec0da52245e2d2f6edeae5a1142 = UNSTREAM_STRING( &constant_bin[ 12759 ], 21, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_919dfec0da52245e2d2f6edeae5a1142_tuple, 0, const_str_digest_919dfec0da52245e2d2f6edeae5a1142 ); Py_INCREF( const_str_digest_919dfec0da52245e2d2f6edeae5a1142 );
    const_str_digest_2adad11ced0222182a3bde8b4673464b = UNSTREAM_STRING( &constant_bin[ 12780 ], 14, 0 );
    const_dict_b81c98a4816e9ddb7651bd033b7215d2 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_b81c98a4816e9ddb7651bd033b7215d2, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_is_standalone = UNSTREAM_STRING( &constant_bin[ 12794 ], 13, 1 );
    PyDict_SetItem( const_dict_b81c98a4816e9ddb7651bd033b7215d2, const_str_plain_dest, const_str_plain_is_standalone );
    PyDict_SetItem( const_dict_b81c98a4816e9ddb7651bd033b7215d2, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_b81c98a4816e9ddb7651bd033b7215d2, const_str_plain_help, const_str_digest_31730815375f0e787899dcd04cc30aa0 );
    assert( PyDict_Size( const_dict_b81c98a4816e9ddb7651bd033b7215d2 ) == 4 );
    const_str_digest_3ccf4aedec4bac5727cc0c1b289964ab = UNSTREAM_STRING( &constant_bin[ 12807 ], 25, 0 );
    const_str_digest_2e24eb0be25ec092a3baa722dc55b330 = UNSTREAM_STRING( &constant_bin[ 12832 ], 23, 0 );
    const_tuple_str_digest_63956f13172d297e8502409fdc42b709_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_63956f13172d297e8502409fdc42b709_tuple, 0, const_str_digest_63956f13172d297e8502409fdc42b709 ); Py_INCREF( const_str_digest_63956f13172d297e8502409fdc42b709 );
    const_str_digest_20cbdfa9ffc9f9c39bdd7d5fd94cd769 = UNSTREAM_STRING( &constant_bin[ 12855 ], 70, 0 );
    const_str_digest_218df1a0cc5a4ceaffc69395c4609ab7 = UNSTREAM_STRING( &constant_bin[ 12925 ], 19, 0 );
    const_str_digest_f13acabca636d4d483b3d53e84c3d766 = UNSTREAM_STRING( &constant_bin[ 12944 ], 125, 0 );
    const_str_plain_improved = UNSTREAM_STRING( &constant_bin[ 13069 ], 8, 1 );
    const_tuple_str_digest_0e4e79a120d8772251ce3088f7d11248_tuple = PyTuple_New( 1 );
    const_str_digest_0e4e79a120d8772251ce3088f7d11248 = UNSTREAM_STRING( &constant_bin[ 13077 ], 7, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_0e4e79a120d8772251ce3088f7d11248_tuple, 0, const_str_digest_0e4e79a120d8772251ce3088f7d11248 ); Py_INCREF( const_str_digest_0e4e79a120d8772251ce3088f7d11248 );
    const_str_digest_a36e77b7d0a3758e6a6afc584106002f = UNSTREAM_STRING( &constant_bin[ 13084 ], 90, 0 );
    const_str_plain_recurse_group = UNSTREAM_STRING( &constant_bin[ 13174 ], 13, 1 );
    const_dict_ab01781f7bc15d0cb66d375a405a8c23 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_ab01781f7bc15d0cb66d375a405a8c23, const_str_plain_action, const_str_plain_store );
    const_str_plain_msvc = UNSTREAM_STRING( &constant_bin[ 2339 ], 4, 1 );
    PyDict_SetItem( const_dict_ab01781f7bc15d0cb66d375a405a8c23, const_str_plain_dest, const_str_plain_msvc );
    PyDict_SetItem( const_dict_ab01781f7bc15d0cb66d375a405a8c23, const_str_plain_default, Py_None );
    const_str_digest_f5da5fd9e2df79997f1c0724df55d569 = UNSTREAM_STRING( &constant_bin[ 13187 ], 186, 0 );
    PyDict_SetItem( const_dict_ab01781f7bc15d0cb66d375a405a8c23, const_str_plain_help, const_str_digest_f5da5fd9e2df79997f1c0724df55d569 );
    assert( PyDict_Size( const_dict_ab01781f7bc15d0cb66d375a405a8c23 ) == 4 );
    const_str_plain_debug_group = UNSTREAM_STRING( &constant_bin[ 13373 ], 11, 1 );
    const_str_digest_20c9a2ec3b9bc0c10958122412cc775c = UNSTREAM_STRING( &constant_bin[ 13384 ], 10, 0 );
    const_str_digest_000f2dcd6617662a5ec06cf266d5aede = UNSTREAM_STRING( &constant_bin[ 13394 ], 16, 0 );
    const_str_digest_ca95b6fd7bd310521598a1589c336a8c = UNSTREAM_STRING( &constant_bin[ 13410 ], 88, 0 );
    const_str_plain_assume_yes_for_downloads = UNSTREAM_STRING( &constant_bin[ 13498 ], 24, 1 );
    const_str_plain_detect_missing_plugins = UNSTREAM_STRING( &constant_bin[ 13522 ], 22, 1 );
    const_tuple_str_digest_e0e0f50e90b11d04627e07e5e534115c_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e0e0f50e90b11d04627e07e5e534115c_tuple, 0, const_str_digest_e0e0f50e90b11d04627e07e5e534115c ); Py_INCREF( const_str_digest_e0e0f50e90b11d04627e07e5e534115c );
    const_tuple_94e9cfb72d94240569769ed9b57cf011_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_94e9cfb72d94240569769ed9b57cf011_tuple, 0, const_str_digest_20c9a2ec3b9bc0c10958122412cc775c ); Py_INCREF( const_str_digest_20c9a2ec3b9bc0c10958122412cc775c );
    PyTuple_SET_ITEM( const_tuple_94e9cfb72d94240569769ed9b57cf011_tuple, 1, const_str_digest_e8b095c0d61a542b5771967680c01e67 ); Py_INCREF( const_str_digest_e8b095c0d61a542b5771967680c01e67 );
    const_dict_d1f0ccc2f13cc00c28313115feff62ba = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d1f0ccc2f13cc00c28313115feff62ba, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_d1f0ccc2f13cc00c28313115feff62ba, const_str_plain_dest, const_str_plain_python_debug );
    PyDict_SetItem( const_dict_d1f0ccc2f13cc00c28313115feff62ba, const_str_plain_default, Py_None );
    const_str_digest_3cb499860ad4d7639999eef254575b78 = UNSTREAM_STRING( &constant_bin[ 13544 ], 105, 0 );
    PyDict_SetItem( const_dict_d1f0ccc2f13cc00c28313115feff62ba, const_str_plain_help, const_str_digest_3cb499860ad4d7639999eef254575b78 );
    assert( PyDict_Size( const_dict_d1f0ccc2f13cc00c28313115feff62ba ) == 4 );
    const_str_plain__splitShellPattern = UNSTREAM_STRING( &constant_bin[ 13649 ], 18, 1 );
    const_dict_d46f58cd09bb8f0399ff079ba57dd7f0 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0, const_str_plain_dest, const_str_plain_clang );
    PyDict_SetItem( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0, const_str_plain_help, const_str_digest_20cbdfa9ffc9f9c39bdd7d5fd94cd769 );
    assert( PyDict_Size( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0 ) == 4 );
    const_str_digest_60916d45686821dae42b81cd8917e3ba = UNSTREAM_STRING( &constant_bin[ 13667 ], 14, 0 );
    const_dict_0db29dd5ce570108641e26279aa1d6bb = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_0db29dd5ce570108641e26279aa1d6bb, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_remove_build = UNSTREAM_STRING( &constant_bin[ 13681 ], 12, 1 );
    PyDict_SetItem( const_dict_0db29dd5ce570108641e26279aa1d6bb, const_str_plain_dest, const_str_plain_remove_build );
    PyDict_SetItem( const_dict_0db29dd5ce570108641e26279aa1d6bb, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_0db29dd5ce570108641e26279aa1d6bb, const_str_plain_help, const_str_digest_3196075a13d9c8ad6a5ded309a38562c );
    assert( PyDict_Size( const_dict_0db29dd5ce570108641e26279aa1d6bb ) == 4 );
    const_str_digest_25433114711138da4c9f37c122d5a3e0 = UNSTREAM_STRING( &constant_bin[ 13693 ], 13, 0 );
    const_str_digest_d3391bc5505627a621ab17af42b5e153 = UNSTREAM_STRING( &constant_bin[ 13706 ], 12, 0 );
    const_str_digest_76a20e0434f49c589f5f87e961db8fd3 = UNSTREAM_STRING( &constant_bin[ 13718 ], 72, 0 );
    const_dict_f7ee065b4f969f810663b09dfe85cb24 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_f7ee065b4f969f810663b09dfe85cb24, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_generate_c_only = UNSTREAM_STRING( &constant_bin[ 13790 ], 15, 1 );
    PyDict_SetItem( const_dict_f7ee065b4f969f810663b09dfe85cb24, const_str_plain_dest, const_str_plain_generate_c_only );
    PyDict_SetItem( const_dict_f7ee065b4f969f810663b09dfe85cb24, const_str_plain_default, Py_False );
    const_str_digest_d1976a1121a27393007d081974bf5ae9 = UNSTREAM_STRING( &constant_bin[ 13805 ], 161, 0 );
    PyDict_SetItem( const_dict_f7ee065b4f969f810663b09dfe85cb24, const_str_plain_help, const_str_digest_d1976a1121a27393007d081974bf5ae9 );
    assert( PyDict_Size( const_dict_f7ee065b4f969f810663b09dfe85cb24 ) == 4 );
    const_tuple_919a9acd13336714b04cc11908b85505_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_919a9acd13336714b04cc11908b85505_tuple, 0, const_str_digest_3ccf4aedec4bac5727cc0c1b289964ab ); Py_INCREF( const_str_digest_3ccf4aedec4bac5727cc0c1b289964ab );
    PyTuple_SET_ITEM( const_tuple_919a9acd13336714b04cc11908b85505_tuple, 1, const_str_digest_ff29ba6accba7bf3bc585f9666d1f472 ); Py_INCREF( const_str_digest_ff29ba6accba7bf3bc585f9666d1f472 );
    const_str_plain_nowarnings = UNSTREAM_STRING( &constant_bin[ 13966 ], 10, 1 );
    const_tuple_str_digest_df2c7df2c8191b7413ae4192dda59b2f_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_df2c7df2c8191b7413ae4192dda59b2f_tuple, 0, const_str_digest_df2c7df2c8191b7413ae4192dda59b2f ); Py_INCREF( const_str_digest_df2c7df2c8191b7413ae4192dda59b2f );
    const_str_plain_MODULE = UNSTREAM_STRING( &constant_bin[ 6934 ], 6, 1 );
    const_str_digest_0f684c542ec93bce2df505f518c4b1b8 = UNSTREAM_STRING( &constant_bin[ 13976 ], 35, 0 );
    const_str_digest_7c20112af2aeaa07afafa72120d096df = UNSTREAM_STRING( &constant_bin[ 14011 ], 16, 0 );
    const_str_plain_windows_group = UNSTREAM_STRING( &constant_bin[ 14027 ], 13, 1 );
    const_str_digest_a85c1bd4a7e7b3e2eae7b4253bfefb6c = UNSTREAM_STRING( &constant_bin[ 14040 ], 87, 0 );
    const_dict_95ccfece433c6f6c934c3808a3f69f19 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_95ccfece433c6f6c934c3808a3f69f19, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_95ccfece433c6f6c934c3808a3f69f19, const_str_plain_dest, const_str_plain_warn_unusual_code );
    PyDict_SetItem( const_dict_95ccfece433c6f6c934c3808a3f69f19, const_str_plain_default, Py_False );
    const_str_digest_7cd5b8590b982e2d81ae96b374f786b4 = UNSTREAM_STRING( &constant_bin[ 14127 ], 58, 0 );
    PyDict_SetItem( const_dict_95ccfece433c6f6c934c3808a3f69f19, const_str_plain_help, const_str_digest_7cd5b8590b982e2d81ae96b374f786b4 );
    assert( PyDict_Size( const_dict_95ccfece433c6f6c934c3808a3f69f19 ) == 4 );
    const_dict_f53f2b68bdeb8b2acc2b479d67a53074 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_f53f2b68bdeb8b2acc2b479d67a53074, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_f53f2b68bdeb8b2acc2b479d67a53074, const_str_plain_dest, const_str_plain_debug );
    PyDict_SetItem( const_dict_f53f2b68bdeb8b2acc2b479d67a53074, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_f53f2b68bdeb8b2acc2b479d67a53074, const_str_plain_help, const_str_digest_008a0a017baee6aff43344720dc02ad9 );
    assert( PyDict_Size( const_dict_f53f2b68bdeb8b2acc2b479d67a53074 ) == 4 );
    const_dict_6fdb311d2c4c6508c918d2fe1b337bd3 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_recurse_none = UNSTREAM_STRING( &constant_bin[ 14185 ], 12, 1 );
    PyDict_SetItem( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3, const_str_plain_dest, const_str_plain_recurse_none );
    PyDict_SetItem( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3, const_str_plain_help, const_str_digest_8ad9a10a20aa1e5f8014eb0eae178c2f );
    assert( PyDict_Size( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3 ) == 4 );
    const_str_digest_507e1544d34f3449cefc7e95aa4e43f6 = UNSTREAM_STRING( &constant_bin[ 14197 ], 90, 0 );
    const_dict_1f7fbc2dabea4a09516283b4d4bc14e4 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4, const_str_plain_action, const_str_plain_store_false );
    PyDict_SetItem( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4, const_str_plain_dest, const_str_plain_improved );
    PyDict_SetItem( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4, const_str_plain_default, Py_True );
    const_str_digest_7d4652e457bb729a32f57d1e066a5d67 = UNSTREAM_STRING( &constant_bin[ 14287 ], 252, 0 );
    PyDict_SetItem( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4, const_str_plain_help, const_str_digest_7d4652e457bb729a32f57d1e066a5d67 );
    assert( PyDict_Size( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4 ) == 4 );
    const_dict_d65576168a837f10db67bdd0d5297d28 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d65576168a837f10db67bdd0d5297d28, const_str_plain_action, const_str_plain_append );
    PyDict_SetItem( const_dict_d65576168a837f10db67bdd0d5297d28, const_str_plain_dest, const_str_plain_experimental );
    PyDict_SetItem( const_dict_d65576168a837f10db67bdd0d5297d28, const_str_plain_default, const_list_empty );
    PyDict_SetItem( const_dict_d65576168a837f10db67bdd0d5297d28, const_str_plain_help, const_str_digest_3f6200677f4db8f5d868225a76599c65 );
    assert( PyDict_Size( const_dict_d65576168a837f10db67bdd0d5297d28 ) == 4 );
    const_tuple_str_digest_9a09f3be7c40522696df04272854d4ad_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_9a09f3be7c40522696df04272854d4ad_tuple, 0, const_str_digest_9a09f3be7c40522696df04272854d4ad ); Py_INCREF( const_str_digest_9a09f3be7c40522696df04272854d4ad );
    const_str_digest_4913f61cf652f6bfa0f584ea4716697a = UNSTREAM_STRING( &constant_bin[ 14539 ], 16, 0 );
    const_str_digest_5369445afe6ad40445ccdb0facd01155 = UNSTREAM_STRING( &constant_bin[ 14555 ], 53, 0 );
    const_tuple_str_digest_77b02a1a563d330fd51e8c9e7358129e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_77b02a1a563d330fd51e8c9e7358129e_tuple, 0, const_str_digest_77b02a1a563d330fd51e8c9e7358129e ); Py_INCREF( const_str_digest_77b02a1a563d330fd51e8c9e7358129e );
    const_dict_570f8765b523a6b072016db58acd7292 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_570f8765b523a6b072016db58acd7292, const_str_plain_action, const_str_plain_append );
    const_str_plain_python_flags = UNSTREAM_STRING( &constant_bin[ 14608 ], 12, 1 );
    PyDict_SetItem( const_dict_570f8765b523a6b072016db58acd7292, const_str_plain_dest, const_str_plain_python_flags );
    PyDict_SetItem( const_dict_570f8765b523a6b072016db58acd7292, const_str_plain_default, const_list_empty );
    PyDict_SetItem( const_dict_570f8765b523a6b072016db58acd7292, const_str_plain_help, const_str_digest_1166ed4ea02e252b349ea20821361e49 );
    assert( PyDict_Size( const_dict_570f8765b523a6b072016db58acd7292 ) == 4 );
    const_tuple_str_plain_no_asserts_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_asserts_tuple, 0, const_str_plain_no_asserts ); Py_INCREF( const_str_plain_no_asserts );
    const_str_digest_0c22f7af7b0a4fa33a79410137285596 = UNSTREAM_STRING( &constant_bin[ 14620 ], 57, 0 );
    const_str_digest_e22d9173bccdc16d4477eee43c8497ac = UNSTREAM_STRING( &constant_bin[ 9527 ], 2, 0 );
    const_str_digest_a94f5f3ab2b42ad0afcf959f0497fce7 = UNSTREAM_STRING( &constant_bin[ 14677 ], 15, 0 );
    const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple, 0, const_str_plain_SUPPRESS_HELP ); Py_INCREF( const_str_plain_SUPPRESS_HELP );
    PyTuple_SET_ITEM( const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple, 1, const_str_plain_OptionGroup ); Py_INCREF( const_str_plain_OptionGroup );
    PyTuple_SET_ITEM( const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple, 2, const_str_plain_OptionParser ); Py_INCREF( const_str_plain_OptionParser );
    const_dict_d80a95aa8a24826f03f1bbcb02e0d877 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d80a95aa8a24826f03f1bbcb02e0d877, const_str_plain_action, const_str_plain_store );
    PyDict_SetItem( const_dict_d80a95aa8a24826f03f1bbcb02e0d877, const_str_plain_dest, const_str_plain_python_scons );
    PyDict_SetItem( const_dict_d80a95aa8a24826f03f1bbcb02e0d877, const_str_plain_default, Py_None );
    PyDict_SetItem( const_dict_d80a95aa8a24826f03f1bbcb02e0d877, const_str_plain_help, const_str_digest_3ac6a5b1ddeef4b1cc6a93178eede16e );
    assert( PyDict_Size( const_dict_d80a95aa8a24826f03f1bbcb02e0d877 ) == 4 );
    const_str_plain_plugin_group = UNSTREAM_STRING( &constant_bin[ 14692 ], 12, 1 );
    const_tuple_str_digest_ca95b6fd7bd310521598a1589c336a8c_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_ca95b6fd7bd310521598a1589c336a8c_tuple, 0, const_str_digest_ca95b6fd7bd310521598a1589c336a8c ); Py_INCREF( const_str_digest_ca95b6fd7bd310521598a1589c336a8c );
    const_dict_982e5273ca0a6d2d38c9e565a691c0f2 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_982e5273ca0a6d2d38c9e565a691c0f2, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_no_dependency_cache = UNSTREAM_STRING( &constant_bin[ 14704 ], 19, 1 );
    PyDict_SetItem( const_dict_982e5273ca0a6d2d38c9e565a691c0f2, const_str_plain_dest, const_str_plain_no_dependency_cache );
    PyDict_SetItem( const_dict_982e5273ca0a6d2d38c9e565a691c0f2, const_str_plain_default, Py_False );
    const_str_digest_77fb617d8001d38b07d7c0c49950ac49 = UNSTREAM_STRING( &constant_bin[ 14723 ], 169, 0 );
    PyDict_SetItem( const_dict_982e5273ca0a6d2d38c9e565a691c0f2, const_str_plain_help, const_str_digest_77fb617d8001d38b07d7c0c49950ac49 );
    assert( PyDict_Size( const_dict_982e5273ca0a6d2d38c9e565a691c0f2 ) == 4 );
    const_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1 = UNSTREAM_STRING( &constant_bin[ 14892 ], 17, 0 );
    const_str_plain_python_arch = UNSTREAM_STRING( &constant_bin[ 14909 ], 11, 1 );
    const_dict_f6a84467671671bed9a729c01faf6eb0 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_f6a84467671671bed9a729c01faf6eb0, const_str_plain_action, const_str_plain_store_false );
    PyDict_SetItem( const_dict_f6a84467671671bed9a729c01faf6eb0, const_str_plain_dest, const_str_plain_detect_missing_plugins );
    PyDict_SetItem( const_dict_f6a84467671671bed9a729c01faf6eb0, const_str_plain_default, Py_True );
    PyDict_SetItem( const_dict_f6a84467671671bed9a729c01faf6eb0, const_str_plain_help, const_str_digest_caae9f31bca5fbe5610d39e1657be0f0 );
    assert( PyDict_Size( const_dict_f6a84467671671bed9a729c01faf6eb0 ) == 4 );
    const_tuple_d6bdf977d7cdf572f474b619c9d47469_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_d6bdf977d7cdf572f474b619c9d47469_tuple, 0, const_str_digest_a94f5f3ab2b42ad0afcf959f0497fce7 ); Py_INCREF( const_str_digest_a94f5f3ab2b42ad0afcf959f0497fce7 );
    const_str_digest_1df1930ead0b5e1f7163c1225a06fa07 = UNSTREAM_STRING( &constant_bin[ 14920 ], 15, 0 );
    PyTuple_SET_ITEM( const_tuple_d6bdf977d7cdf572f474b619c9d47469_tuple, 1, const_str_digest_1df1930ead0b5e1f7163c1225a06fa07 ); Py_INCREF( const_str_digest_1df1930ead0b5e1f7163c1225a06fa07 );
    const_str_digest_6120fea2456c84f26fd70306fee05e56 = UNSTREAM_STRING( &constant_bin[ 14935 ], 17, 0 );
    const_str_digest_915928a8f3046246eea03ff37578bdf9 = UNSTREAM_STRING( &constant_bin[ 14952 ], 22, 0 );
    const_tuple_str_digest_9556b4546b4577c6523da3578179b9b4_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_9556b4546b4577c6523da3578179b9b4_tuple, 0, const_str_digest_9556b4546b4577c6523da3578179b9b4 ); Py_INCREF( const_str_digest_9556b4546b4577c6523da3578179b9b4 );
    const_tuple_str_digest_d26c39e8ed4ddb2171e43f32074c3668_tuple = PyTuple_New( 1 );
    const_str_digest_d26c39e8ed4ddb2171e43f32074c3668 = UNSTREAM_STRING( &constant_bin[ 14974 ], 14, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d26c39e8ed4ddb2171e43f32074c3668_tuple, 0, const_str_digest_d26c39e8ed4ddb2171e43f32074c3668 ); Py_INCREF( const_str_digest_d26c39e8ed4ddb2171e43f32074c3668 );
    const_tuple_str_plain_no_warnings_str_plain_nowarnings_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_warnings_str_plain_nowarnings_tuple, 0, const_str_plain_no_warnings ); Py_INCREF( const_str_plain_no_warnings );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_warnings_str_plain_nowarnings_tuple, 1, const_str_plain_nowarnings ); Py_INCREF( const_str_plain_nowarnings );
    const_tuple_str_digest_46f785c15c72b806f29a68d8dfd47979_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_46f785c15c72b806f29a68d8dfd47979_tuple, 0, const_str_digest_46f785c15c72b806f29a68d8dfd47979 ); Py_INCREF( const_str_digest_46f785c15c72b806f29a68d8dfd47979 );
    const_tuple_str_digest_749d64834db4e74f339318a144653b9a_tuple = PyTuple_New( 1 );
    const_str_digest_749d64834db4e74f339318a144653b9a = UNSTREAM_STRING( &constant_bin[ 14988 ], 14, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_749d64834db4e74f339318a144653b9a_tuple, 0, const_str_digest_749d64834db4e74f339318a144653b9a ); Py_INCREF( const_str_digest_749d64834db4e74f339318a144653b9a );
    const_str_digest_2628b2da7143e7e835e536f6f73483c8 = UNSTREAM_STRING( &constant_bin[ 15002 ], 17, 0 );
    const_dict_963aa946b3440440fe76b2e311636977 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_963aa946b3440440fe76b2e311636977, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_963aa946b3440440fe76b2e311636977, const_str_plain_dest, const_str_plain_update_dependency_cache );
    PyDict_SetItem( const_dict_963aa946b3440440fe76b2e311636977, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_963aa946b3440440fe76b2e311636977, const_str_plain_help, const_str_digest_06cc1079d55905af7b68e7a756b22d05 );
    assert( PyDict_Size( const_dict_963aa946b3440440fe76b2e311636977 ) == 4 );
    const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_keep_pythonpath = UNSTREAM_STRING( &constant_bin[ 15019 ], 15, 1 );
    PyDict_SetItem( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79, const_str_plain_dest, const_str_plain_keep_pythonpath );
    PyDict_SetItem( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79, const_str_plain_default, Py_False );
    const_str_digest_e48e8408e1e689620d63cb57dcd8c5bd = UNSTREAM_STRING( &constant_bin[ 15034 ], 168, 0 );
    PyDict_SetItem( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79, const_str_plain_help, const_str_digest_e48e8408e1e689620d63cb57dcd8c5bd );
    assert( PyDict_Size( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79 ) == 4 );
    const_str_digest_2af64c3ed3ff95fc82dfce1598612dc1 = UNSTREAM_STRING( &constant_bin[ 15202 ], 35, 0 );
    const_str_digest_0a0aff9f62f0d1e8c59663305c25a371 = UNSTREAM_STRING( &constant_bin[ 15237 ], 16, 0 );
    const_str_digest_a1b73434dde6ef4b54439b149420d10b = UNSTREAM_STRING( &constant_bin[ 15253 ], 43, 0 );
    const_str_digest_0f64d43d9cf5e40fb886257fa3b28964 = UNSTREAM_STRING( &constant_bin[ 15296 ], 25, 0 );
    const_str_plain_outputdir_group = UNSTREAM_STRING( &constant_bin[ 15321 ], 15, 1 );
    const_dict_e05c9b973b11029e09a99d8142ddfc93 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_e05c9b973b11029e09a99d8142ddfc93, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_e05c9b973b11029e09a99d8142ddfc93, const_str_plain_dest, const_str_plain_show_inclusion );
    PyDict_SetItem( const_dict_e05c9b973b11029e09a99d8142ddfc93, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_e05c9b973b11029e09a99d8142ddfc93, const_str_plain_help, const_str_digest_1999b862fee169df7201f15bd1e9bcad );
    assert( PyDict_Size( const_dict_e05c9b973b11029e09a99d8142ddfc93 ) == 4 );
    const_tuple_1c0e6ffbbde28de054c77c94763a9e2b_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_1c0e6ffbbde28de054c77c94763a9e2b_tuple, 0, const_str_digest_070be269e5c34380728f9fc12e47c2bf ); Py_INCREF( const_str_digest_070be269e5c34380728f9fc12e47c2bf );
    const_str_digest_e87c1164c808877bf2c4be689574292e = UNSTREAM_STRING( &constant_bin[ 15336 ], 12, 0 );
    PyTuple_SET_ITEM( const_tuple_1c0e6ffbbde28de054c77c94763a9e2b_tuple, 1, const_str_digest_e87c1164c808877bf2c4be689574292e ); Py_INCREF( const_str_digest_e87c1164c808877bf2c4be689574292e );
    const_str_plain_warn_implicit_exceptions = UNSTREAM_STRING( &constant_bin[ 15348 ], 24, 1 );
    const_str_digest_23e2e20ef56f951794853554a3a508d6 = UNSTREAM_STRING( &constant_bin[ 15372 ], 3, 0 );
    const_str_plain_explain_imports = UNSTREAM_STRING( &constant_bin[ 15375 ], 15, 1 );
    const_tuple_str_plain_getSupportedPythonVersions_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_getSupportedPythonVersions_tuple, 0, const_str_plain_getSupportedPythonVersions ); Py_INCREF( const_str_plain_getSupportedPythonVersions );
    const_str_plain_dump_group = UNSTREAM_STRING( &constant_bin[ 15390 ], 10, 1 );
    const_dict_f55c75937f11f826e31f0719c4fa9c96 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_f55c75937f11f826e31f0719c4fa9c96, const_str_plain_action, const_str_plain_store_false );
    PyDict_SetItem( const_dict_f55c75937f11f826e31f0719c4fa9c96, const_str_plain_dest, const_str_plain_executable );
    PyDict_SetItem( const_dict_f55c75937f11f826e31f0719c4fa9c96, const_str_plain_default, Py_True );
    PyDict_SetItem( const_dict_f55c75937f11f826e31f0719c4fa9c96, const_str_plain_help, const_str_digest_a8790475190f78aa2acabac27744f407 );
    assert( PyDict_Size( const_dict_f55c75937f11f826e31f0719c4fa9c96 ) == 4 );
    const_str_plain_statement_lines = UNSTREAM_STRING( &constant_bin[ 15400 ], 15, 1 );
    const_str_digest_2b0af2d25c2533b6a07c1aacbaa63eba = UNSTREAM_STRING( &constant_bin[ 15415 ], 17, 0 );
    const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 0, const_str_plain_plugin_name ); Py_INCREF( const_str_plain_plugin_name );
    PyTuple_SET_ITEM( const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 1, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 2, const_str_plain_plugin_enabled ); Py_INCREF( const_str_plain_plugin_enabled );
    PyTuple_SET_ITEM( const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 4, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    const_tuple_7f868864dcb1dd0c7268cc60bfcfc142_tuple = PyTuple_New( 2 );
    const_str_digest_aaf340b09aa648ed0e35d7b8fed1e68b = UNSTREAM_STRING( &constant_bin[ 15432 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_7f868864dcb1dd0c7268cc60bfcfc142_tuple, 0, const_str_digest_aaf340b09aa648ed0e35d7b8fed1e68b ); Py_INCREF( const_str_digest_aaf340b09aa648ed0e35d7b8fed1e68b );
    PyTuple_SET_ITEM( const_tuple_7f868864dcb1dd0c7268cc60bfcfc142_tuple, 1, const_str_digest_89159a5dbad3f2fb2e8b857c60946590 ); Py_INCREF( const_str_digest_89159a5dbad3f2fb2e8b857c60946590 );
    const_str_digest_91374e86cd95854fdf69256ea2446159 = UNSTREAM_STRING( &constant_bin[ 15442 ], 41, 0 );
    const_dict_d8084db55bb0173b66ca83cf5be4a1f7 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_d8084db55bb0173b66ca83cf5be4a1f7, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_d8084db55bb0173b66ca83cf5be4a1f7, const_str_plain_dest, const_str_plain_verbose );
    PyDict_SetItem( const_dict_d8084db55bb0173b66ca83cf5be4a1f7, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_d8084db55bb0173b66ca83cf5be4a1f7, const_str_plain_help, const_str_digest_507e1544d34f3449cefc7e95aa4e43f6 );
    assert( PyDict_Size( const_dict_d8084db55bb0173b66ca83cf5be4a1f7 ) == 4 );
    const_tuple_str_plain_parts_str_plain_part_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_parts_str_plain_part_tuple, 0, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_str_plain_parts_str_plain_part_tuple, 1, const_str_plain_part ); Py_INCREF( const_str_plain_part );
    const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple, 0, const_str_plain_original ); Py_INCREF( const_str_plain_original );
    PyTuple_SET_ITEM( const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple, 1, const_str_plain_runtime ); Py_INCREF( const_str_plain_runtime );
    PyTuple_SET_ITEM( const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple, 2, const_str_plain_frozen ); Py_INCREF( const_str_plain_frozen );
    const_dict_ae7bb8b561973c8d04445137aad11631 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_ae7bb8b561973c8d04445137aad11631, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_lto = UNSTREAM_STRING( &constant_bin[ 2137 ], 3, 1 );
    PyDict_SetItem( const_dict_ae7bb8b561973c8d04445137aad11631, const_str_plain_dest, const_str_plain_lto );
    PyDict_SetItem( const_dict_ae7bb8b561973c8d04445137aad11631, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_ae7bb8b561973c8d04445137aad11631, const_str_plain_help, const_str_digest_a36e77b7d0a3758e6a6afc584106002f );
    assert( PyDict_Size( const_dict_ae7bb8b561973c8d04445137aad11631 ) == 4 );
    const_str_digest_4404820c6f10802a609c05d4a136e6ee = UNSTREAM_STRING( &constant_bin[ 15483 ], 106, 0 );
    const_dict_012a9328b79bad885d5993fdc0b796e8 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_012a9328b79bad885d5993fdc0b796e8, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_012a9328b79bad885d5993fdc0b796e8, const_str_plain_dest, const_str_plain_mingw );
    PyDict_SetItem( const_dict_012a9328b79bad885d5993fdc0b796e8, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_012a9328b79bad885d5993fdc0b796e8, const_str_plain_help, const_str_digest_5369445afe6ad40445ccdb0facd01155 );
    assert( PyDict_Size( const_dict_012a9328b79bad885d5993fdc0b796e8 ) == 4 );
    const_dict_a9a03b40ba8f26cdbb333b87799dc921 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_a9a03b40ba8f26cdbb333b87799dc921, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_a9a03b40ba8f26cdbb333b87799dc921, const_str_plain_dest, const_str_plain_show_scons );
    PyDict_SetItem( const_dict_a9a03b40ba8f26cdbb333b87799dc921, const_str_plain_default, Py_False );
    const_str_digest_05f186fedc8558d8f48fe769c4a7504f = UNSTREAM_STRING( &constant_bin[ 15589 ], 80, 0 );
    PyDict_SetItem( const_dict_a9a03b40ba8f26cdbb333b87799dc921, const_str_plain_help, const_str_digest_05f186fedc8558d8f48fe769c4a7504f );
    assert( PyDict_Size( const_dict_a9a03b40ba8f26cdbb333b87799dc921 ) == 4 );
    const_dict_ccf05bbd6062a341ea16977d08e4ace1 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_ccf05bbd6062a341ea16977d08e4ace1, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_profile = UNSTREAM_STRING( &constant_bin[ 4567 ], 7, 1 );
    PyDict_SetItem( const_dict_ccf05bbd6062a341ea16977d08e4ace1, const_str_plain_dest, const_str_plain_profile );
    PyDict_SetItem( const_dict_ccf05bbd6062a341ea16977d08e4ace1, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_ccf05bbd6062a341ea16977d08e4ace1, const_str_plain_help, const_str_digest_0730bf20647f4f8106e68afba7d49131 );
    assert( PyDict_Size( const_dict_ccf05bbd6062a341ea16977d08e4ace1 ) == 4 );
    const_dict_55b3309b164506bd83a51d039ef1179d = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_55b3309b164506bd83a51d039ef1179d, const_str_plain_action, const_str_plain_append );
    const_str_plain_include_modules = UNSTREAM_STRING( &constant_bin[ 15669 ], 15, 1 );
    PyDict_SetItem( const_dict_55b3309b164506bd83a51d039ef1179d, const_str_plain_dest, const_str_plain_include_modules );
    PyDict_SetItem( const_dict_55b3309b164506bd83a51d039ef1179d, const_str_plain_metavar, const_str_plain_MODULE );
    PyDict_SetItem( const_dict_55b3309b164506bd83a51d039ef1179d, const_str_plain_default, const_list_empty );
    PyDict_SetItem( const_dict_55b3309b164506bd83a51d039ef1179d, const_str_plain_help, const_str_digest_6eb625ebe8945450e4fac63cdf07efd0 );
    assert( PyDict_Size( const_dict_55b3309b164506bd83a51d039ef1179d ) == 5 );
    const_dict_1f72f6528b11a15cfc32a55abad3e2f5 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_1f72f6528b11a15cfc32a55abad3e2f5, const_str_plain_action, const_str_plain_store );
    PyDict_SetItem( const_dict_1f72f6528b11a15cfc32a55abad3e2f5, const_str_plain_dest, const_str_plain_file_reference_mode );
    PyDict_SetItem( const_dict_1f72f6528b11a15cfc32a55abad3e2f5, const_str_plain_choices, const_tuple_str_plain_original_str_plain_runtime_str_plain_frozen_tuple );
    PyDict_SetItem( const_dict_1f72f6528b11a15cfc32a55abad3e2f5, const_str_plain_default, Py_None );
    const_str_digest_978105f0338b08759e4337ceca390cd9 = UNSTREAM_STRING( &constant_bin[ 15684 ], 632, 0 );
    PyDict_SetItem( const_dict_1f72f6528b11a15cfc32a55abad3e2f5, const_str_plain_help, const_str_digest_978105f0338b08759e4337ceca390cd9 );
    assert( PyDict_Size( const_dict_1f72f6528b11a15cfc32a55abad3e2f5 ) == 5 );
    const_tuple_fd9bd18abc843709bbdfa4939c29306e_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_fd9bd18abc843709bbdfa4939c29306e_tuple, 0, const_str_digest_5f92110962dad42b6e9f8718847150da ); Py_INCREF( const_str_digest_5f92110962dad42b6e9f8718847150da );
    PyTuple_SET_ITEM( const_tuple_fd9bd18abc843709bbdfa4939c29306e_tuple, 1, const_str_digest_b6f7031b7e2bccd0ab51d368f37477f8 ); Py_INCREF( const_str_digest_b6f7031b7e2bccd0ab51d368f37477f8 );
    const_tuple_f8c54c1f3d7d17e6cf8e8b9532e0158f_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_f8c54c1f3d7d17e6cf8e8b9532e0158f_tuple, 0, const_str_digest_f1c6c9be039474fe95893251fd2b4000 ); Py_INCREF( const_str_digest_f1c6c9be039474fe95893251fd2b4000 );
    PyTuple_SET_ITEM( const_tuple_f8c54c1f3d7d17e6cf8e8b9532e0158f_tuple, 1, const_str_digest_7681cf7d12f55a4b4df9fcde1b3e30bb ); Py_INCREF( const_str_digest_7681cf7d12f55a4b4df9fcde1b3e30bb );
    const_tuple_str_digest_1fbf263a160f21148f892a1b15932c5a_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_1fbf263a160f21148f892a1b15932c5a_tuple, 0, const_str_digest_1fbf263a160f21148f892a1b15932c5a ); Py_INCREF( const_str_digest_1fbf263a160f21148f892a1b15932c5a );
    const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple, 0, const_str_digest_e22d9173bccdc16d4477eee43c8497ac ); Py_INCREF( const_str_digest_e22d9173bccdc16d4477eee43c8497ac );
    PyTuple_SET_ITEM( const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple, 1, const_str_plain_no_asserts ); Py_INCREF( const_str_plain_no_asserts );
    const_str_plain_noasserts = UNSTREAM_STRING( &constant_bin[ 9539 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple, 2, const_str_plain_noasserts ); Py_INCREF( const_str_plain_noasserts );
    const_str_digest_3cd4325f1e1f69e4ec5f33696a01c94f = UNSTREAM_STRING( &constant_bin[ 16316 ], 14, 0 );
    const_str_plain_show_memory = UNSTREAM_STRING( &constant_bin[ 16330 ], 11, 1 );
    const_tuple_25f13a07532615ebccd7a031a6fe2ed5_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_25f13a07532615ebccd7a031a6fe2ed5_tuple, 0, const_str_digest_2b0af2d25c2533b6a07c1aacbaa63eba ); Py_INCREF( const_str_digest_2b0af2d25c2533b6a07c1aacbaa63eba );
    PyTuple_SET_ITEM( const_tuple_25f13a07532615ebccd7a031a6fe2ed5_tuple, 1, const_str_digest_218df1a0cc5a4ceaffc69395c4609ab7 ); Py_INCREF( const_str_digest_218df1a0cc5a4ceaffc69395c4609ab7 );
    const_tuple_4a1f625c7edc4f9009ea9412f2eb7ca6_tuple = PyTuple_New( 2 );
    const_str_digest_7b6bde9c6b044c89b857f7ac6f019324 = UNSTREAM_STRING( &constant_bin[ 16341 ], 18, 0 );
    PyTuple_SET_ITEM( const_tuple_4a1f625c7edc4f9009ea9412f2eb7ca6_tuple, 0, const_str_digest_7b6bde9c6b044c89b857f7ac6f019324 ); Py_INCREF( const_str_digest_7b6bde9c6b044c89b857f7ac6f019324 );
    const_str_digest_8074300badc2e1a18e0504a3633df880 = UNSTREAM_STRING( &constant_bin[ 16359 ], 20, 0 );
    PyTuple_SET_ITEM( const_tuple_4a1f625c7edc4f9009ea9412f2eb7ca6_tuple, 1, const_str_digest_8074300badc2e1a18e0504a3633df880 ); Py_INCREF( const_str_digest_8074300badc2e1a18e0504a3633df880 );
    const_str_digest_b22b6a8fbe4f1eb24d47c1182e8594be = UNSTREAM_STRING( &constant_bin[ 16379 ], 75, 0 );
    const_tuple_str_digest_181925cc600ef7846f4fc9b1da40c033_tuple = PyTuple_New( 1 );
    const_str_digest_181925cc600ef7846f4fc9b1da40c033 = UNSTREAM_STRING( &constant_bin[ 16454 ], 23, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_181925cc600ef7846f4fc9b1da40c033_tuple, 0, const_str_digest_181925cc600ef7846f4fc9b1da40c033 ); Py_INCREF( const_str_digest_181925cc600ef7846f4fc9b1da40c033 );
    const_str_digest_d226a3eaf71353ef4246518ce9a7bf20 = UNSTREAM_STRING( &constant_bin[ 16477 ], 89, 0 );
    const_tuple_str_digest_d3391bc5505627a621ab17af42b5e153_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d3391bc5505627a621ab17af42b5e153_tuple, 0, const_str_digest_d3391bc5505627a621ab17af42b5e153 ); Py_INCREF( const_str_digest_d3391bc5505627a621ab17af42b5e153 );
    const_dict_ded7ced2e817eaed7d9d3482108130c5 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_ded7ced2e817eaed7d9d3482108130c5, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_ded7ced2e817eaed7d9d3482108130c5, const_str_plain_dest, const_str_plain_display_tree );
    PyDict_SetItem( const_dict_ded7ced2e817eaed7d9d3482108130c5, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_ded7ced2e817eaed7d9d3482108130c5, const_str_plain_help, const_str_digest_2066ce09ec83a0da05ffee69f6f232a2 );
    assert( PyDict_Size( const_dict_ded7ced2e817eaed7d9d3482108130c5 ) == 4 );
    const_tuple_str_digest_a4fc5193531b6150e42d718b392fd227_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_a4fc5193531b6150e42d718b392fd227_tuple, 0, const_str_digest_a4fc5193531b6150e42d718b392fd227 ); Py_INCREF( const_str_digest_a4fc5193531b6150e42d718b392fd227 );
    const_str_digest_3493e1419f00062da30c5054eace3ba0 = UNSTREAM_STRING( &constant_bin[ 16566 ], 71, 0 );
    const_tuple_str_plain_getNuitkaVersion_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_getNuitkaVersion_tuple, 0, const_str_plain_getNuitkaVersion ); Py_INCREF( const_str_plain_getNuitkaVersion );
    const_dict_cd2f10c233c60e843dc94e0ca3fff447 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_cd2f10c233c60e843dc94e0ca3fff447, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_cd2f10c233c60e843dc94e0ca3fff447, const_str_plain_dest, const_str_plain_show_memory );
    PyDict_SetItem( const_dict_cd2f10c233c60e843dc94e0ca3fff447, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_cd2f10c233c60e843dc94e0ca3fff447, const_str_plain_help, const_str_digest_1763e4d4cad050cb477b4075c12e61b9 );
    assert( PyDict_Size( const_dict_cd2f10c233c60e843dc94e0ca3fff447 ) == 4 );
    const_str_digest_d78eaf819b148cd0ed4de8a87366220a = UNSTREAM_STRING( &constant_bin[ 16637 ], 16, 0 );
    const_str_plain_shallListPlugins = UNSTREAM_STRING( &constant_bin[ 16653 ], 16, 1 );
    const_tuple_str_digest_eb2a748be8fdd84357bb51822fa7dd48_tuple = PyTuple_New( 1 );
    const_str_digest_eb2a748be8fdd84357bb51822fa7dd48 = UNSTREAM_STRING( &constant_bin[ 10509 ], 5, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_eb2a748be8fdd84357bb51822fa7dd48_tuple, 0, const_str_digest_eb2a748be8fdd84357bb51822fa7dd48 ); Py_INCREF( const_str_digest_eb2a748be8fdd84357bb51822fa7dd48 );
    const_tuple_str_digest_0a0aff9f62f0d1e8c59663305c25a371_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_0a0aff9f62f0d1e8c59663305c25a371_tuple, 0, const_str_digest_0a0aff9f62f0d1e8c59663305c25a371 ); Py_INCREF( const_str_digest_0a0aff9f62f0d1e8c59663305c25a371 );
    const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple, 0, const_str_digest_59bdb53e22971cd7d7e7b286d1104da6 ); Py_INCREF( const_str_digest_59bdb53e22971cd7d7e7b286d1104da6 );
    const_str_plain_nosite = UNSTREAM_STRING( &constant_bin[ 9417 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple, 1, const_str_plain_nosite ); Py_INCREF( const_str_plain_nosite );
    PyTuple_SET_ITEM( const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple, 2, const_str_plain_no_site ); Py_INCREF( const_str_plain_no_site );
    const_dict_3f4bd6c51d5048274ce90a44405017b0 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_3f4bd6c51d5048274ce90a44405017b0, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_3f4bd6c51d5048274ce90a44405017b0, const_str_plain_dest, const_str_plain_assume_yes_for_downloads );
    PyDict_SetItem( const_dict_3f4bd6c51d5048274ce90a44405017b0, const_str_plain_default, Py_False );
    const_str_digest_aa4fe1cd654c351d323b097fb681dd9f = UNSTREAM_STRING( &constant_bin[ 16669 ], 78, 0 );
    PyDict_SetItem( const_dict_3f4bd6c51d5048274ce90a44405017b0, const_str_plain_help, const_str_digest_aa4fe1cd654c351d323b097fb681dd9f );
    assert( PyDict_Size( const_dict_3f4bd6c51d5048274ce90a44405017b0 ) == 4 );
    const_str_digest_096be9a55acdb9f027de49b047bd228d = UNSTREAM_STRING( &constant_bin[ 16747 ], 21, 0 );
    const_dict_48a12ca9025ab4ff10c795867c5ba0bb = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_48a12ca9025ab4ff10c795867c5ba0bb, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_48a12ca9025ab4ff10c795867c5ba0bb, const_str_plain_dest, const_str_plain_recurse_all );
    PyDict_SetItem( const_dict_48a12ca9025ab4ff10c795867c5ba0bb, const_str_plain_default, Py_False );
    const_str_digest_019250c3dabb431ea6145ba8daa3611e = UNSTREAM_STRING( &constant_bin[ 16768 ], 90, 0 );
    PyDict_SetItem( const_dict_48a12ca9025ab4ff10c795867c5ba0bb, const_str_plain_help, const_str_digest_019250c3dabb431ea6145ba8daa3611e );
    assert( PyDict_Size( const_dict_48a12ca9025ab4ff10c795867c5ba0bb ) == 4 );
    const_tuple_str_digest_348f668e21b79db9e8ad525164de0ee1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_348f668e21b79db9e8ad525164de0ee1_tuple, 0, const_str_digest_348f668e21b79db9e8ad525164de0ee1 ); Py_INCREF( const_str_digest_348f668e21b79db9e8ad525164de0ee1 );
    const_dict_f38a879f43bf713c7195c04e0d245695 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_f38a879f43bf713c7195c04e0d245695, const_str_plain_action, const_str_plain_store_false );
    PyDict_SetItem( const_dict_f38a879f43bf713c7195c04e0d245695, const_str_plain_dest, const_str_plain_pyi_file );
    PyDict_SetItem( const_dict_f38a879f43bf713c7195c04e0d245695, const_str_plain_default, Py_True );
    const_str_digest_733603cf65360204826c57d7ec02deed = UNSTREAM_STRING( &constant_bin[ 16858 ], 85, 0 );
    PyDict_SetItem( const_dict_f38a879f43bf713c7195c04e0d245695, const_str_plain_help, const_str_digest_733603cf65360204826c57d7ec02deed );
    assert( PyDict_Size( const_dict_f38a879f43bf713c7195c04e0d245695 ) == 4 );
    const_str_digest_ea23ff8606bc48a7cd2ae9210fd4a7d3 = UNSTREAM_STRING( &constant_bin[ 16943 ], 53, 0 );
    const_tuple_str_digest_2628b2da7143e7e835e536f6f73483c8_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_2628b2da7143e7e835e536f6f73483c8_tuple, 0, const_str_digest_2628b2da7143e7e835e536f6f73483c8 ); Py_INCREF( const_str_digest_2628b2da7143e7e835e536f6f73483c8 );
    const_str_digest_126a85cfeb4a081042e66eeac95137b9 = UNSTREAM_STRING( &constant_bin[ 16996 ], 30, 0 );
    const_tuple_str_plain_indication_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_indication_tuple, 0, const_str_plain_indication ); Py_INCREF( const_str_plain_indication );
    const_dict_aa8231dd4f6fdaa06dbf5512dde88796 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_aa8231dd4f6fdaa06dbf5512dde88796, const_str_plain_action, const_str_plain_store_true );
    const_str_plain_show_progress = UNSTREAM_STRING( &constant_bin[ 17026 ], 13, 1 );
    PyDict_SetItem( const_dict_aa8231dd4f6fdaa06dbf5512dde88796, const_str_plain_dest, const_str_plain_show_progress );
    PyDict_SetItem( const_dict_aa8231dd4f6fdaa06dbf5512dde88796, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_aa8231dd4f6fdaa06dbf5512dde88796, const_str_plain_help, const_str_digest_99c99677a4e4e5551851722475466536 );
    assert( PyDict_Size( const_dict_aa8231dd4f6fdaa06dbf5512dde88796 ) == 4 );
    const_str_plain_immediate_execution = UNSTREAM_STRING( &constant_bin[ 17039 ], 19, 1 );
    const_str_digest_ef2ed6d9473fc26d981c5602152fe549 = UNSTREAM_STRING( &constant_bin[ 17058 ], 30, 0 );
    const_tuple_str_plain_x86_str_plain_x86_64_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x86_str_plain_x86_64_tuple, 0, const_str_plain_x86 ); Py_INCREF( const_str_plain_x86 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x86_str_plain_x86_64_tuple, 1, const_str_plain_x86_64 ); Py_INCREF( const_str_plain_x86_64 );
    const_tuple_bf3176bee2556beb326253fa06ee2b45_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_bf3176bee2556beb326253fa06ee2b45_tuple, 0, const_str_digest_c46232c53d9f9936cf8242ca32901592 ); Py_INCREF( const_str_digest_c46232c53d9f9936cf8242ca32901592 );
    PyTuple_SET_ITEM( const_tuple_bf3176bee2556beb326253fa06ee2b45_tuple, 1, const_str_digest_00c314cfeb398027009e203584943dfb ); Py_INCREF( const_str_digest_00c314cfeb398027009e203584943dfb );
    const_tuple_str_digest_4913f61cf652f6bfa0f584ea4716697a_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_4913f61cf652f6bfa0f584ea4716697a_tuple, 0, const_str_digest_4913f61cf652f6bfa0f584ea4716697a ); Py_INCREF( const_str_digest_4913f61cf652f6bfa0f584ea4716697a );
    const_tuple_str_digest_000f2dcd6617662a5ec06cf266d5aede_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_000f2dcd6617662a5ec06cf266d5aede_tuple, 0, const_str_digest_000f2dcd6617662a5ec06cf266d5aede ); Py_INCREF( const_str_digest_000f2dcd6617662a5ec06cf266d5aede );
    const_tuple_str_digest_ef2ed6d9473fc26d981c5602152fe549_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_ef2ed6d9473fc26d981c5602152fe549_tuple, 0, const_str_digest_ef2ed6d9473fc26d981c5602152fe549 ); Py_INCREF( const_str_digest_ef2ed6d9473fc26d981c5602152fe549 );
    const_tuple_e4cb1538d3263a5929c47e9b9ad8e0ca_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_e4cb1538d3263a5929c47e9b9ad8e0ca_tuple, 0, const_str_digest_60916d45686821dae42b81cd8917e3ba ); Py_INCREF( const_str_digest_60916d45686821dae42b81cd8917e3ba );
    PyTuple_SET_ITEM( const_tuple_e4cb1538d3263a5929c47e9b9ad8e0ca_tuple, 1, const_str_digest_9ac1ed25c92f3ebd3d47fc83855c6798 ); Py_INCREF( const_str_digest_9ac1ed25c92f3ebd3d47fc83855c6798 );
    const_tuple_str_digest_6120fea2456c84f26fd70306fee05e56_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_6120fea2456c84f26fd70306fee05e56_tuple, 0, const_str_digest_6120fea2456c84f26fd70306fee05e56 ); Py_INCREF( const_str_digest_6120fea2456c84f26fd70306fee05e56 );
    const_tuple_str_digest_096be9a55acdb9f027de49b047bd228d_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_096be9a55acdb9f027de49b047bd228d_tuple, 0, const_str_digest_096be9a55acdb9f027de49b047bd228d ); Py_INCREF( const_str_digest_096be9a55acdb9f027de49b047bd228d );
    const_tuple_str_digest_76a20e0434f49c589f5f87e961db8fd3_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_76a20e0434f49c589f5f87e961db8fd3_tuple, 0, const_str_digest_76a20e0434f49c589f5f87e961db8fd3 ); Py_INCREF( const_str_digest_76a20e0434f49c589f5f87e961db8fd3 );
    const_str_digest_6ffff9871e7a9049cdcc39ccb0332ee2 = UNSTREAM_STRING( &constant_bin[ 17088 ], 14, 0 );
    const_dict_5050b44d40c50f56cd13e9ad189ccc0e = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_5050b44d40c50f56cd13e9ad189ccc0e, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_5050b44d40c50f56cd13e9ad189ccc0e, const_str_plain_dest, const_str_plain_graph );
    PyDict_SetItem( const_dict_5050b44d40c50f56cd13e9ad189ccc0e, const_str_plain_default, Py_False );
    const_str_digest_59a7509ad2b012191ee0b981113c58d4 = UNSTREAM_STRING( &constant_bin[ 17102 ], 54, 0 );
    PyDict_SetItem( const_dict_5050b44d40c50f56cd13e9ad189ccc0e, const_str_plain_help, const_str_digest_59a7509ad2b012191ee0b981113c58d4 );
    assert( PyDict_Size( const_dict_5050b44d40c50f56cd13e9ad189ccc0e ) == 4 );
    const_str_plain_tracing_group = UNSTREAM_STRING( &constant_bin[ 17156 ], 13, 1 );
    const_tuple_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60_tuple, 0, const_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60 ); Py_INCREF( const_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60 );
    const_tuple_str_digest_e83450d8f459f012a8e64edb69727742_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e83450d8f459f012a8e64edb69727742_tuple, 0, const_str_digest_e83450d8f459f012a8e64edb69727742 ); Py_INCREF( const_str_digest_e83450d8f459f012a8e64edb69727742 );
    const_tuple_str_plain_no_randomization_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_randomization_tuple, 0, const_str_plain_no_randomization ); Py_INCREF( const_str_plain_no_randomization );
    const_tuple_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1_tuple, 0, const_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1 ); Py_INCREF( const_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1 );
    const_tuple_str_digest_25433114711138da4c9f37c122d5a3e0_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_25433114711138da4c9f37c122d5a3e0_tuple, 0, const_str_digest_25433114711138da4c9f37c122d5a3e0 ); Py_INCREF( const_str_digest_25433114711138da4c9f37c122d5a3e0 );
    const_str_plain__python_flags = UNSTREAM_STRING( &constant_bin[ 17169 ], 13, 1 );
    const_dict_a3622bcc2795e0b4e6bb780eab3dc833 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_a3622bcc2795e0b4e6bb780eab3dc833, const_str_plain_action, const_str_plain_store_true );
    PyDict_SetItem( const_dict_a3622bcc2795e0b4e6bb780eab3dc833, const_str_plain_dest, const_str_plain_warn_implicit_exceptions );
    PyDict_SetItem( const_dict_a3622bcc2795e0b4e6bb780eab3dc833, const_str_plain_default, Py_False );
    PyDict_SetItem( const_dict_a3622bcc2795e0b4e6bb780eab3dc833, const_str_plain_help, const_str_digest_6f223af97602dbde04d0ea3a5add6869 );
    assert( PyDict_Size( const_dict_a3622bcc2795e0b4e6bb780eab3dc833 ) == 4 );
    const_tuple_str_plain_no_site_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_no_site_tuple, 0, const_str_plain_no_site ); Py_INCREF( const_str_plain_no_site );
    const_dict_0902eb40bd31bd25b3bae9ef7176fa85 = _PyDict_NewPresized( 5 );
    PyDict_SetItem( const_dict_0902eb40bd31bd25b3bae9ef7176fa85, const_str_plain_action, const_str_plain_store );
    PyDict_SetItem( const_dict_0902eb40bd31bd25b3bae9ef7176fa85, const_str_plain_dest, const_str_plain_icon_path );
    PyDict_SetItem( const_dict_0902eb40bd31bd25b3bae9ef7176fa85, const_str_plain_metavar, const_str_plain_ICON_PATH );
    PyDict_SetItem( const_dict_0902eb40bd31bd25b3bae9ef7176fa85, const_str_plain_default, Py_None );
    PyDict_SetItem( const_dict_0902eb40bd31bd25b3bae9ef7176fa85, const_str_plain_help, const_str_digest_0f684c542ec93bce2df505f518c4b1b8 );
    assert( PyDict_Size( const_dict_0902eb40bd31bd25b3bae9ef7176fa85 ) == 5 );
    const_str_digest_f265ec4f445f7dafa56a7c60cf81c5b9 = UNSTREAM_STRING( &constant_bin[ 17182 ], 111, 0 );
    const_dict_45062a32a0550745ae06f84c5860b292 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_45062a32a0550745ae06f84c5860b292, const_str_plain_action, const_str_plain_append );
    PyDict_SetItem( const_dict_45062a32a0550745ae06f84c5860b292, const_str_plain_dest, const_str_plain_plugins_disabled );
    PyDict_SetItem( const_dict_45062a32a0550745ae06f84c5860b292, const_str_plain_default, const_list_empty );
    PyDict_SetItem( const_dict_45062a32a0550745ae06f84c5860b292, const_str_plain_help, const_str_digest_4404820c6f10802a609c05d4a136e6ee );
    assert( PyDict_Size( const_dict_45062a32a0550745ae06f84c5860b292 ) == 4 );
    const_tuple_str_digest_f13acabca636d4d483b3d53e84c3d766_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f13acabca636d4d483b3d53e84c3d766_tuple, 0, const_str_digest_f13acabca636d4d483b3d53e84c3d766 ); Py_INCREF( const_str_digest_f13acabca636d4d483b3d53e84c3d766 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_Options( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_ce72348006636f3b1d48f63be6336e5c;
static PyCodeObject *codeobj_f8d619e8fb32ffd66203c9c2939bf1f6;
static PyCodeObject *codeobj_c721fc79d077c2b14e42177a06329c85;
static PyCodeObject *codeobj_6c12b512b3dea76e9c7dc2e486b61d7f;
static PyCodeObject *codeobj_4bebe3e14b9a7aa974a75088fa55838c;
static PyCodeObject *codeobj_e247755bd74b0ae1ce03487b4067d9e8;
static PyCodeObject *codeobj_c58a6b313fcc56d855cb1583debb45f4;
static PyCodeObject *codeobj_ff896619f018e5169268dd4e6352a0fb;
static PyCodeObject *codeobj_e9568ec9f2372518858530f1e368f07b;
static PyCodeObject *codeobj_a8a85772fc9aa4c76d07fffd99c28d26;
static PyCodeObject *codeobj_272528bf4636d442d00d6a18b95d85dd;
static PyCodeObject *codeobj_d78116b19c5a705c69847ce6f0f0a6e8;
static PyCodeObject *codeobj_54b9c0307687c886454ab94ba1aa079b;
static PyCodeObject *codeobj_af19baa1ab5af3e1fba732aad9b40a5d;
static PyCodeObject *codeobj_eb11be53fb77c76d2826cff4d9c08247;
static PyCodeObject *codeobj_be0d106c45d34e95877f4996ec8d75b7;
static PyCodeObject *codeobj_2b41d17ce2ce901c30b6d180b922e6cc;
static PyCodeObject *codeobj_d0e72dd5176d8fb44a2a894177240eee;
static PyCodeObject *codeobj_a521c517b8991aad61def47b5f4d695b;
static PyCodeObject *codeobj_c00d3fc69c4374d1325ec84fe1aec136;
static PyCodeObject *codeobj_39ca76230b1066f515fe4ccee38cb42b;
static PyCodeObject *codeobj_491df70ab21e3f1d09686b30ddc39c24;
static PyCodeObject *codeobj_884b504793f584ec870f8bcbada6556a;
static PyCodeObject *codeobj_2a53c9c37badde19d78b2a36fe3875dc;
static PyCodeObject *codeobj_aaff8348fa4ec25d845604fa01fc5e66;
static PyCodeObject *codeobj_16065475bb34579370f7f78a96f24fa6;
static PyCodeObject *codeobj_4bd96c049702e1671d294217f1aa0e22;
static PyCodeObject *codeobj_95ca596c1c70767c7c1e62f9209438e4;
static PyCodeObject *codeobj_6d1b960b567971407ddf22e61c4cf1fe;
static PyCodeObject *codeobj_1e83e4d70cf7aacbd8c100d6e42e6b9a;
static PyCodeObject *codeobj_505945e7d1254f4132a1d5ce2a8071d3;
static PyCodeObject *codeobj_740beeaa8324802bf1747ce98c5bbb53;
static PyCodeObject *codeobj_6f0e6a95e1ce7d0b91dae6b7e68c291b;
static PyCodeObject *codeobj_5cb9696cdcff5fe60bf2c0d942196107;
static PyCodeObject *codeobj_ff82744b35918d18314beabdf85850e0;
static PyCodeObject *codeobj_167b79dc77d0a1f9967239702a9b1a97;
static PyCodeObject *codeobj_8672f7cad8c8767f00958a426d497654;
static PyCodeObject *codeobj_31849ef404ecd5ac3889e3bb57a82672;
static PyCodeObject *codeobj_ea6084817f5b965d979b5cee01c6a4de;
static PyCodeObject *codeobj_0b49820045f9b4d8ba0abd98800fe426;
static PyCodeObject *codeobj_d3df4d744514aa4a646eb001b12d4f76;
static PyCodeObject *codeobj_6f66582f1988bb4e6e9266e1fc9a7269;
static PyCodeObject *codeobj_dc54d9f0c2c026b54c7673e3a1deb0c5;
static PyCodeObject *codeobj_75eb440780b1b0ac66e0b2f84e064457;
static PyCodeObject *codeobj_e93d2a5293ec7fe8033f75dceb597261;
static PyCodeObject *codeobj_596a1bb6fd8eea4f8b16844aeb8159ed;
static PyCodeObject *codeobj_1aad631595d6346be68289d6f6c64b22;
static PyCodeObject *codeobj_7654c6e5a4f8ea52a929d8d7178b3bf6;
static PyCodeObject *codeobj_df973e9887ec6e2e08a9939e8b7c75a5;
static PyCodeObject *codeobj_18e27c2685da591014101268dffffba2;
static PyCodeObject *codeobj_dda6c6fc2ad31d4b75bf8ae29a203af2;
static PyCodeObject *codeobj_737c97aa48d786ecb227db57f52a9e87;
static PyCodeObject *codeobj_b29a7a4e6a10a5d2c9fdbd62c0de0ecc;
static PyCodeObject *codeobj_f0cd6618b75f6edee2ef0daadfe71560;
static PyCodeObject *codeobj_413469e92c4e424cdec39269f5c5d5ae;
static PyCodeObject *codeobj_0311dc3f50b2a8f7c24f49e1af94c2b2;
static PyCodeObject *codeobj_ad2ad9fb53912298f58d6ca738392edc;
static PyCodeObject *codeobj_65d4f032c8c5f79bc382c9337a929478;
static PyCodeObject *codeobj_c46af5b2d77cf0b451ac6599684abc48;
static PyCodeObject *codeobj_94734671575e56910016a914e03510a9;
static PyCodeObject *codeobj_8a6dd9706c10f994c6de2227774ada4a;
static PyCodeObject *codeobj_36b3d12f9a457ad2a3e9ae488c75f2bc;
static PyCodeObject *codeobj_970832abd8d359a2679a1bab059e0b97;
static PyCodeObject *codeobj_fcfca8aede2e0b4a92a0f5ee107de9e7;
static PyCodeObject *codeobj_d1da03d8bcb10c9f5aed4a9294699f4f;
static PyCodeObject *codeobj_ddd75748bd61bcf23a75d38c2797002f;
static PyCodeObject *codeobj_a7f578fb789af89c76c3dfd82e67226f;
static PyCodeObject *codeobj_360248c43c527dc9e1429c3c2d08eeee;
static PyCodeObject *codeobj_fc00721a4ae8a87da2a5540240c9b0aa;
static PyCodeObject *codeobj_5cbb78624ee9adc6c7063694ecaa2d72;
static PyCodeObject *codeobj_97446d6c273ab6be83f8d8c8d7870fcd;
static PyCodeObject *codeobj_5aa04e625a24c00a60c719e5a7b846fb;
static PyCodeObject *codeobj_84a94085338dd777dbd28747a2105f2f;
static PyCodeObject *codeobj_11c54a3e55595eff4de75e4e8a1668d7;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_7b113117fd237deaef422d3a4d7e9c32;
    codeobj_ce72348006636f3b1d48f63be6336e5c = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 960, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f8d619e8fb32ffd66203c9c2939bf1f6 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 967, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c721fc79d077c2b14e42177a06329c85 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 974, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6c12b512b3dea76e9c7dc2e486b61d7f = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 981, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4bebe3e14b9a7aa974a75088fa55838c = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 988, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e247755bd74b0ae1ce03487b4067d9e8 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 995, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c58a6b313fcc56d855cb1583debb45f4 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_d78eaf819b148cd0ed4de8a87366220a, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_ff896619f018e5169268dd4e6352a0fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__splitShellPattern, 954, const_tuple_str_plain_value_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e9568ec9f2372518858530f1e368f07b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assumeYesForDownloads, 1008, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8a85772fc9aa4c76d07fffd99c28d26 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getExperimentalIndications, 1121, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_272528bf4636d442d00d6a18b95d85dd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getFileReferenceMode, 919, const_tuple_str_plain_value_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d78116b19c5a705c69847ce6f0f0a6e8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIconPath, 1136, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_54b9c0307687c886454ab94ba1aa079b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIntendedPythonArch, 1111, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_af19baa1ab5af3e1fba732aad9b40a5d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getIntendedPythonVersion, 1107, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eb11be53fb77c76d2826cff4d9c08247 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getJobLimit, 1063, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be0d106c45d34e95877f4996ec8d75b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getMainArgs, 1047, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2b41d17ce2ce901c30b6d180b922e6cc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getMsvcVersion, 1079, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d0e72dd5176d8fb44a2a894177240eee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getMustIncludeModules, 986, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a521c517b8991aad61def47b5f4d695b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getMustIncludePackages, 993, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c00d3fc69c4374d1325ec84fe1aec136 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getOutputDir, 1039, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_39ca76230b1066f515fe4ccee38cb42b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getOutputPath, 1032, const_tuple_str_plain_path_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_491df70ab21e3f1d09686b30ddc39c24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPluginOptions, 1198, const_tuple_ab09b1dca54a534ab2124f7c6db19294_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_884b504793f584ec870f8bcbada6556a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPluginsDisabled, 1217, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2a53c9c37badde19d78b2a36fe3875dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPluginsEnabled, 1185, const_tuple_str_plain_result_str_plain_plugin_enabled_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aaff8348fa4ec25d845604fa01fc5e66 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPositionalArgs, 1043, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_16065475bb34579370f7f78a96f24fa6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPythonFlags, 1141, const_tuple_str_plain_parts_str_plain_part_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4bd96c049702e1671d294217f1aa0e22 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getPythonPathForScons, 1231, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95ca596c1c70767c7c1e62f9209438e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getShallFollowExtra, 972, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6d1b960b567971407ddf22e61c4cf1fe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getShallFollowExtraFilePatterns, 979, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1e83e4d70cf7aacbd8c100d6e42e6b9a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getShallFollowInNoCase, 958, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_505945e7d1254f4132a1d5ce2a8071d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getShallFollowModules, 965, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_740beeaa8324802bf1747ce98c5bbb53 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isAllowedToReexecute, 938, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f0e6a95e1ce7d0b91dae6b7e68c291b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isClang, 1071, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5cb9696cdcff5fe60bf2c0d942196107 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isDebug, 1012, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ff82744b35918d18314beabdf85850e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isExperimental, 1115, const_tuple_str_plain_indication_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_167b79dc77d0a1f9967239702a9b1a97 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isFullCompat, 1087, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8672f7cad8c8767f00958a426d497654 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isLto, 1067, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_31849ef404ecd5ac3889e3bb57a82672 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isMingw, 1075, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ea6084817f5b965d979b5cee01c6a4de = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isProfile, 1024, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0b49820045f9b4d8ba0abd98800fe426 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isPythonDebug, 1016, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d3df4d744514aa4a646eb001b12d4f76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isRemoveBuildDir, 1103, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f66582f1988bb4e6e9266e1fc9a7269 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isShowInclusion, 1099, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dc54d9f0c2c026b54c7673e3a1deb0c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isShowMemory, 1095, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_75eb440780b1b0ac66e0b2f84e064457 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isShowProgress, 1091, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e93d2a5293ec7fe8033f75dceb597261 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isShowScons, 1059, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_596a1bb6fd8eea4f8b16844aeb8159ed = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isStandaloneMode, 1132, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1aad631595d6346be68289d6f6c64b22 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isUnstripped, 1020, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7654c6e5a4f8ea52a929d8d7178b3bf6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isVerbose, 883, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df973e9887ec6e2e08a9939e8b7c75a5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_parseArgs, 780, const_tuple_b7eabc4c589c577c223f24ec6da53ff5_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_18e27c2685da591014101268dffffba2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallClearPythonPathEnvironment, 1055, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dda6c6fc2ad31d4b75bf8ae29a203af2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallCreateGraph, 1028, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_737c97aa48d786ecb227db57f52a9e87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallCreatePyiFile, 934, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b29a7a4e6a10a5d2c9fdbd62c0de0ecc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallDetectMissingPlugins, 1227, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f0cd6618b75f6edee2ef0daadfe71560 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallDisableConsoleWindow, 1083, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_413469e92c4e424cdec39269f5c5d5ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallDisplayBuiltTree, 903, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0311dc3f50b2a8f7c24f49e1af94c2b2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallDumpBuiltTreeXML, 899, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ad2ad9fb53912298f58d6ca738392edc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallExecuteImmediately, 891, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_65d4f032c8c5f79bc382c9337a929478 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallExplainImports, 1128, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c46af5b2d77cf0b451ac6599684abc48 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallFollowAllImports, 950, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_94734671575e56910016a914e03510a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallFollowNoImports, 946, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a6dd9706c10f994c6de2227774ada4a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallFollowStandardLibrary, 942, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_36b3d12f9a457ad2a3e9ae488c75f2bc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallFreezeAllStdlib, 1169, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_970832abd8d359a2679a1bab059e0b97 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallHaveStatementLines, 915, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fcfca8aede2e0b4a92a0f5ee107de9e7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallListPlugins, 1181, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d1da03d8bcb10c9f5aed4a9294699f4f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallMakeModule, 930, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ddd75748bd61bcf23a75d38c2797002f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallNotDoExecCCompilerCall, 911, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a7f578fb789af89c76c3dfd82e67226f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallNotStoreDependsExeCachedResults, 1177, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_360248c43c527dc9e1429c3c2d08eeee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallNotUseDependsExeCachedResults, 1173, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fc00721a4ae8a87da2a5540240c9b0aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallOnlyExecCCompilerCall, 907, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5cbb78624ee9adc6c7063694ecaa2d72 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallOptimizeStringExec, 1051, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_97446d6c273ab6be83f8d8c8d7870fcd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallRunInDebugger, 895, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5aa04e625a24c00a60c719e5a7b846fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallTraceExecution, 887, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84a94085338dd777dbd28747a2105f2f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallWarnImplicitRaises, 1000, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_11c54a3e55595eff4de75e4e8a1668d7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shallWarnUnusualCode, 1004, const_tuple_empty, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
static PyObject *MAKE_FUNCTION_Options$$$function_10_shallHaveStatementLines(  );


static PyObject *MAKE_FUNCTION_Options$$$function_11_getFileReferenceMode(  );


static PyObject *MAKE_FUNCTION_Options$$$function_12_shallMakeModule(  );


static PyObject *MAKE_FUNCTION_Options$$$function_13_shallCreatePyiFile(  );


static PyObject *MAKE_FUNCTION_Options$$$function_14_isAllowedToReexecute(  );


static PyObject *MAKE_FUNCTION_Options$$$function_15_shallFollowStandardLibrary(  );


static PyObject *MAKE_FUNCTION_Options$$$function_16_shallFollowNoImports(  );


static PyObject *MAKE_FUNCTION_Options$$$function_17_shallFollowAllImports(  );


static PyObject *MAKE_FUNCTION_Options$$$function_18__splitShellPattern(  );


static PyObject *MAKE_FUNCTION_Options$$$function_19_getShallFollowInNoCase(  );


static PyObject *MAKE_FUNCTION_Options$$$function_1_parseArgs(  );


static PyObject *MAKE_FUNCTION_Options$$$function_20_getShallFollowModules(  );


static PyObject *MAKE_FUNCTION_Options$$$function_21_getShallFollowExtra(  );


static PyObject *MAKE_FUNCTION_Options$$$function_22_getShallFollowExtraFilePatterns(  );


static PyObject *MAKE_FUNCTION_Options$$$function_23_getMustIncludeModules(  );


static PyObject *MAKE_FUNCTION_Options$$$function_24_getMustIncludePackages(  );


static PyObject *MAKE_FUNCTION_Options$$$function_25_shallWarnImplicitRaises(  );


static PyObject *MAKE_FUNCTION_Options$$$function_26_shallWarnUnusualCode(  );


static PyObject *MAKE_FUNCTION_Options$$$function_27_assumeYesForDownloads(  );


static PyObject *MAKE_FUNCTION_Options$$$function_28_isDebug(  );


static PyObject *MAKE_FUNCTION_Options$$$function_29_isPythonDebug(  );


static PyObject *MAKE_FUNCTION_Options$$$function_2_isVerbose(  );


static PyObject *MAKE_FUNCTION_Options$$$function_30_isUnstripped(  );


static PyObject *MAKE_FUNCTION_Options$$$function_31_isProfile(  );


static PyObject *MAKE_FUNCTION_Options$$$function_32_shallCreateGraph(  );


static PyObject *MAKE_FUNCTION_Options$$$function_33_getOutputPath(  );


static PyObject *MAKE_FUNCTION_Options$$$function_34_getOutputDir(  );


static PyObject *MAKE_FUNCTION_Options$$$function_35_getPositionalArgs(  );


static PyObject *MAKE_FUNCTION_Options$$$function_36_getMainArgs(  );


static PyObject *MAKE_FUNCTION_Options$$$function_37_shallOptimizeStringExec(  );


static PyObject *MAKE_FUNCTION_Options$$$function_38_shallClearPythonPathEnvironment(  );


static PyObject *MAKE_FUNCTION_Options$$$function_39_isShowScons(  );


static PyObject *MAKE_FUNCTION_Options$$$function_3_shallTraceExecution(  );


static PyObject *MAKE_FUNCTION_Options$$$function_40_getJobLimit(  );


static PyObject *MAKE_FUNCTION_Options$$$function_41_isLto(  );


static PyObject *MAKE_FUNCTION_Options$$$function_42_isClang(  );


static PyObject *MAKE_FUNCTION_Options$$$function_43_isMingw(  );


static PyObject *MAKE_FUNCTION_Options$$$function_44_getMsvcVersion(  );


static PyObject *MAKE_FUNCTION_Options$$$function_45_shallDisableConsoleWindow(  );


static PyObject *MAKE_FUNCTION_Options$$$function_46_isFullCompat(  );


static PyObject *MAKE_FUNCTION_Options$$$function_47_isShowProgress(  );


static PyObject *MAKE_FUNCTION_Options$$$function_48_isShowMemory(  );


static PyObject *MAKE_FUNCTION_Options$$$function_49_isShowInclusion(  );


static PyObject *MAKE_FUNCTION_Options$$$function_4_shallExecuteImmediately(  );


static PyObject *MAKE_FUNCTION_Options$$$function_50_isRemoveBuildDir(  );


static PyObject *MAKE_FUNCTION_Options$$$function_51_getIntendedPythonVersion(  );


static PyObject *MAKE_FUNCTION_Options$$$function_52_getIntendedPythonArch(  );


static PyObject *MAKE_FUNCTION_Options$$$function_53_isExperimental(  );


static PyObject *MAKE_FUNCTION_Options$$$function_54_getExperimentalIndications(  );


static PyObject *MAKE_FUNCTION_Options$$$function_55_shallExplainImports(  );


static PyObject *MAKE_FUNCTION_Options$$$function_56_isStandaloneMode(  );


static PyObject *MAKE_FUNCTION_Options$$$function_57_getIconPath(  );


static PyObject *MAKE_FUNCTION_Options$$$function_58_getPythonFlags(  );


static PyObject *MAKE_FUNCTION_Options$$$function_59_shallFreezeAllStdlib(  );


static PyObject *MAKE_FUNCTION_Options$$$function_5_shallRunInDebugger(  );


static PyObject *MAKE_FUNCTION_Options$$$function_60_shallNotUseDependsExeCachedResults(  );


static PyObject *MAKE_FUNCTION_Options$$$function_61_shallNotStoreDependsExeCachedResults(  );


static PyObject *MAKE_FUNCTION_Options$$$function_62_shallListPlugins(  );


static PyObject *MAKE_FUNCTION_Options$$$function_63_getPluginsEnabled(  );


static PyObject *MAKE_FUNCTION_Options$$$function_64_getPluginOptions(  );


static PyObject *MAKE_FUNCTION_Options$$$function_65_getPluginsDisabled(  );


static PyObject *MAKE_FUNCTION_Options$$$function_66_shallDetectMissingPlugins(  );


static PyObject *MAKE_FUNCTION_Options$$$function_67_getPythonPathForScons(  );


static PyObject *MAKE_FUNCTION_Options$$$function_6_shallDumpBuiltTreeXML(  );


static PyObject *MAKE_FUNCTION_Options$$$function_7_shallDisplayBuiltTree(  );


static PyObject *MAKE_FUNCTION_Options$$$function_8_shallOnlyExecCCompilerCall(  );


static PyObject *MAKE_FUNCTION_Options$$$function_9_shallNotDoExecCCompilerCall(  );


// The module function definitions.
static PyObject *impl_Options$$$function_1_parseArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_count = NULL;
    PyObject *var_arg = NULL;
    PyObject *var_listPlugins = NULL;
    PyObject *var_any_case_module = NULL;
    PyObject *var_bad = NULL;
    PyObject *var_char = NULL;
    PyObject *var_no_case_module = NULL;
    PyObject *var_scons_python = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_for_loop_3__break_indicator = NULL;
    PyObject *tmp_for_loop_3__for_iterator = NULL;
    PyObject *tmp_for_loop_3__iter_value = NULL;
    PyObject *tmp_for_loop_4__for_iterator = NULL;
    PyObject *tmp_for_loop_4__iter_value = NULL;
    PyObject *tmp_for_loop_5__break_indicator = NULL;
    PyObject *tmp_for_loop_5__for_iterator = NULL;
    PyObject *tmp_for_loop_5__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_Gt_1;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    int tmp_cond_truth_10;
    int tmp_cond_truth_11;
    int tmp_cond_truth_12;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_cond_value_10;
    PyObject *tmp_cond_value_11;
    PyObject *tmp_cond_value_12;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    int tmp_exc_match_exception_match_3;
    int tmp_exc_match_exception_match_4;
    int tmp_exc_match_exception_match_5;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iter_arg_4;
    PyObject *tmp_iter_arg_5;
    PyObject *tmp_iter_arg_6;
    PyObject *tmp_iter_arg_7;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_iterator_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_level_name_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_start_name_1;
    PyObject *tmp_start_name_2;
    PyObject *tmp_step_name_1;
    PyObject *tmp_step_name_2;
    PyObject *tmp_stop_name_1;
    PyObject *tmp_stop_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_unpack_3;
    PyObject *tmp_unpack_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    PyObject *tmp_value_name_2;
    PyObject *tmp_value_name_3;
    PyObject *tmp_value_name_4;
    PyObject *tmp_value_name_5;
    static struct Nuitka_FrameObject *cache_frame_df973e9887ec6e2e08a9939e8b7c75a5 = NULL;

    struct Nuitka_FrameObject *frame_df973e9887ec6e2e08a9939e8b7c75a5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df973e9887ec6e2e08a9939e8b7c75a5, codeobj_df973e9887ec6e2e08a9939e8b7c75a5, module_Options, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_df973e9887ec6e2e08a9939e8b7c75a5 = cache_frame_df973e9887ec6e2e08a9939e8b7c75a5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df973e9887ec6e2e08a9939e8b7c75a5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df973e9887ec6e2e08a9939e8b7c75a5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "is_nuitka_run" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 785;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = const_int_0;
    assert( var_count == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_count = tmp_assign_source_1;

    tmp_called_name_1 = (PyObject *)&PyEnum_Type;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_argv );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 788;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 788;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    // Tried code:
    tmp_iter_arg_2 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 788;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 788;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooooo";
                exception_lineno = 788;
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "oooooooo";
        exception_lineno = 788;
        goto try_except_handler_5;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_7 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_count;
        var_count = tmp_assign_source_7;
        Py_INCREF( var_count );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_8 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_arg;
        var_arg = tmp_assign_source_8;
        Py_INCREF( var_arg );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_2 = var_count;

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 789;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = const_int_0;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 789;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    goto loop_start_1;
    branch_no_3:;
    tmp_subscribed_name_1 = var_arg;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arg" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 792;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_subscript_name_1 = const_int_0;
    tmp_compare_left_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_3 = const_str_chr_45;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_3, tmp_compare_right_3 );
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    goto loop_end_1;
    branch_no_4:;
    tmp_compare_left_4 = var_arg;

    if ( tmp_compare_left_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arg" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 796;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_4 = const_str_digest_85fe97af08c9a213aa891dc673aeaa3e;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 796;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_left_name_1 = var_count;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 797;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_1 = const_int_pos_1;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_9 = tmp_left_name_1;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 797;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    var_count = tmp_assign_source_9;

    goto loop_end_1;
    branch_no_5:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 788;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_compare_left_5 = var_count;

    if ( tmp_compare_left_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_5 = const_int_0;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 800;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_argv );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = var_count;

    if ( tmp_left_name_2 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_2 = const_int_pos_1;
    tmp_start_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_start_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_subscribed_name_2 );

        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_stop_name_1 = Py_None;
    tmp_step_name_1 = Py_None;
    tmp_subscript_name_2 = MAKE_SLICEOBJ3( tmp_start_name_1, tmp_stop_name_1, tmp_step_name_1 );
    Py_DECREF( tmp_start_name_1 );
    assert( !(tmp_subscript_name_2 == NULL) );
    tmp_assign_source_10 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    Py_DECREF( tmp_subscript_name_2 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_extra_args, tmp_assign_source_10 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_argv );
    if ( tmp_subscribed_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_start_name_2 = const_int_0;
    tmp_left_name_3 = var_count;

    if ( tmp_left_name_3 == NULL )
    {
        Py_DECREF( tmp_subscribed_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "count" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_3 = const_int_pos_1;
    tmp_stop_name_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_3 );
    if ( tmp_stop_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_subscribed_name_3 );

        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_step_name_2 = Py_None;
    tmp_subscript_name_3 = MAKE_SLICEOBJ3( tmp_start_name_2, tmp_stop_name_2, tmp_step_name_2 );
    Py_DECREF( tmp_stop_name_2 );
    assert( !(tmp_subscript_name_3 == NULL) );
    tmp_assattr_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    Py_DECREF( tmp_subscribed_name_3 );
    Py_DECREF( tmp_subscript_name_3 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_assattr_target_1 == NULL ))
    {
        tmp_assattr_target_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_argv, tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_6:;
    branch_no_1:;
    // Tried code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 804;
        type_description_1 = "oooooooo";
        goto try_except_handler_6;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 804;
    tmp_iter_arg_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_parse_args );
    if ( tmp_iter_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description_1 = "oooooooo";
        goto try_except_handler_6;
    }
    tmp_assign_source_11 = MAKE_ITERATOR( tmp_iter_arg_3 );
    Py_DECREF( tmp_iter_arg_3 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description_1 = "oooooooo";
        goto try_except_handler_6;
    }
    assert( tmp_tuple_unpack_2__source_iter == NULL );
    tmp_tuple_unpack_2__source_iter = tmp_assign_source_11;

    // Tried code:
    tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_unpack_3 );
    tmp_assign_source_12 = UNPACK_NEXT( tmp_unpack_3, 0, 2 );
    if ( tmp_assign_source_12 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 804;
        goto try_except_handler_7;
    }
    assert( tmp_tuple_unpack_2__element_1 == NULL );
    tmp_tuple_unpack_2__element_1 = tmp_assign_source_12;

    tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_unpack_4 );
    tmp_assign_source_13 = UNPACK_NEXT( tmp_unpack_4, 1, 2 );
    if ( tmp_assign_source_13 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 804;
        goto try_except_handler_7;
    }
    assert( tmp_tuple_unpack_2__element_2 == NULL );
    tmp_tuple_unpack_2__element_2 = tmp_assign_source_13;

    tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_iterator_name_2 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooooo";
                exception_lineno = 804;
                goto try_except_handler_7;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "oooooooo";
        exception_lineno = 804;
        goto try_except_handler_7;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_6;
    // End of try:
    try_end_5:;
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    tmp_assign_source_14 = tmp_tuple_unpack_2__element_1;

    CHECK_OBJECT( tmp_assign_source_14 );
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options, tmp_assign_source_14 );
    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    tmp_assign_source_15 = tmp_tuple_unpack_2__element_2;

    CHECK_OBJECT( tmp_assign_source_15 );
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_positional_args, tmp_assign_source_15 );
    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallListPlugins );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_shallListPlugins );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "shallListPlugins" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 806;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 806;
    tmp_cond_value_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 806;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 806;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_name_name_1 = const_str_digest_ebf31cb8a295537cdd204a85dd2b13f2;
    tmp_globals_name_1 = (PyObject *)moduledict_Options;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_listPlugins_tuple;
    tmp_level_name_1 = const_int_0;
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 807;
    tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 807;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_listPlugins );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 807;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_listPlugins == NULL );
    var_listPlugins = tmp_assign_source_16;

    tmp_called_name_3 = var_listPlugins;

    CHECK_OBJECT( tmp_called_name_3 );
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 808;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 808;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_7:;
    tmp_cond_value_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_positional_args );

    if (unlikely( tmp_cond_value_3 == NULL ))
    {
        tmp_cond_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_positional_args );
    }

    if ( tmp_cond_value_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "positional_args" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 810;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 811;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 811;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_print_help );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 813;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 813;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_exit, &PyTuple_GET_ITEM( const_tuple_str_digest_76a20e0434f49c589f5f87e961db8fd3_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 813;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_8:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_immediate_execution );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_len_arg_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_positional_args );

    if (unlikely( tmp_len_arg_1 == NULL ))
    {
        tmp_len_arg_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_positional_args );
    }

    if ( tmp_len_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "positional_args" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_and_right_value_1 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_4 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_cond_value_4 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 816;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 817;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_print_help );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 819;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 819;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_exit, &PyTuple_GET_ITEM( const_tuple_str_digest_f13acabca636d4d483b3d53e84c3d766_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_9:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 823;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_verbose );
    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 823;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 824;
    tmp_source_name_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getLogger );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_setLevel );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_DEBUG );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 824;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_10;
    branch_no_10:;
    tmp_called_instance_7 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_called_instance_7 == NULL ))
    {
        tmp_called_instance_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 826;
    tmp_source_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getLogger );
    if ( tmp_source_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_setLevel );
    Py_DECREF( tmp_source_name_8 );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_INFO );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 826;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_10:;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 831;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_6 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_is_standalone );
    if ( tmp_cond_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 831;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 832;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_7 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_executable );
    if ( tmp_cond_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 832;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_no_12;
    }
    else
    {
        goto branch_yes_12;
    }
    branch_yes_12:;
    tmp_called_instance_8 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_called_instance_8 == NULL ))
    {
        tmp_called_instance_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 833;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 833;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_exit, &PyTuple_GET_ITEM( const_tuple_str_digest_9556b4546b4577c6523da3578179b9b4_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 833;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_12:;
    tmp_assattr_name_2 = Py_True;
    tmp_assattr_target_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_assattr_target_2 == NULL ))
    {
        tmp_assattr_target_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_assattr_target_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 836;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_recurse_all, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 836;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_Utils );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Utils );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Utils" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 838;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 838;
    tmp_compare_left_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_getOS );
    if ( tmp_compare_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 838;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_6 = const_str_plain_NetBSD;
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    Py_DECREF( tmp_compare_left_6 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 838;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_called_instance_10 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_called_instance_10 == NULL ))
    {
        tmp_called_instance_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_called_instance_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 839;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 839;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_warning, &PyTuple_GET_ITEM( const_tuple_str_digest_ca95b6fd7bd310521598a1589c336a8c_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 839;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    branch_no_11:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowModules );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getShallFollowModules );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getShallFollowModules" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 841;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 841;
    tmp_iter_arg_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    if ( tmp_iter_arg_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 841;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_17 = MAKE_ITERATOR( tmp_iter_arg_4 );
    Py_DECREF( tmp_iter_arg_4 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 841;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_2__for_iterator == NULL );
    tmp_for_loop_2__for_iterator = tmp_assign_source_17;

    // Tried code:
    loop_start_2:;
    // Tried code:
    tmp_value_name_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_value_name_2 );
    tmp_assign_source_18 = ITERATOR_NEXT( tmp_value_name_2 );
    if ( tmp_assign_source_18 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 841;
        goto try_except_handler_9;
    }
    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_18;
        Py_XDECREF( old );
    }

    goto try_end_7;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_7 = exception_keeper_type_7;
    tmp_compare_right_7 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_7 );
        Py_XDECREF( exception_keeper_value_7 );
        Py_XDECREF( exception_keeper_tb_7 );

        exception_lineno = 841;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_14;
    }
    else
    {
        goto branch_no_14;
    }
    branch_yes_14:;
    Py_DECREF( exception_keeper_type_7 );
    Py_XDECREF( exception_keeper_value_7 );
    Py_XDECREF( exception_keeper_tb_7 );
    goto loop_end_2;
    goto branch_end_14;
    branch_no_14:;
    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto try_except_handler_8;
    branch_end_14:;
    // End of try:
    try_end_7:;
    tmp_assign_source_19 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_19 );
    {
        PyObject *old = var_any_case_module;
        var_any_case_module = tmp_assign_source_19;
        Py_INCREF( var_any_case_module );
        Py_XDECREF( old );
    }

    tmp_called_instance_11 = var_any_case_module;

    CHECK_OBJECT( tmp_called_instance_11 );
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 842;
    tmp_cond_value_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_11, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

    if ( tmp_cond_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 842;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_8 );

        exception_lineno = 842;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    Py_DECREF( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_15;
    }
    else
    {
        goto branch_no_15;
    }
    branch_yes_15:;
    tmp_assign_source_20 = Py_True;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_20;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    goto branch_end_15;
    branch_no_15:;
    tmp_assign_source_21 = Py_False;
    {
        PyObject *old = tmp_for_loop_3__break_indicator;
        tmp_for_loop_3__break_indicator = tmp_assign_source_21;
        Py_INCREF( tmp_for_loop_3__break_indicator );
        Py_XDECREF( old );
    }

    tmp_iter_arg_5 = const_str_digest_23e2e20ef56f951794853554a3a508d6;
    tmp_assign_source_22 = MAKE_ITERATOR( tmp_iter_arg_5 );
    assert( !(tmp_assign_source_22 == NULL) );
    {
        PyObject *old = tmp_for_loop_3__for_iterator;
        tmp_for_loop_3__for_iterator = tmp_assign_source_22;
        Py_XDECREF( old );
    }

    // Tried code:
    // Tried code:
    loop_start_3:;
    // Tried code:
    tmp_value_name_3 = tmp_for_loop_3__for_iterator;

    CHECK_OBJECT( tmp_value_name_3 );
    tmp_assign_source_23 = ITERATOR_NEXT( tmp_value_name_3 );
    if ( tmp_assign_source_23 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 845;
        goto try_except_handler_12;
    }
    {
        PyObject *old = tmp_for_loop_3__iter_value;
        tmp_for_loop_3__iter_value = tmp_assign_source_23;
        Py_XDECREF( old );
    }

    goto try_end_8;
    // Exception handler code:
    try_except_handler_12:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_8 = exception_keeper_type_8;
    tmp_compare_right_8 = PyExc_StopIteration;
    tmp_exc_match_exception_match_3 = EXCEPTION_MATCH_BOOL( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_exc_match_exception_match_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_8 );
        Py_XDECREF( exception_keeper_value_8 );
        Py_XDECREF( exception_keeper_tb_8 );

        exception_lineno = 845;
        type_description_1 = "oooooooo";
        goto try_except_handler_11;
    }
    if ( tmp_exc_match_exception_match_3 == 1 )
    {
        goto branch_yes_16;
    }
    else
    {
        goto branch_no_16;
    }
    branch_yes_16:;
    tmp_assign_source_24 = Py_True;
    {
        PyObject *old = tmp_for_loop_3__break_indicator;
        assert( old != NULL );
        tmp_for_loop_3__break_indicator = tmp_assign_source_24;
        Py_INCREF( tmp_for_loop_3__break_indicator );
        Py_DECREF( old );
    }

    Py_DECREF( exception_keeper_type_8 );
    Py_XDECREF( exception_keeper_value_8 );
    Py_XDECREF( exception_keeper_tb_8 );
    goto loop_end_3;
    goto branch_end_16;
    branch_no_16:;
    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto try_except_handler_11;
    branch_end_16:;
    // End of try:
    try_end_8:;
    tmp_assign_source_25 = tmp_for_loop_3__iter_value;

    CHECK_OBJECT( tmp_assign_source_25 );
    {
        PyObject *old = var_char;
        var_char = tmp_assign_source_25;
        Py_INCREF( var_char );
        Py_XDECREF( old );
    }

    tmp_compare_left_9 = var_char;

    CHECK_OBJECT( tmp_compare_left_9 );
    tmp_compare_right_9 = var_any_case_module;

    if ( tmp_compare_right_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "any_case_module" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 846;
        type_description_1 = "oooooooo";
        goto try_except_handler_11;
    }

    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_9, tmp_compare_left_9 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_17;
    }
    else
    {
        goto branch_no_17;
    }
    branch_yes_17:;
    tmp_assign_source_26 = Py_True;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_26;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    goto loop_end_3;
    branch_no_17:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 845;
        type_description_1 = "oooooooo";
        goto try_except_handler_11;
    }
    goto loop_start_3;
    loop_end_3:;
    goto try_end_9;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_3__iter_value );
    tmp_for_loop_3__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
    Py_DECREF( tmp_for_loop_3__for_iterator );
    tmp_for_loop_3__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto try_except_handler_10;
    // End of try:
    try_end_9:;
    goto try_end_10;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_3__break_indicator );
    tmp_for_loop_3__break_indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto try_except_handler_8;
    // End of try:
    try_end_10:;
    Py_XDECREF( tmp_for_loop_3__iter_value );
    tmp_for_loop_3__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
    Py_DECREF( tmp_for_loop_3__for_iterator );
    tmp_for_loop_3__for_iterator = NULL;

    tmp_compare_left_10 = tmp_for_loop_3__break_indicator;

    CHECK_OBJECT( tmp_compare_left_10 );
    tmp_compare_right_10 = Py_True;
    tmp_is_1 = ( tmp_compare_left_10 == tmp_compare_right_10 );
    if ( tmp_is_1 )
    {
        goto branch_yes_18;
    }
    else
    {
        goto branch_no_18;
    }
    branch_yes_18:;
    tmp_assign_source_27 = Py_False;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_27;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    branch_no_18:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_3__break_indicator );
    Py_DECREF( tmp_for_loop_3__break_indicator );
    tmp_for_loop_3__break_indicator = NULL;

    branch_end_15:;
    tmp_cond_value_9 = var_bad;

    if ( tmp_cond_value_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "bad" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 852;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }

    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_yes_19;
    }
    else
    {
        goto branch_no_19;
    }
    branch_yes_19:;
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 853;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_exit );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    tmp_left_name_4 = const_str_digest_3493e1419f00062da30c5054eace3ba0;
    tmp_right_name_4 = var_any_case_module;

    if ( tmp_right_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "any_case_module" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 856;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }

    tmp_args_element_name_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 855;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 853;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 853;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    Py_DECREF( tmp_unused );
    branch_no_19:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 841;
        type_description_1 = "oooooooo";
        goto try_except_handler_8;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_11;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowInNoCase );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getShallFollowInNoCase );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getShallFollowInNoCase" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 859;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 859;
    tmp_iter_arg_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    if ( tmp_iter_arg_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 859;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_28 = MAKE_ITERATOR( tmp_iter_arg_6 );
    Py_DECREF( tmp_iter_arg_6 );
    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 859;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_4__for_iterator == NULL );
    tmp_for_loop_4__for_iterator = tmp_assign_source_28;

    // Tried code:
    loop_start_4:;
    // Tried code:
    tmp_value_name_4 = tmp_for_loop_4__for_iterator;

    CHECK_OBJECT( tmp_value_name_4 );
    tmp_assign_source_29 = ITERATOR_NEXT( tmp_value_name_4 );
    if ( tmp_assign_source_29 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 859;
        goto try_except_handler_14;
    }
    {
        PyObject *old = tmp_for_loop_4__iter_value;
        tmp_for_loop_4__iter_value = tmp_assign_source_29;
        Py_XDECREF( old );
    }

    goto try_end_12;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_11 = exception_keeper_type_12;
    tmp_compare_right_11 = PyExc_StopIteration;
    tmp_exc_match_exception_match_4 = EXCEPTION_MATCH_BOOL( tmp_compare_left_11, tmp_compare_right_11 );
    if ( tmp_exc_match_exception_match_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_12 );
        Py_XDECREF( exception_keeper_value_12 );
        Py_XDECREF( exception_keeper_tb_12 );

        exception_lineno = 859;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    if ( tmp_exc_match_exception_match_4 == 1 )
    {
        goto branch_yes_20;
    }
    else
    {
        goto branch_no_20;
    }
    branch_yes_20:;
    Py_DECREF( exception_keeper_type_12 );
    Py_XDECREF( exception_keeper_value_12 );
    Py_XDECREF( exception_keeper_tb_12 );
    goto loop_end_4;
    goto branch_end_20;
    branch_no_20:;
    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto try_except_handler_13;
    branch_end_20:;
    // End of try:
    try_end_12:;
    tmp_assign_source_30 = tmp_for_loop_4__iter_value;

    CHECK_OBJECT( tmp_assign_source_30 );
    {
        PyObject *old = var_no_case_module;
        var_no_case_module = tmp_assign_source_30;
        Py_INCREF( var_no_case_module );
        Py_XDECREF( old );
    }

    tmp_called_instance_12 = var_no_case_module;

    CHECK_OBJECT( tmp_called_instance_12 );
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 860;
    tmp_cond_value_10 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_12, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

    if ( tmp_cond_value_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    tmp_cond_truth_10 = CHECK_IF_TRUE( tmp_cond_value_10 );
    if ( tmp_cond_truth_10 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_10 );

        exception_lineno = 860;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    Py_DECREF( tmp_cond_value_10 );
    if ( tmp_cond_truth_10 == 1 )
    {
        goto branch_yes_21;
    }
    else
    {
        goto branch_no_21;
    }
    branch_yes_21:;
    tmp_assign_source_31 = Py_True;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_31;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    goto branch_end_21;
    branch_no_21:;
    tmp_assign_source_32 = Py_False;
    {
        PyObject *old = tmp_for_loop_5__break_indicator;
        tmp_for_loop_5__break_indicator = tmp_assign_source_32;
        Py_INCREF( tmp_for_loop_5__break_indicator );
        Py_XDECREF( old );
    }

    tmp_iter_arg_7 = const_str_digest_23e2e20ef56f951794853554a3a508d6;
    tmp_assign_source_33 = MAKE_ITERATOR( tmp_iter_arg_7 );
    assert( !(tmp_assign_source_33 == NULL) );
    {
        PyObject *old = tmp_for_loop_5__for_iterator;
        tmp_for_loop_5__for_iterator = tmp_assign_source_33;
        Py_XDECREF( old );
    }

    // Tried code:
    // Tried code:
    loop_start_5:;
    // Tried code:
    tmp_value_name_5 = tmp_for_loop_5__for_iterator;

    CHECK_OBJECT( tmp_value_name_5 );
    tmp_assign_source_34 = ITERATOR_NEXT( tmp_value_name_5 );
    if ( tmp_assign_source_34 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oooooooo";
        exception_lineno = 863;
        goto try_except_handler_17;
    }
    {
        PyObject *old = tmp_for_loop_5__iter_value;
        tmp_for_loop_5__iter_value = tmp_assign_source_34;
        Py_XDECREF( old );
    }

    goto try_end_13;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_12 = exception_keeper_type_13;
    tmp_compare_right_12 = PyExc_StopIteration;
    tmp_exc_match_exception_match_5 = EXCEPTION_MATCH_BOOL( tmp_compare_left_12, tmp_compare_right_12 );
    if ( tmp_exc_match_exception_match_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_13 );
        Py_XDECREF( exception_keeper_value_13 );
        Py_XDECREF( exception_keeper_tb_13 );

        exception_lineno = 863;
        type_description_1 = "oooooooo";
        goto try_except_handler_16;
    }
    if ( tmp_exc_match_exception_match_5 == 1 )
    {
        goto branch_yes_22;
    }
    else
    {
        goto branch_no_22;
    }
    branch_yes_22:;
    tmp_assign_source_35 = Py_True;
    {
        PyObject *old = tmp_for_loop_5__break_indicator;
        assert( old != NULL );
        tmp_for_loop_5__break_indicator = tmp_assign_source_35;
        Py_INCREF( tmp_for_loop_5__break_indicator );
        Py_DECREF( old );
    }

    Py_DECREF( exception_keeper_type_13 );
    Py_XDECREF( exception_keeper_value_13 );
    Py_XDECREF( exception_keeper_tb_13 );
    goto loop_end_5;
    goto branch_end_22;
    branch_no_22:;
    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto try_except_handler_16;
    branch_end_22:;
    // End of try:
    try_end_13:;
    tmp_assign_source_36 = tmp_for_loop_5__iter_value;

    CHECK_OBJECT( tmp_assign_source_36 );
    {
        PyObject *old = var_char;
        var_char = tmp_assign_source_36;
        Py_INCREF( var_char );
        Py_XDECREF( old );
    }

    tmp_compare_left_13 = var_char;

    CHECK_OBJECT( tmp_compare_left_13 );
    tmp_compare_right_13 = var_no_case_module;

    if ( tmp_compare_right_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "no_case_module" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 864;
        type_description_1 = "oooooooo";
        goto try_except_handler_16;
    }

    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_13, tmp_compare_left_13 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto branch_yes_23;
    }
    else
    {
        goto branch_no_23;
    }
    branch_yes_23:;
    tmp_assign_source_37 = Py_True;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_37;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    goto loop_end_5;
    branch_no_23:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 863;
        type_description_1 = "oooooooo";
        goto try_except_handler_16;
    }
    goto loop_start_5;
    loop_end_5:;
    goto try_end_14;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_5__iter_value );
    tmp_for_loop_5__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_5__for_iterator );
    Py_DECREF( tmp_for_loop_5__for_iterator );
    tmp_for_loop_5__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto try_except_handler_15;
    // End of try:
    try_end_14:;
    goto try_end_15;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_5__break_indicator );
    tmp_for_loop_5__break_indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto try_except_handler_13;
    // End of try:
    try_end_15:;
    Py_XDECREF( tmp_for_loop_5__iter_value );
    tmp_for_loop_5__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_5__for_iterator );
    Py_DECREF( tmp_for_loop_5__for_iterator );
    tmp_for_loop_5__for_iterator = NULL;

    tmp_compare_left_14 = tmp_for_loop_5__break_indicator;

    CHECK_OBJECT( tmp_compare_left_14 );
    tmp_compare_right_14 = Py_True;
    tmp_is_2 = ( tmp_compare_left_14 == tmp_compare_right_14 );
    if ( tmp_is_2 )
    {
        goto branch_yes_24;
    }
    else
    {
        goto branch_no_24;
    }
    branch_yes_24:;
    tmp_assign_source_38 = Py_False;
    {
        PyObject *old = var_bad;
        var_bad = tmp_assign_source_38;
        Py_INCREF( var_bad );
        Py_XDECREF( old );
    }

    branch_no_24:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_5__break_indicator );
    Py_DECREF( tmp_for_loop_5__break_indicator );
    tmp_for_loop_5__break_indicator = NULL;

    branch_end_21:;
    tmp_cond_value_11 = var_bad;

    if ( tmp_cond_value_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "bad" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 870;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }

    tmp_cond_truth_11 = CHECK_IF_TRUE( tmp_cond_value_11 );
    if ( tmp_cond_truth_11 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 870;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    if ( tmp_cond_truth_11 == 1 )
    {
        goto branch_yes_25;
    }
    else
    {
        goto branch_no_25;
    }
    branch_yes_25:;
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 871;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_exit );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 871;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    tmp_left_name_5 = const_str_digest_b22b6a8fbe4f1eb24d47c1182e8594be;
    tmp_right_name_5 = var_no_case_module;

    if ( tmp_right_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "no_case_module" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 874;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }

    tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 873;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 871;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 871;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    Py_DECREF( tmp_unused );
    branch_no_25:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 859;
        type_description_1 = "oooooooo";
        goto try_except_handler_13;
    }
    goto loop_start_4;
    loop_end_4:;
    goto try_end_16;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_4__iter_value );
    tmp_for_loop_4__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_4__for_iterator );
    Py_DECREF( tmp_for_loop_4__for_iterator );
    tmp_for_loop_4__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    Py_XDECREF( tmp_for_loop_4__iter_value );
    tmp_for_loop_4__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_4__for_iterator );
    Py_DECREF( tmp_for_loop_4__for_iterator );
    tmp_for_loop_4__for_iterator = NULL;

    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPythonPathForScons );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getPythonPathForScons );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getPythonPathForScons" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 877;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 877;
    tmp_assign_source_39 = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scons_python == NULL );
    var_scons_python = tmp_assign_source_39;

    tmp_compexpr_left_2 = var_scons_python;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_left_value_2 = BOOL_FROM( tmp_compexpr_left_2 != tmp_compexpr_right_2 );
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    assert( !(tmp_and_left_truth_2 == -1) );
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_path );
    if ( tmp_source_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_exists );
    Py_DECREF( tmp_source_name_14 );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_scons_python;

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "scons_python" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 879;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    if ( tmp_operand_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_2 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_2 );
    Py_DECREF( tmp_operand_name_2 );
    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_12 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_12 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_12 = CHECK_IF_TRUE( tmp_cond_value_12 );
    if ( tmp_cond_truth_12 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_12 == 1 )
    {
        goto branch_yes_26;
    }
    else
    {
        goto branch_no_26;
    }
    branch_yes_26:;
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 880;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_exit );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 880;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_6 = const_str_digest_2af64c3ed3ff95fc82dfce1598612dc1;
    tmp_right_name_6 = var_scons_python;

    if ( tmp_right_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_12 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "scons_python" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 880;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_12 );

        exception_lineno = 880;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame.f_lineno = 880;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 880;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_26:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df973e9887ec6e2e08a9939e8b7c75a5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df973e9887ec6e2e08a9939e8b7c75a5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df973e9887ec6e2e08a9939e8b7c75a5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df973e9887ec6e2e08a9939e8b7c75a5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df973e9887ec6e2e08a9939e8b7c75a5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df973e9887ec6e2e08a9939e8b7c75a5,
        type_description_1,
        var_count,
        var_arg,
        var_listPlugins,
        var_any_case_module,
        var_bad,
        var_char,
        var_no_case_module,
        var_scons_python
    );


    // Release cached frame.
    if ( frame_df973e9887ec6e2e08a9939e8b7c75a5 == cache_frame_df973e9887ec6e2e08a9939e8b7c75a5 )
    {
        Py_DECREF( frame_df973e9887ec6e2e08a9939e8b7c75a5 );
    }
    cache_frame_df973e9887ec6e2e08a9939e8b7c75a5 = NULL;

    assertFrameObject( frame_df973e9887ec6e2e08a9939e8b7c75a5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_1_parseArgs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_listPlugins );
    var_listPlugins = NULL;

    Py_XDECREF( var_any_case_module );
    var_any_case_module = NULL;

    Py_XDECREF( var_bad );
    var_bad = NULL;

    Py_XDECREF( var_char );
    var_char = NULL;

    Py_XDECREF( var_no_case_module );
    var_no_case_module = NULL;

    Py_XDECREF( var_scons_python );
    var_scons_python = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    Py_XDECREF( var_listPlugins );
    var_listPlugins = NULL;

    Py_XDECREF( var_any_case_module );
    var_any_case_module = NULL;

    Py_XDECREF( var_bad );
    var_bad = NULL;

    Py_XDECREF( var_char );
    var_char = NULL;

    Py_XDECREF( var_no_case_module );
    var_no_case_module = NULL;

    Py_XDECREF( var_scons_python );
    var_scons_python = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_1_parseArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_2_isVerbose( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_7654c6e5a4f8ea52a929d8d7178b3bf6 = NULL;

    struct Nuitka_FrameObject *frame_7654c6e5a4f8ea52a929d8d7178b3bf6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_7654c6e5a4f8ea52a929d8d7178b3bf6, codeobj_7654c6e5a4f8ea52a929d8d7178b3bf6, module_Options, 0 );
    frame_7654c6e5a4f8ea52a929d8d7178b3bf6 = cache_frame_7654c6e5a4f8ea52a929d8d7178b3bf6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 884;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verbose );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 884;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7654c6e5a4f8ea52a929d8d7178b3bf6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7654c6e5a4f8ea52a929d8d7178b3bf6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7654c6e5a4f8ea52a929d8d7178b3bf6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7654c6e5a4f8ea52a929d8d7178b3bf6,
        type_description_1
    );


    // Release cached frame.
    if ( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 == cache_frame_7654c6e5a4f8ea52a929d8d7178b3bf6 )
    {
        Py_DECREF( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );
    }
    cache_frame_7654c6e5a4f8ea52a929d8d7178b3bf6 = NULL;

    assertFrameObject( frame_7654c6e5a4f8ea52a929d8d7178b3bf6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_2_isVerbose );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_3_shallTraceExecution( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_5aa04e625a24c00a60c719e5a7b846fb = NULL;

    struct Nuitka_FrameObject *frame_5aa04e625a24c00a60c719e5a7b846fb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_5aa04e625a24c00a60c719e5a7b846fb, codeobj_5aa04e625a24c00a60c719e5a7b846fb, module_Options, 0 );
    frame_5aa04e625a24c00a60c719e5a7b846fb = cache_frame_5aa04e625a24c00a60c719e5a7b846fb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5aa04e625a24c00a60c719e5a7b846fb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5aa04e625a24c00a60c719e5a7b846fb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 888;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_trace_execution );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 888;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5aa04e625a24c00a60c719e5a7b846fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5aa04e625a24c00a60c719e5a7b846fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5aa04e625a24c00a60c719e5a7b846fb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5aa04e625a24c00a60c719e5a7b846fb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5aa04e625a24c00a60c719e5a7b846fb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5aa04e625a24c00a60c719e5a7b846fb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5aa04e625a24c00a60c719e5a7b846fb,
        type_description_1
    );


    // Release cached frame.
    if ( frame_5aa04e625a24c00a60c719e5a7b846fb == cache_frame_5aa04e625a24c00a60c719e5a7b846fb )
    {
        Py_DECREF( frame_5aa04e625a24c00a60c719e5a7b846fb );
    }
    cache_frame_5aa04e625a24c00a60c719e5a7b846fb = NULL;

    assertFrameObject( frame_5aa04e625a24c00a60c719e5a7b846fb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_3_shallTraceExecution );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_4_shallExecuteImmediately( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ad2ad9fb53912298f58d6ca738392edc = NULL;

    struct Nuitka_FrameObject *frame_ad2ad9fb53912298f58d6ca738392edc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_ad2ad9fb53912298f58d6ca738392edc, codeobj_ad2ad9fb53912298f58d6ca738392edc, module_Options, 0 );
    frame_ad2ad9fb53912298f58d6ca738392edc = cache_frame_ad2ad9fb53912298f58d6ca738392edc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ad2ad9fb53912298f58d6ca738392edc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ad2ad9fb53912298f58d6ca738392edc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 892;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_immediate_execution );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 892;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad2ad9fb53912298f58d6ca738392edc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad2ad9fb53912298f58d6ca738392edc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad2ad9fb53912298f58d6ca738392edc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ad2ad9fb53912298f58d6ca738392edc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ad2ad9fb53912298f58d6ca738392edc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ad2ad9fb53912298f58d6ca738392edc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ad2ad9fb53912298f58d6ca738392edc,
        type_description_1
    );


    // Release cached frame.
    if ( frame_ad2ad9fb53912298f58d6ca738392edc == cache_frame_ad2ad9fb53912298f58d6ca738392edc )
    {
        Py_DECREF( frame_ad2ad9fb53912298f58d6ca738392edc );
    }
    cache_frame_ad2ad9fb53912298f58d6ca738392edc = NULL;

    assertFrameObject( frame_ad2ad9fb53912298f58d6ca738392edc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_4_shallExecuteImmediately );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_5_shallRunInDebugger( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_97446d6c273ab6be83f8d8c8d7870fcd = NULL;

    struct Nuitka_FrameObject *frame_97446d6c273ab6be83f8d8c8d7870fcd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_97446d6c273ab6be83f8d8c8d7870fcd, codeobj_97446d6c273ab6be83f8d8c8d7870fcd, module_Options, 0 );
    frame_97446d6c273ab6be83f8d8c8d7870fcd = cache_frame_97446d6c273ab6be83f8d8c8d7870fcd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_97446d6c273ab6be83f8d8c8d7870fcd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_97446d6c273ab6be83f8d8c8d7870fcd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 896;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_debugger );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 896;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97446d6c273ab6be83f8d8c8d7870fcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_97446d6c273ab6be83f8d8c8d7870fcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97446d6c273ab6be83f8d8c8d7870fcd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_97446d6c273ab6be83f8d8c8d7870fcd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_97446d6c273ab6be83f8d8c8d7870fcd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_97446d6c273ab6be83f8d8c8d7870fcd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97446d6c273ab6be83f8d8c8d7870fcd,
        type_description_1
    );


    // Release cached frame.
    if ( frame_97446d6c273ab6be83f8d8c8d7870fcd == cache_frame_97446d6c273ab6be83f8d8c8d7870fcd )
    {
        Py_DECREF( frame_97446d6c273ab6be83f8d8c8d7870fcd );
    }
    cache_frame_97446d6c273ab6be83f8d8c8d7870fcd = NULL;

    assertFrameObject( frame_97446d6c273ab6be83f8d8c8d7870fcd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_5_shallRunInDebugger );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_6_shallDumpBuiltTreeXML( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_0311dc3f50b2a8f7c24f49e1af94c2b2 = NULL;

    struct Nuitka_FrameObject *frame_0311dc3f50b2a8f7c24f49e1af94c2b2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_0311dc3f50b2a8f7c24f49e1af94c2b2, codeobj_0311dc3f50b2a8f7c24f49e1af94c2b2, module_Options, 0 );
    frame_0311dc3f50b2a8f7c24f49e1af94c2b2 = cache_frame_0311dc3f50b2a8f7c24f49e1af94c2b2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 900;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_dump_xml );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 900;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0311dc3f50b2a8f7c24f49e1af94c2b2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0311dc3f50b2a8f7c24f49e1af94c2b2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0311dc3f50b2a8f7c24f49e1af94c2b2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0311dc3f50b2a8f7c24f49e1af94c2b2,
        type_description_1
    );


    // Release cached frame.
    if ( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 == cache_frame_0311dc3f50b2a8f7c24f49e1af94c2b2 )
    {
        Py_DECREF( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );
    }
    cache_frame_0311dc3f50b2a8f7c24f49e1af94c2b2 = NULL;

    assertFrameObject( frame_0311dc3f50b2a8f7c24f49e1af94c2b2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_6_shallDumpBuiltTreeXML );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_7_shallDisplayBuiltTree( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_413469e92c4e424cdec39269f5c5d5ae = NULL;

    struct Nuitka_FrameObject *frame_413469e92c4e424cdec39269f5c5d5ae;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_413469e92c4e424cdec39269f5c5d5ae, codeobj_413469e92c4e424cdec39269f5c5d5ae, module_Options, 0 );
    frame_413469e92c4e424cdec39269f5c5d5ae = cache_frame_413469e92c4e424cdec39269f5c5d5ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_413469e92c4e424cdec39269f5c5d5ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_413469e92c4e424cdec39269f5c5d5ae ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 904;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_display_tree );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 904;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_413469e92c4e424cdec39269f5c5d5ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_413469e92c4e424cdec39269f5c5d5ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_413469e92c4e424cdec39269f5c5d5ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_413469e92c4e424cdec39269f5c5d5ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_413469e92c4e424cdec39269f5c5d5ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_413469e92c4e424cdec39269f5c5d5ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_413469e92c4e424cdec39269f5c5d5ae,
        type_description_1
    );


    // Release cached frame.
    if ( frame_413469e92c4e424cdec39269f5c5d5ae == cache_frame_413469e92c4e424cdec39269f5c5d5ae )
    {
        Py_DECREF( frame_413469e92c4e424cdec39269f5c5d5ae );
    }
    cache_frame_413469e92c4e424cdec39269f5c5d5ae = NULL;

    assertFrameObject( frame_413469e92c4e424cdec39269f5c5d5ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_7_shallDisplayBuiltTree );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_8_shallOnlyExecCCompilerCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fc00721a4ae8a87da2a5540240c9b0aa = NULL;

    struct Nuitka_FrameObject *frame_fc00721a4ae8a87da2a5540240c9b0aa;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_fc00721a4ae8a87da2a5540240c9b0aa, codeobj_fc00721a4ae8a87da2a5540240c9b0aa, module_Options, 0 );
    frame_fc00721a4ae8a87da2a5540240c9b0aa = cache_frame_fc00721a4ae8a87da2a5540240c9b0aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fc00721a4ae8a87da2a5540240c9b0aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fc00721a4ae8a87da2a5540240c9b0aa ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 908;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recompile_c_only );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 908;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc00721a4ae8a87da2a5540240c9b0aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc00721a4ae8a87da2a5540240c9b0aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc00721a4ae8a87da2a5540240c9b0aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fc00721a4ae8a87da2a5540240c9b0aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fc00721a4ae8a87da2a5540240c9b0aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fc00721a4ae8a87da2a5540240c9b0aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fc00721a4ae8a87da2a5540240c9b0aa,
        type_description_1
    );


    // Release cached frame.
    if ( frame_fc00721a4ae8a87da2a5540240c9b0aa == cache_frame_fc00721a4ae8a87da2a5540240c9b0aa )
    {
        Py_DECREF( frame_fc00721a4ae8a87da2a5540240c9b0aa );
    }
    cache_frame_fc00721a4ae8a87da2a5540240c9b0aa = NULL;

    assertFrameObject( frame_fc00721a4ae8a87da2a5540240c9b0aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_8_shallOnlyExecCCompilerCall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_9_shallNotDoExecCCompilerCall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ddd75748bd61bcf23a75d38c2797002f = NULL;

    struct Nuitka_FrameObject *frame_ddd75748bd61bcf23a75d38c2797002f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_ddd75748bd61bcf23a75d38c2797002f, codeobj_ddd75748bd61bcf23a75d38c2797002f, module_Options, 0 );
    frame_ddd75748bd61bcf23a75d38c2797002f = cache_frame_ddd75748bd61bcf23a75d38c2797002f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ddd75748bd61bcf23a75d38c2797002f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ddd75748bd61bcf23a75d38c2797002f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 912;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_generate_c_only );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 912;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddd75748bd61bcf23a75d38c2797002f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddd75748bd61bcf23a75d38c2797002f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ddd75748bd61bcf23a75d38c2797002f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ddd75748bd61bcf23a75d38c2797002f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ddd75748bd61bcf23a75d38c2797002f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ddd75748bd61bcf23a75d38c2797002f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ddd75748bd61bcf23a75d38c2797002f,
        type_description_1
    );


    // Release cached frame.
    if ( frame_ddd75748bd61bcf23a75d38c2797002f == cache_frame_ddd75748bd61bcf23a75d38c2797002f )
    {
        Py_DECREF( frame_ddd75748bd61bcf23a75d38c2797002f );
    }
    cache_frame_ddd75748bd61bcf23a75d38c2797002f = NULL;

    assertFrameObject( frame_ddd75748bd61bcf23a75d38c2797002f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_9_shallNotDoExecCCompilerCall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_10_shallHaveStatementLines( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_970832abd8d359a2679a1bab059e0b97 = NULL;

    struct Nuitka_FrameObject *frame_970832abd8d359a2679a1bab059e0b97;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_970832abd8d359a2679a1bab059e0b97, codeobj_970832abd8d359a2679a1bab059e0b97, module_Options, 0 );
    frame_970832abd8d359a2679a1bab059e0b97 = cache_frame_970832abd8d359a2679a1bab059e0b97;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_970832abd8d359a2679a1bab059e0b97 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_970832abd8d359a2679a1bab059e0b97 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 916;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_statement_lines );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 916;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_970832abd8d359a2679a1bab059e0b97 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_970832abd8d359a2679a1bab059e0b97 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_970832abd8d359a2679a1bab059e0b97 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_970832abd8d359a2679a1bab059e0b97, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_970832abd8d359a2679a1bab059e0b97->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_970832abd8d359a2679a1bab059e0b97, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_970832abd8d359a2679a1bab059e0b97,
        type_description_1
    );


    // Release cached frame.
    if ( frame_970832abd8d359a2679a1bab059e0b97 == cache_frame_970832abd8d359a2679a1bab059e0b97 )
    {
        Py_DECREF( frame_970832abd8d359a2679a1bab059e0b97 );
    }
    cache_frame_970832abd8d359a2679a1bab059e0b97 = NULL;

    assertFrameObject( frame_970832abd8d359a2679a1bab059e0b97 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_10_shallHaveStatementLines );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_11_getFileReferenceMode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    bool tmp_is_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_272528bf4636d442d00d6a18b95d85dd = NULL;

    struct Nuitka_FrameObject *frame_272528bf4636d442d00d6a18b95d85dd;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_272528bf4636d442d00d6a18b95d85dd, codeobj_272528bf4636d442d00d6a18b95d85dd, module_Options, sizeof(void *) );
    frame_272528bf4636d442d00d6a18b95d85dd = cache_frame_272528bf4636d442d00d6a18b95d85dd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_272528bf4636d442d00d6a18b95d85dd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_272528bf4636d442d00d6a18b95d85dd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 920;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_file_reference_mode );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallMakeModule );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_shallMakeModule );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "shallMakeModule" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_272528bf4636d442d00d6a18b95d85dd->m_frame.f_lineno = 922;
    tmp_or_left_value_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isStandaloneMode );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_isStandaloneMode );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "isStandaloneMode" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_272528bf4636d442d00d6a18b95d85dd->m_frame.f_lineno = 922;
    tmp_or_right_value_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 922;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_assign_source_1 = const_str_plain_runtime;
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_assign_source_1 = const_str_plain_original;
    condexpr_end_1:;
    assert( var_value == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_value = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 925;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_file_reference_mode );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 925;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    assert( var_value == NULL );
    var_value = tmp_assign_source_2;

    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_272528bf4636d442d00d6a18b95d85dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_272528bf4636d442d00d6a18b95d85dd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_272528bf4636d442d00d6a18b95d85dd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_272528bf4636d442d00d6a18b95d85dd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_272528bf4636d442d00d6a18b95d85dd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_272528bf4636d442d00d6a18b95d85dd,
        type_description_1,
        var_value
    );


    // Release cached frame.
    if ( frame_272528bf4636d442d00d6a18b95d85dd == cache_frame_272528bf4636d442d00d6a18b95d85dd )
    {
        Py_DECREF( frame_272528bf4636d442d00d6a18b95d85dd );
    }
    cache_frame_272528bf4636d442d00d6a18b95d85dd = NULL;

    assertFrameObject( frame_272528bf4636d442d00d6a18b95d85dd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_value;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_11_getFileReferenceMode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_value );
    Py_DECREF( var_value );
    var_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_11_getFileReferenceMode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_12_shallMakeModule( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d1da03d8bcb10c9f5aed4a9294699f4f = NULL;

    struct Nuitka_FrameObject *frame_d1da03d8bcb10c9f5aed4a9294699f4f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_d1da03d8bcb10c9f5aed4a9294699f4f, codeobj_d1da03d8bcb10c9f5aed4a9294699f4f, module_Options, 0 );
    frame_d1da03d8bcb10c9f5aed4a9294699f4f = cache_frame_d1da03d8bcb10c9f5aed4a9294699f4f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d1da03d8bcb10c9f5aed4a9294699f4f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d1da03d8bcb10c9f5aed4a9294699f4f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 931;

        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_executable );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;

        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;

        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1da03d8bcb10c9f5aed4a9294699f4f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1da03d8bcb10c9f5aed4a9294699f4f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1da03d8bcb10c9f5aed4a9294699f4f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d1da03d8bcb10c9f5aed4a9294699f4f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d1da03d8bcb10c9f5aed4a9294699f4f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d1da03d8bcb10c9f5aed4a9294699f4f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d1da03d8bcb10c9f5aed4a9294699f4f,
        type_description_1
    );


    // Release cached frame.
    if ( frame_d1da03d8bcb10c9f5aed4a9294699f4f == cache_frame_d1da03d8bcb10c9f5aed4a9294699f4f )
    {
        Py_DECREF( frame_d1da03d8bcb10c9f5aed4a9294699f4f );
    }
    cache_frame_d1da03d8bcb10c9f5aed4a9294699f4f = NULL;

    assertFrameObject( frame_d1da03d8bcb10c9f5aed4a9294699f4f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_12_shallMakeModule );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_13_shallCreatePyiFile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_737c97aa48d786ecb227db57f52a9e87 = NULL;

    struct Nuitka_FrameObject *frame_737c97aa48d786ecb227db57f52a9e87;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_737c97aa48d786ecb227db57f52a9e87, codeobj_737c97aa48d786ecb227db57f52a9e87, module_Options, 0 );
    frame_737c97aa48d786ecb227db57f52a9e87 = cache_frame_737c97aa48d786ecb227db57f52a9e87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_737c97aa48d786ecb227db57f52a9e87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_737c97aa48d786ecb227db57f52a9e87 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 935;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_pyi_file );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_737c97aa48d786ecb227db57f52a9e87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_737c97aa48d786ecb227db57f52a9e87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_737c97aa48d786ecb227db57f52a9e87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_737c97aa48d786ecb227db57f52a9e87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_737c97aa48d786ecb227db57f52a9e87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_737c97aa48d786ecb227db57f52a9e87, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_737c97aa48d786ecb227db57f52a9e87,
        type_description_1
    );


    // Release cached frame.
    if ( frame_737c97aa48d786ecb227db57f52a9e87 == cache_frame_737c97aa48d786ecb227db57f52a9e87 )
    {
        Py_DECREF( frame_737c97aa48d786ecb227db57f52a9e87 );
    }
    cache_frame_737c97aa48d786ecb227db57f52a9e87 = NULL;

    assertFrameObject( frame_737c97aa48d786ecb227db57f52a9e87 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_13_shallCreatePyiFile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_14_isAllowedToReexecute( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_740beeaa8324802bf1747ce98c5bbb53 = NULL;

    struct Nuitka_FrameObject *frame_740beeaa8324802bf1747ce98c5bbb53;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_740beeaa8324802bf1747ce98c5bbb53, codeobj_740beeaa8324802bf1747ce98c5bbb53, module_Options, 0 );
    frame_740beeaa8324802bf1747ce98c5bbb53 = cache_frame_740beeaa8324802bf1747ce98c5bbb53;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_740beeaa8324802bf1747ce98c5bbb53 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_740beeaa8324802bf1747ce98c5bbb53 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 939;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_allow_reexecute );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_740beeaa8324802bf1747ce98c5bbb53 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_740beeaa8324802bf1747ce98c5bbb53 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_740beeaa8324802bf1747ce98c5bbb53 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_740beeaa8324802bf1747ce98c5bbb53, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_740beeaa8324802bf1747ce98c5bbb53->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_740beeaa8324802bf1747ce98c5bbb53, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_740beeaa8324802bf1747ce98c5bbb53,
        type_description_1
    );


    // Release cached frame.
    if ( frame_740beeaa8324802bf1747ce98c5bbb53 == cache_frame_740beeaa8324802bf1747ce98c5bbb53 )
    {
        Py_DECREF( frame_740beeaa8324802bf1747ce98c5bbb53 );
    }
    cache_frame_740beeaa8324802bf1747ce98c5bbb53 = NULL;

    assertFrameObject( frame_740beeaa8324802bf1747ce98c5bbb53 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_14_isAllowedToReexecute );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_15_shallFollowStandardLibrary( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_8a6dd9706c10f994c6de2227774ada4a = NULL;

    struct Nuitka_FrameObject *frame_8a6dd9706c10f994c6de2227774ada4a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_8a6dd9706c10f994c6de2227774ada4a, codeobj_8a6dd9706c10f994c6de2227774ada4a, module_Options, 0 );
    frame_8a6dd9706c10f994c6de2227774ada4a = cache_frame_8a6dd9706c10f994c6de2227774ada4a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a6dd9706c10f994c6de2227774ada4a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a6dd9706c10f994c6de2227774ada4a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 943;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_stdlib );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 943;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a6dd9706c10f994c6de2227774ada4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a6dd9706c10f994c6de2227774ada4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a6dd9706c10f994c6de2227774ada4a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a6dd9706c10f994c6de2227774ada4a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a6dd9706c10f994c6de2227774ada4a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a6dd9706c10f994c6de2227774ada4a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a6dd9706c10f994c6de2227774ada4a,
        type_description_1
    );


    // Release cached frame.
    if ( frame_8a6dd9706c10f994c6de2227774ada4a == cache_frame_8a6dd9706c10f994c6de2227774ada4a )
    {
        Py_DECREF( frame_8a6dd9706c10f994c6de2227774ada4a );
    }
    cache_frame_8a6dd9706c10f994c6de2227774ada4a = NULL;

    assertFrameObject( frame_8a6dd9706c10f994c6de2227774ada4a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_15_shallFollowStandardLibrary );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_16_shallFollowNoImports( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_94734671575e56910016a914e03510a9 = NULL;

    struct Nuitka_FrameObject *frame_94734671575e56910016a914e03510a9;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_94734671575e56910016a914e03510a9, codeobj_94734671575e56910016a914e03510a9, module_Options, 0 );
    frame_94734671575e56910016a914e03510a9 = cache_frame_94734671575e56910016a914e03510a9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_94734671575e56910016a914e03510a9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_94734671575e56910016a914e03510a9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 947;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_none );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 947;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_94734671575e56910016a914e03510a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_94734671575e56910016a914e03510a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_94734671575e56910016a914e03510a9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_94734671575e56910016a914e03510a9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_94734671575e56910016a914e03510a9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_94734671575e56910016a914e03510a9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_94734671575e56910016a914e03510a9,
        type_description_1
    );


    // Release cached frame.
    if ( frame_94734671575e56910016a914e03510a9 == cache_frame_94734671575e56910016a914e03510a9 )
    {
        Py_DECREF( frame_94734671575e56910016a914e03510a9 );
    }
    cache_frame_94734671575e56910016a914e03510a9 = NULL;

    assertFrameObject( frame_94734671575e56910016a914e03510a9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_16_shallFollowNoImports );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_17_shallFollowAllImports( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_c46af5b2d77cf0b451ac6599684abc48 = NULL;

    struct Nuitka_FrameObject *frame_c46af5b2d77cf0b451ac6599684abc48;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_c46af5b2d77cf0b451ac6599684abc48, codeobj_c46af5b2d77cf0b451ac6599684abc48, module_Options, 0 );
    frame_c46af5b2d77cf0b451ac6599684abc48 = cache_frame_c46af5b2d77cf0b451ac6599684abc48;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c46af5b2d77cf0b451ac6599684abc48 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c46af5b2d77cf0b451ac6599684abc48 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 951;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_all );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 951;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c46af5b2d77cf0b451ac6599684abc48 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c46af5b2d77cf0b451ac6599684abc48 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c46af5b2d77cf0b451ac6599684abc48 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c46af5b2d77cf0b451ac6599684abc48, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c46af5b2d77cf0b451ac6599684abc48->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c46af5b2d77cf0b451ac6599684abc48, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c46af5b2d77cf0b451ac6599684abc48,
        type_description_1
    );


    // Release cached frame.
    if ( frame_c46af5b2d77cf0b451ac6599684abc48 == cache_frame_c46af5b2d77cf0b451ac6599684abc48 )
    {
        Py_DECREF( frame_c46af5b2d77cf0b451ac6599684abc48 );
    }
    cache_frame_c46af5b2d77cf0b451ac6599684abc48 = NULL;

    assertFrameObject( frame_c46af5b2d77cf0b451ac6599684abc48 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_17_shallFollowAllImports );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_18__splitShellPattern( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_value = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_ff896619f018e5169268dd4e6352a0fb = NULL;

    struct Nuitka_FrameObject *frame_ff896619f018e5169268dd4e6352a0fb;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff896619f018e5169268dd4e6352a0fb, codeobj_ff896619f018e5169268dd4e6352a0fb, module_Options, sizeof(void *) );
    frame_ff896619f018e5169268dd4e6352a0fb = cache_frame_ff896619f018e5169268dd4e6352a0fb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff896619f018e5169268dd4e6352a0fb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff896619f018e5169268dd4e6352a0fb ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = const_str_chr_123;
    tmp_compare_right_1 = par_value;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_called_instance_1 = par_value;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 955;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_ff896619f018e5169268dd4e6352a0fb->m_frame.f_lineno = 955;
    tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_44_tuple, 0 ) );

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 955;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_list_element_1 = par_value;

    if ( tmp_list_element_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "value" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 955;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_return_value = PyList_New( 1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_return_value, 0, tmp_list_element_1 );
    condexpr_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff896619f018e5169268dd4e6352a0fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff896619f018e5169268dd4e6352a0fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff896619f018e5169268dd4e6352a0fb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff896619f018e5169268dd4e6352a0fb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff896619f018e5169268dd4e6352a0fb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff896619f018e5169268dd4e6352a0fb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff896619f018e5169268dd4e6352a0fb,
        type_description_1,
        par_value
    );


    // Release cached frame.
    if ( frame_ff896619f018e5169268dd4e6352a0fb == cache_frame_ff896619f018e5169268dd4e6352a0fb )
    {
        Py_DECREF( frame_ff896619f018e5169268dd4e6352a0fb );
    }
    cache_frame_ff896619f018e5169268dd4e6352a0fb = NULL;

    assertFrameObject( frame_ff896619f018e5169268dd4e6352a0fb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_18__splitShellPattern );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_18__splitShellPattern );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_19_getShallFollowInNoCase( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_ce72348006636f3b1d48f63be6336e5c_2 = NULL;

    struct Nuitka_FrameObject *frame_ce72348006636f3b1d48f63be6336e5c_2;

    static struct Nuitka_FrameObject *cache_frame_1e83e4d70cf7aacbd8c100d6e42e6b9a = NULL;

    struct Nuitka_FrameObject *frame_1e83e4d70cf7aacbd8c100d6e42e6b9a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_1e83e4d70cf7aacbd8c100d6e42e6b9a, codeobj_1e83e4d70cf7aacbd8c100d6e42e6b9a, module_Options, 0 );
    frame_1e83e4d70cf7aacbd8c100d6e42e6b9a = cache_frame_1e83e4d70cf7aacbd8c100d6e42e6b9a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 960;

        goto try_except_handler_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_not_modules );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_ce72348006636f3b1d48f63be6336e5c_2, codeobj_ce72348006636f3b1d48f63be6336e5c, module_Options, sizeof(void *) );
    frame_ce72348006636f3b1d48f63be6336e5c_2 = cache_frame_ce72348006636f3b1d48f63be6336e5c_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce72348006636f3b1d48f63be6336e5c_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce72348006636f3b1d48f63be6336e5c_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 960;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 960;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 960;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_ce72348006636f3b1d48f63be6336e5c_2->m_frame.f_lineno = 960;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_19_getShallFollowInNoCase );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce72348006636f3b1d48f63be6336e5c_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce72348006636f3b1d48f63be6336e5c_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce72348006636f3b1d48f63be6336e5c_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce72348006636f3b1d48f63be6336e5c_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce72348006636f3b1d48f63be6336e5c_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce72348006636f3b1d48f63be6336e5c_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce72348006636f3b1d48f63be6336e5c_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_ce72348006636f3b1d48f63be6336e5c_2 == cache_frame_ce72348006636f3b1d48f63be6336e5c_2 )
    {
        Py_DECREF( frame_ce72348006636f3b1d48f63be6336e5c_2 );
    }
    cache_frame_ce72348006636f3b1d48f63be6336e5c_2 = NULL;

    assertFrameObject( frame_ce72348006636f3b1d48f63be6336e5c_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_19_getShallFollowInNoCase );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_19_getShallFollowInNoCase );
    return NULL;
    outline_exception_1:;
    exception_lineno = 960;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 959;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1e83e4d70cf7aacbd8c100d6e42e6b9a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1e83e4d70cf7aacbd8c100d6e42e6b9a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1e83e4d70cf7aacbd8c100d6e42e6b9a,
        type_description_1
    );


    // Release cached frame.
    if ( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a == cache_frame_1e83e4d70cf7aacbd8c100d6e42e6b9a )
    {
        Py_DECREF( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );
    }
    cache_frame_1e83e4d70cf7aacbd8c100d6e42e6b9a = NULL;

    assertFrameObject( frame_1e83e4d70cf7aacbd8c100d6e42e6b9a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_19_getShallFollowInNoCase );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_20_getShallFollowModules( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 = NULL;

    struct Nuitka_FrameObject *frame_f8d619e8fb32ffd66203c9c2939bf1f6_2;

    static struct Nuitka_FrameObject *cache_frame_505945e7d1254f4132a1d5ce2a8071d3 = NULL;

    struct Nuitka_FrameObject *frame_505945e7d1254f4132a1d5ce2a8071d3;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_505945e7d1254f4132a1d5ce2a8071d3, codeobj_505945e7d1254f4132a1d5ce2a8071d3, module_Options, 0 );
    frame_505945e7d1254f4132a1d5ce2a8071d3 = cache_frame_505945e7d1254f4132a1d5ce2a8071d3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_505945e7d1254f4132a1d5ce2a8071d3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_505945e7d1254f4132a1d5ce2a8071d3 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;

        goto try_except_handler_1;
    }

    tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_modules );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;

        goto try_except_handler_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_left_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;

        goto try_except_handler_1;
    }

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_include_modules );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_2 );

        exception_lineno = 967;

        goto try_except_handler_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_2 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;

        goto try_except_handler_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;

        goto try_except_handler_1;
    }

    tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_include_packages );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 967;

        goto try_except_handler_1;
    }
    tmp_iter_arg_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_f8d619e8fb32ffd66203c9c2939bf1f6_2, codeobj_f8d619e8fb32ffd66203c9c2939bf1f6, module_Options, sizeof(void *) );
    frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 = cache_frame_f8d619e8fb32ffd66203c9c2939bf1f6_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 967;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 967;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 967;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_f8d619e8fb32ffd66203c9c2939bf1f6_2->m_frame.f_lineno = 967;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_20_getShallFollowModules );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8d619e8fb32ffd66203c9c2939bf1f6_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8d619e8fb32ffd66203c9c2939bf1f6_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8d619e8fb32ffd66203c9c2939bf1f6_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 == cache_frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 )
    {
        Py_DECREF( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );
    }
    cache_frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 = NULL;

    assertFrameObject( frame_f8d619e8fb32ffd66203c9c2939bf1f6_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_20_getShallFollowModules );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_20_getShallFollowModules );
    return NULL;
    outline_exception_1:;
    exception_lineno = 967;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_505945e7d1254f4132a1d5ce2a8071d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_505945e7d1254f4132a1d5ce2a8071d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_505945e7d1254f4132a1d5ce2a8071d3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_505945e7d1254f4132a1d5ce2a8071d3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_505945e7d1254f4132a1d5ce2a8071d3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_505945e7d1254f4132a1d5ce2a8071d3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_505945e7d1254f4132a1d5ce2a8071d3,
        type_description_1
    );


    // Release cached frame.
    if ( frame_505945e7d1254f4132a1d5ce2a8071d3 == cache_frame_505945e7d1254f4132a1d5ce2a8071d3 )
    {
        Py_DECREF( frame_505945e7d1254f4132a1d5ce2a8071d3 );
    }
    cache_frame_505945e7d1254f4132a1d5ce2a8071d3 = NULL;

    assertFrameObject( frame_505945e7d1254f4132a1d5ce2a8071d3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_20_getShallFollowModules );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_21_getShallFollowExtra( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_c721fc79d077c2b14e42177a06329c85_2 = NULL;

    struct Nuitka_FrameObject *frame_c721fc79d077c2b14e42177a06329c85_2;

    static struct Nuitka_FrameObject *cache_frame_95ca596c1c70767c7c1e62f9209438e4 = NULL;

    struct Nuitka_FrameObject *frame_95ca596c1c70767c7c1e62f9209438e4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_95ca596c1c70767c7c1e62f9209438e4, codeobj_95ca596c1c70767c7c1e62f9209438e4, module_Options, 0 );
    frame_95ca596c1c70767c7c1e62f9209438e4 = cache_frame_95ca596c1c70767c7c1e62f9209438e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_95ca596c1c70767c7c1e62f9209438e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_95ca596c1c70767c7c1e62f9209438e4 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;

        goto try_except_handler_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_extra );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_c721fc79d077c2b14e42177a06329c85_2, codeobj_c721fc79d077c2b14e42177a06329c85, module_Options, sizeof(void *) );
    frame_c721fc79d077c2b14e42177a06329c85_2 = cache_frame_c721fc79d077c2b14e42177a06329c85_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c721fc79d077c2b14e42177a06329c85_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c721fc79d077c2b14e42177a06329c85_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 974;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 974;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_c721fc79d077c2b14e42177a06329c85_2->m_frame.f_lineno = 974;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_21_getShallFollowExtra );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c721fc79d077c2b14e42177a06329c85_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c721fc79d077c2b14e42177a06329c85_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c721fc79d077c2b14e42177a06329c85_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c721fc79d077c2b14e42177a06329c85_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c721fc79d077c2b14e42177a06329c85_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c721fc79d077c2b14e42177a06329c85_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c721fc79d077c2b14e42177a06329c85_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_c721fc79d077c2b14e42177a06329c85_2 == cache_frame_c721fc79d077c2b14e42177a06329c85_2 )
    {
        Py_DECREF( frame_c721fc79d077c2b14e42177a06329c85_2 );
    }
    cache_frame_c721fc79d077c2b14e42177a06329c85_2 = NULL;

    assertFrameObject( frame_c721fc79d077c2b14e42177a06329c85_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_21_getShallFollowExtra );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_21_getShallFollowExtra );
    return NULL;
    outline_exception_1:;
    exception_lineno = 974;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 973;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ca596c1c70767c7c1e62f9209438e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ca596c1c70767c7c1e62f9209438e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ca596c1c70767c7c1e62f9209438e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_95ca596c1c70767c7c1e62f9209438e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_95ca596c1c70767c7c1e62f9209438e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_95ca596c1c70767c7c1e62f9209438e4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_95ca596c1c70767c7c1e62f9209438e4,
        type_description_1
    );


    // Release cached frame.
    if ( frame_95ca596c1c70767c7c1e62f9209438e4 == cache_frame_95ca596c1c70767c7c1e62f9209438e4 )
    {
        Py_DECREF( frame_95ca596c1c70767c7c1e62f9209438e4 );
    }
    cache_frame_95ca596c1c70767c7c1e62f9209438e4 = NULL;

    assertFrameObject( frame_95ca596c1c70767c7c1e62f9209438e4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_21_getShallFollowExtra );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_22_getShallFollowExtraFilePatterns( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 = NULL;

    struct Nuitka_FrameObject *frame_6c12b512b3dea76e9c7dc2e486b61d7f_2;

    static struct Nuitka_FrameObject *cache_frame_6d1b960b567971407ddf22e61c4cf1fe = NULL;

    struct Nuitka_FrameObject *frame_6d1b960b567971407ddf22e61c4cf1fe;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_6d1b960b567971407ddf22e61c4cf1fe, codeobj_6d1b960b567971407ddf22e61c4cf1fe, module_Options, 0 );
    frame_6d1b960b567971407ddf22e61c4cf1fe = cache_frame_6d1b960b567971407ddf22e61c4cf1fe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6d1b960b567971407ddf22e61c4cf1fe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6d1b960b567971407ddf22e61c4cf1fe ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 981;

        goto try_except_handler_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_recurse_extra_files );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_6c12b512b3dea76e9c7dc2e486b61d7f_2, codeobj_6c12b512b3dea76e9c7dc2e486b61d7f, module_Options, sizeof(void *) );
    frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 = cache_frame_6c12b512b3dea76e9c7dc2e486b61d7f_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 981;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 981;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 981;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_6c12b512b3dea76e9c7dc2e486b61d7f_2->m_frame.f_lineno = 981;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_22_getShallFollowExtraFilePatterns );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c12b512b3dea76e9c7dc2e486b61d7f_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c12b512b3dea76e9c7dc2e486b61d7f_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c12b512b3dea76e9c7dc2e486b61d7f_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 == cache_frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 )
    {
        Py_DECREF( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );
    }
    cache_frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 = NULL;

    assertFrameObject( frame_6c12b512b3dea76e9c7dc2e486b61d7f_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_22_getShallFollowExtraFilePatterns );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_22_getShallFollowExtraFilePatterns );
    return NULL;
    outline_exception_1:;
    exception_lineno = 981;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1b960b567971407ddf22e61c4cf1fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1b960b567971407ddf22e61c4cf1fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d1b960b567971407ddf22e61c4cf1fe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6d1b960b567971407ddf22e61c4cf1fe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6d1b960b567971407ddf22e61c4cf1fe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6d1b960b567971407ddf22e61c4cf1fe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6d1b960b567971407ddf22e61c4cf1fe,
        type_description_1
    );


    // Release cached frame.
    if ( frame_6d1b960b567971407ddf22e61c4cf1fe == cache_frame_6d1b960b567971407ddf22e61c4cf1fe )
    {
        Py_DECREF( frame_6d1b960b567971407ddf22e61c4cf1fe );
    }
    cache_frame_6d1b960b567971407ddf22e61c4cf1fe = NULL;

    assertFrameObject( frame_6d1b960b567971407ddf22e61c4cf1fe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_22_getShallFollowExtraFilePatterns );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_23_getMustIncludeModules( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_4bebe3e14b9a7aa974a75088fa55838c_2 = NULL;

    struct Nuitka_FrameObject *frame_4bebe3e14b9a7aa974a75088fa55838c_2;

    static struct Nuitka_FrameObject *cache_frame_d0e72dd5176d8fb44a2a894177240eee = NULL;

    struct Nuitka_FrameObject *frame_d0e72dd5176d8fb44a2a894177240eee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_d0e72dd5176d8fb44a2a894177240eee, codeobj_d0e72dd5176d8fb44a2a894177240eee, module_Options, 0 );
    frame_d0e72dd5176d8fb44a2a894177240eee = cache_frame_d0e72dd5176d8fb44a2a894177240eee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0e72dd5176d8fb44a2a894177240eee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0e72dd5176d8fb44a2a894177240eee ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;

        goto try_except_handler_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_include_modules );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_4bebe3e14b9a7aa974a75088fa55838c_2, codeobj_4bebe3e14b9a7aa974a75088fa55838c, module_Options, sizeof(void *) );
    frame_4bebe3e14b9a7aa974a75088fa55838c_2 = cache_frame_4bebe3e14b9a7aa974a75088fa55838c_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4bebe3e14b9a7aa974a75088fa55838c_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 988;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 988;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_4bebe3e14b9a7aa974a75088fa55838c_2->m_frame.f_lineno = 988;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_23_getMustIncludeModules );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4bebe3e14b9a7aa974a75088fa55838c_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4bebe3e14b9a7aa974a75088fa55838c_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4bebe3e14b9a7aa974a75088fa55838c_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4bebe3e14b9a7aa974a75088fa55838c_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_4bebe3e14b9a7aa974a75088fa55838c_2 == cache_frame_4bebe3e14b9a7aa974a75088fa55838c_2 )
    {
        Py_DECREF( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );
    }
    cache_frame_4bebe3e14b9a7aa974a75088fa55838c_2 = NULL;

    assertFrameObject( frame_4bebe3e14b9a7aa974a75088fa55838c_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_23_getMustIncludeModules );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_23_getMustIncludeModules );
    return NULL;
    outline_exception_1:;
    exception_lineno = 988;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0e72dd5176d8fb44a2a894177240eee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0e72dd5176d8fb44a2a894177240eee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0e72dd5176d8fb44a2a894177240eee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0e72dd5176d8fb44a2a894177240eee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0e72dd5176d8fb44a2a894177240eee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0e72dd5176d8fb44a2a894177240eee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d0e72dd5176d8fb44a2a894177240eee,
        type_description_1
    );


    // Release cached frame.
    if ( frame_d0e72dd5176d8fb44a2a894177240eee == cache_frame_d0e72dd5176d8fb44a2a894177240eee )
    {
        Py_DECREF( frame_d0e72dd5176d8fb44a2a894177240eee );
    }
    cache_frame_d0e72dd5176d8fb44a2a894177240eee = NULL;

    assertFrameObject( frame_d0e72dd5176d8fb44a2a894177240eee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_23_getMustIncludeModules );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_24_getMustIncludePackages( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *outline_0_var_x = NULL;
    PyObject *tmp_listcontraction_1__$0 = NULL;
    PyObject *tmp_listcontraction_1__contraction = NULL;
    PyObject *tmp_listcontraction_1__iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_sum_sequence_1;
    PyObject *tmp_sum_start_1;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_e247755bd74b0ae1ce03487b4067d9e8_2 = NULL;

    struct Nuitka_FrameObject *frame_e247755bd74b0ae1ce03487b4067d9e8_2;

    static struct Nuitka_FrameObject *cache_frame_a521c517b8991aad61def47b5f4d695b = NULL;

    struct Nuitka_FrameObject *frame_a521c517b8991aad61def47b5f4d695b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_a521c517b8991aad61def47b5f4d695b, codeobj_a521c517b8991aad61def47b5f4d695b, module_Options, 0 );
    frame_a521c517b8991aad61def47b5f4d695b = cache_frame_a521c517b8991aad61def47b5f4d695b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a521c517b8991aad61def47b5f4d695b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a521c517b8991aad61def47b5f4d695b ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 995;

        goto try_except_handler_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_include_packages );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;

        goto try_except_handler_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;

        goto try_except_handler_1;
    }
    assert( tmp_listcontraction_1__$0 == NULL );
    tmp_listcontraction_1__$0 = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( tmp_listcontraction_1__contraction == NULL );
    tmp_listcontraction_1__contraction = tmp_assign_source_2;

    MAKE_OR_REUSE_FRAME( cache_frame_e247755bd74b0ae1ce03487b4067d9e8_2, codeobj_e247755bd74b0ae1ce03487b4067d9e8, module_Options, sizeof(void *) );
    frame_e247755bd74b0ae1ce03487b4067d9e8_2 = cache_frame_e247755bd74b0ae1ce03487b4067d9e8_2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e247755bd74b0ae1ce03487b4067d9e8_2 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_listcontraction_1__$0;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_2 = "o";
        exception_lineno = 995;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_listcontraction_1__iter_value_0;
        tmp_listcontraction_1__iter_value_0 = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 995;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_1;
    branch_no_1:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_1:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_listcontraction_1__iter_value_0;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = outline_0_var_x;
        outline_0_var_x = tmp_assign_source_4;
        Py_INCREF( outline_0_var_x );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__splitShellPattern );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_splitShellPattern" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 995;
        type_description_2 = "o";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = outline_0_var_x;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_e247755bd74b0ae1ce03487b4067d9e8_2->m_frame.f_lineno = 995;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_append_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_append_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        type_description_2 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_listcontraction_1__contraction;

    CHECK_OBJECT( tmp_outline_return_value_1 );
    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_24_getMustIncludePackages );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    goto frame_return_exit_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__$0 );
    Py_DECREF( tmp_listcontraction_1__$0 );
    tmp_listcontraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_listcontraction_1__contraction );
    Py_DECREF( tmp_listcontraction_1__contraction );
    tmp_listcontraction_1__contraction = NULL;

    Py_XDECREF( tmp_listcontraction_1__iter_value_0 );
    tmp_listcontraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_2;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_2:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e247755bd74b0ae1ce03487b4067d9e8_2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e247755bd74b0ae1ce03487b4067d9e8_2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e247755bd74b0ae1ce03487b4067d9e8_2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e247755bd74b0ae1ce03487b4067d9e8_2,
        type_description_2,
        outline_0_var_x
    );


    // Release cached frame.
    if ( frame_e247755bd74b0ae1ce03487b4067d9e8_2 == cache_frame_e247755bd74b0ae1ce03487b4067d9e8_2 )
    {
        Py_DECREF( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );
    }
    cache_frame_e247755bd74b0ae1ce03487b4067d9e8_2 = NULL;

    assertFrameObject( frame_e247755bd74b0ae1ce03487b4067d9e8_2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto nested_frame_exit_1;

    frame_no_exception_1:;

    goto skip_nested_handling_1;
    nested_frame_exit_1:;

    goto try_except_handler_1;
    skip_nested_handling_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_24_getMustIncludePackages );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( outline_0_var_x );
    outline_0_var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto outline_exception_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_24_getMustIncludePackages );
    return NULL;
    outline_exception_1:;
    exception_lineno = 995;
    goto frame_exception_exit_1;
    outline_result_1:;
    tmp_sum_sequence_1 = tmp_outline_return_value_1;
    tmp_sum_start_1 = PyList_New( 0 );
    tmp_return_value = BUILTIN_SUM2( tmp_sum_sequence_1, tmp_sum_start_1 );
    Py_DECREF( tmp_sum_sequence_1 );
    Py_DECREF( tmp_sum_start_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 994;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a521c517b8991aad61def47b5f4d695b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a521c517b8991aad61def47b5f4d695b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a521c517b8991aad61def47b5f4d695b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a521c517b8991aad61def47b5f4d695b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a521c517b8991aad61def47b5f4d695b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a521c517b8991aad61def47b5f4d695b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a521c517b8991aad61def47b5f4d695b,
        type_description_1
    );


    // Release cached frame.
    if ( frame_a521c517b8991aad61def47b5f4d695b == cache_frame_a521c517b8991aad61def47b5f4d695b )
    {
        Py_DECREF( frame_a521c517b8991aad61def47b5f4d695b );
    }
    cache_frame_a521c517b8991aad61def47b5f4d695b = NULL;

    assertFrameObject( frame_a521c517b8991aad61def47b5f4d695b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_2:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_24_getMustIncludePackages );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_25_shallWarnImplicitRaises( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_84a94085338dd777dbd28747a2105f2f = NULL;

    struct Nuitka_FrameObject *frame_84a94085338dd777dbd28747a2105f2f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_84a94085338dd777dbd28747a2105f2f, codeobj_84a94085338dd777dbd28747a2105f2f, module_Options, 0 );
    frame_84a94085338dd777dbd28747a2105f2f = cache_frame_84a94085338dd777dbd28747a2105f2f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84a94085338dd777dbd28747a2105f2f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84a94085338dd777dbd28747a2105f2f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1001;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_warn_implicit_exceptions );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1001;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84a94085338dd777dbd28747a2105f2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_84a94085338dd777dbd28747a2105f2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84a94085338dd777dbd28747a2105f2f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84a94085338dd777dbd28747a2105f2f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84a94085338dd777dbd28747a2105f2f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84a94085338dd777dbd28747a2105f2f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84a94085338dd777dbd28747a2105f2f,
        type_description_1
    );


    // Release cached frame.
    if ( frame_84a94085338dd777dbd28747a2105f2f == cache_frame_84a94085338dd777dbd28747a2105f2f )
    {
        Py_DECREF( frame_84a94085338dd777dbd28747a2105f2f );
    }
    cache_frame_84a94085338dd777dbd28747a2105f2f = NULL;

    assertFrameObject( frame_84a94085338dd777dbd28747a2105f2f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_25_shallWarnImplicitRaises );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_26_shallWarnUnusualCode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_11c54a3e55595eff4de75e4e8a1668d7 = NULL;

    struct Nuitka_FrameObject *frame_11c54a3e55595eff4de75e4e8a1668d7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_11c54a3e55595eff4de75e4e8a1668d7, codeobj_11c54a3e55595eff4de75e4e8a1668d7, module_Options, 0 );
    frame_11c54a3e55595eff4de75e4e8a1668d7 = cache_frame_11c54a3e55595eff4de75e4e8a1668d7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_11c54a3e55595eff4de75e4e8a1668d7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_11c54a3e55595eff4de75e4e8a1668d7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1005;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_warn_unusual_code );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1005;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_11c54a3e55595eff4de75e4e8a1668d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_11c54a3e55595eff4de75e4e8a1668d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_11c54a3e55595eff4de75e4e8a1668d7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_11c54a3e55595eff4de75e4e8a1668d7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_11c54a3e55595eff4de75e4e8a1668d7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_11c54a3e55595eff4de75e4e8a1668d7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_11c54a3e55595eff4de75e4e8a1668d7,
        type_description_1
    );


    // Release cached frame.
    if ( frame_11c54a3e55595eff4de75e4e8a1668d7 == cache_frame_11c54a3e55595eff4de75e4e8a1668d7 )
    {
        Py_DECREF( frame_11c54a3e55595eff4de75e4e8a1668d7 );
    }
    cache_frame_11c54a3e55595eff4de75e4e8a1668d7 = NULL;

    assertFrameObject( frame_11c54a3e55595eff4de75e4e8a1668d7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_26_shallWarnUnusualCode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_27_assumeYesForDownloads( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e9568ec9f2372518858530f1e368f07b = NULL;

    struct Nuitka_FrameObject *frame_e9568ec9f2372518858530f1e368f07b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_e9568ec9f2372518858530f1e368f07b, codeobj_e9568ec9f2372518858530f1e368f07b, module_Options, 0 );
    frame_e9568ec9f2372518858530f1e368f07b = cache_frame_e9568ec9f2372518858530f1e368f07b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e9568ec9f2372518858530f1e368f07b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e9568ec9f2372518858530f1e368f07b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1009;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_assume_yes_for_downloads );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9568ec9f2372518858530f1e368f07b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9568ec9f2372518858530f1e368f07b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e9568ec9f2372518858530f1e368f07b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e9568ec9f2372518858530f1e368f07b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e9568ec9f2372518858530f1e368f07b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e9568ec9f2372518858530f1e368f07b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e9568ec9f2372518858530f1e368f07b,
        type_description_1
    );


    // Release cached frame.
    if ( frame_e9568ec9f2372518858530f1e368f07b == cache_frame_e9568ec9f2372518858530f1e368f07b )
    {
        Py_DECREF( frame_e9568ec9f2372518858530f1e368f07b );
    }
    cache_frame_e9568ec9f2372518858530f1e368f07b = NULL;

    assertFrameObject( frame_e9568ec9f2372518858530f1e368f07b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_27_assumeYesForDownloads );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_28_isDebug( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_5cb9696cdcff5fe60bf2c0d942196107 = NULL;

    struct Nuitka_FrameObject *frame_5cb9696cdcff5fe60bf2c0d942196107;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_5cb9696cdcff5fe60bf2c0d942196107, codeobj_5cb9696cdcff5fe60bf2c0d942196107, module_Options, 0 );
    frame_5cb9696cdcff5fe60bf2c0d942196107 = cache_frame_5cb9696cdcff5fe60bf2c0d942196107;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cb9696cdcff5fe60bf2c0d942196107 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cb9696cdcff5fe60bf2c0d942196107 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }

    tmp_or_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_debug );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }

    tmp_or_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_debugger );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;

        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_and_right_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb9696cdcff5fe60bf2c0d942196107 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb9696cdcff5fe60bf2c0d942196107 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb9696cdcff5fe60bf2c0d942196107 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cb9696cdcff5fe60bf2c0d942196107, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cb9696cdcff5fe60bf2c0d942196107->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cb9696cdcff5fe60bf2c0d942196107, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cb9696cdcff5fe60bf2c0d942196107,
        type_description_1
    );


    // Release cached frame.
    if ( frame_5cb9696cdcff5fe60bf2c0d942196107 == cache_frame_5cb9696cdcff5fe60bf2c0d942196107 )
    {
        Py_DECREF( frame_5cb9696cdcff5fe60bf2c0d942196107 );
    }
    cache_frame_5cb9696cdcff5fe60bf2c0d942196107 = NULL;

    assertFrameObject( frame_5cb9696cdcff5fe60bf2c0d942196107 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_28_isDebug );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_29_isPythonDebug( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_0b49820045f9b4d8ba0abd98800fe426 = NULL;

    struct Nuitka_FrameObject *frame_0b49820045f9b4d8ba0abd98800fe426;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_0b49820045f9b4d8ba0abd98800fe426, codeobj_0b49820045f9b4d8ba0abd98800fe426, module_Options, 0 );
    frame_0b49820045f9b4d8ba0abd98800fe426 = cache_frame_0b49820045f9b4d8ba0abd98800fe426;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b49820045f9b4d8ba0abd98800fe426 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b49820045f9b4d8ba0abd98800fe426 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }

    tmp_or_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_python_debug );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_flags );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }
    tmp_or_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_debug );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_return_value = tmp_or_left_value_1;
    or_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b49820045f9b4d8ba0abd98800fe426 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b49820045f9b4d8ba0abd98800fe426 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b49820045f9b4d8ba0abd98800fe426 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b49820045f9b4d8ba0abd98800fe426, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b49820045f9b4d8ba0abd98800fe426->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b49820045f9b4d8ba0abd98800fe426, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b49820045f9b4d8ba0abd98800fe426,
        type_description_1
    );


    // Release cached frame.
    if ( frame_0b49820045f9b4d8ba0abd98800fe426 == cache_frame_0b49820045f9b4d8ba0abd98800fe426 )
    {
        Py_DECREF( frame_0b49820045f9b4d8ba0abd98800fe426 );
    }
    cache_frame_0b49820045f9b4d8ba0abd98800fe426 = NULL;

    assertFrameObject( frame_0b49820045f9b4d8ba0abd98800fe426 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_29_isPythonDebug );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_30_isUnstripped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_1aad631595d6346be68289d6f6c64b22 = NULL;

    struct Nuitka_FrameObject *frame_1aad631595d6346be68289d6f6c64b22;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_1aad631595d6346be68289d6f6c64b22, codeobj_1aad631595d6346be68289d6f6c64b22, module_Options, 0 );
    frame_1aad631595d6346be68289d6f6c64b22 = cache_frame_1aad631595d6346be68289d6f6c64b22;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1aad631595d6346be68289d6f6c64b22 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1aad631595d6346be68289d6f6c64b22 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1021;

        goto frame_exception_exit_1;
    }

    tmp_or_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_unstripped );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;

        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1021;

        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1021;

        goto frame_exception_exit_1;
    }

    tmp_or_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_profile );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_return_value = tmp_or_left_value_1;
    or_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1aad631595d6346be68289d6f6c64b22 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1aad631595d6346be68289d6f6c64b22 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1aad631595d6346be68289d6f6c64b22 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1aad631595d6346be68289d6f6c64b22, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1aad631595d6346be68289d6f6c64b22->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1aad631595d6346be68289d6f6c64b22, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1aad631595d6346be68289d6f6c64b22,
        type_description_1
    );


    // Release cached frame.
    if ( frame_1aad631595d6346be68289d6f6c64b22 == cache_frame_1aad631595d6346be68289d6f6c64b22 )
    {
        Py_DECREF( frame_1aad631595d6346be68289d6f6c64b22 );
    }
    cache_frame_1aad631595d6346be68289d6f6c64b22 = NULL;

    assertFrameObject( frame_1aad631595d6346be68289d6f6c64b22 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_30_isUnstripped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_31_isProfile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ea6084817f5b965d979b5cee01c6a4de = NULL;

    struct Nuitka_FrameObject *frame_ea6084817f5b965d979b5cee01c6a4de;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_ea6084817f5b965d979b5cee01c6a4de, codeobj_ea6084817f5b965d979b5cee01c6a4de, module_Options, 0 );
    frame_ea6084817f5b965d979b5cee01c6a4de = cache_frame_ea6084817f5b965d979b5cee01c6a4de;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ea6084817f5b965d979b5cee01c6a4de );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ea6084817f5b965d979b5cee01c6a4de ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1025;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_profile );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea6084817f5b965d979b5cee01c6a4de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea6084817f5b965d979b5cee01c6a4de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea6084817f5b965d979b5cee01c6a4de );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ea6084817f5b965d979b5cee01c6a4de, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ea6084817f5b965d979b5cee01c6a4de->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ea6084817f5b965d979b5cee01c6a4de, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ea6084817f5b965d979b5cee01c6a4de,
        type_description_1
    );


    // Release cached frame.
    if ( frame_ea6084817f5b965d979b5cee01c6a4de == cache_frame_ea6084817f5b965d979b5cee01c6a4de )
    {
        Py_DECREF( frame_ea6084817f5b965d979b5cee01c6a4de );
    }
    cache_frame_ea6084817f5b965d979b5cee01c6a4de = NULL;

    assertFrameObject( frame_ea6084817f5b965d979b5cee01c6a4de );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_31_isProfile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_32_shallCreateGraph( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_dda6c6fc2ad31d4b75bf8ae29a203af2 = NULL;

    struct Nuitka_FrameObject *frame_dda6c6fc2ad31d4b75bf8ae29a203af2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_dda6c6fc2ad31d4b75bf8ae29a203af2, codeobj_dda6c6fc2ad31d4b75bf8ae29a203af2, module_Options, 0 );
    frame_dda6c6fc2ad31d4b75bf8ae29a203af2 = cache_frame_dda6c6fc2ad31d4b75bf8ae29a203af2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1029;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_graph );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dda6c6fc2ad31d4b75bf8ae29a203af2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dda6c6fc2ad31d4b75bf8ae29a203af2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dda6c6fc2ad31d4b75bf8ae29a203af2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dda6c6fc2ad31d4b75bf8ae29a203af2,
        type_description_1
    );


    // Release cached frame.
    if ( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 == cache_frame_dda6c6fc2ad31d4b75bf8ae29a203af2 )
    {
        Py_DECREF( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );
    }
    cache_frame_dda6c6fc2ad31d4b75bf8ae29a203af2 = NULL;

    assertFrameObject( frame_dda6c6fc2ad31d4b75bf8ae29a203af2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_32_shallCreateGraph );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_33_getOutputPath( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_path = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    static struct Nuitka_FrameObject *cache_frame_39ca76230b1066f515fe4ccee38cb42b = NULL;

    struct Nuitka_FrameObject *frame_39ca76230b1066f515fe4ccee38cb42b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_39ca76230b1066f515fe4ccee38cb42b, codeobj_39ca76230b1066f515fe4ccee38cb42b, module_Options, sizeof(void *) );
    frame_39ca76230b1066f515fe4ccee38cb42b = cache_frame_39ca76230b1066f515fe4ccee38cb42b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_39ca76230b1066f515fe4ccee38cb42b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_39ca76230b1066f515fe4ccee38cb42b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_output_dir );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1033;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_path );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_normpath );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_path );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_join );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_output_dir );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_path;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "path" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    frame_39ca76230b1066f515fe4ccee38cb42b->m_frame.f_lineno = 1034;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    frame_39ca76230b1066f515fe4ccee38cb42b->m_frame.f_lineno = 1034;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1034;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = par_path;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "path" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1036;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39ca76230b1066f515fe4ccee38cb42b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_39ca76230b1066f515fe4ccee38cb42b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39ca76230b1066f515fe4ccee38cb42b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_39ca76230b1066f515fe4ccee38cb42b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_39ca76230b1066f515fe4ccee38cb42b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_39ca76230b1066f515fe4ccee38cb42b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_39ca76230b1066f515fe4ccee38cb42b,
        type_description_1,
        par_path
    );


    // Release cached frame.
    if ( frame_39ca76230b1066f515fe4ccee38cb42b == cache_frame_39ca76230b1066f515fe4ccee38cb42b )
    {
        Py_DECREF( frame_39ca76230b1066f515fe4ccee38cb42b );
    }
    cache_frame_39ca76230b1066f515fe4ccee38cb42b = NULL;

    assertFrameObject( frame_39ca76230b1066f515fe4ccee38cb42b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_33_getOutputPath );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_path );
    par_path = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_path );
    par_path = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_33_getOutputPath );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_34_getOutputDir( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_c00d3fc69c4374d1325ec84fe1aec136 = NULL;

    struct Nuitka_FrameObject *frame_c00d3fc69c4374d1325ec84fe1aec136;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_c00d3fc69c4374d1325ec84fe1aec136, codeobj_c00d3fc69c4374d1325ec84fe1aec136, module_Options, 0 );
    frame_c00d3fc69c4374d1325ec84fe1aec136 = cache_frame_c00d3fc69c4374d1325ec84fe1aec136;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c00d3fc69c4374d1325ec84fe1aec136 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c00d3fc69c4374d1325ec84fe1aec136 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1040;

        goto frame_exception_exit_1;
    }

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_output_dir );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1040;

        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1040;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1040;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_output_dir );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1040;

        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_return_value = const_str_dot;
    Py_INCREF( tmp_return_value );
    condexpr_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c00d3fc69c4374d1325ec84fe1aec136 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c00d3fc69c4374d1325ec84fe1aec136 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c00d3fc69c4374d1325ec84fe1aec136 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c00d3fc69c4374d1325ec84fe1aec136, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c00d3fc69c4374d1325ec84fe1aec136->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c00d3fc69c4374d1325ec84fe1aec136, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c00d3fc69c4374d1325ec84fe1aec136,
        type_description_1
    );


    // Release cached frame.
    if ( frame_c00d3fc69c4374d1325ec84fe1aec136 == cache_frame_c00d3fc69c4374d1325ec84fe1aec136 )
    {
        Py_DECREF( frame_c00d3fc69c4374d1325ec84fe1aec136 );
    }
    cache_frame_c00d3fc69c4374d1325ec84fe1aec136 = NULL;

    assertFrameObject( frame_c00d3fc69c4374d1325ec84fe1aec136 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_34_getOutputDir );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_35_getPositionalArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_aaff8348fa4ec25d845604fa01fc5e66 = NULL;

    struct Nuitka_FrameObject *frame_aaff8348fa4ec25d845604fa01fc5e66;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_aaff8348fa4ec25d845604fa01fc5e66, codeobj_aaff8348fa4ec25d845604fa01fc5e66, module_Options, 0 );
    frame_aaff8348fa4ec25d845604fa01fc5e66 = cache_frame_aaff8348fa4ec25d845604fa01fc5e66;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aaff8348fa4ec25d845604fa01fc5e66 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aaff8348fa4ec25d845604fa01fc5e66 ) == 2 ); // Frame stack

    // Framed code:
    tmp_tuple_arg_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_positional_args );

    if (unlikely( tmp_tuple_arg_1 == NULL ))
    {
        tmp_tuple_arg_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_positional_args );
    }

    if ( tmp_tuple_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "positional_args" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1044;

        goto frame_exception_exit_1;
    }

    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1044;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aaff8348fa4ec25d845604fa01fc5e66 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_aaff8348fa4ec25d845604fa01fc5e66 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aaff8348fa4ec25d845604fa01fc5e66 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aaff8348fa4ec25d845604fa01fc5e66, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aaff8348fa4ec25d845604fa01fc5e66->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aaff8348fa4ec25d845604fa01fc5e66, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aaff8348fa4ec25d845604fa01fc5e66,
        type_description_1
    );


    // Release cached frame.
    if ( frame_aaff8348fa4ec25d845604fa01fc5e66 == cache_frame_aaff8348fa4ec25d845604fa01fc5e66 )
    {
        Py_DECREF( frame_aaff8348fa4ec25d845604fa01fc5e66 );
    }
    cache_frame_aaff8348fa4ec25d845604fa01fc5e66 = NULL;

    assertFrameObject( frame_aaff8348fa4ec25d845604fa01fc5e66 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_35_getPositionalArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_36_getMainArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_be0d106c45d34e95877f4996ec8d75b7 = NULL;

    struct Nuitka_FrameObject *frame_be0d106c45d34e95877f4996ec8d75b7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_be0d106c45d34e95877f4996ec8d75b7, codeobj_be0d106c45d34e95877f4996ec8d75b7, module_Options, 0 );
    frame_be0d106c45d34e95877f4996ec8d75b7 = cache_frame_be0d106c45d34e95877f4996ec8d75b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_be0d106c45d34e95877f4996ec8d75b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_be0d106c45d34e95877f4996ec8d75b7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_tuple_arg_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_extra_args );

    if (unlikely( tmp_tuple_arg_1 == NULL ))
    {
        tmp_tuple_arg_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_extra_args );
    }

    if ( tmp_tuple_arg_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "extra_args" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1048;

        goto frame_exception_exit_1;
    }

    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1048;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be0d106c45d34e95877f4996ec8d75b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_be0d106c45d34e95877f4996ec8d75b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be0d106c45d34e95877f4996ec8d75b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_be0d106c45d34e95877f4996ec8d75b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_be0d106c45d34e95877f4996ec8d75b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_be0d106c45d34e95877f4996ec8d75b7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be0d106c45d34e95877f4996ec8d75b7,
        type_description_1
    );


    // Release cached frame.
    if ( frame_be0d106c45d34e95877f4996ec8d75b7 == cache_frame_be0d106c45d34e95877f4996ec8d75b7 )
    {
        Py_DECREF( frame_be0d106c45d34e95877f4996ec8d75b7 );
    }
    cache_frame_be0d106c45d34e95877f4996ec8d75b7 = NULL;

    assertFrameObject( frame_be0d106c45d34e95877f4996ec8d75b7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_36_getMainArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_37_shallOptimizeStringExec( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_37_shallOptimizeStringExec );
    return NULL;

function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_38_shallClearPythonPathEnvironment( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_18e27c2685da591014101268dffffba2 = NULL;

    struct Nuitka_FrameObject *frame_18e27c2685da591014101268dffffba2;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_18e27c2685da591014101268dffffba2, codeobj_18e27c2685da591014101268dffffba2, module_Options, 0 );
    frame_18e27c2685da591014101268dffffba2 = cache_frame_18e27c2685da591014101268dffffba2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_18e27c2685da591014101268dffffba2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_18e27c2685da591014101268dffffba2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1056;

        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_keep_pythonpath );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;

        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;

        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18e27c2685da591014101268dffffba2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_18e27c2685da591014101268dffffba2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18e27c2685da591014101268dffffba2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_18e27c2685da591014101268dffffba2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_18e27c2685da591014101268dffffba2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_18e27c2685da591014101268dffffba2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_18e27c2685da591014101268dffffba2,
        type_description_1
    );


    // Release cached frame.
    if ( frame_18e27c2685da591014101268dffffba2 == cache_frame_18e27c2685da591014101268dffffba2 )
    {
        Py_DECREF( frame_18e27c2685da591014101268dffffba2 );
    }
    cache_frame_18e27c2685da591014101268dffffba2 = NULL;

    assertFrameObject( frame_18e27c2685da591014101268dffffba2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_38_shallClearPythonPathEnvironment );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_39_isShowScons( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_e93d2a5293ec7fe8033f75dceb597261 = NULL;

    struct Nuitka_FrameObject *frame_e93d2a5293ec7fe8033f75dceb597261;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_e93d2a5293ec7fe8033f75dceb597261, codeobj_e93d2a5293ec7fe8033f75dceb597261, module_Options, 0 );
    frame_e93d2a5293ec7fe8033f75dceb597261 = cache_frame_e93d2a5293ec7fe8033f75dceb597261;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e93d2a5293ec7fe8033f75dceb597261 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e93d2a5293ec7fe8033f75dceb597261 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1060;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_show_scons );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d2a5293ec7fe8033f75dceb597261 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d2a5293ec7fe8033f75dceb597261 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e93d2a5293ec7fe8033f75dceb597261 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e93d2a5293ec7fe8033f75dceb597261, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e93d2a5293ec7fe8033f75dceb597261->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e93d2a5293ec7fe8033f75dceb597261, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e93d2a5293ec7fe8033f75dceb597261,
        type_description_1
    );


    // Release cached frame.
    if ( frame_e93d2a5293ec7fe8033f75dceb597261 == cache_frame_e93d2a5293ec7fe8033f75dceb597261 )
    {
        Py_DECREF( frame_e93d2a5293ec7fe8033f75dceb597261 );
    }
    cache_frame_e93d2a5293ec7fe8033f75dceb597261 = NULL;

    assertFrameObject( frame_e93d2a5293ec7fe8033f75dceb597261 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_39_isShowScons );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_40_getJobLimit( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_int_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_eb11be53fb77c76d2826cff4d9c08247 = NULL;

    struct Nuitka_FrameObject *frame_eb11be53fb77c76d2826cff4d9c08247;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_eb11be53fb77c76d2826cff4d9c08247, codeobj_eb11be53fb77c76d2826cff4d9c08247, module_Options, 0 );
    frame_eb11be53fb77c76d2826cff4d9c08247 = cache_frame_eb11be53fb77c76d2826cff4d9c08247;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eb11be53fb77c76d2826cff4d9c08247 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eb11be53fb77c76d2826cff4d9c08247 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1064;

        goto frame_exception_exit_1;
    }

    tmp_int_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_jobs );
    if ( tmp_int_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1064;

        goto frame_exception_exit_1;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
    Py_DECREF( tmp_int_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1064;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb11be53fb77c76d2826cff4d9c08247 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb11be53fb77c76d2826cff4d9c08247 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb11be53fb77c76d2826cff4d9c08247 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eb11be53fb77c76d2826cff4d9c08247, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eb11be53fb77c76d2826cff4d9c08247->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eb11be53fb77c76d2826cff4d9c08247, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eb11be53fb77c76d2826cff4d9c08247,
        type_description_1
    );


    // Release cached frame.
    if ( frame_eb11be53fb77c76d2826cff4d9c08247 == cache_frame_eb11be53fb77c76d2826cff4d9c08247 )
    {
        Py_DECREF( frame_eb11be53fb77c76d2826cff4d9c08247 );
    }
    cache_frame_eb11be53fb77c76d2826cff4d9c08247 = NULL;

    assertFrameObject( frame_eb11be53fb77c76d2826cff4d9c08247 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_40_getJobLimit );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_41_isLto( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_8672f7cad8c8767f00958a426d497654 = NULL;

    struct Nuitka_FrameObject *frame_8672f7cad8c8767f00958a426d497654;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_8672f7cad8c8767f00958a426d497654, codeobj_8672f7cad8c8767f00958a426d497654, module_Options, 0 );
    frame_8672f7cad8c8767f00958a426d497654 = cache_frame_8672f7cad8c8767f00958a426d497654;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8672f7cad8c8767f00958a426d497654 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8672f7cad8c8767f00958a426d497654 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1068;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_lto );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8672f7cad8c8767f00958a426d497654 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8672f7cad8c8767f00958a426d497654 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8672f7cad8c8767f00958a426d497654 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8672f7cad8c8767f00958a426d497654, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8672f7cad8c8767f00958a426d497654->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8672f7cad8c8767f00958a426d497654, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8672f7cad8c8767f00958a426d497654,
        type_description_1
    );


    // Release cached frame.
    if ( frame_8672f7cad8c8767f00958a426d497654 == cache_frame_8672f7cad8c8767f00958a426d497654 )
    {
        Py_DECREF( frame_8672f7cad8c8767f00958a426d497654 );
    }
    cache_frame_8672f7cad8c8767f00958a426d497654 = NULL;

    assertFrameObject( frame_8672f7cad8c8767f00958a426d497654 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_41_isLto );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_42_isClang( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6f0e6a95e1ce7d0b91dae6b7e68c291b = NULL;

    struct Nuitka_FrameObject *frame_6f0e6a95e1ce7d0b91dae6b7e68c291b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_6f0e6a95e1ce7d0b91dae6b7e68c291b, codeobj_6f0e6a95e1ce7d0b91dae6b7e68c291b, module_Options, 0 );
    frame_6f0e6a95e1ce7d0b91dae6b7e68c291b = cache_frame_6f0e6a95e1ce7d0b91dae6b7e68c291b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1072;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_clang );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1072;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f0e6a95e1ce7d0b91dae6b7e68c291b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f0e6a95e1ce7d0b91dae6b7e68c291b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f0e6a95e1ce7d0b91dae6b7e68c291b,
        type_description_1
    );


    // Release cached frame.
    if ( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b == cache_frame_6f0e6a95e1ce7d0b91dae6b7e68c291b )
    {
        Py_DECREF( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );
    }
    cache_frame_6f0e6a95e1ce7d0b91dae6b7e68c291b = NULL;

    assertFrameObject( frame_6f0e6a95e1ce7d0b91dae6b7e68c291b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_42_isClang );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_43_isMingw( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_31849ef404ecd5ac3889e3bb57a82672 = NULL;

    struct Nuitka_FrameObject *frame_31849ef404ecd5ac3889e3bb57a82672;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_31849ef404ecd5ac3889e3bb57a82672, codeobj_31849ef404ecd5ac3889e3bb57a82672, module_Options, 0 );
    frame_31849ef404ecd5ac3889e3bb57a82672 = cache_frame_31849ef404ecd5ac3889e3bb57a82672;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31849ef404ecd5ac3889e3bb57a82672 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31849ef404ecd5ac3889e3bb57a82672 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1076;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mingw );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1076;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31849ef404ecd5ac3889e3bb57a82672 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_31849ef404ecd5ac3889e3bb57a82672 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31849ef404ecd5ac3889e3bb57a82672 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31849ef404ecd5ac3889e3bb57a82672, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31849ef404ecd5ac3889e3bb57a82672->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31849ef404ecd5ac3889e3bb57a82672, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31849ef404ecd5ac3889e3bb57a82672,
        type_description_1
    );


    // Release cached frame.
    if ( frame_31849ef404ecd5ac3889e3bb57a82672 == cache_frame_31849ef404ecd5ac3889e3bb57a82672 )
    {
        Py_DECREF( frame_31849ef404ecd5ac3889e3bb57a82672 );
    }
    cache_frame_31849ef404ecd5ac3889e3bb57a82672 = NULL;

    assertFrameObject( frame_31849ef404ecd5ac3889e3bb57a82672 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_43_isMingw );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_44_getMsvcVersion( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_2b41d17ce2ce901c30b6d180b922e6cc = NULL;

    struct Nuitka_FrameObject *frame_2b41d17ce2ce901c30b6d180b922e6cc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_2b41d17ce2ce901c30b6d180b922e6cc, codeobj_2b41d17ce2ce901c30b6d180b922e6cc, module_Options, 0 );
    frame_2b41d17ce2ce901c30b6d180b922e6cc = cache_frame_2b41d17ce2ce901c30b6d180b922e6cc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2b41d17ce2ce901c30b6d180b922e6cc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2b41d17ce2ce901c30b6d180b922e6cc ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1080;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_msvc );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2b41d17ce2ce901c30b6d180b922e6cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2b41d17ce2ce901c30b6d180b922e6cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2b41d17ce2ce901c30b6d180b922e6cc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2b41d17ce2ce901c30b6d180b922e6cc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2b41d17ce2ce901c30b6d180b922e6cc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2b41d17ce2ce901c30b6d180b922e6cc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2b41d17ce2ce901c30b6d180b922e6cc,
        type_description_1
    );


    // Release cached frame.
    if ( frame_2b41d17ce2ce901c30b6d180b922e6cc == cache_frame_2b41d17ce2ce901c30b6d180b922e6cc )
    {
        Py_DECREF( frame_2b41d17ce2ce901c30b6d180b922e6cc );
    }
    cache_frame_2b41d17ce2ce901c30b6d180b922e6cc = NULL;

    assertFrameObject( frame_2b41d17ce2ce901c30b6d180b922e6cc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_44_getMsvcVersion );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_45_shallDisableConsoleWindow( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_f0cd6618b75f6edee2ef0daadfe71560 = NULL;

    struct Nuitka_FrameObject *frame_f0cd6618b75f6edee2ef0daadfe71560;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_f0cd6618b75f6edee2ef0daadfe71560, codeobj_f0cd6618b75f6edee2ef0daadfe71560, module_Options, 0 );
    frame_f0cd6618b75f6edee2ef0daadfe71560 = cache_frame_f0cd6618b75f6edee2ef0daadfe71560;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f0cd6618b75f6edee2ef0daadfe71560 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f0cd6618b75f6edee2ef0daadfe71560 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1084;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_win_disable_console );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1084;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0cd6618b75f6edee2ef0daadfe71560 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0cd6618b75f6edee2ef0daadfe71560 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0cd6618b75f6edee2ef0daadfe71560 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f0cd6618b75f6edee2ef0daadfe71560, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f0cd6618b75f6edee2ef0daadfe71560->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f0cd6618b75f6edee2ef0daadfe71560, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f0cd6618b75f6edee2ef0daadfe71560,
        type_description_1
    );


    // Release cached frame.
    if ( frame_f0cd6618b75f6edee2ef0daadfe71560 == cache_frame_f0cd6618b75f6edee2ef0daadfe71560 )
    {
        Py_DECREF( frame_f0cd6618b75f6edee2ef0daadfe71560 );
    }
    cache_frame_f0cd6618b75f6edee2ef0daadfe71560 = NULL;

    assertFrameObject( frame_f0cd6618b75f6edee2ef0daadfe71560 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_45_shallDisableConsoleWindow );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_46_isFullCompat( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_167b79dc77d0a1f9967239702a9b1a97 = NULL;

    struct Nuitka_FrameObject *frame_167b79dc77d0a1f9967239702a9b1a97;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_167b79dc77d0a1f9967239702a9b1a97, codeobj_167b79dc77d0a1f9967239702a9b1a97, module_Options, 0 );
    frame_167b79dc77d0a1f9967239702a9b1a97 = cache_frame_167b79dc77d0a1f9967239702a9b1a97;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_167b79dc77d0a1f9967239702a9b1a97 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_167b79dc77d0a1f9967239702a9b1a97 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;

        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_improved );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;

        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;

        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_167b79dc77d0a1f9967239702a9b1a97 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_167b79dc77d0a1f9967239702a9b1a97 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_167b79dc77d0a1f9967239702a9b1a97 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_167b79dc77d0a1f9967239702a9b1a97, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_167b79dc77d0a1f9967239702a9b1a97->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_167b79dc77d0a1f9967239702a9b1a97, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_167b79dc77d0a1f9967239702a9b1a97,
        type_description_1
    );


    // Release cached frame.
    if ( frame_167b79dc77d0a1f9967239702a9b1a97 == cache_frame_167b79dc77d0a1f9967239702a9b1a97 )
    {
        Py_DECREF( frame_167b79dc77d0a1f9967239702a9b1a97 );
    }
    cache_frame_167b79dc77d0a1f9967239702a9b1a97 = NULL;

    assertFrameObject( frame_167b79dc77d0a1f9967239702a9b1a97 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_46_isFullCompat );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_47_isShowProgress( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_75eb440780b1b0ac66e0b2f84e064457 = NULL;

    struct Nuitka_FrameObject *frame_75eb440780b1b0ac66e0b2f84e064457;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_75eb440780b1b0ac66e0b2f84e064457, codeobj_75eb440780b1b0ac66e0b2f84e064457, module_Options, 0 );
    frame_75eb440780b1b0ac66e0b2f84e064457 = cache_frame_75eb440780b1b0ac66e0b2f84e064457;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_75eb440780b1b0ac66e0b2f84e064457 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_75eb440780b1b0ac66e0b2f84e064457 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1092;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_show_progress );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75eb440780b1b0ac66e0b2f84e064457 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_75eb440780b1b0ac66e0b2f84e064457 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_75eb440780b1b0ac66e0b2f84e064457 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_75eb440780b1b0ac66e0b2f84e064457, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_75eb440780b1b0ac66e0b2f84e064457->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_75eb440780b1b0ac66e0b2f84e064457, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_75eb440780b1b0ac66e0b2f84e064457,
        type_description_1
    );


    // Release cached frame.
    if ( frame_75eb440780b1b0ac66e0b2f84e064457 == cache_frame_75eb440780b1b0ac66e0b2f84e064457 )
    {
        Py_DECREF( frame_75eb440780b1b0ac66e0b2f84e064457 );
    }
    cache_frame_75eb440780b1b0ac66e0b2f84e064457 = NULL;

    assertFrameObject( frame_75eb440780b1b0ac66e0b2f84e064457 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_47_isShowProgress );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_48_isShowMemory( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_dc54d9f0c2c026b54c7673e3a1deb0c5 = NULL;

    struct Nuitka_FrameObject *frame_dc54d9f0c2c026b54c7673e3a1deb0c5;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_dc54d9f0c2c026b54c7673e3a1deb0c5, codeobj_dc54d9f0c2c026b54c7673e3a1deb0c5, module_Options, 0 );
    frame_dc54d9f0c2c026b54c7673e3a1deb0c5 = cache_frame_dc54d9f0c2c026b54c7673e3a1deb0c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1096;

        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1096;

        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_show_memory );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1096;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dc54d9f0c2c026b54c7673e3a1deb0c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dc54d9f0c2c026b54c7673e3a1deb0c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dc54d9f0c2c026b54c7673e3a1deb0c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dc54d9f0c2c026b54c7673e3a1deb0c5,
        type_description_1
    );


    // Release cached frame.
    if ( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 == cache_frame_dc54d9f0c2c026b54c7673e3a1deb0c5 )
    {
        Py_DECREF( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );
    }
    cache_frame_dc54d9f0c2c026b54c7673e3a1deb0c5 = NULL;

    assertFrameObject( frame_dc54d9f0c2c026b54c7673e3a1deb0c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_48_isShowMemory );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_49_isShowInclusion( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_6f66582f1988bb4e6e9266e1fc9a7269 = NULL;

    struct Nuitka_FrameObject *frame_6f66582f1988bb4e6e9266e1fc9a7269;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_6f66582f1988bb4e6e9266e1fc9a7269, codeobj_6f66582f1988bb4e6e9266e1fc9a7269, module_Options, 0 );
    frame_6f66582f1988bb4e6e9266e1fc9a7269 = cache_frame_6f66582f1988bb4e6e9266e1fc9a7269;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f66582f1988bb4e6e9266e1fc9a7269 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f66582f1988bb4e6e9266e1fc9a7269 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1100;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_show_inclusion );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f66582f1988bb4e6e9266e1fc9a7269 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f66582f1988bb4e6e9266e1fc9a7269 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f66582f1988bb4e6e9266e1fc9a7269 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f66582f1988bb4e6e9266e1fc9a7269, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f66582f1988bb4e6e9266e1fc9a7269->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f66582f1988bb4e6e9266e1fc9a7269, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f66582f1988bb4e6e9266e1fc9a7269,
        type_description_1
    );


    // Release cached frame.
    if ( frame_6f66582f1988bb4e6e9266e1fc9a7269 == cache_frame_6f66582f1988bb4e6e9266e1fc9a7269 )
    {
        Py_DECREF( frame_6f66582f1988bb4e6e9266e1fc9a7269 );
    }
    cache_frame_6f66582f1988bb4e6e9266e1fc9a7269 = NULL;

    assertFrameObject( frame_6f66582f1988bb4e6e9266e1fc9a7269 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_49_isShowInclusion );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_50_isRemoveBuildDir( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_d3df4d744514aa4a646eb001b12d4f76 = NULL;

    struct Nuitka_FrameObject *frame_d3df4d744514aa4a646eb001b12d4f76;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_d3df4d744514aa4a646eb001b12d4f76, codeobj_d3df4d744514aa4a646eb001b12d4f76, module_Options, 0 );
    frame_d3df4d744514aa4a646eb001b12d4f76 = cache_frame_d3df4d744514aa4a646eb001b12d4f76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d3df4d744514aa4a646eb001b12d4f76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d3df4d744514aa4a646eb001b12d4f76 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }

    tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_remove_build );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_generate_c_only );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1104;

        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_and_right_value_1 );
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3df4d744514aa4a646eb001b12d4f76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3df4d744514aa4a646eb001b12d4f76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3df4d744514aa4a646eb001b12d4f76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d3df4d744514aa4a646eb001b12d4f76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d3df4d744514aa4a646eb001b12d4f76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d3df4d744514aa4a646eb001b12d4f76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d3df4d744514aa4a646eb001b12d4f76,
        type_description_1
    );


    // Release cached frame.
    if ( frame_d3df4d744514aa4a646eb001b12d4f76 == cache_frame_d3df4d744514aa4a646eb001b12d4f76 )
    {
        Py_DECREF( frame_d3df4d744514aa4a646eb001b12d4f76 );
    }
    cache_frame_d3df4d744514aa4a646eb001b12d4f76 = NULL;

    assertFrameObject( frame_d3df4d744514aa4a646eb001b12d4f76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_50_isRemoveBuildDir );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_51_getIntendedPythonVersion( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_af19baa1ab5af3e1fba732aad9b40a5d = NULL;

    struct Nuitka_FrameObject *frame_af19baa1ab5af3e1fba732aad9b40a5d;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_af19baa1ab5af3e1fba732aad9b40a5d, codeobj_af19baa1ab5af3e1fba732aad9b40a5d, module_Options, 0 );
    frame_af19baa1ab5af3e1fba732aad9b40a5d = cache_frame_af19baa1ab5af3e1fba732aad9b40a5d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_af19baa1ab5af3e1fba732aad9b40a5d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_af19baa1ab5af3e1fba732aad9b40a5d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1108;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_python_version );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1108;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af19baa1ab5af3e1fba732aad9b40a5d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_af19baa1ab5af3e1fba732aad9b40a5d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af19baa1ab5af3e1fba732aad9b40a5d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_af19baa1ab5af3e1fba732aad9b40a5d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_af19baa1ab5af3e1fba732aad9b40a5d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_af19baa1ab5af3e1fba732aad9b40a5d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_af19baa1ab5af3e1fba732aad9b40a5d,
        type_description_1
    );


    // Release cached frame.
    if ( frame_af19baa1ab5af3e1fba732aad9b40a5d == cache_frame_af19baa1ab5af3e1fba732aad9b40a5d )
    {
        Py_DECREF( frame_af19baa1ab5af3e1fba732aad9b40a5d );
    }
    cache_frame_af19baa1ab5af3e1fba732aad9b40a5d = NULL;

    assertFrameObject( frame_af19baa1ab5af3e1fba732aad9b40a5d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_51_getIntendedPythonVersion );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_52_getIntendedPythonArch( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_54b9c0307687c886454ab94ba1aa079b = NULL;

    struct Nuitka_FrameObject *frame_54b9c0307687c886454ab94ba1aa079b;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_54b9c0307687c886454ab94ba1aa079b, codeobj_54b9c0307687c886454ab94ba1aa079b, module_Options, 0 );
    frame_54b9c0307687c886454ab94ba1aa079b = cache_frame_54b9c0307687c886454ab94ba1aa079b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_54b9c0307687c886454ab94ba1aa079b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_54b9c0307687c886454ab94ba1aa079b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1112;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_python_arch );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_54b9c0307687c886454ab94ba1aa079b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_54b9c0307687c886454ab94ba1aa079b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_54b9c0307687c886454ab94ba1aa079b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_54b9c0307687c886454ab94ba1aa079b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_54b9c0307687c886454ab94ba1aa079b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_54b9c0307687c886454ab94ba1aa079b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_54b9c0307687c886454ab94ba1aa079b,
        type_description_1
    );


    // Release cached frame.
    if ( frame_54b9c0307687c886454ab94ba1aa079b == cache_frame_54b9c0307687c886454ab94ba1aa079b )
    {
        Py_DECREF( frame_54b9c0307687c886454ab94ba1aa079b );
    }
    cache_frame_54b9c0307687c886454ab94ba1aa079b = NULL;

    assertFrameObject( frame_54b9c0307687c886454ab94ba1aa079b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_52_getIntendedPythonArch );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_53_isExperimental( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_indication = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_ff82744b35918d18314beabdf85850e0 = NULL;

    struct Nuitka_FrameObject *frame_ff82744b35918d18314beabdf85850e0;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff82744b35918d18314beabdf85850e0, codeobj_ff82744b35918d18314beabdf85850e0, module_Options, sizeof(void *) );
    frame_ff82744b35918d18314beabdf85850e0 = cache_frame_ff82744b35918d18314beabdf85850e0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff82744b35918d18314beabdf85850e0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff82744b35918d18314beabdf85850e0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hasattr_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_hasattr_value_1 == NULL ))
    {
        tmp_hasattr_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_hasattr_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_hasattr_attr_1 = const_str_plain_experimental;
    tmp_and_left_value_1 = BUILTIN_HASATTR( tmp_hasattr_value_1, tmp_hasattr_attr_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_compexpr_left_1 = par_indication;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_experimental );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff82744b35918d18314beabdf85850e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff82744b35918d18314beabdf85850e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff82744b35918d18314beabdf85850e0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff82744b35918d18314beabdf85850e0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff82744b35918d18314beabdf85850e0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff82744b35918d18314beabdf85850e0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff82744b35918d18314beabdf85850e0,
        type_description_1,
        par_indication
    );


    // Release cached frame.
    if ( frame_ff82744b35918d18314beabdf85850e0 == cache_frame_ff82744b35918d18314beabdf85850e0 )
    {
        Py_DECREF( frame_ff82744b35918d18314beabdf85850e0 );
    }
    cache_frame_ff82744b35918d18314beabdf85850e0 = NULL;

    assertFrameObject( frame_ff82744b35918d18314beabdf85850e0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_53_isExperimental );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_indication );
    par_indication = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_indication );
    par_indication = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_53_isExperimental );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_54_getExperimentalIndications( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a8a85772fc9aa4c76d07fffd99c28d26 = NULL;

    struct Nuitka_FrameObject *frame_a8a85772fc9aa4c76d07fffd99c28d26;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_a8a85772fc9aa4c76d07fffd99c28d26, codeobj_a8a85772fc9aa4c76d07fffd99c28d26, module_Options, 0 );
    frame_a8a85772fc9aa4c76d07fffd99c28d26 = cache_frame_a8a85772fc9aa4c76d07fffd99c28d26;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a8a85772fc9aa4c76d07fffd99c28d26 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a8a85772fc9aa4c76d07fffd99c28d26 ) == 2 ); // Frame stack

    // Framed code:
    tmp_hasattr_source_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_hasattr_source_1 == NULL ))
    {
        tmp_hasattr_source_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_hasattr_source_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1122;

        goto frame_exception_exit_1;
    }

    tmp_hasattr_attr_1 = const_str_plain_experimental;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;

        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1123;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_experimental );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1123;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = const_tuple_empty;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a85772fc9aa4c76d07fffd99c28d26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a85772fc9aa4c76d07fffd99c28d26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a85772fc9aa4c76d07fffd99c28d26 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a8a85772fc9aa4c76d07fffd99c28d26, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a8a85772fc9aa4c76d07fffd99c28d26->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a8a85772fc9aa4c76d07fffd99c28d26, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8a85772fc9aa4c76d07fffd99c28d26,
        type_description_1
    );


    // Release cached frame.
    if ( frame_a8a85772fc9aa4c76d07fffd99c28d26 == cache_frame_a8a85772fc9aa4c76d07fffd99c28d26 )
    {
        Py_DECREF( frame_a8a85772fc9aa4c76d07fffd99c28d26 );
    }
    cache_frame_a8a85772fc9aa4c76d07fffd99c28d26 = NULL;

    assertFrameObject( frame_a8a85772fc9aa4c76d07fffd99c28d26 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_54_getExperimentalIndications );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_55_shallExplainImports( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_65d4f032c8c5f79bc382c9337a929478 = NULL;

    struct Nuitka_FrameObject *frame_65d4f032c8c5f79bc382c9337a929478;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_65d4f032c8c5f79bc382c9337a929478, codeobj_65d4f032c8c5f79bc382c9337a929478, module_Options, 0 );
    frame_65d4f032c8c5f79bc382c9337a929478 = cache_frame_65d4f032c8c5f79bc382c9337a929478;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_65d4f032c8c5f79bc382c9337a929478 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_65d4f032c8c5f79bc382c9337a929478 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1129;

        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1129;

        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_explain_imports );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1129;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65d4f032c8c5f79bc382c9337a929478 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_65d4f032c8c5f79bc382c9337a929478 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65d4f032c8c5f79bc382c9337a929478 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_65d4f032c8c5f79bc382c9337a929478, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_65d4f032c8c5f79bc382c9337a929478->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_65d4f032c8c5f79bc382c9337a929478, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_65d4f032c8c5f79bc382c9337a929478,
        type_description_1
    );


    // Release cached frame.
    if ( frame_65d4f032c8c5f79bc382c9337a929478 == cache_frame_65d4f032c8c5f79bc382c9337a929478 )
    {
        Py_DECREF( frame_65d4f032c8c5f79bc382c9337a929478 );
    }
    cache_frame_65d4f032c8c5f79bc382c9337a929478 = NULL;

    assertFrameObject( frame_65d4f032c8c5f79bc382c9337a929478 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_55_shallExplainImports );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_56_isStandaloneMode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_596a1bb6fd8eea4f8b16844aeb8159ed = NULL;

    struct Nuitka_FrameObject *frame_596a1bb6fd8eea4f8b16844aeb8159ed;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_596a1bb6fd8eea4f8b16844aeb8159ed, codeobj_596a1bb6fd8eea4f8b16844aeb8159ed, module_Options, 0 );
    frame_596a1bb6fd8eea4f8b16844aeb8159ed = cache_frame_596a1bb6fd8eea4f8b16844aeb8159ed;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_596a1bb6fd8eea4f8b16844aeb8159ed );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_596a1bb6fd8eea4f8b16844aeb8159ed ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1133;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_is_standalone );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1133;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_596a1bb6fd8eea4f8b16844aeb8159ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_596a1bb6fd8eea4f8b16844aeb8159ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_596a1bb6fd8eea4f8b16844aeb8159ed );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_596a1bb6fd8eea4f8b16844aeb8159ed, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_596a1bb6fd8eea4f8b16844aeb8159ed->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_596a1bb6fd8eea4f8b16844aeb8159ed, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_596a1bb6fd8eea4f8b16844aeb8159ed,
        type_description_1
    );


    // Release cached frame.
    if ( frame_596a1bb6fd8eea4f8b16844aeb8159ed == cache_frame_596a1bb6fd8eea4f8b16844aeb8159ed )
    {
        Py_DECREF( frame_596a1bb6fd8eea4f8b16844aeb8159ed );
    }
    cache_frame_596a1bb6fd8eea4f8b16844aeb8159ed = NULL;

    assertFrameObject( frame_596a1bb6fd8eea4f8b16844aeb8159ed );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_56_isStandaloneMode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_57_getIconPath( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_d78116b19c5a705c69847ce6f0f0a6e8 = NULL;

    struct Nuitka_FrameObject *frame_d78116b19c5a705c69847ce6f0f0a6e8;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_d78116b19c5a705c69847ce6f0f0a6e8, codeobj_d78116b19c5a705c69847ce6f0f0a6e8, module_Options, 0 );
    frame_d78116b19c5a705c69847ce6f0f0a6e8 = cache_frame_d78116b19c5a705c69847ce6f0f0a6e8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d78116b19c5a705c69847ce6f0f0a6e8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d78116b19c5a705c69847ce6f0f0a6e8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1137;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_icon_path );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1137;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d78116b19c5a705c69847ce6f0f0a6e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d78116b19c5a705c69847ce6f0f0a6e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d78116b19c5a705c69847ce6f0f0a6e8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d78116b19c5a705c69847ce6f0f0a6e8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d78116b19c5a705c69847ce6f0f0a6e8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d78116b19c5a705c69847ce6f0f0a6e8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d78116b19c5a705c69847ce6f0f0a6e8,
        type_description_1
    );


    // Release cached frame.
    if ( frame_d78116b19c5a705c69847ce6f0f0a6e8 == cache_frame_d78116b19c5a705c69847ce6f0f0a6e8 )
    {
        Py_DECREF( frame_d78116b19c5a705c69847ce6f0f0a6e8 );
    }
    cache_frame_d78116b19c5a705c69847ce6f0f0a6e8 = NULL;

    assertFrameObject( frame_d78116b19c5a705c69847ce6f0f0a6e8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_57_getIconPath );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_58_getPythonFlags( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_parts = NULL;
    PyObject *var_part = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_name_1;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_In_3;
    int tmp_cmp_In_4;
    int tmp_cmp_In_5;
    int tmp_cmp_In_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    PyObject *tmp_value_name_2;
    static struct Nuitka_FrameObject *cache_frame_16065475bb34579370f7f78a96f24fa6 = NULL;

    struct Nuitka_FrameObject *frame_16065475bb34579370f7f78a96f24fa6;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_16065475bb34579370f7f78a96f24fa6, codeobj_16065475bb34579370f7f78a96f24fa6, module_Options, sizeof(void *)+sizeof(void *) );
    frame_16065475bb34579370f7f78a96f24fa6 = cache_frame_16065475bb34579370f7f78a96f24fa6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_16065475bb34579370f7f78a96f24fa6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_16065475bb34579370f7f78a96f24fa6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_compare_left_1 == NULL ))
    {
        tmp_compare_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1145;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = PySet_New( NULL );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags, tmp_assign_source_1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1148;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_python_flags );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oo";
        exception_lineno = 1148;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_2 = exception_keeper_type_1;
    tmp_compare_right_2 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1148;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_parts;
        var_parts = tmp_assign_source_4;
        Py_INCREF( var_parts );
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = var_parts;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1149;
    tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_44_tuple, 0 ) );

    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_2:;
    // Tried code:
    tmp_value_name_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_value_name_2 );
    tmp_assign_source_6 = ITERATOR_NEXT( tmp_value_name_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oo";
        exception_lineno = 1149;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_3 = exception_keeper_type_2;
    tmp_compare_right_3 = PyExc_StopIteration;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1149;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    Py_DECREF( exception_keeper_type_2 );
    Py_XDECREF( exception_keeper_value_2 );
    Py_XDECREF( exception_keeper_tb_2 );
    goto loop_end_2;
    goto branch_end_3;
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    branch_end_3:;
    // End of try:
    try_end_2:;
    tmp_assign_source_7 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_part;
        var_part = tmp_assign_source_7;
        Py_INCREF( var_part );
        Py_XDECREF( old );
    }

    tmp_compare_left_4 = var_part;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = const_tuple_a600f0f9128ffb175215423ade3fd2d4_tuple;
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1151;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1151;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_add, &PyTuple_GET_ITEM( const_tuple_str_plain_no_site_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1151;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_4;
    branch_no_4:;
    tmp_compare_left_5 = var_part;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = const_tuple_b7bdfcebb4d682a901187c529bdfc6f0_tuple;
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1154;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1154;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_add, &PyTuple_GET_ITEM( const_tuple_str_plain_no_randomization_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_5;
    branch_no_5:;
    tmp_compare_left_6 = var_part;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = const_tuple_2b03baaeafc58d3a60df70141a55ec11_tuple;
    tmp_cmp_In_3 = PySequence_Contains( tmp_compare_right_6, tmp_compare_left_6 );
    assert( !(tmp_cmp_In_3 == -1) );
    if ( tmp_cmp_In_3 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1156;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1156;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_add, &PyTuple_GET_ITEM( const_tuple_str_plain_trace_imports_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1156;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_6;
    branch_no_6:;
    tmp_compare_left_7 = var_part;

    CHECK_OBJECT( tmp_compare_left_7 );
    tmp_compare_right_7 = const_tuple_str_plain_no_warnings_str_plain_nowarnings_tuple;
    tmp_cmp_In_4 = PySequence_Contains( tmp_compare_right_7, tmp_compare_left_7 );
    assert( !(tmp_cmp_In_4 == -1) );
    if ( tmp_cmp_In_4 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1158;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1158;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_add, &PyTuple_GET_ITEM( const_tuple_str_plain_no_warnings_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_7;
    branch_no_7:;
    tmp_compare_left_8 = var_part;

    CHECK_OBJECT( tmp_compare_left_8 );
    tmp_compare_right_8 = const_tuple_b4a3ba64ce61f2ba82fcc202427015c6_tuple;
    tmp_cmp_In_5 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    assert( !(tmp_cmp_In_5 == -1) );
    if ( tmp_cmp_In_5 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_called_instance_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_called_instance_6 == NULL ))
    {
        tmp_called_instance_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1160;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1160;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_add, &PyTuple_GET_ITEM( const_tuple_str_plain_no_asserts_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_9 = const_str_plain_PYTHONHASHSEED;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1163;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    tmp_compare_right_9 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_environ );
    if ( tmp_compare_right_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1163;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    tmp_cmp_In_6 = PySequence_Contains( tmp_compare_right_9, tmp_compare_left_9 );
    Py_DECREF( tmp_compare_right_9 );
    assert( !(tmp_cmp_In_6 == -1) );
    if ( tmp_cmp_In_6 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_logging );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "logging" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_warning );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    tmp_args_element_name_1 = const_str_digest_915928a8f3046246eea03ff37578bdf9;
    tmp_args_element_name_2 = var_part;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "part" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }

    frame_16065475bb34579370f7f78a96f24fa6->m_frame.f_lineno = 1164;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    branch_no_9:;
    branch_end_8:;
    branch_end_7:;
    branch_end_6:;
    branch_end_5:;
    branch_end_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description_1 = "oo";
        goto try_except_handler_4;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_1:;
    tmp_return_value = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags );

    if (unlikely( tmp_return_value == NULL ))
    {
        tmp_return_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__python_flags );
    }

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_python_flags" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1166;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16065475bb34579370f7f78a96f24fa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_16065475bb34579370f7f78a96f24fa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16065475bb34579370f7f78a96f24fa6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_16065475bb34579370f7f78a96f24fa6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_16065475bb34579370f7f78a96f24fa6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_16065475bb34579370f7f78a96f24fa6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16065475bb34579370f7f78a96f24fa6,
        type_description_1,
        var_parts,
        var_part
    );


    // Release cached frame.
    if ( frame_16065475bb34579370f7f78a96f24fa6 == cache_frame_16065475bb34579370f7f78a96f24fa6 )
    {
        Py_DECREF( frame_16065475bb34579370f7f78a96f24fa6 );
    }
    cache_frame_16065475bb34579370f7f78a96f24fa6 = NULL;

    assertFrameObject( frame_16065475bb34579370f7f78a96f24fa6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_58_getPythonFlags );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_part );
    var_part = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_part );
    var_part = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_58_getPythonFlags );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_59_shallFreezeAllStdlib( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_called_name_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_36b3d12f9a457ad2a3e9ae488c75f2bc = NULL;

    struct Nuitka_FrameObject *frame_36b3d12f9a457ad2a3e9ae488c75f2bc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_36b3d12f9a457ad2a3e9ae488c75f2bc, codeobj_36b3d12f9a457ad2a3e9ae488c75f2bc, module_Options, 0 );
    frame_36b3d12f9a457ad2a3e9ae488c75f2bc = cache_frame_36b3d12f9a457ad2a3e9ae488c75f2bc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_36b3d12f9a457ad2a3e9ae488c75f2bc ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallFollowStandardLibrary );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_shallFollowStandardLibrary );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "shallFollowStandardLibrary" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1170;

        goto frame_exception_exit_1;
    }

    frame_36b3d12f9a457ad2a3e9ae488c75f2bc->m_frame.f_lineno = 1170;
    tmp_operand_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1170;

        goto frame_exception_exit_1;
    }
    tmp_return_value = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1170;

        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_36b3d12f9a457ad2a3e9ae488c75f2bc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_36b3d12f9a457ad2a3e9ae488c75f2bc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_36b3d12f9a457ad2a3e9ae488c75f2bc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36b3d12f9a457ad2a3e9ae488c75f2bc,
        type_description_1
    );


    // Release cached frame.
    if ( frame_36b3d12f9a457ad2a3e9ae488c75f2bc == cache_frame_36b3d12f9a457ad2a3e9ae488c75f2bc )
    {
        Py_DECREF( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );
    }
    cache_frame_36b3d12f9a457ad2a3e9ae488c75f2bc = NULL;

    assertFrameObject( frame_36b3d12f9a457ad2a3e9ae488c75f2bc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_59_shallFreezeAllStdlib );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_60_shallNotUseDependsExeCachedResults( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_360248c43c527dc9e1429c3c2d08eeee = NULL;

    struct Nuitka_FrameObject *frame_360248c43c527dc9e1429c3c2d08eeee;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_360248c43c527dc9e1429c3c2d08eeee, codeobj_360248c43c527dc9e1429c3c2d08eeee, module_Options, 0 );
    frame_360248c43c527dc9e1429c3c2d08eeee = cache_frame_360248c43c527dc9e1429c3c2d08eeee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_360248c43c527dc9e1429c3c2d08eeee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_360248c43c527dc9e1429c3c2d08eeee ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1174;

        goto frame_exception_exit_1;
    }

    tmp_or_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_no_dependency_cache );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1174;

        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1174;

        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1174;

        goto frame_exception_exit_1;
    }

    tmp_or_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_update_dependency_cache );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1174;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_return_value = tmp_or_left_value_1;
    or_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_360248c43c527dc9e1429c3c2d08eeee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_360248c43c527dc9e1429c3c2d08eeee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_360248c43c527dc9e1429c3c2d08eeee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_360248c43c527dc9e1429c3c2d08eeee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_360248c43c527dc9e1429c3c2d08eeee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_360248c43c527dc9e1429c3c2d08eeee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_360248c43c527dc9e1429c3c2d08eeee,
        type_description_1
    );


    // Release cached frame.
    if ( frame_360248c43c527dc9e1429c3c2d08eeee == cache_frame_360248c43c527dc9e1429c3c2d08eeee )
    {
        Py_DECREF( frame_360248c43c527dc9e1429c3c2d08eeee );
    }
    cache_frame_360248c43c527dc9e1429c3c2d08eeee = NULL;

    assertFrameObject( frame_360248c43c527dc9e1429c3c2d08eeee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_60_shallNotUseDependsExeCachedResults );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_61_shallNotStoreDependsExeCachedResults( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a7f578fb789af89c76c3dfd82e67226f = NULL;

    struct Nuitka_FrameObject *frame_a7f578fb789af89c76c3dfd82e67226f;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_a7f578fb789af89c76c3dfd82e67226f, codeobj_a7f578fb789af89c76c3dfd82e67226f, module_Options, 0 );
    frame_a7f578fb789af89c76c3dfd82e67226f = cache_frame_a7f578fb789af89c76c3dfd82e67226f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a7f578fb789af89c76c3dfd82e67226f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a7f578fb789af89c76c3dfd82e67226f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1178;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_no_dependency_cache );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1178;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a7f578fb789af89c76c3dfd82e67226f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a7f578fb789af89c76c3dfd82e67226f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a7f578fb789af89c76c3dfd82e67226f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a7f578fb789af89c76c3dfd82e67226f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a7f578fb789af89c76c3dfd82e67226f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a7f578fb789af89c76c3dfd82e67226f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a7f578fb789af89c76c3dfd82e67226f,
        type_description_1
    );


    // Release cached frame.
    if ( frame_a7f578fb789af89c76c3dfd82e67226f == cache_frame_a7f578fb789af89c76c3dfd82e67226f )
    {
        Py_DECREF( frame_a7f578fb789af89c76c3dfd82e67226f );
    }
    cache_frame_a7f578fb789af89c76c3dfd82e67226f = NULL;

    assertFrameObject( frame_a7f578fb789af89c76c3dfd82e67226f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_61_shallNotStoreDependsExeCachedResults );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_62_shallListPlugins( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_fcfca8aede2e0b4a92a0f5ee107de9e7 = NULL;

    struct Nuitka_FrameObject *frame_fcfca8aede2e0b4a92a0f5ee107de9e7;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_fcfca8aede2e0b4a92a0f5ee107de9e7, codeobj_fcfca8aede2e0b4a92a0f5ee107de9e7, module_Options, 0 );
    frame_fcfca8aede2e0b4a92a0f5ee107de9e7 = cache_frame_fcfca8aede2e0b4a92a0f5ee107de9e7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1182;

        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1182;

        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_list_plugins );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1182;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fcfca8aede2e0b4a92a0f5ee107de9e7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fcfca8aede2e0b4a92a0f5ee107de9e7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fcfca8aede2e0b4a92a0f5ee107de9e7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fcfca8aede2e0b4a92a0f5ee107de9e7,
        type_description_1
    );


    // Release cached frame.
    if ( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 == cache_frame_fcfca8aede2e0b4a92a0f5ee107de9e7 )
    {
        Py_DECREF( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );
    }
    cache_frame_fcfca8aede2e0b4a92a0f5ee107de9e7 = NULL;

    assertFrameObject( frame_fcfca8aede2e0b4a92a0f5ee107de9e7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_62_shallListPlugins );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_63_getPluginsEnabled( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_result = NULL;
    PyObject *var_plugin_enabled = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_arg_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_2a53c9c37badde19d78b2a36fe3875dc = NULL;

    struct Nuitka_FrameObject *frame_2a53c9c37badde19d78b2a36fe3875dc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PySet_New( NULL );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2a53c9c37badde19d78b2a36fe3875dc, codeobj_2a53c9c37badde19d78b2a36fe3875dc, module_Options, sizeof(void *)+sizeof(void *) );
    frame_2a53c9c37badde19d78b2a36fe3875dc = cache_frame_2a53c9c37badde19d78b2a36fe3875dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2a53c9c37badde19d78b2a36fe3875dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2a53c9c37badde19d78b2a36fe3875dc ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1191;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_plugins_enabled );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "oo";
        exception_lineno = 1192;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1192;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_plugin_enabled;
        var_plugin_enabled = tmp_assign_source_4;
        Py_INCREF( var_plugin_enabled );
        Py_XDECREF( old );
    }

    tmp_source_name_2 = var_result;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_add );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_called_instance_1 = var_plugin_enabled;

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "plugin_enabled" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }

    frame_2a53c9c37badde19d78b2a36fe3875dc->m_frame.f_lineno = 1193;
    tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_61_int_pos_1_tuple, 0 ) );

    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    frame_2a53c9c37badde19d78b2a36fe3875dc->m_frame.f_lineno = 1193;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1193;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_1:;
    tmp_tuple_arg_1 = var_result;

    if ( tmp_tuple_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1195;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a53c9c37badde19d78b2a36fe3875dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a53c9c37badde19d78b2a36fe3875dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2a53c9c37badde19d78b2a36fe3875dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2a53c9c37badde19d78b2a36fe3875dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2a53c9c37badde19d78b2a36fe3875dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2a53c9c37badde19d78b2a36fe3875dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2a53c9c37badde19d78b2a36fe3875dc,
        type_description_1,
        var_result,
        var_plugin_enabled
    );


    // Release cached frame.
    if ( frame_2a53c9c37badde19d78b2a36fe3875dc == cache_frame_2a53c9c37badde19d78b2a36fe3875dc )
    {
        Py_DECREF( frame_2a53c9c37badde19d78b2a36fe3875dc );
    }
    cache_frame_2a53c9c37badde19d78b2a36fe3875dc = NULL;

    assertFrameObject( frame_2a53c9c37badde19d78b2a36fe3875dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_63_getPluginsEnabled );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_plugin_enabled );
    var_plugin_enabled = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_plugin_enabled );
    var_plugin_enabled = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_63_getPluginsEnabled );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_64_getPluginOptions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_plugin_name = python_pars[ 0 ];
    PyObject *var_result = NULL;
    PyObject *var_plugin_enabled = NULL;
    PyObject *var_name = NULL;
    PyObject *var_args = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    PyObject *tmp_value_name_1;
    static struct Nuitka_FrameObject *cache_frame_491df70ab21e3f1d09686b30ddc39c24 = NULL;

    struct Nuitka_FrameObject *frame_491df70ab21e3f1d09686b30ddc39c24;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_result == NULL );
    var_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_491df70ab21e3f1d09686b30ddc39c24, codeobj_491df70ab21e3f1d09686b30ddc39c24, module_Options, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_491df70ab21e3f1d09686b30ddc39c24 = cache_frame_491df70ab21e3f1d09686b30ddc39c24;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_491df70ab21e3f1d09686b30ddc39c24 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_491df70ab21e3f1d09686b30ddc39c24 ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1204;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_plugins_enabled );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    // Tried code:
    tmp_value_name_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_value_name_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_value_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 1205;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    tmp_compare_left_1 = exception_keeper_type_1;
    tmp_compare_right_1 = PyExc_StopIteration;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );

        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    Py_DECREF( exception_keeper_type_1 );
    Py_XDECREF( exception_keeper_value_1 );
    Py_XDECREF( exception_keeper_tb_1 );
    goto loop_end_1;
    goto branch_end_2;
    branch_no_2:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    branch_end_2:;
    // End of try:
    try_end_1:;
    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_plugin_enabled;
        var_plugin_enabled = tmp_assign_source_4;
        Py_INCREF( var_plugin_enabled );
        Py_XDECREF( old );
    }

    tmp_compare_left_2 = const_str_chr_61;
    tmp_compare_right_2 = var_plugin_enabled;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    goto loop_start_1;
    branch_no_3:;
    // Tried code:
    tmp_called_instance_1 = var_plugin_enabled;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "plugin_enabled" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1209;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }

    frame_491df70ab21e3f1d09686b30ddc39c24->m_frame.f_lineno = 1209;
    tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_61_int_pos_1_tuple, 0 ) );

    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1209;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1209;
        type_description_1 = "ooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 1209;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description_1 = "ooooo";
        exception_lineno = 1209;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "ooooo";
                exception_lineno = 1209;
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description_1 = "ooooo";
        exception_lineno = 1209;
        goto try_except_handler_5;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_4;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_8;
        Py_INCREF( var_name );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_9 );
    {
        PyObject *old = var_args;
        var_args = tmp_assign_source_9;
        Py_INCREF( var_args );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_3 = var_name;

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_3 = par_plugin_name;

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "plugin_name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1211;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_2 = var_result;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_extend );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_2 = var_args;

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "args" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }

    frame_491df70ab21e3f1d09686b30ddc39c24->m_frame.f_lineno = 1212;
    tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_44_tuple, 0 ) );

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    frame_491df70ab21e3f1d09686b30ddc39c24->m_frame.f_lineno = 1212;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_1:;
    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1214;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_491df70ab21e3f1d09686b30ddc39c24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_491df70ab21e3f1d09686b30ddc39c24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_491df70ab21e3f1d09686b30ddc39c24 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_491df70ab21e3f1d09686b30ddc39c24, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_491df70ab21e3f1d09686b30ddc39c24->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_491df70ab21e3f1d09686b30ddc39c24, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_491df70ab21e3f1d09686b30ddc39c24,
        type_description_1,
        par_plugin_name,
        var_result,
        var_plugin_enabled,
        var_name,
        var_args
    );


    // Release cached frame.
    if ( frame_491df70ab21e3f1d09686b30ddc39c24 == cache_frame_491df70ab21e3f1d09686b30ddc39c24 )
    {
        Py_DECREF( frame_491df70ab21e3f1d09686b30ddc39c24 );
    }
    cache_frame_491df70ab21e3f1d09686b30ddc39c24 = NULL;

    assertFrameObject( frame_491df70ab21e3f1d09686b30ddc39c24 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( Options$$$function_64_getPluginOptions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_plugin_name );
    par_plugin_name = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_plugin_enabled );
    var_plugin_enabled = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_args );
    var_args = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_plugin_name );
    par_plugin_name = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_plugin_enabled );
    var_plugin_enabled = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_args );
    var_args = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_64_getPluginOptions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_65_getPluginsDisabled( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_set_arg_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_arg_1;
    static struct Nuitka_FrameObject *cache_frame_884b504793f584ec870f8bcbada6556a = NULL;

    struct Nuitka_FrameObject *frame_884b504793f584ec870f8bcbada6556a;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_884b504793f584ec870f8bcbada6556a, codeobj_884b504793f584ec870f8bcbada6556a, module_Options, 0 );
    frame_884b504793f584ec870f8bcbada6556a = cache_frame_884b504793f584ec870f8bcbada6556a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_884b504793f584ec870f8bcbada6556a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_884b504793f584ec870f8bcbada6556a ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1221;

        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1221;

        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = const_tuple_empty;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1224;

        goto frame_exception_exit_1;
    }

    tmp_set_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_plugins_disabled );
    if ( tmp_set_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1224;

        goto frame_exception_exit_1;
    }
    tmp_tuple_arg_1 = PySet_New( tmp_set_arg_1 );
    Py_DECREF( tmp_set_arg_1 );
    if ( tmp_tuple_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1224;

        goto frame_exception_exit_1;
    }
    tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
    Py_DECREF( tmp_tuple_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1224;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_884b504793f584ec870f8bcbada6556a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_884b504793f584ec870f8bcbada6556a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_884b504793f584ec870f8bcbada6556a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_884b504793f584ec870f8bcbada6556a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_884b504793f584ec870f8bcbada6556a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_884b504793f584ec870f8bcbada6556a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_884b504793f584ec870f8bcbada6556a,
        type_description_1
    );


    // Release cached frame.
    if ( frame_884b504793f584ec870f8bcbada6556a == cache_frame_884b504793f584ec870f8bcbada6556a )
    {
        Py_DECREF( frame_884b504793f584ec870f8bcbada6556a );
    }
    cache_frame_884b504793f584ec870f8bcbada6556a = NULL;

    assertFrameObject( frame_884b504793f584ec870f8bcbada6556a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_65_getPluginsDisabled );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_66_shallDetectMissingPlugins( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc = NULL;

    struct Nuitka_FrameObject *frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc, codeobj_b29a7a4e6a10a5d2c9fdbd62c0de0ecc, module_Options, 0 );
    frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc = cache_frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_compexpr_left_1 == NULL ))
    {
        tmp_compexpr_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_compexpr_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1228;

        goto frame_exception_exit_1;
    }

    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1228;

        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_detect_missing_plugins );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1228;

        goto frame_exception_exit_1;
    }
    tmp_return_value = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_return_value = tmp_and_left_value_1;
    and_end_1:;
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc,
        type_description_1
    );


    // Release cached frame.
    if ( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc == cache_frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc )
    {
        Py_DECREF( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );
    }
    cache_frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc = NULL;

    assertFrameObject( frame_b29a7a4e6a10a5d2c9fdbd62c0de0ecc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_66_shallDetectMissingPlugins );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}


static PyObject *impl_Options$$$function_67_getPythonPathForScons( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_4bd96c049702e1671d294217f1aa0e22 = NULL;

    struct Nuitka_FrameObject *frame_4bd96c049702e1671d294217f1aa0e22;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_4bd96c049702e1671d294217f1aa0e22, codeobj_4bd96c049702e1671d294217f1aa0e22, module_Options, 0 );
    frame_4bd96c049702e1671d294217f1aa0e22 = cache_frame_4bd96c049702e1671d294217f1aa0e22;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4bd96c049702e1671d294217f1aa0e22 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4bd96c049702e1671d294217f1aa0e22 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_options );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1232;

        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_python_scons );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1232;

        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bd96c049702e1671d294217f1aa0e22 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bd96c049702e1671d294217f1aa0e22 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bd96c049702e1671d294217f1aa0e22 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4bd96c049702e1671d294217f1aa0e22, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4bd96c049702e1671d294217f1aa0e22->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4bd96c049702e1671d294217f1aa0e22, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4bd96c049702e1671d294217f1aa0e22,
        type_description_1
    );


    // Release cached frame.
    if ( frame_4bd96c049702e1671d294217f1aa0e22 == cache_frame_4bd96c049702e1671d294217f1aa0e22 )
    {
        Py_DECREF( frame_4bd96c049702e1671d294217f1aa0e22 );
    }
    cache_frame_4bd96c049702e1671d294217f1aa0e22 = NULL;

    assertFrameObject( frame_4bd96c049702e1671d294217f1aa0e22 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( Options$$$function_67_getPythonPathForScons );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
function_return_exit:

CHECK_OBJECT( tmp_return_value );
assert( had_error || !ERROR_OCCURRED() );
return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_Options$$$function_10_shallHaveStatementLines(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_10_shallHaveStatementLines,
        const_str_plain_shallHaveStatementLines,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_970832abd8d359a2679a1bab059e0b97,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_11_getFileReferenceMode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_11_getFileReferenceMode,
        const_str_plain_getFileReferenceMode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_272528bf4636d442d00d6a18b95d85dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_12_shallMakeModule(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_12_shallMakeModule,
        const_str_plain_shallMakeModule,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d1da03d8bcb10c9f5aed4a9294699f4f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_13_shallCreatePyiFile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_13_shallCreatePyiFile,
        const_str_plain_shallCreatePyiFile,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_737c97aa48d786ecb227db57f52a9e87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_14_isAllowedToReexecute(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_14_isAllowedToReexecute,
        const_str_plain_isAllowedToReexecute,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_740beeaa8324802bf1747ce98c5bbb53,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_15_shallFollowStandardLibrary(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_15_shallFollowStandardLibrary,
        const_str_plain_shallFollowStandardLibrary,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8a6dd9706c10f994c6de2227774ada4a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_16_shallFollowNoImports(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_16_shallFollowNoImports,
        const_str_plain_shallFollowNoImports,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_94734671575e56910016a914e03510a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_17_shallFollowAllImports(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_17_shallFollowAllImports,
        const_str_plain_shallFollowAllImports,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c46af5b2d77cf0b451ac6599684abc48,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_18__splitShellPattern(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_18__splitShellPattern,
        const_str_plain__splitShellPattern,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ff896619f018e5169268dd4e6352a0fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_19_getShallFollowInNoCase(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_19_getShallFollowInNoCase,
        const_str_plain_getShallFollowInNoCase,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1e83e4d70cf7aacbd8c100d6e42e6b9a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_1_parseArgs(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_1_parseArgs,
        const_str_plain_parseArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_df973e9887ec6e2e08a9939e8b7c75a5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_20_getShallFollowModules(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_20_getShallFollowModules,
        const_str_plain_getShallFollowModules,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_505945e7d1254f4132a1d5ce2a8071d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_21_getShallFollowExtra(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_21_getShallFollowExtra,
        const_str_plain_getShallFollowExtra,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_95ca596c1c70767c7c1e62f9209438e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_22_getShallFollowExtraFilePatterns(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_22_getShallFollowExtraFilePatterns,
        const_str_plain_getShallFollowExtraFilePatterns,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6d1b960b567971407ddf22e61c4cf1fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_23_getMustIncludeModules(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_23_getMustIncludeModules,
        const_str_plain_getMustIncludeModules,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d0e72dd5176d8fb44a2a894177240eee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_24_getMustIncludePackages(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_24_getMustIncludePackages,
        const_str_plain_getMustIncludePackages,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a521c517b8991aad61def47b5f4d695b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_25_shallWarnImplicitRaises(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_25_shallWarnImplicitRaises,
        const_str_plain_shallWarnImplicitRaises,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_84a94085338dd777dbd28747a2105f2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_26_shallWarnUnusualCode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_26_shallWarnUnusualCode,
        const_str_plain_shallWarnUnusualCode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_11c54a3e55595eff4de75e4e8a1668d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_27_assumeYesForDownloads(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_27_assumeYesForDownloads,
        const_str_plain_assumeYesForDownloads,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e9568ec9f2372518858530f1e368f07b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_28_isDebug(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_28_isDebug,
        const_str_plain_isDebug,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5cb9696cdcff5fe60bf2c0d942196107,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_29_isPythonDebug(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_29_isPythonDebug,
        const_str_plain_isPythonDebug,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0b49820045f9b4d8ba0abd98800fe426,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_2_isVerbose(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_2_isVerbose,
        const_str_plain_isVerbose,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7654c6e5a4f8ea52a929d8d7178b3bf6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_30_isUnstripped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_30_isUnstripped,
        const_str_plain_isUnstripped,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1aad631595d6346be68289d6f6c64b22,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_31_isProfile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_31_isProfile,
        const_str_plain_isProfile,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ea6084817f5b965d979b5cee01c6a4de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_32_shallCreateGraph(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_32_shallCreateGraph,
        const_str_plain_shallCreateGraph,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dda6c6fc2ad31d4b75bf8ae29a203af2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_33_getOutputPath(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_33_getOutputPath,
        const_str_plain_getOutputPath,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_39ca76230b1066f515fe4ccee38cb42b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_34_getOutputDir(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_34_getOutputDir,
        const_str_plain_getOutputDir,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c00d3fc69c4374d1325ec84fe1aec136,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_35_getPositionalArgs(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_35_getPositionalArgs,
        const_str_plain_getPositionalArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aaff8348fa4ec25d845604fa01fc5e66,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_36_getMainArgs(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_36_getMainArgs,
        const_str_plain_getMainArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_be0d106c45d34e95877f4996ec8d75b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_37_shallOptimizeStringExec(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_37_shallOptimizeStringExec,
        const_str_plain_shallOptimizeStringExec,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5cbb78624ee9adc6c7063694ecaa2d72,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_38_shallClearPythonPathEnvironment(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_38_shallClearPythonPathEnvironment,
        const_str_plain_shallClearPythonPathEnvironment,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_18e27c2685da591014101268dffffba2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_39_isShowScons(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_39_isShowScons,
        const_str_plain_isShowScons,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e93d2a5293ec7fe8033f75dceb597261,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_3_shallTraceExecution(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_3_shallTraceExecution,
        const_str_plain_shallTraceExecution,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5aa04e625a24c00a60c719e5a7b846fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_40_getJobLimit(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_40_getJobLimit,
        const_str_plain_getJobLimit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eb11be53fb77c76d2826cff4d9c08247,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_41_isLto(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_41_isLto,
        const_str_plain_isLto,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8672f7cad8c8767f00958a426d497654,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_42_isClang(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_42_isClang,
        const_str_plain_isClang,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6f0e6a95e1ce7d0b91dae6b7e68c291b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_43_isMingw(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_43_isMingw,
        const_str_plain_isMingw,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_31849ef404ecd5ac3889e3bb57a82672,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_44_getMsvcVersion(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_44_getMsvcVersion,
        const_str_plain_getMsvcVersion,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2b41d17ce2ce901c30b6d180b922e6cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_45_shallDisableConsoleWindow(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_45_shallDisableConsoleWindow,
        const_str_plain_shallDisableConsoleWindow,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f0cd6618b75f6edee2ef0daadfe71560,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_46_isFullCompat(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_46_isFullCompat,
        const_str_plain_isFullCompat,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_167b79dc77d0a1f9967239702a9b1a97,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_47_isShowProgress(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_47_isShowProgress,
        const_str_plain_isShowProgress,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_75eb440780b1b0ac66e0b2f84e064457,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_48_isShowMemory(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_48_isShowMemory,
        const_str_plain_isShowMemory,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dc54d9f0c2c026b54c7673e3a1deb0c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_49_isShowInclusion(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_49_isShowInclusion,
        const_str_plain_isShowInclusion,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6f66582f1988bb4e6e9266e1fc9a7269,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_4_shallExecuteImmediately(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_4_shallExecuteImmediately,
        const_str_plain_shallExecuteImmediately,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ad2ad9fb53912298f58d6ca738392edc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_50_isRemoveBuildDir(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_50_isRemoveBuildDir,
        const_str_plain_isRemoveBuildDir,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d3df4d744514aa4a646eb001b12d4f76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_51_getIntendedPythonVersion(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_51_getIntendedPythonVersion,
        const_str_plain_getIntendedPythonVersion,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_af19baa1ab5af3e1fba732aad9b40a5d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_52_getIntendedPythonArch(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_52_getIntendedPythonArch,
        const_str_plain_getIntendedPythonArch,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_54b9c0307687c886454ab94ba1aa079b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_53_isExperimental(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_53_isExperimental,
        const_str_plain_isExperimental,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ff82744b35918d18314beabdf85850e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        const_str_digest_91374e86cd95854fdf69256ea2446159,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_54_getExperimentalIndications(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_54_getExperimentalIndications,
        const_str_plain_getExperimentalIndications,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a8a85772fc9aa4c76d07fffd99c28d26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_55_shallExplainImports(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_55_shallExplainImports,
        const_str_plain_shallExplainImports,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_65d4f032c8c5f79bc382c9337a929478,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_56_isStandaloneMode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_56_isStandaloneMode,
        const_str_plain_isStandaloneMode,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_596a1bb6fd8eea4f8b16844aeb8159ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_57_getIconPath(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_57_getIconPath,
        const_str_plain_getIconPath,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d78116b19c5a705c69847ce6f0f0a6e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_58_getPythonFlags(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_58_getPythonFlags,
        const_str_plain_getPythonFlags,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_16065475bb34579370f7f78a96f24fa6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_59_shallFreezeAllStdlib(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_59_shallFreezeAllStdlib,
        const_str_plain_shallFreezeAllStdlib,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_36b3d12f9a457ad2a3e9ae488c75f2bc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_5_shallRunInDebugger(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_5_shallRunInDebugger,
        const_str_plain_shallRunInDebugger,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_97446d6c273ab6be83f8d8c8d7870fcd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_60_shallNotUseDependsExeCachedResults(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_60_shallNotUseDependsExeCachedResults,
        const_str_plain_shallNotUseDependsExeCachedResults,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_360248c43c527dc9e1429c3c2d08eeee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_61_shallNotStoreDependsExeCachedResults(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_61_shallNotStoreDependsExeCachedResults,
        const_str_plain_shallNotStoreDependsExeCachedResults,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a7f578fb789af89c76c3dfd82e67226f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_62_shallListPlugins(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_62_shallListPlugins,
        const_str_plain_shallListPlugins,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fcfca8aede2e0b4a92a0f5ee107de9e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_63_getPluginsEnabled(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_63_getPluginsEnabled,
        const_str_plain_getPluginsEnabled,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2a53c9c37badde19d78b2a36fe3875dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        const_str_digest_9f25c19858b77b731128c72d40e5f5b1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_64_getPluginOptions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_64_getPluginOptions,
        const_str_plain_getPluginOptions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_491df70ab21e3f1d09686b30ddc39c24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        const_str_digest_0c22f7af7b0a4fa33a79410137285596,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_65_getPluginsDisabled(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_65_getPluginsDisabled,
        const_str_plain_getPluginsDisabled,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_884b504793f584ec870f8bcbada6556a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        const_str_digest_ea23ff8606bc48a7cd2ae9210fd4a7d3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_66_shallDetectMissingPlugins(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_66_shallDetectMissingPlugins,
        const_str_plain_shallDetectMissingPlugins,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b29a7a4e6a10a5d2c9fdbd62c0de0ecc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_67_getPythonPathForScons(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_67_getPythonPathForScons,
        const_str_plain_getPythonPathForScons,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4bd96c049702e1671d294217f1aa0e22,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_6_shallDumpBuiltTreeXML(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_6_shallDumpBuiltTreeXML,
        const_str_plain_shallDumpBuiltTreeXML,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0311dc3f50b2a8f7c24f49e1af94c2b2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_7_shallDisplayBuiltTree(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_7_shallDisplayBuiltTree,
        const_str_plain_shallDisplayBuiltTree,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_413469e92c4e424cdec39269f5c5d5ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_8_shallOnlyExecCCompilerCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_8_shallOnlyExecCCompilerCall,
        const_str_plain_shallOnlyExecCCompilerCall,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fc00721a4ae8a87da2a5540240c9b0aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_Options$$$function_9_shallNotDoExecCCompilerCall(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_Options$$$function_9_shallNotDoExecCCompilerCall,
        const_str_plain_shallNotDoExecCCompilerCall,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ddd75748bd61bcf23a75d38c2797002f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_Options,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_Options =
{
    PyModuleDef_HEAD_INIT,
    "Options",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___spec__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( Options )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_Options );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("Options: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("Options: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("Options: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initOptions" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_Options = Py_InitModule4(
        "Options",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_Options = PyModule_Create( &mdef_Options );
#endif

    moduledict_Options = MODULE_DICT( module_Options );

    // Update "__package__" value to what it ought to be.
    {
#if 0
#if PYTHON_VERSION < 300 || PYTHON_VERSION >= 330
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_Options,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#endif

#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_Options,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#elif PYTHON_VERSION < 330
        UPDATE_STRING_DICT1(
            moduledict_Options,
            (Nuitka_StringObject *)const_str_plain___package__,
            Py_None
        );
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_Options,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_Options );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_plain_Options, module_Options );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 330
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___loader__, metapath_based_loader );
#endif

#if PYTHON_VERSION >= 340
#if 0
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain___name__ ),
            metapath_based_loader
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );

        UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );

        Py_DECREF( module_spec_class );
    }
#endif
#endif


    // Temp variables if any
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_args_name_3;
    PyObject *tmp_args_name_4;
    PyObject *tmp_args_name_5;
    PyObject *tmp_args_name_6;
    PyObject *tmp_args_name_7;
    PyObject *tmp_args_name_8;
    PyObject *tmp_args_name_9;
    PyObject *tmp_args_name_10;
    PyObject *tmp_args_name_11;
    PyObject *tmp_args_name_12;
    PyObject *tmp_args_name_13;
    PyObject *tmp_args_name_14;
    PyObject *tmp_args_name_15;
    PyObject *tmp_args_name_16;
    PyObject *tmp_args_name_17;
    PyObject *tmp_args_name_18;
    PyObject *tmp_args_name_19;
    PyObject *tmp_args_name_20;
    PyObject *tmp_args_name_21;
    PyObject *tmp_args_name_22;
    PyObject *tmp_args_name_23;
    PyObject *tmp_args_name_24;
    PyObject *tmp_args_name_25;
    PyObject *tmp_args_name_26;
    PyObject *tmp_args_name_27;
    PyObject *tmp_args_name_28;
    PyObject *tmp_args_name_29;
    PyObject *tmp_args_name_30;
    PyObject *tmp_args_name_31;
    PyObject *tmp_args_name_32;
    PyObject *tmp_args_name_33;
    PyObject *tmp_args_name_34;
    PyObject *tmp_args_name_35;
    PyObject *tmp_args_name_36;
    PyObject *tmp_args_name_37;
    PyObject *tmp_args_name_38;
    PyObject *tmp_args_name_39;
    PyObject *tmp_args_name_40;
    PyObject *tmp_args_name_41;
    PyObject *tmp_args_name_42;
    PyObject *tmp_args_name_43;
    PyObject *tmp_args_name_44;
    PyObject *tmp_args_name_45;
    PyObject *tmp_args_name_46;
    PyObject *tmp_args_name_47;
    PyObject *tmp_args_name_48;
    PyObject *tmp_args_name_49;
    PyObject *tmp_args_name_50;
    PyObject *tmp_args_name_51;
    PyObject *tmp_args_name_52;
    PyObject *tmp_args_name_53;
    PyObject *tmp_args_name_54;
    PyObject *tmp_args_name_55;
    PyObject *tmp_args_name_56;
    PyObject *tmp_args_name_57;
    PyObject *tmp_args_name_58;
    PyObject *tmp_args_name_59;
    PyObject *tmp_args_name_60;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_called_name_32;
    PyObject *tmp_called_name_33;
    PyObject *tmp_called_name_34;
    PyObject *tmp_called_name_35;
    PyObject *tmp_called_name_36;
    PyObject *tmp_called_name_37;
    PyObject *tmp_called_name_38;
    PyObject *tmp_called_name_39;
    PyObject *tmp_called_name_40;
    PyObject *tmp_called_name_41;
    PyObject *tmp_called_name_42;
    PyObject *tmp_called_name_43;
    PyObject *tmp_called_name_44;
    PyObject *tmp_called_name_45;
    PyObject *tmp_called_name_46;
    PyObject *tmp_called_name_47;
    PyObject *tmp_called_name_48;
    PyObject *tmp_called_name_49;
    PyObject *tmp_called_name_50;
    PyObject *tmp_called_name_51;
    PyObject *tmp_called_name_52;
    PyObject *tmp_called_name_53;
    PyObject *tmp_called_name_54;
    PyObject *tmp_called_name_55;
    PyObject *tmp_called_name_56;
    PyObject *tmp_called_name_57;
    PyObject *tmp_called_name_58;
    PyObject *tmp_called_name_59;
    PyObject *tmp_called_name_60;
    PyObject *tmp_called_name_61;
    PyObject *tmp_called_name_62;
    PyObject *tmp_called_name_63;
    PyObject *tmp_called_name_64;
    PyObject *tmp_called_name_65;
    PyObject *tmp_called_name_66;
    PyObject *tmp_called_name_67;
    PyObject *tmp_called_name_68;
    PyObject *tmp_called_name_69;
    PyObject *tmp_called_name_70;
    PyObject *tmp_called_name_71;
    PyObject *tmp_called_name_72;
    PyObject *tmp_called_name_73;
    PyObject *tmp_called_name_74;
    PyObject *tmp_called_name_75;
    PyObject *tmp_called_name_76;
    PyObject *tmp_called_name_77;
    PyObject *tmp_called_name_78;
    PyObject *tmp_called_name_79;
    PyObject *tmp_called_name_80;
    PyObject *tmp_called_name_81;
    PyObject *tmp_called_name_82;
    PyObject *tmp_called_name_83;
    PyObject *tmp_called_name_84;
    PyObject *tmp_called_name_85;
    PyObject *tmp_called_name_86;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_key_10;
    PyObject *tmp_dict_key_11;
    PyObject *tmp_dict_key_12;
    PyObject *tmp_dict_key_13;
    PyObject *tmp_dict_key_14;
    PyObject *tmp_dict_key_15;
    PyObject *tmp_dict_key_16;
    PyObject *tmp_dict_key_17;
    PyObject *tmp_dict_key_18;
    PyObject *tmp_dict_key_19;
    PyObject *tmp_dict_key_20;
    PyObject *tmp_dict_key_21;
    PyObject *tmp_dict_key_22;
    PyObject *tmp_dict_key_23;
    PyObject *tmp_dict_key_24;
    PyObject *tmp_dict_key_25;
    PyObject *tmp_dict_key_26;
    PyObject *tmp_dict_key_27;
    PyObject *tmp_dict_key_28;
    PyObject *tmp_dict_key_29;
    PyObject *tmp_dict_key_30;
    PyObject *tmp_dict_key_31;
    PyObject *tmp_dict_key_32;
    PyObject *tmp_dict_key_33;
    PyObject *tmp_dict_key_34;
    PyObject *tmp_dict_key_35;
    PyObject *tmp_dict_key_36;
    PyObject *tmp_dict_key_37;
    PyObject *tmp_dict_key_38;
    PyObject *tmp_dict_key_39;
    PyObject *tmp_dict_key_40;
    PyObject *tmp_dict_key_41;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_dict_value_10;
    PyObject *tmp_dict_value_11;
    PyObject *tmp_dict_value_12;
    PyObject *tmp_dict_value_13;
    PyObject *tmp_dict_value_14;
    PyObject *tmp_dict_value_15;
    PyObject *tmp_dict_value_16;
    PyObject *tmp_dict_value_17;
    PyObject *tmp_dict_value_18;
    PyObject *tmp_dict_value_19;
    PyObject *tmp_dict_value_20;
    PyObject *tmp_dict_value_21;
    PyObject *tmp_dict_value_22;
    PyObject *tmp_dict_value_23;
    PyObject *tmp_dict_value_24;
    PyObject *tmp_dict_value_25;
    PyObject *tmp_dict_value_26;
    PyObject *tmp_dict_value_27;
    PyObject *tmp_dict_value_28;
    PyObject *tmp_dict_value_29;
    PyObject *tmp_dict_value_30;
    PyObject *tmp_dict_value_31;
    PyObject *tmp_dict_value_32;
    PyObject *tmp_dict_value_33;
    PyObject *tmp_dict_value_34;
    PyObject *tmp_dict_value_35;
    PyObject *tmp_dict_value_36;
    PyObject *tmp_dict_value_37;
    PyObject *tmp_dict_value_38;
    PyObject *tmp_dict_value_39;
    PyObject *tmp_dict_value_40;
    PyObject *tmp_dict_value_41;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_kw_name_4;
    PyObject *tmp_kw_name_5;
    PyObject *tmp_kw_name_6;
    PyObject *tmp_kw_name_7;
    PyObject *tmp_kw_name_8;
    PyObject *tmp_kw_name_9;
    PyObject *tmp_kw_name_10;
    PyObject *tmp_kw_name_11;
    PyObject *tmp_kw_name_12;
    PyObject *tmp_kw_name_13;
    PyObject *tmp_kw_name_14;
    PyObject *tmp_kw_name_15;
    PyObject *tmp_kw_name_16;
    PyObject *tmp_kw_name_17;
    PyObject *tmp_kw_name_18;
    PyObject *tmp_kw_name_19;
    PyObject *tmp_kw_name_20;
    PyObject *tmp_kw_name_21;
    PyObject *tmp_kw_name_22;
    PyObject *tmp_kw_name_23;
    PyObject *tmp_kw_name_24;
    PyObject *tmp_kw_name_25;
    PyObject *tmp_kw_name_26;
    PyObject *tmp_kw_name_27;
    PyObject *tmp_kw_name_28;
    PyObject *tmp_kw_name_29;
    PyObject *tmp_kw_name_30;
    PyObject *tmp_kw_name_31;
    PyObject *tmp_kw_name_32;
    PyObject *tmp_kw_name_33;
    PyObject *tmp_kw_name_34;
    PyObject *tmp_kw_name_35;
    PyObject *tmp_kw_name_36;
    PyObject *tmp_kw_name_37;
    PyObject *tmp_kw_name_38;
    PyObject *tmp_kw_name_39;
    PyObject *tmp_kw_name_40;
    PyObject *tmp_kw_name_41;
    PyObject *tmp_kw_name_42;
    PyObject *tmp_kw_name_43;
    PyObject *tmp_kw_name_44;
    PyObject *tmp_kw_name_45;
    PyObject *tmp_kw_name_46;
    PyObject *tmp_kw_name_47;
    PyObject *tmp_kw_name_48;
    PyObject *tmp_kw_name_49;
    PyObject *tmp_kw_name_50;
    PyObject *tmp_kw_name_51;
    PyObject *tmp_kw_name_52;
    PyObject *tmp_kw_name_53;
    PyObject *tmp_kw_name_54;
    PyObject *tmp_kw_name_55;
    PyObject *tmp_kw_name_56;
    PyObject *tmp_kw_name_57;
    PyObject *tmp_kw_name_58;
    PyObject *tmp_kw_name_59;
    PyObject *tmp_kw_name_60;
    PyObject *tmp_kw_name_61;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_level_name_1;
    PyObject *tmp_level_name_2;
    PyObject *tmp_level_name_3;
    PyObject *tmp_level_name_4;
    PyObject *tmp_level_name_5;
    PyObject *tmp_level_name_6;
    PyObject *tmp_level_name_7;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    int tmp_res;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_source_name_25;
    PyObject *tmp_source_name_26;
    PyObject *tmp_source_name_27;
    PyObject *tmp_source_name_28;
    PyObject *tmp_source_name_29;
    PyObject *tmp_source_name_30;
    PyObject *tmp_source_name_31;
    PyObject *tmp_source_name_32;
    PyObject *tmp_source_name_33;
    PyObject *tmp_source_name_34;
    PyObject *tmp_source_name_35;
    PyObject *tmp_source_name_36;
    PyObject *tmp_source_name_37;
    PyObject *tmp_source_name_38;
    PyObject *tmp_source_name_39;
    PyObject *tmp_source_name_40;
    PyObject *tmp_source_name_41;
    PyObject *tmp_source_name_42;
    PyObject *tmp_source_name_43;
    PyObject *tmp_source_name_44;
    PyObject *tmp_source_name_45;
    PyObject *tmp_source_name_46;
    PyObject *tmp_source_name_47;
    PyObject *tmp_source_name_48;
    PyObject *tmp_source_name_49;
    PyObject *tmp_source_name_50;
    PyObject *tmp_source_name_51;
    PyObject *tmp_source_name_52;
    PyObject *tmp_source_name_53;
    PyObject *tmp_source_name_54;
    PyObject *tmp_source_name_55;
    PyObject *tmp_source_name_56;
    PyObject *tmp_source_name_57;
    PyObject *tmp_source_name_58;
    PyObject *tmp_source_name_59;
    PyObject *tmp_source_name_60;
    PyObject *tmp_source_name_61;
    PyObject *tmp_source_name_62;
    PyObject *tmp_source_name_63;
    PyObject *tmp_source_name_64;
    PyObject *tmp_source_name_65;
    PyObject *tmp_source_name_66;
    PyObject *tmp_source_name_67;
    PyObject *tmp_source_name_68;
    PyObject *tmp_source_name_69;
    PyObject *tmp_source_name_70;
    PyObject *tmp_source_name_71;
    PyObject *tmp_source_name_72;
    PyObject *tmp_source_name_73;
    PyObject *tmp_source_name_74;
    PyObject *tmp_source_name_75;
    PyObject *tmp_source_name_76;
    PyObject *tmp_source_name_77;
    PyObject *tmp_source_name_78;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    struct Nuitka_FrameObject *frame_c58a6b313fcc56d855cb1583debb45f4;

    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;

    // Module code.
    tmp_assign_source_1 = const_str_digest_7c20112af2aeaa07afafa72120d096df;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = const_str_digest_7b113117fd237deaef422d3a4d7e9c32;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = Py_None;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    // Frame without reuse.
    frame_c58a6b313fcc56d855cb1583debb45f4 = MAKE_MODULE_FRAME( codeobj_c58a6b313fcc56d855cb1583debb45f4, module_Options );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_c58a6b313fcc56d855cb1583debb45f4 );
    assert( Py_REFCNT( frame_c58a6b313fcc56d855cb1583debb45f4 ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_plain_logging;
    tmp_globals_name_1 = (PyObject *)moduledict_Options;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_level_name_1 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 20;
    tmp_assign_source_4 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_logging, tmp_assign_source_4 );
    tmp_name_name_2 = const_str_plain_os;
    tmp_globals_name_2 = (PyObject *)moduledict_Options;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    tmp_level_name_2 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 21;
    tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 21;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_5 );
    tmp_name_name_3 = const_str_plain_sys;
    tmp_globals_name_3 = (PyObject *)moduledict_Options;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = Py_None;
    tmp_level_name_3 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 22;
    tmp_assign_source_6 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
    assert( !(tmp_assign_source_6 == NULL) );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_6 );
    tmp_name_name_4 = const_str_plain_optparse;
    tmp_globals_name_4 = (PyObject *)moduledict_Options;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = const_tuple_c7a39c80c7af73462cf398bc2b6621cf_tuple;
    tmp_level_name_4 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 23;
    tmp_assign_source_7 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_1__module == NULL );
    tmp_import_from_1__module = tmp_assign_source_7;

    // Tried code:
    tmp_import_name_from_1 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_1 );
    tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_SUPPRESS_HELP );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP, tmp_assign_source_8 );
    tmp_import_name_from_2 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_2 );
    tmp_assign_source_9 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_OptionGroup );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup, tmp_assign_source_9 );
    tmp_import_name_from_3 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_3 );
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_OptionParser );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionParser, tmp_assign_source_10 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_5 = const_str_plain_PythonVersions;
    tmp_globals_name_5 = (PyObject *)moduledict_Options;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = const_tuple_str_plain_getSupportedPythonVersions_tuple;
    tmp_level_name_5 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 25;
    tmp_import_name_from_4 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 25;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_getSupportedPythonVersions );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 25;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getSupportedPythonVersions, tmp_assign_source_11 );
    tmp_name_name_6 = const_str_plain_utils;
    tmp_globals_name_6 = (PyObject *)moduledict_Options;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_str_plain_Utils_tuple;
    tmp_level_name_6 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 26;
    tmp_import_name_from_5 = IMPORT_MODULE5( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_Utils );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_Utils, tmp_assign_source_12 );
    tmp_name_name_7 = const_str_plain_Version;
    tmp_globals_name_7 = (PyObject *)moduledict_Options;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = const_tuple_str_plain_getNuitkaVersion_tuple;
    tmp_level_name_7 = const_int_0;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 27;
    tmp_import_name_from_6 = IMPORT_MODULE5( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_getNuitkaVersion );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 27;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getNuitkaVersion, tmp_assign_source_13 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 31;

        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_path );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_basename );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 31;

        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_argv );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_0;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 31;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_called_instance_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 31;
    tmp_called_instance_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_lower );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 31;
    tmp_assign_source_14 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_endswith, &PyTuple_GET_ITEM( const_tuple_str_digest_07c984f555862c5fe07a79469d5a22eb_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_is_nuitka_run, tmp_assign_source_14 );
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );
    }

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 33;

        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_assign_source_15 = const_str_digest_a13bdb5e65543fe6e94f114a56984c5c;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_usage, tmp_assign_source_15 );
    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_16 = const_str_digest_ea57b1d8c130aaa1d4daa0d4f3dbdac0;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_usage, tmp_assign_source_16 );
    branch_end_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionParser );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionParser );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionParser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 38;

        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_usage;
    tmp_dict_value_1 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_usage );

    if (unlikely( tmp_dict_value_1 == NULL ))
    {
        tmp_dict_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_usage );
    }

    CHECK_OBJECT( tmp_dict_value_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_version;
    tmp_source_name_4 = const_str_newline;
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_join );
    assert( !(tmp_called_name_3 == NULL) );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getNuitkaVersion );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getNuitkaVersion );
    }

    if ( tmp_called_name_4 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getNuitkaVersion" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 42;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 42;
    tmp_tuple_element_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 42;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = PyTuple_New( 3 );
    PyTuple_SET_ITEM( tmp_args_element_name_2, 0, tmp_tuple_element_1 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 43;

        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_version );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 43;

        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_element_name_2, 1, tmp_tuple_element_1 );
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 44;

        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_executable );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 44;

        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_element_name_2, 2, tmp_tuple_element_1 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 40;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 40;

        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 38;
    tmp_assign_source_17 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 38;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser, tmp_assign_source_17 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_add_option );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 50;

        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_str_digest_eb2a748be8fdd84357bb51822fa7dd48_tuple;
    tmp_dict_key_3 = const_str_plain_action;
    tmp_dict_value_3 = const_str_plain_store_true;
    tmp_kw_name_2 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_dest;
    tmp_dict_value_4 = const_str_plain_obsolete_executable;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_4, tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_default;
    tmp_dict_value_5 = Py_False;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_help;
    tmp_dict_value_6 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_6 == NULL ))
    {
        tmp_dict_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 55;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 50;
    tmp_unused = CALL_FUNCTION( tmp_called_name_5, tmp_args_name_1, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 50;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 58;

        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_add_option );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;

        goto frame_exception_exit_1;
    }
    tmp_args_name_2 = const_tuple_str_digest_a947f6ac24fa6a97b6c8bf181ce52cb6_tuple;
    tmp_kw_name_3 = PyDict_Copy( const_dict_f55c75937f11f826e31f0719c4fa9c96 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 58;
    tmp_unused = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_2, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 67;

        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_add_option );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;

        goto frame_exception_exit_1;
    }
    tmp_args_name_3 = const_tuple_dfa13117464e5f55a384729e762e1638_tuple;
    tmp_kw_name_4 = PyDict_Copy( const_dict_b81c98a4816e9ddb7651bd033b7215d2 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 67;
    tmp_unused = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_3, tmp_kw_name_4 );
    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_kw_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 81;

        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_add_option );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;

        goto frame_exception_exit_1;
    }
    tmp_args_name_4 = const_tuple_str_digest_0a0aff9f62f0d1e8c59663305c25a371_tuple;
    tmp_dict_key_7 = const_str_plain_action;
    tmp_dict_value_7 = const_str_plain_store;
    tmp_kw_name_5 = _PyDict_NewPresized( 5 );
    tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_7, tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_dest;
    tmp_dict_value_8 = const_str_plain_python_version;
    tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_8, tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_choices;
    tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getSupportedPythonVersions );

    if (unlikely( tmp_called_name_9 == NULL ))
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getSupportedPythonVersions );
    }

    if ( tmp_called_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_kw_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "getSupportedPythonVersions" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 85;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 85;
    tmp_dict_value_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_9 );
    if ( tmp_dict_value_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_kw_name_5 );

        exception_lineno = 85;

        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_9, tmp_dict_value_9 );
    Py_DECREF( tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_10 = const_str_plain_default;
    tmp_dict_value_10 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_10, tmp_dict_value_10 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_11 = const_str_plain_help;
    tmp_dict_value_11 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_11 == NULL ))
    {
        tmp_dict_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_11 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_kw_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 87;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_11, tmp_dict_value_11 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 81;
    tmp_unused = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_4, tmp_kw_name_5 );
    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_kw_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 96;

        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;

        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_str_plain_nt;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ_NORECURSE( tmp_compare_left_1, tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;

        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 97;

        goto frame_exception_exit_1;
    }

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_add_option );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 97;

        goto frame_exception_exit_1;
    }
    tmp_args_name_5 = const_tuple_str_digest_268bd5cadede0ba0322c51dab58060ed_tuple;
    tmp_dict_key_12 = const_str_plain_action;
    tmp_dict_value_12 = const_str_plain_store;
    tmp_kw_name_6 = _PyDict_NewPresized( 5 );
    tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_12, tmp_dict_value_12 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_13 = const_str_plain_dest;
    tmp_dict_value_13 = const_str_plain_python_arch;
    tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_13, tmp_dict_value_13 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_14 = const_str_plain_choices;
    tmp_dict_value_14 = const_tuple_str_plain_x86_str_plain_x86_64_tuple;
    tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_14, tmp_dict_value_14 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_15 = const_str_plain_default;
    tmp_dict_value_15 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_15, tmp_dict_value_15 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_16 = const_str_plain_help;
    tmp_left_name_1 = const_str_digest_f265ec4f445f7dafa56a7c60cf81c5b9;
    tmp_called_instance_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_Utils );

    if (unlikely( tmp_called_instance_3 == NULL ))
    {
        tmp_called_instance_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Utils );
    }

    if ( tmp_called_instance_3 == NULL )
    {
        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_kw_name_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Utils" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 106;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 106;
    tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getArchitecture );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_kw_name_6 );

        exception_lineno = 106;

        goto frame_exception_exit_1;
    }
    tmp_dict_value_16 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_dict_value_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_kw_name_6 );

        exception_lineno = 105;

        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_16, tmp_dict_value_16 );
    Py_DECREF( tmp_dict_value_16 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 97;
    tmp_unused = CALL_FUNCTION( tmp_called_name_10, tmp_args_name_5, tmp_kw_name_6 );
    Py_DECREF( tmp_called_name_10 );
    Py_DECREF( tmp_kw_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 97;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 110;

        goto frame_exception_exit_1;
    }

    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_add_option );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 110;

        goto frame_exception_exit_1;
    }
    tmp_args_name_6 = const_tuple_e4cb1538d3263a5929c47e9b9ad8e0ca_tuple;
    tmp_kw_name_7 = PyDict_Copy( const_dict_d1f0ccc2f13cc00c28313115feff62ba );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 110;
    tmp_unused = CALL_FUNCTION( tmp_called_name_11, tmp_args_name_6, tmp_kw_name_7 );
    Py_DECREF( tmp_called_name_11 );
    Py_DECREF( tmp_kw_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 110;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 120;

        goto frame_exception_exit_1;
    }

    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_add_option );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 120;

        goto frame_exception_exit_1;
    }
    tmp_args_name_7 = const_tuple_str_digest_18e517f9850452ab3cf33b46e8bcada9_tuple;
    tmp_kw_name_8 = DEEP_COPY( const_dict_570f8765b523a6b072016db58acd7292 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 120;
    tmp_unused = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_7, tmp_kw_name_8 );
    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_kw_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 120;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_15 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_15 == NULL ))
    {
        tmp_source_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 133;

        goto frame_exception_exit_1;
    }

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_add_option );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;

        goto frame_exception_exit_1;
    }
    tmp_args_name_8 = const_tuple_6a4e2a16b6c2151a91df21cd0a488536_tuple;
    tmp_kw_name_9 = PyDict_Copy( const_dict_d80a95aa8a24826f03f1bbcb02e0d877 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 133;
    tmp_unused = CALL_FUNCTION( tmp_called_name_13, tmp_args_name_8, tmp_kw_name_9 );
    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_kw_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 144;

        goto frame_exception_exit_1;
    }

    tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_add_option );
    if ( tmp_called_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;

        goto frame_exception_exit_1;
    }
    tmp_args_name_9 = const_tuple_str_digest_9a09f3be7c40522696df04272854d4ad_tuple;
    tmp_kw_name_10 = PyDict_Copy( const_dict_a3622bcc2795e0b4e6bb780eab3dc833 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 144;
    tmp_unused = CALL_FUNCTION( tmp_called_name_14, tmp_args_name_9, tmp_kw_name_10 );
    Py_DECREF( tmp_called_name_14 );
    Py_DECREF( tmp_kw_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_17 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_17 == NULL ))
    {
        tmp_source_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 153;

        goto frame_exception_exit_1;
    }

    tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_add_option );
    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;

        goto frame_exception_exit_1;
    }
    tmp_args_name_10 = const_tuple_str_digest_ef48d902fc32bf8f11ba290ed22dfe84_tuple;
    tmp_kw_name_11 = PyDict_Copy( const_dict_95ccfece433c6f6c934c3808a3f69f19 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 153;
    tmp_unused = CALL_FUNCTION( tmp_called_name_15, tmp_args_name_10, tmp_kw_name_11 );
    Py_DECREF( tmp_called_name_15 );
    Py_DECREF( tmp_kw_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 162;

        goto frame_exception_exit_1;
    }

    tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_add_option );
    if ( tmp_called_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;

        goto frame_exception_exit_1;
    }
    tmp_args_name_11 = const_tuple_str_digest_77b02a1a563d330fd51e8c9e7358129e_tuple;
    tmp_kw_name_12 = PyDict_Copy( const_dict_3f4bd6c51d5048274ce90a44405017b0 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 162;
    tmp_unused = CALL_FUNCTION( tmp_called_name_16, tmp_args_name_11, tmp_kw_name_12 );
    Py_DECREF( tmp_called_name_16 );
    Py_DECREF( tmp_kw_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 172;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_3 == NULL ))
    {
        tmp_args_element_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 173;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_str_digest_274157aee680c8eed59b3be6f77587cd;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 172;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_18 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_17, call_args );
    }

    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_include_group, tmp_assign_source_18 );
    tmp_source_name_19 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_include_group );

    if (unlikely( tmp_source_name_19 == NULL ))
    {
        tmp_source_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_include_group );
    }

    CHECK_OBJECT( tmp_source_name_19 );
    tmp_called_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_add_option );
    if ( tmp_called_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;

        goto frame_exception_exit_1;
    }
    tmp_args_name_12 = const_tuple_str_digest_e43d4cacd6596c1a1dddfdccaa3715a1_tuple;
    tmp_kw_name_13 = DEEP_COPY( const_dict_75ac81846735ba336e897a41798a025c );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 177;
    tmp_unused = CALL_FUNCTION( tmp_called_name_18, tmp_args_name_12, tmp_kw_name_13 );
    Py_DECREF( tmp_called_name_18 );
    Py_DECREF( tmp_kw_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_include_group );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_include_group );
    }

    if ( tmp_source_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "include_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 190;

        goto frame_exception_exit_1;
    }

    tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_add_option );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;

        goto frame_exception_exit_1;
    }
    tmp_args_name_13 = const_tuple_str_digest_e83450d8f459f012a8e64edb69727742_tuple;
    tmp_kw_name_14 = DEEP_COPY( const_dict_55b3309b164506bd83a51d039ef1179d );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 190;
    tmp_unused = CALL_FUNCTION( tmp_called_name_19, tmp_args_name_13, tmp_kw_name_14 );
    Py_DECREF( tmp_called_name_19 );
    Py_DECREF( tmp_kw_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_20 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_20 == NULL ))
    {
        tmp_called_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 203;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_5 == NULL ))
    {
        tmp_args_element_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 204;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_str_digest_a1b73434dde6ef4b54439b149420d10b;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 203;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_19 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_20, call_args );
    }

    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group, tmp_assign_source_19 );
    tmp_source_name_21 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_21 == NULL ))
    {
        tmp_source_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    CHECK_OBJECT( tmp_source_name_21 );
    tmp_called_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_add_option );
    if ( tmp_called_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 209;

        goto frame_exception_exit_1;
    }
    tmp_args_name_14 = const_tuple_str_digest_4913f61cf652f6bfa0f584ea4716697a_tuple;
    tmp_kw_name_15 = PyDict_Copy( const_dict_9968416de4b8eb40646f6388041eec5a );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 209;
    tmp_unused = CALL_FUNCTION( tmp_called_name_21, tmp_args_name_14, tmp_kw_name_15 );
    Py_DECREF( tmp_called_name_21 );
    Py_DECREF( tmp_kw_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 209;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 219;

        goto frame_exception_exit_1;
    }

    tmp_called_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_add_option );
    if ( tmp_called_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;

        goto frame_exception_exit_1;
    }
    tmp_args_name_15 = const_tuple_str_digest_46f785c15c72b806f29a68d8dfd47979_tuple;
    tmp_kw_name_16 = PyDict_Copy( const_dict_6fdb311d2c4c6508c918d2fe1b337bd3 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 219;
    tmp_unused = CALL_FUNCTION( tmp_called_name_22, tmp_args_name_15, tmp_kw_name_16 );
    Py_DECREF( tmp_called_name_22 );
    Py_DECREF( tmp_kw_name_16 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 229;

        goto frame_exception_exit_1;
    }

    tmp_called_name_23 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_add_option );
    if ( tmp_called_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;

        goto frame_exception_exit_1;
    }
    tmp_args_name_16 = const_tuple_1c0e6ffbbde28de054c77c94763a9e2b_tuple;
    tmp_kw_name_17 = PyDict_Copy( const_dict_48a12ca9025ab4ff10c795867c5ba0bb );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 229;
    tmp_unused = CALL_FUNCTION( tmp_called_name_23, tmp_args_name_16, tmp_kw_name_17 );
    Py_DECREF( tmp_called_name_23 );
    Py_DECREF( tmp_kw_name_17 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_24 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_24 == NULL ))
    {
        tmp_source_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 239;

        goto frame_exception_exit_1;
    }

    tmp_called_name_24 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_add_option );
    if ( tmp_called_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 239;

        goto frame_exception_exit_1;
    }
    tmp_args_name_17 = const_tuple_str_digest_d3391bc5505627a621ab17af42b5e153_tuple;
    tmp_kw_name_18 = DEEP_COPY( const_dict_8051a9b4950f7a98676f92b125b0a5a9 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 239;
    tmp_unused = CALL_FUNCTION( tmp_called_name_24, tmp_args_name_17, tmp_kw_name_18 );
    Py_DECREF( tmp_called_name_24 );
    Py_DECREF( tmp_kw_name_18 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 239;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_25 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_25 == NULL ))
    {
        tmp_source_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 250;

        goto frame_exception_exit_1;
    }

    tmp_called_name_25 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_add_option );
    if ( tmp_called_name_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;

        goto frame_exception_exit_1;
    }
    tmp_args_name_18 = const_tuple_str_digest_000f2dcd6617662a5ec06cf266d5aede_tuple;
    tmp_kw_name_19 = DEEP_COPY( const_dict_a9101022469a764fe6b4acd01bb22355 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 250;
    tmp_unused = CALL_FUNCTION( tmp_called_name_25, tmp_args_name_18, tmp_kw_name_19 );
    Py_DECREF( tmp_called_name_25 );
    Py_DECREF( tmp_kw_name_19 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_26 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_26 == NULL ))
    {
        tmp_source_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 262;

        goto frame_exception_exit_1;
    }

    tmp_called_name_26 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_add_option );
    if ( tmp_called_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;

        goto frame_exception_exit_1;
    }
    tmp_args_name_19 = const_tuple_25f13a07532615ebccd7a031a6fe2ed5_tuple;
    tmp_kw_name_20 = DEEP_COPY( const_dict_b6567d48878bd6a564df12f2792ed412 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 262;
    tmp_unused = CALL_FUNCTION( tmp_called_name_26, tmp_args_name_19, tmp_kw_name_20 );
    Py_DECREF( tmp_called_name_26 );
    Py_DECREF( tmp_kw_name_20 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_27 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_source_name_27 == NULL ))
    {
        tmp_source_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_source_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 274;

        goto frame_exception_exit_1;
    }

    tmp_called_name_27 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_add_option );
    if ( tmp_called_name_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;

        goto frame_exception_exit_1;
    }
    tmp_args_name_20 = const_tuple_fd9bd18abc843709bbdfa4939c29306e_tuple;
    tmp_kw_name_21 = DEEP_COPY( const_dict_f9dec362e3826b89bc423d0a382669c5 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 274;
    tmp_unused = CALL_FUNCTION( tmp_called_name_27, tmp_args_name_20, tmp_kw_name_21 );
    Py_DECREF( tmp_called_name_27 );
    Py_DECREF( tmp_kw_name_21 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_28 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_28 == NULL ))
    {
        tmp_source_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 286;

        goto frame_exception_exit_1;
    }

    tmp_called_name_28 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain_add_option_group );
    if ( tmp_called_name_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 286;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_recurse_group );

    if (unlikely( tmp_args_element_name_7 == NULL ))
    {
        tmp_args_element_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_recurse_group );
    }

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_28 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "recurse_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 286;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 286;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
    }

    Py_DECREF( tmp_called_name_28 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 286;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_29 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_29 == NULL ))
    {
        tmp_called_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 288;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 289;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = const_str_digest_29f22d31e2612090153f2d0b53f05d17;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 288;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_20 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_29, call_args );
    }

    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_execute_group, tmp_assign_source_20 );
    tmp_source_name_29 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_execute_group );

    if (unlikely( tmp_source_name_29 == NULL ))
    {
        tmp_source_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_execute_group );
    }

    CHECK_OBJECT( tmp_source_name_29 );
    tmp_called_name_30 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_add_option );
    if ( tmp_called_name_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;

        goto frame_exception_exit_1;
    }
    tmp_args_name_21 = const_tuple_bf3176bee2556beb326253fa06ee2b45_tuple;
    tmp_dict_key_17 = const_str_plain_action;
    tmp_dict_value_17 = const_str_plain_store_true;
    tmp_kw_name_22 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_22, tmp_dict_key_17, tmp_dict_value_17 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_18 = const_str_plain_dest;
    tmp_dict_value_18 = const_str_plain_immediate_execution;
    tmp_res = PyDict_SetItem( tmp_kw_name_22, tmp_dict_key_18, tmp_dict_value_18 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_19 = const_str_plain_default;
    tmp_dict_value_19 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );

    if (unlikely( tmp_dict_value_19 == NULL ))
    {
        tmp_dict_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );
    }

    if ( tmp_dict_value_19 == NULL )
    {
        Py_DECREF( tmp_called_name_30 );
        Py_DECREF( tmp_kw_name_22 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "is_nuitka_run" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 297;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_22, tmp_dict_key_19, tmp_dict_value_19 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_20 = const_str_plain_help;
    tmp_left_name_2 = const_str_digest_a85c1bd4a7e7b3e2eae7b4253bfefb6c;
    tmp_cond_value_2 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );

    if (unlikely( tmp_cond_value_2 == NULL ))
    {
        tmp_cond_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_is_nuitka_run );
    }

    if ( tmp_cond_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_30 );
        Py_DECREF( tmp_kw_name_22 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "is_nuitka_run" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 301;

        goto frame_exception_exit_1;
    }

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_30 );
        Py_DECREF( tmp_kw_name_22 );

        exception_lineno = 301;

        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_right_name_2 = const_str_plain_on;
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_right_name_2 = const_str_plain_off;
    condexpr_end_1:;
    tmp_dict_value_20 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_dict_value_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_30 );
        Py_DECREF( tmp_kw_name_22 );

        exception_lineno = 300;

        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_22, tmp_dict_key_20, tmp_dict_value_20 );
    Py_DECREF( tmp_dict_value_20 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 293;
    tmp_unused = CALL_FUNCTION( tmp_called_name_30, tmp_args_name_21, tmp_kw_name_22 );
    Py_DECREF( tmp_called_name_30 );
    Py_DECREF( tmp_kw_name_22 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_30 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_execute_group );

    if (unlikely( tmp_source_name_30 == NULL ))
    {
        tmp_source_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_execute_group );
    }

    if ( tmp_source_name_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "execute_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 304;

        goto frame_exception_exit_1;
    }

    tmp_called_name_31 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_add_option );
    if ( tmp_called_name_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;

        goto frame_exception_exit_1;
    }
    tmp_args_name_22 = const_tuple_7f868864dcb1dd0c7268cc60bfcfc142_tuple;
    tmp_kw_name_23 = PyDict_Copy( const_dict_a2e498776be6cd82fda35028659b0622 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 304;
    tmp_unused = CALL_FUNCTION( tmp_called_name_31, tmp_args_name_22, tmp_kw_name_23 );
    Py_DECREF( tmp_called_name_31 );
    Py_DECREF( tmp_kw_name_23 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_31 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_execute_group );

    if (unlikely( tmp_source_name_31 == NULL ))
    {
        tmp_source_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_execute_group );
    }

    if ( tmp_source_name_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "execute_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 314;

        goto frame_exception_exit_1;
    }

    tmp_called_name_32 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_add_option );
    if ( tmp_called_name_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;

        goto frame_exception_exit_1;
    }
    tmp_args_name_23 = const_tuple_919a9acd13336714b04cc11908b85505_tuple;
    tmp_kw_name_24 = PyDict_Copy( const_dict_b45d9c25c80a6a6a8e2a54d581dfcf79 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 314;
    tmp_unused = CALL_FUNCTION( tmp_called_name_32, tmp_args_name_23, tmp_kw_name_24 );
    Py_DECREF( tmp_called_name_32 );
    Py_DECREF( tmp_kw_name_24 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_32 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_32 == NULL ))
    {
        tmp_source_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 325;

        goto frame_exception_exit_1;
    }

    tmp_called_name_33 = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain_add_option_group );
    if ( tmp_called_name_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_execute_group );

    if (unlikely( tmp_args_element_name_10 == NULL ))
    {
        tmp_args_element_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_execute_group );
    }

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_33 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "execute_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 325;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 325;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_33, call_args );
    }

    Py_DECREF( tmp_called_name_33 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_34 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_34 == NULL ))
    {
        tmp_called_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 327;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_11 == NULL ))
    {
        tmp_args_element_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 328;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = const_str_digest_126a85cfeb4a081042e66eeac95137b9;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 327;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_assign_source_21 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_34, call_args );
    }

    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_dump_group, tmp_assign_source_21 );
    tmp_source_name_33 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_dump_group );

    if (unlikely( tmp_source_name_33 == NULL ))
    {
        tmp_source_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_group );
    }

    CHECK_OBJECT( tmp_source_name_33 );
    tmp_called_name_35 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain_add_option );
    if ( tmp_called_name_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;

        goto frame_exception_exit_1;
    }
    tmp_args_name_24 = const_tuple_7ffab47799d19814b98636af0b44a932_tuple;
    tmp_kw_name_25 = PyDict_Copy( const_dict_64c48e06c6d6ab7fe0e78d50b8abe2e5 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 332;
    tmp_unused = CALL_FUNCTION( tmp_called_name_35, tmp_args_name_24, tmp_kw_name_25 );
    Py_DECREF( tmp_called_name_35 );
    Py_DECREF( tmp_kw_name_25 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_34 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_dump_group );

    if (unlikely( tmp_source_name_34 == NULL ))
    {
        tmp_source_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_group );
    }

    if ( tmp_source_name_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "dump_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 340;

        goto frame_exception_exit_1;
    }

    tmp_called_name_36 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain_add_option );
    if ( tmp_called_name_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 340;

        goto frame_exception_exit_1;
    }
    tmp_args_name_25 = const_tuple_str_digest_749d64834db4e74f339318a144653b9a_tuple;
    tmp_kw_name_26 = PyDict_Copy( const_dict_ded7ced2e817eaed7d9d3482108130c5 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 340;
    tmp_unused = CALL_FUNCTION( tmp_called_name_36, tmp_args_name_25, tmp_kw_name_26 );
    Py_DECREF( tmp_called_name_36 );
    Py_DECREF( tmp_kw_name_26 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 340;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_35 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_35 == NULL ))
    {
        tmp_source_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 349;

        goto frame_exception_exit_1;
    }

    tmp_called_name_37 = LOOKUP_ATTRIBUTE( tmp_source_name_35, const_str_plain_add_option_group );
    if ( tmp_called_name_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 349;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_13 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_dump_group );

    if (unlikely( tmp_args_element_name_13 == NULL ))
    {
        tmp_args_element_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_group );
    }

    if ( tmp_args_element_name_13 == NULL )
    {
        Py_DECREF( tmp_called_name_37 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "dump_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 349;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 349;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_37, call_args );
    }

    Py_DECREF( tmp_called_name_37 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 349;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_38 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_38 == NULL ))
    {
        tmp_called_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 352;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_14 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_14 == NULL ))
    {
        tmp_args_element_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 353;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_15 = const_str_digest_2e24eb0be25ec092a3baa722dc55b330;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 352;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_assign_source_22 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_38, call_args );
    }

    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 352;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group, tmp_assign_source_22 );
    tmp_source_name_36 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group );

    if (unlikely( tmp_source_name_36 == NULL ))
    {
        tmp_source_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_codegen_group );
    }

    CHECK_OBJECT( tmp_source_name_36 );
    tmp_called_name_39 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain_add_option );
    if ( tmp_called_name_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;

        goto frame_exception_exit_1;
    }
    tmp_args_name_26 = const_tuple_94e9cfb72d94240569769ed9b57cf011_tuple;
    tmp_dict_key_21 = const_str_plain_action;
    tmp_dict_value_21 = const_str_plain_store_true;
    tmp_kw_name_27 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_27, tmp_dict_key_21, tmp_dict_value_21 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_22 = const_str_plain_dest;
    tmp_dict_value_22 = const_str_plain_disabled;
    tmp_res = PyDict_SetItem( tmp_kw_name_27, tmp_dict_key_22, tmp_dict_value_22 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_23 = const_str_plain_default;
    tmp_dict_value_23 = Py_False;
    tmp_res = PyDict_SetItem( tmp_kw_name_27, tmp_dict_key_23, tmp_dict_value_23 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_24 = const_str_plain_help;
    tmp_dict_value_24 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_24 == NULL ))
    {
        tmp_dict_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_24 == NULL )
    {
        Py_DECREF( tmp_called_name_39 );
        Py_DECREF( tmp_kw_name_27 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 362;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_27, tmp_dict_key_24, tmp_dict_value_24 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 357;
    tmp_unused = CALL_FUNCTION( tmp_called_name_39, tmp_args_name_26, tmp_kw_name_27 );
    Py_DECREF( tmp_called_name_39 );
    Py_DECREF( tmp_kw_name_27 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 357;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_37 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group );

    if (unlikely( tmp_source_name_37 == NULL ))
    {
        tmp_source_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_codegen_group );
    }

    if ( tmp_source_name_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "codegen_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 365;

        goto frame_exception_exit_1;
    }

    tmp_called_name_40 = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_add_option );
    if ( tmp_called_name_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;

        goto frame_exception_exit_1;
    }
    tmp_args_name_27 = const_tuple_str_digest_25433114711138da4c9f37c122d5a3e0_tuple;
    tmp_kw_name_28 = PyDict_Copy( const_dict_1f7fbc2dabea4a09516283b4d4bc14e4 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 365;
    tmp_unused = CALL_FUNCTION( tmp_called_name_40, tmp_args_name_27, tmp_kw_name_28 );
    Py_DECREF( tmp_called_name_40 );
    Py_DECREF( tmp_kw_name_28 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_38 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group );

    if (unlikely( tmp_source_name_38 == NULL ))
    {
        tmp_source_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_codegen_group );
    }

    if ( tmp_source_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "codegen_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 377;

        goto frame_exception_exit_1;
    }

    tmp_called_name_41 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_add_option );
    if ( tmp_called_name_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 377;

        goto frame_exception_exit_1;
    }
    tmp_args_name_28 = const_tuple_str_digest_348f668e21b79db9e8ad525164de0ee1_tuple;
    tmp_dict_key_25 = const_str_plain_action;
    tmp_dict_value_25 = const_str_plain_store_false;
    tmp_kw_name_29 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_29, tmp_dict_key_25, tmp_dict_value_25 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_26 = const_str_plain_dest;
    tmp_dict_value_26 = const_str_plain_statement_lines;
    tmp_res = PyDict_SetItem( tmp_kw_name_29, tmp_dict_key_26, tmp_dict_value_26 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_27 = const_str_plain_default;
    tmp_dict_value_27 = Py_True;
    tmp_res = PyDict_SetItem( tmp_kw_name_29, tmp_dict_key_27, tmp_dict_value_27 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_28 = const_str_plain_help;
    tmp_dict_value_28 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_28 == NULL ))
    {
        tmp_dict_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_28 == NULL )
    {
        Py_DECREF( tmp_called_name_41 );
        Py_DECREF( tmp_kw_name_29 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 382;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_29, tmp_dict_key_28, tmp_dict_value_28 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 377;
    tmp_unused = CALL_FUNCTION( tmp_called_name_41, tmp_args_name_28, tmp_kw_name_29 );
    Py_DECREF( tmp_called_name_41 );
    Py_DECREF( tmp_kw_name_29 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 377;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_39 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group );

    if (unlikely( tmp_source_name_39 == NULL ))
    {
        tmp_source_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_codegen_group );
    }

    if ( tmp_source_name_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "codegen_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 388;

        goto frame_exception_exit_1;
    }

    tmp_called_name_42 = LOOKUP_ATTRIBUTE( tmp_source_name_39, const_str_plain_add_option );
    if ( tmp_called_name_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;

        goto frame_exception_exit_1;
    }
    tmp_args_name_29 = const_tuple_str_digest_181925cc600ef7846f4fc9b1da40c033_tuple;
    tmp_kw_name_30 = PyDict_Copy( const_dict_1f72f6528b11a15cfc32a55abad3e2f5 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 388;
    tmp_unused = CALL_FUNCTION( tmp_called_name_42, tmp_args_name_29, tmp_kw_name_30 );
    Py_DECREF( tmp_called_name_42 );
    Py_DECREF( tmp_kw_name_30 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_40 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_40 == NULL ))
    {
        tmp_source_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 406;

        goto frame_exception_exit_1;
    }

    tmp_called_name_43 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain_add_option_group );
    if ( tmp_called_name_43 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_16 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_codegen_group );

    if (unlikely( tmp_args_element_name_16 == NULL ))
    {
        tmp_args_element_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_codegen_group );
    }

    if ( tmp_args_element_name_16 == NULL )
    {
        Py_DECREF( tmp_called_name_43 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "codegen_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 406;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 406;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
    }

    Py_DECREF( tmp_called_name_43 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 406;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_44 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_44 == NULL ))
    {
        tmp_called_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 408;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_17 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_17 == NULL ))
    {
        tmp_args_element_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 409;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = const_str_digest_3cd4325f1e1f69e4ec5f33696a01c94f;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 408;
    {
        PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_23 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_44, call_args );
    }

    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 408;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_outputdir_group, tmp_assign_source_23 );
    tmp_source_name_41 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_outputdir_group );

    if (unlikely( tmp_source_name_41 == NULL ))
    {
        tmp_source_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_outputdir_group );
    }

    CHECK_OBJECT( tmp_source_name_41 );
    tmp_called_name_45 = LOOKUP_ATTRIBUTE( tmp_source_name_41, const_str_plain_add_option );
    if ( tmp_called_name_45 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 413;

        goto frame_exception_exit_1;
    }
    tmp_args_name_30 = const_tuple_str_digest_1fbf263a160f21148f892a1b15932c5a_tuple;
    tmp_kw_name_31 = PyDict_Copy( const_dict_4806082570b3d4a3b572377edcbcb3bb );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 413;
    tmp_unused = CALL_FUNCTION( tmp_called_name_45, tmp_args_name_30, tmp_kw_name_31 );
    Py_DECREF( tmp_called_name_45 );
    Py_DECREF( tmp_kw_name_31 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 413;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_42 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_outputdir_group );

    if (unlikely( tmp_source_name_42 == NULL ))
    {
        tmp_source_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_outputdir_group );
    }

    if ( tmp_source_name_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "outputdir_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 426;

        goto frame_exception_exit_1;
    }

    tmp_called_name_46 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain_add_option );
    if ( tmp_called_name_46 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 426;

        goto frame_exception_exit_1;
    }
    tmp_args_name_31 = const_tuple_str_digest_49ad4f31d937fb275eae6082ce4c2f7e_tuple;
    tmp_kw_name_32 = PyDict_Copy( const_dict_0db29dd5ce570108641e26279aa1d6bb );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 426;
    tmp_unused = CALL_FUNCTION( tmp_called_name_46, tmp_args_name_31, tmp_kw_name_32 );
    Py_DECREF( tmp_called_name_46 );
    Py_DECREF( tmp_kw_name_32 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 426;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_43 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_outputdir_group );

    if (unlikely( tmp_source_name_43 == NULL ))
    {
        tmp_source_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_outputdir_group );
    }

    if ( tmp_source_name_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "outputdir_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 436;

        goto frame_exception_exit_1;
    }

    tmp_called_name_47 = LOOKUP_ATTRIBUTE( tmp_source_name_43, const_str_plain_add_option );
    if ( tmp_called_name_47 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 436;

        goto frame_exception_exit_1;
    }
    tmp_args_name_32 = const_tuple_str_digest_44da9cf7d063a682915b28e16c190ea6_tuple;
    tmp_kw_name_33 = PyDict_Copy( const_dict_f38a879f43bf713c7195c04e0d245695 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 436;
    tmp_unused = CALL_FUNCTION( tmp_called_name_47, tmp_args_name_32, tmp_kw_name_33 );
    Py_DECREF( tmp_called_name_47 );
    Py_DECREF( tmp_kw_name_33 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 436;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_44 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_44 == NULL ))
    {
        tmp_source_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 448;

        goto frame_exception_exit_1;
    }

    tmp_called_name_48 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain_add_option_group );
    if ( tmp_called_name_48 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 448;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_19 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_outputdir_group );

    if (unlikely( tmp_args_element_name_19 == NULL ))
    {
        tmp_args_element_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_outputdir_group );
    }

    if ( tmp_args_element_name_19 == NULL )
    {
        Py_DECREF( tmp_called_name_48 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "outputdir_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 448;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 448;
    {
        PyObject *call_args[] = { tmp_args_element_name_19 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_48, call_args );
    }

    Py_DECREF( tmp_called_name_48 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 448;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_49 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_49 == NULL ))
    {
        tmp_called_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 451;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_20 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_20 == NULL ))
    {
        tmp_args_element_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 452;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_21 = const_str_digest_905a0ca1360b0a5bb2b938cdcab0da3d;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 451;
    {
        PyObject *call_args[] = { tmp_args_element_name_20, tmp_args_element_name_21 };
        tmp_assign_source_24 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_49, call_args );
    }

    if ( tmp_assign_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 451;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_windows_group, tmp_assign_source_24 );
    tmp_called_name_50 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_50 == NULL ))
    {
        tmp_called_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 457;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_22 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_22 == NULL ))
    {
        tmp_args_element_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 458;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_23 = const_str_digest_2adad11ced0222182a3bde8b4673464b;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 457;
    {
        PyObject *call_args[] = { tmp_args_element_name_22, tmp_args_element_name_23 };
        tmp_assign_source_25 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_50, call_args );
    }

    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 457;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group, tmp_assign_source_25 );
    tmp_source_name_45 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_45 == NULL ))
    {
        tmp_source_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    CHECK_OBJECT( tmp_source_name_45 );
    tmp_called_name_51 = LOOKUP_ATTRIBUTE( tmp_source_name_45, const_str_plain_add_option );
    if ( tmp_called_name_51 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 462;

        goto frame_exception_exit_1;
    }
    tmp_args_name_33 = const_tuple_str_digest_b18a177c45550b4f3f516a11bf101257_tuple;
    tmp_kw_name_34 = PyDict_Copy( const_dict_f53f2b68bdeb8b2acc2b479d67a53074 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 462;
    tmp_unused = CALL_FUNCTION( tmp_called_name_51, tmp_args_name_33, tmp_kw_name_34 );
    Py_DECREF( tmp_called_name_51 );
    Py_DECREF( tmp_kw_name_34 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 462;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_46 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_46 == NULL ))
    {
        tmp_source_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 472;

        goto frame_exception_exit_1;
    }

    tmp_called_name_52 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain_add_option );
    if ( tmp_called_name_52 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 472;

        goto frame_exception_exit_1;
    }
    tmp_args_name_34 = const_tuple_78ca38c5fc9459659bcd1da15533630f_tuple;
    tmp_kw_name_35 = PyDict_Copy( const_dict_ebdbe560f3c5c5a20f7bbf306d0c53d6 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 472;
    tmp_unused = CALL_FUNCTION( tmp_called_name_52, tmp_args_name_34, tmp_kw_name_35 );
    Py_DECREF( tmp_called_name_52 );
    Py_DECREF( tmp_kw_name_35 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 472;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_47 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_47 == NULL ))
    {
        tmp_source_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 482;

        goto frame_exception_exit_1;
    }

    tmp_called_name_53 = LOOKUP_ATTRIBUTE( tmp_source_name_47, const_str_plain_add_option );
    if ( tmp_called_name_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;

        goto frame_exception_exit_1;
    }
    tmp_args_name_35 = const_tuple_str_digest_93035a62de394da955eafe810adcb94a_tuple;
    tmp_kw_name_36 = PyDict_Copy( const_dict_ccf05bbd6062a341ea16977d08e4ace1 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 482;
    tmp_unused = CALL_FUNCTION( tmp_called_name_53, tmp_args_name_35, tmp_kw_name_36 );
    Py_DECREF( tmp_called_name_53 );
    Py_DECREF( tmp_kw_name_36 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_48 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_48 == NULL ))
    {
        tmp_source_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 491;

        goto frame_exception_exit_1;
    }

    tmp_called_name_54 = LOOKUP_ATTRIBUTE( tmp_source_name_48, const_str_plain_add_option );
    if ( tmp_called_name_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 491;

        goto frame_exception_exit_1;
    }
    tmp_args_name_36 = const_tuple_str_digest_0e4e79a120d8772251ce3088f7d11248_tuple;
    tmp_kw_name_37 = PyDict_Copy( const_dict_5050b44d40c50f56cd13e9ad189ccc0e );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 491;
    tmp_unused = CALL_FUNCTION( tmp_called_name_54, tmp_args_name_36, tmp_kw_name_37 );
    Py_DECREF( tmp_called_name_54 );
    Py_DECREF( tmp_kw_name_37 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 491;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_49 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_49 == NULL ))
    {
        tmp_source_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 500;

        goto frame_exception_exit_1;
    }

    tmp_called_name_55 = LOOKUP_ATTRIBUTE( tmp_source_name_49, const_str_plain_add_option );
    if ( tmp_called_name_55 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;

        goto frame_exception_exit_1;
    }
    tmp_args_name_37 = const_tuple_str_digest_2628b2da7143e7e835e536f6f73483c8_tuple;
    tmp_kw_name_38 = PyDict_Copy( const_dict_68bef2472fa0693d2e9cde3165230e7e );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 500;
    tmp_unused = CALL_FUNCTION( tmp_called_name_55, tmp_args_name_37, tmp_kw_name_38 );
    Py_DECREF( tmp_called_name_55 );
    Py_DECREF( tmp_kw_name_38 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_50 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_50 == NULL ))
    {
        tmp_source_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 510;

        goto frame_exception_exit_1;
    }

    tmp_called_name_56 = LOOKUP_ATTRIBUTE( tmp_source_name_50, const_str_plain_add_option );
    if ( tmp_called_name_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 510;

        goto frame_exception_exit_1;
    }
    tmp_args_name_38 = const_tuple_4a1f625c7edc4f9009ea9412f2eb7ca6_tuple;
    tmp_kw_name_39 = PyDict_Copy( const_dict_d08467263ea7a279b4a5e664b6eb12c4 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 510;
    tmp_unused = CALL_FUNCTION( tmp_called_name_56, tmp_args_name_38, tmp_kw_name_39 );
    Py_DECREF( tmp_called_name_56 );
    Py_DECREF( tmp_kw_name_39 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 510;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_51 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_51 == NULL ))
    {
        tmp_source_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_51 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 522;

        goto frame_exception_exit_1;
    }

    tmp_called_name_57 = LOOKUP_ATTRIBUTE( tmp_source_name_51, const_str_plain_add_option );
    if ( tmp_called_name_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;

        goto frame_exception_exit_1;
    }
    tmp_args_name_39 = const_tuple_str_digest_d180296833a757be816b5fcab44e0347_tuple;
    tmp_kw_name_40 = PyDict_Copy( const_dict_f7ee065b4f969f810663b09dfe85cb24 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 522;
    tmp_unused = CALL_FUNCTION( tmp_called_name_57, tmp_args_name_39, tmp_kw_name_40 );
    Py_DECREF( tmp_called_name_57 );
    Py_DECREF( tmp_kw_name_40 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 522;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_52 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_52 == NULL ))
    {
        tmp_source_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_52 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 533;

        goto frame_exception_exit_1;
    }

    tmp_called_name_58 = LOOKUP_ATTRIBUTE( tmp_source_name_52, const_str_plain_add_option );
    if ( tmp_called_name_58 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;

        goto frame_exception_exit_1;
    }
    tmp_args_name_40 = const_tuple_str_digest_d26c39e8ed4ddb2171e43f32074c3668_tuple;
    tmp_kw_name_41 = DEEP_COPY( const_dict_d65576168a837f10db67bdd0d5297d28 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 533;
    tmp_unused = CALL_FUNCTION( tmp_called_name_58, tmp_args_name_40, tmp_kw_name_41 );
    Py_DECREF( tmp_called_name_58 );
    Py_DECREF( tmp_kw_name_41 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_53 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_53 == NULL ))
    {
        tmp_source_name_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_53 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 544;

        goto frame_exception_exit_1;
    }

    tmp_called_name_59 = LOOKUP_ATTRIBUTE( tmp_source_name_53, const_str_plain_add_option );
    if ( tmp_called_name_59 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;

        goto frame_exception_exit_1;
    }
    tmp_args_name_41 = const_tuple_str_digest_6120fea2456c84f26fd70306fee05e56_tuple;
    tmp_dict_key_29 = const_str_plain_action;
    tmp_dict_value_29 = const_str_plain_store_true;
    tmp_kw_name_42 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_42, tmp_dict_key_29, tmp_dict_value_29 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_30 = const_str_plain_dest;
    tmp_dict_value_30 = const_str_plain_explain_imports;
    tmp_res = PyDict_SetItem( tmp_kw_name_42, tmp_dict_key_30, tmp_dict_value_30 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_31 = const_str_plain_default;
    tmp_dict_value_31 = Py_False;
    tmp_res = PyDict_SetItem( tmp_kw_name_42, tmp_dict_key_31, tmp_dict_value_31 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_32 = const_str_plain_help;
    tmp_dict_value_32 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_32 == NULL ))
    {
        tmp_dict_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_32 == NULL )
    {
        Py_DECREF( tmp_called_name_59 );
        Py_DECREF( tmp_kw_name_42 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 549;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_42, tmp_dict_key_32, tmp_dict_value_32 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 544;
    tmp_unused = CALL_FUNCTION( tmp_called_name_59, tmp_args_name_41, tmp_kw_name_42 );
    Py_DECREF( tmp_called_name_59 );
    Py_DECREF( tmp_kw_name_42 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_54 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_54 == NULL ))
    {
        tmp_source_name_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_54 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 552;

        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_54, const_str_plain_name );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;

        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_str_plain_nt;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ_NORECURSE( tmp_compare_left_2, tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 552;

        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_55 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_55 == NULL ))
    {
        tmp_source_name_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_55 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 553;

        goto frame_exception_exit_1;
    }

    tmp_called_name_60 = LOOKUP_ATTRIBUTE( tmp_source_name_55, const_str_plain_add_option );
    if ( tmp_called_name_60 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;

        goto frame_exception_exit_1;
    }
    tmp_args_name_42 = const_tuple_str_digest_ef2ed6d9473fc26d981c5602152fe549_tuple;
    tmp_kw_name_43 = PyDict_Copy( const_dict_982e5273ca0a6d2d38c9e565a691c0f2 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 553;
    tmp_unused = CALL_FUNCTION( tmp_called_name_60, tmp_args_name_42, tmp_kw_name_43 );
    Py_DECREF( tmp_called_name_60 );
    Py_DECREF( tmp_kw_name_43 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 553;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_56 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_source_name_56 == NULL ))
    {
        tmp_source_name_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_source_name_56 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 565;

        goto frame_exception_exit_1;
    }

    tmp_called_name_61 = LOOKUP_ATTRIBUTE( tmp_source_name_56, const_str_plain_add_option );
    if ( tmp_called_name_61 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 565;

        goto frame_exception_exit_1;
    }
    tmp_args_name_43 = const_tuple_str_digest_df2c7df2c8191b7413ae4192dda59b2f_tuple;
    tmp_kw_name_44 = PyDict_Copy( const_dict_963aa946b3440440fe76b2e311636977 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 565;
    tmp_unused = CALL_FUNCTION( tmp_called_name_61, tmp_args_name_43, tmp_kw_name_44 );
    Py_DECREF( tmp_called_name_61 );
    Py_DECREF( tmp_kw_name_44 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 565;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_source_name_57 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_57 == NULL ))
    {
        tmp_source_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_57 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 579;

        goto frame_exception_exit_1;
    }

    tmp_called_name_62 = LOOKUP_ATTRIBUTE( tmp_source_name_57, const_str_plain_add_option );
    if ( tmp_called_name_62 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;

        goto frame_exception_exit_1;
    }
    tmp_args_name_44 = const_tuple_str_digest_096be9a55acdb9f027de49b047bd228d_tuple;
    tmp_dict_key_33 = const_str_plain_action;
    tmp_dict_value_33 = const_str_plain_store_false;
    tmp_kw_name_45 = _PyDict_NewPresized( 4 );
    tmp_res = PyDict_SetItem( tmp_kw_name_45, tmp_dict_key_33, tmp_dict_value_33 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_34 = const_str_plain_dest;
    tmp_dict_value_34 = const_str_plain_allow_reexecute;
    tmp_res = PyDict_SetItem( tmp_kw_name_45, tmp_dict_key_34, tmp_dict_value_34 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_35 = const_str_plain_default;
    tmp_dict_value_35 = Py_True;
    tmp_res = PyDict_SetItem( tmp_kw_name_45, tmp_dict_key_35, tmp_dict_value_35 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_36 = const_str_plain_help;
    tmp_dict_value_36 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );

    if (unlikely( tmp_dict_value_36 == NULL ))
    {
        tmp_dict_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SUPPRESS_HELP );
    }

    if ( tmp_dict_value_36 == NULL )
    {
        Py_DECREF( tmp_called_name_62 );
        Py_DECREF( tmp_kw_name_45 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SUPPRESS_HELP" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 584;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_45, tmp_dict_key_36, tmp_dict_value_36 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 579;
    tmp_unused = CALL_FUNCTION( tmp_called_name_62, tmp_args_name_44, tmp_kw_name_45 );
    Py_DECREF( tmp_called_name_62 );
    Py_DECREF( tmp_kw_name_45 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_58 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_58 == NULL ))
    {
        tmp_source_name_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_58 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 588;

        goto frame_exception_exit_1;
    }

    tmp_called_name_63 = LOOKUP_ATTRIBUTE( tmp_source_name_58, const_str_plain_add_option_group );
    if ( tmp_called_name_63 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_24 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_debug_group );

    if (unlikely( tmp_args_element_name_24 == NULL ))
    {
        tmp_args_element_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_debug_group );
    }

    if ( tmp_args_element_name_24 == NULL )
    {
        Py_DECREF( tmp_called_name_63 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "debug_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 588;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 588;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_63, call_args );
    }

    Py_DECREF( tmp_called_name_63 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_64 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_64 == NULL ))
    {
        tmp_called_name_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_64 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 590;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_25 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_25 == NULL ))
    {
        tmp_args_element_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 591;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_26 = const_str_digest_0f64d43d9cf5e40fb886257fa3b28964;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 590;
    {
        PyObject *call_args[] = { tmp_args_element_name_25, tmp_args_element_name_26 };
        tmp_assign_source_26 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_64, call_args );
    }

    if ( tmp_assign_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 590;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group, tmp_assign_source_26 );
    tmp_source_name_59 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_source_name_59 == NULL ))
    {
        tmp_source_name_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    CHECK_OBJECT( tmp_source_name_59 );
    tmp_called_name_65 = LOOKUP_ATTRIBUTE( tmp_source_name_59, const_str_plain_add_option );
    if ( tmp_called_name_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 596;

        goto frame_exception_exit_1;
    }
    tmp_args_name_45 = const_tuple_str_digest_1e0691616d687838fcfcf9e105cb4f2c_tuple;
    tmp_kw_name_46 = PyDict_Copy( const_dict_d46f58cd09bb8f0399ff079ba57dd7f0 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 596;
    tmp_unused = CALL_FUNCTION( tmp_called_name_65, tmp_args_name_45, tmp_kw_name_46 );
    Py_DECREF( tmp_called_name_65 );
    Py_DECREF( tmp_kw_name_46 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 596;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_60 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_source_name_60 == NULL ))
    {
        tmp_source_name_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    if ( tmp_source_name_60 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_compiler_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 606;

        goto frame_exception_exit_1;
    }

    tmp_called_name_66 = LOOKUP_ATTRIBUTE( tmp_source_name_60, const_str_plain_add_option );
    if ( tmp_called_name_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 606;

        goto frame_exception_exit_1;
    }
    tmp_args_name_46 = const_tuple_str_digest_e0e0f50e90b11d04627e07e5e534115c_tuple;
    tmp_kw_name_47 = PyDict_Copy( const_dict_012a9328b79bad885d5993fdc0b796e8 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 606;
    tmp_unused = CALL_FUNCTION( tmp_called_name_66, tmp_args_name_46, tmp_kw_name_47 );
    Py_DECREF( tmp_called_name_66 );
    Py_DECREF( tmp_kw_name_47 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 606;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_61 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_source_name_61 == NULL ))
    {
        tmp_source_name_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    if ( tmp_source_name_61 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_compiler_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 616;

        goto frame_exception_exit_1;
    }

    tmp_called_name_67 = LOOKUP_ATTRIBUTE( tmp_source_name_61, const_str_plain_add_option );
    if ( tmp_called_name_67 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 616;

        goto frame_exception_exit_1;
    }
    tmp_args_name_47 = const_tuple_str_digest_2353a1b7be128da2615d51f9a4ca3dbe_tuple;
    tmp_kw_name_48 = PyDict_Copy( const_dict_ab01781f7bc15d0cb66d375a405a8c23 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 616;
    tmp_unused = CALL_FUNCTION( tmp_called_name_67, tmp_args_name_47, tmp_kw_name_48 );
    Py_DECREF( tmp_called_name_67 );
    Py_DECREF( tmp_kw_name_48 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 616;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_62 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_source_name_62 == NULL ))
    {
        tmp_source_name_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    if ( tmp_source_name_62 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_compiler_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 627;

        goto frame_exception_exit_1;
    }

    tmp_called_name_68 = LOOKUP_ATTRIBUTE( tmp_source_name_62, const_str_plain_add_option );
    if ( tmp_called_name_68 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 627;

        goto frame_exception_exit_1;
    }
    tmp_args_name_48 = const_tuple_f8c54c1f3d7d17e6cf8e8b9532e0158f_tuple;
    tmp_dict_key_37 = const_str_plain_action;
    tmp_dict_value_37 = const_str_plain_store;
    tmp_kw_name_49 = _PyDict_NewPresized( 5 );
    tmp_res = PyDict_SetItem( tmp_kw_name_49, tmp_dict_key_37, tmp_dict_value_37 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_38 = const_str_plain_dest;
    tmp_dict_value_38 = const_str_plain_jobs;
    tmp_res = PyDict_SetItem( tmp_kw_name_49, tmp_dict_key_38, tmp_dict_value_38 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_39 = const_str_plain_metavar;
    tmp_dict_value_39 = const_str_plain_N;
    tmp_res = PyDict_SetItem( tmp_kw_name_49, tmp_dict_key_39, tmp_dict_value_39 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_40 = const_str_plain_default;
    tmp_called_instance_4 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_Utils );

    if (unlikely( tmp_called_instance_4 == NULL ))
    {
        tmp_called_instance_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Utils );
    }

    if ( tmp_called_instance_4 == NULL )
    {
        Py_DECREF( tmp_called_name_68 );
        Py_DECREF( tmp_kw_name_49 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Utils" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 632;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 632;
    tmp_dict_value_40 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getCoreCount );
    if ( tmp_dict_value_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_68 );
        Py_DECREF( tmp_kw_name_49 );

        exception_lineno = 632;

        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_49, tmp_dict_key_40, tmp_dict_value_40 );
    Py_DECREF( tmp_dict_value_40 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_41 = const_str_plain_help;
    tmp_dict_value_41 = const_str_digest_d226a3eaf71353ef4246518ce9a7bf20;
    tmp_res = PyDict_SetItem( tmp_kw_name_49, tmp_dict_key_41, tmp_dict_value_41 );
    assert( !(tmp_res != 0) );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 627;
    tmp_unused = CALL_FUNCTION( tmp_called_name_68, tmp_args_name_48, tmp_kw_name_49 );
    Py_DECREF( tmp_called_name_68 );
    Py_DECREF( tmp_kw_name_49 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 627;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_63 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_source_name_63 == NULL ))
    {
        tmp_source_name_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    if ( tmp_source_name_63 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_compiler_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 638;

        goto frame_exception_exit_1;
    }

    tmp_called_name_69 = LOOKUP_ATTRIBUTE( tmp_source_name_63, const_str_plain_add_option );
    if ( tmp_called_name_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;

        goto frame_exception_exit_1;
    }
    tmp_args_name_49 = const_tuple_str_digest_00d395acfd6f5a59596c56db84b18679_tuple;
    tmp_kw_name_50 = PyDict_Copy( const_dict_ae7bb8b561973c8d04445137aad11631 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 638;
    tmp_unused = CALL_FUNCTION( tmp_called_name_69, tmp_args_name_49, tmp_kw_name_50 );
    Py_DECREF( tmp_called_name_69 );
    Py_DECREF( tmp_kw_name_50 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 638;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_64 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_64 == NULL ))
    {
        tmp_source_name_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_64 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 648;

        goto frame_exception_exit_1;
    }

    tmp_called_name_70 = LOOKUP_ATTRIBUTE( tmp_source_name_64, const_str_plain_add_option_group );
    if ( tmp_called_name_70 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 648;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_27 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_c_compiler_group );

    if (unlikely( tmp_args_element_name_27 == NULL ))
    {
        tmp_args_element_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_compiler_group );
    }

    if ( tmp_args_element_name_27 == NULL )
    {
        Py_DECREF( tmp_called_name_70 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_compiler_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 648;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 648;
    {
        PyObject *call_args[] = { tmp_args_element_name_27 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_70, call_args );
    }

    Py_DECREF( tmp_called_name_70 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 648;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_71 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_71 == NULL ))
    {
        tmp_called_name_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_71 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 650;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_28 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_28 == NULL ))
    {
        tmp_args_element_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 651;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_29 = const_str_digest_7b529154659ec358155e1d1de105842b;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 650;
    {
        PyObject *call_args[] = { tmp_args_element_name_28, tmp_args_element_name_29 };
        tmp_assign_source_27 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_71, call_args );
    }

    if ( tmp_assign_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group, tmp_assign_source_27 );
    tmp_source_name_65 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_source_name_65 == NULL ))
    {
        tmp_source_name_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    CHECK_OBJECT( tmp_source_name_65 );
    tmp_called_name_72 = LOOKUP_ATTRIBUTE( tmp_source_name_65, const_str_plain_add_option );
    if ( tmp_called_name_72 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;

        goto frame_exception_exit_1;
    }
    tmp_args_name_50 = const_tuple_str_digest_182801ca351e48a7ac147d78d9a5a172_tuple;
    tmp_kw_name_51 = PyDict_Copy( const_dict_a9a03b40ba8f26cdbb333b87799dc921 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 655;
    tmp_unused = CALL_FUNCTION( tmp_called_name_72, tmp_args_name_50, tmp_kw_name_51 );
    Py_DECREF( tmp_called_name_72 );
    Py_DECREF( tmp_kw_name_51 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_66 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_source_name_66 == NULL ))
    {
        tmp_source_name_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    if ( tmp_source_name_66 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "tracing_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 665;

        goto frame_exception_exit_1;
    }

    tmp_called_name_73 = LOOKUP_ATTRIBUTE( tmp_source_name_66, const_str_plain_add_option );
    if ( tmp_called_name_73 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;

        goto frame_exception_exit_1;
    }
    tmp_args_name_51 = const_tuple_str_digest_a4fc5193531b6150e42d718b392fd227_tuple;
    tmp_kw_name_52 = PyDict_Copy( const_dict_aa8231dd4f6fdaa06dbf5512dde88796 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 665;
    tmp_unused = CALL_FUNCTION( tmp_called_name_73, tmp_args_name_51, tmp_kw_name_52 );
    Py_DECREF( tmp_called_name_73 );
    Py_DECREF( tmp_kw_name_52 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_67 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_source_name_67 == NULL ))
    {
        tmp_source_name_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    if ( tmp_source_name_67 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "tracing_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 674;

        goto frame_exception_exit_1;
    }

    tmp_called_name_74 = LOOKUP_ATTRIBUTE( tmp_source_name_67, const_str_plain_add_option );
    if ( tmp_called_name_74 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;

        goto frame_exception_exit_1;
    }
    tmp_args_name_52 = const_tuple_str_digest_d622909c277871892b649806560e5ee9_tuple;
    tmp_kw_name_53 = PyDict_Copy( const_dict_cd2f10c233c60e843dc94e0ca3fff447 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 674;
    tmp_unused = CALL_FUNCTION( tmp_called_name_74, tmp_args_name_52, tmp_kw_name_53 );
    Py_DECREF( tmp_called_name_74 );
    Py_DECREF( tmp_kw_name_53 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_68 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_source_name_68 == NULL ))
    {
        tmp_source_name_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    if ( tmp_source_name_68 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "tracing_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 684;

        goto frame_exception_exit_1;
    }

    tmp_called_name_75 = LOOKUP_ATTRIBUTE( tmp_source_name_68, const_str_plain_add_option );
    if ( tmp_called_name_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;

        goto frame_exception_exit_1;
    }
    tmp_args_name_53 = const_tuple_str_digest_63956f13172d297e8502409fdc42b709_tuple;
    tmp_kw_name_54 = PyDict_Copy( const_dict_e05c9b973b11029e09a99d8142ddfc93 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 684;
    tmp_unused = CALL_FUNCTION( tmp_called_name_75, tmp_args_name_53, tmp_kw_name_54 );
    Py_DECREF( tmp_called_name_75 );
    Py_DECREF( tmp_kw_name_54 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_69 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_source_name_69 == NULL ))
    {
        tmp_source_name_69 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    if ( tmp_source_name_69 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "tracing_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 693;

        goto frame_exception_exit_1;
    }

    tmp_called_name_76 = LOOKUP_ATTRIBUTE( tmp_source_name_69, const_str_plain_add_option );
    if ( tmp_called_name_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;

        goto frame_exception_exit_1;
    }
    tmp_args_name_54 = const_tuple_str_digest_8d9a7968bdcf97bf89ecd9cc70ce5a60_tuple;
    tmp_kw_name_55 = PyDict_Copy( const_dict_d8084db55bb0173b66ca83cf5be4a1f7 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 693;
    tmp_unused = CALL_FUNCTION( tmp_called_name_76, tmp_args_name_54, tmp_kw_name_55 );
    Py_DECREF( tmp_called_name_76 );
    Py_DECREF( tmp_kw_name_55 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_70 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_70 == NULL ))
    {
        tmp_source_name_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_70 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 703;

        goto frame_exception_exit_1;
    }

    tmp_called_name_77 = LOOKUP_ATTRIBUTE( tmp_source_name_70, const_str_plain_add_option_group );
    if ( tmp_called_name_77 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 703;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_30 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_tracing_group );

    if (unlikely( tmp_args_element_name_30 == NULL ))
    {
        tmp_args_element_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_tracing_group );
    }

    if ( tmp_args_element_name_30 == NULL )
    {
        Py_DECREF( tmp_called_name_77 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "tracing_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 703;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 703;
    {
        PyObject *call_args[] = { tmp_args_element_name_30 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_77, call_args );
    }

    Py_DECREF( tmp_called_name_77 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 703;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_71 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_windows_group );

    if (unlikely( tmp_source_name_71 == NULL ))
    {
        tmp_source_name_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_windows_group );
    }

    if ( tmp_source_name_71 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "windows_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 705;

        goto frame_exception_exit_1;
    }

    tmp_called_name_78 = LOOKUP_ATTRIBUTE( tmp_source_name_71, const_str_plain_add_option );
    if ( tmp_called_name_78 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;

        goto frame_exception_exit_1;
    }
    tmp_args_name_55 = const_tuple_str_digest_0038a88d36dd7b18556a93f0b96f344c_tuple;
    tmp_kw_name_56 = PyDict_Copy( const_dict_0ad4788675528d8982a04cde68621006 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 705;
    tmp_unused = CALL_FUNCTION( tmp_called_name_78, tmp_args_name_55, tmp_kw_name_56 );
    Py_DECREF( tmp_called_name_78 );
    Py_DECREF( tmp_kw_name_56 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_72 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_windows_group );

    if (unlikely( tmp_source_name_72 == NULL ))
    {
        tmp_source_name_72 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_windows_group );
    }

    if ( tmp_source_name_72 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "windows_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 714;

        goto frame_exception_exit_1;
    }

    tmp_called_name_79 = LOOKUP_ATTRIBUTE( tmp_source_name_72, const_str_plain_add_option );
    if ( tmp_called_name_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;

        goto frame_exception_exit_1;
    }
    tmp_args_name_56 = const_tuple_b6d47a1fac0ac1116306d2c778fc7fa0_tuple;
    tmp_kw_name_57 = PyDict_Copy( const_dict_0902eb40bd31bd25b3bae9ef7176fa85 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 714;
    tmp_unused = CALL_FUNCTION( tmp_called_name_79, tmp_args_name_56, tmp_kw_name_57 );
    Py_DECREF( tmp_called_name_79 );
    Py_DECREF( tmp_kw_name_57 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_73 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_73 == NULL ))
    {
        tmp_source_name_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_73 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 723;

        goto frame_exception_exit_1;
    }

    tmp_called_name_80 = LOOKUP_ATTRIBUTE( tmp_source_name_73, const_str_plain_add_option_group );
    if ( tmp_called_name_80 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_31 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_windows_group );

    if (unlikely( tmp_args_element_name_31 == NULL ))
    {
        tmp_args_element_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_windows_group );
    }

    if ( tmp_args_element_name_31 == NULL )
    {
        Py_DECREF( tmp_called_name_80 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "windows_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 723;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 723;
    {
        PyObject *call_args[] = { tmp_args_element_name_31 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_80, call_args );
    }

    Py_DECREF( tmp_called_name_80 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_81 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_OptionGroup );

    if (unlikely( tmp_called_name_81 == NULL ))
    {
        tmp_called_name_81 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_OptionGroup );
    }

    if ( tmp_called_name_81 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "OptionGroup" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 725;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_32 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_args_element_name_32 == NULL ))
    {
        tmp_args_element_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_args_element_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 726;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_33 = const_str_digest_6ffff9871e7a9049cdcc39ccb0332ee2;
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 725;
    {
        PyObject *call_args[] = { tmp_args_element_name_32, tmp_args_element_name_33 };
        tmp_assign_source_28 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_81, call_args );
    }

    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group, tmp_assign_source_28 );
    tmp_source_name_74 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group );

    if (unlikely( tmp_source_name_74 == NULL ))
    {
        tmp_source_name_74 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_plugin_group );
    }

    CHECK_OBJECT( tmp_source_name_74 );
    tmp_called_name_82 = LOOKUP_ATTRIBUTE( tmp_source_name_74, const_str_plain_add_option );
    if ( tmp_called_name_82 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 730;

        goto frame_exception_exit_1;
    }
    tmp_args_name_57 = const_tuple_d6bdf977d7cdf572f474b619c9d47469_tuple;
    tmp_kw_name_58 = DEEP_COPY( const_dict_90a95198da96374edd136a324cfe2551 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 730;
    tmp_unused = CALL_FUNCTION( tmp_called_name_82, tmp_args_name_57, tmp_kw_name_58 );
    Py_DECREF( tmp_called_name_82 );
    Py_DECREF( tmp_kw_name_58 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 730;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_75 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group );

    if (unlikely( tmp_source_name_75 == NULL ))
    {
        tmp_source_name_75 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_plugin_group );
    }

    if ( tmp_source_name_75 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "plugin_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 740;

        goto frame_exception_exit_1;
    }

    tmp_called_name_83 = LOOKUP_ATTRIBUTE( tmp_source_name_75, const_str_plain_add_option );
    if ( tmp_called_name_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;

        goto frame_exception_exit_1;
    }
    tmp_args_name_58 = const_tuple_fc33f4d4eefe708c7f5fade18f710ac3_tuple;
    tmp_kw_name_59 = DEEP_COPY( const_dict_45062a32a0550745ae06f84c5860b292 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 740;
    tmp_unused = CALL_FUNCTION( tmp_called_name_83, tmp_args_name_58, tmp_kw_name_59 );
    Py_DECREF( tmp_called_name_83 );
    Py_DECREF( tmp_kw_name_59 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_76 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group );

    if (unlikely( tmp_source_name_76 == NULL ))
    {
        tmp_source_name_76 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_plugin_group );
    }

    if ( tmp_source_name_76 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "plugin_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 750;

        goto frame_exception_exit_1;
    }

    tmp_called_name_84 = LOOKUP_ATTRIBUTE( tmp_source_name_76, const_str_plain_add_option );
    if ( tmp_called_name_84 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 750;

        goto frame_exception_exit_1;
    }
    tmp_args_name_59 = const_tuple_str_digest_919dfec0da52245e2d2f6edeae5a1142_tuple;
    tmp_kw_name_60 = PyDict_Copy( const_dict_f6a84467671671bed9a729c01faf6eb0 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 750;
    tmp_unused = CALL_FUNCTION( tmp_called_name_84, tmp_args_name_59, tmp_kw_name_60 );
    Py_DECREF( tmp_called_name_84 );
    Py_DECREF( tmp_kw_name_60 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 750;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_77 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group );

    if (unlikely( tmp_source_name_77 == NULL ))
    {
        tmp_source_name_77 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_plugin_group );
    }

    if ( tmp_source_name_77 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "plugin_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 763;

        goto frame_exception_exit_1;
    }

    tmp_called_name_85 = LOOKUP_ATTRIBUTE( tmp_source_name_77, const_str_plain_add_option );
    if ( tmp_called_name_85 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;

        goto frame_exception_exit_1;
    }
    tmp_args_name_60 = const_tuple_str_digest_3b894041eea82e2fea9b741aeeedf865_tuple;
    tmp_kw_name_61 = PyDict_Copy( const_dict_9698778f5c679af1b643e7cc72ba60e3 );
    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 763;
    tmp_unused = CALL_FUNCTION( tmp_called_name_85, tmp_args_name_60, tmp_kw_name_61 );
    Py_DECREF( tmp_called_name_85 );
    Py_DECREF( tmp_kw_name_61 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_78 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parser );

    if (unlikely( tmp_source_name_78 == NULL ))
    {
        tmp_source_name_78 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parser );
    }

    if ( tmp_source_name_78 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 773;

        goto frame_exception_exit_1;
    }

    tmp_called_name_86 = LOOKUP_ATTRIBUTE( tmp_source_name_78, const_str_plain_add_option_group );
    if ( tmp_called_name_86 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 773;

        goto frame_exception_exit_1;
    }
    tmp_args_element_name_34 = GET_STRING_DICT_VALUE( moduledict_Options, (Nuitka_StringObject *)const_str_plain_plugin_group );

    if (unlikely( tmp_args_element_name_34 == NULL ))
    {
        tmp_args_element_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_plugin_group );
    }

    if ( tmp_args_element_name_34 == NULL )
    {
        Py_DECREF( tmp_called_name_86 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "plugin_group" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 773;

        goto frame_exception_exit_1;
    }

    frame_c58a6b313fcc56d855cb1583debb45f4->m_frame.f_lineno = 773;
    {
        PyObject *call_args[] = { tmp_args_element_name_34 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_86, call_args );
    }

    Py_DECREF( tmp_called_name_86 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 773;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c58a6b313fcc56d855cb1583debb45f4 );
#endif
    popFrameStack();

    assertFrameObject( frame_c58a6b313fcc56d855cb1583debb45f4 );

    goto frame_no_exception_1;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c58a6b313fcc56d855cb1583debb45f4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c58a6b313fcc56d855cb1583debb45f4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c58a6b313fcc56d855cb1583debb45f4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c58a6b313fcc56d855cb1583debb45f4, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_1:;
    tmp_assign_source_29 = Py_None;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_options, tmp_assign_source_29 );
    tmp_assign_source_30 = Py_None;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain_positional_args, tmp_assign_source_30 );
    tmp_assign_source_31 = PyList_New( 0 );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_extra_args, tmp_assign_source_31 );
    tmp_assign_source_32 = MAKE_FUNCTION_Options$$$function_1_parseArgs(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_parseArgs, tmp_assign_source_32 );
    tmp_assign_source_33 = MAKE_FUNCTION_Options$$$function_2_isVerbose(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isVerbose, tmp_assign_source_33 );
    tmp_assign_source_34 = MAKE_FUNCTION_Options$$$function_3_shallTraceExecution(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallTraceExecution, tmp_assign_source_34 );
    tmp_assign_source_35 = MAKE_FUNCTION_Options$$$function_4_shallExecuteImmediately(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallExecuteImmediately, tmp_assign_source_35 );
    tmp_assign_source_36 = MAKE_FUNCTION_Options$$$function_5_shallRunInDebugger(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallRunInDebugger, tmp_assign_source_36 );
    tmp_assign_source_37 = MAKE_FUNCTION_Options$$$function_6_shallDumpBuiltTreeXML(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallDumpBuiltTreeXML, tmp_assign_source_37 );
    tmp_assign_source_38 = MAKE_FUNCTION_Options$$$function_7_shallDisplayBuiltTree(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallDisplayBuiltTree, tmp_assign_source_38 );
    tmp_assign_source_39 = MAKE_FUNCTION_Options$$$function_8_shallOnlyExecCCompilerCall(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallOnlyExecCCompilerCall, tmp_assign_source_39 );
    tmp_assign_source_40 = MAKE_FUNCTION_Options$$$function_9_shallNotDoExecCCompilerCall(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallNotDoExecCCompilerCall, tmp_assign_source_40 );
    tmp_assign_source_41 = MAKE_FUNCTION_Options$$$function_10_shallHaveStatementLines(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallHaveStatementLines, tmp_assign_source_41 );
    tmp_assign_source_42 = MAKE_FUNCTION_Options$$$function_11_getFileReferenceMode(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getFileReferenceMode, tmp_assign_source_42 );
    tmp_assign_source_43 = MAKE_FUNCTION_Options$$$function_12_shallMakeModule(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallMakeModule, tmp_assign_source_43 );
    tmp_assign_source_44 = MAKE_FUNCTION_Options$$$function_13_shallCreatePyiFile(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallCreatePyiFile, tmp_assign_source_44 );
    tmp_assign_source_45 = MAKE_FUNCTION_Options$$$function_14_isAllowedToReexecute(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isAllowedToReexecute, tmp_assign_source_45 );
    tmp_assign_source_46 = MAKE_FUNCTION_Options$$$function_15_shallFollowStandardLibrary(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallFollowStandardLibrary, tmp_assign_source_46 );
    tmp_assign_source_47 = MAKE_FUNCTION_Options$$$function_16_shallFollowNoImports(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallFollowNoImports, tmp_assign_source_47 );
    tmp_assign_source_48 = MAKE_FUNCTION_Options$$$function_17_shallFollowAllImports(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallFollowAllImports, tmp_assign_source_48 );
    tmp_assign_source_49 = MAKE_FUNCTION_Options$$$function_18__splitShellPattern(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain__splitShellPattern, tmp_assign_source_49 );
    tmp_assign_source_50 = MAKE_FUNCTION_Options$$$function_19_getShallFollowInNoCase(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowInNoCase, tmp_assign_source_50 );
    tmp_assign_source_51 = MAKE_FUNCTION_Options$$$function_20_getShallFollowModules(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowModules, tmp_assign_source_51 );
    tmp_assign_source_52 = MAKE_FUNCTION_Options$$$function_21_getShallFollowExtra(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowExtra, tmp_assign_source_52 );
    tmp_assign_source_53 = MAKE_FUNCTION_Options$$$function_22_getShallFollowExtraFilePatterns(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getShallFollowExtraFilePatterns, tmp_assign_source_53 );
    tmp_assign_source_54 = MAKE_FUNCTION_Options$$$function_23_getMustIncludeModules(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getMustIncludeModules, tmp_assign_source_54 );
    tmp_assign_source_55 = MAKE_FUNCTION_Options$$$function_24_getMustIncludePackages(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getMustIncludePackages, tmp_assign_source_55 );
    tmp_assign_source_56 = MAKE_FUNCTION_Options$$$function_25_shallWarnImplicitRaises(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallWarnImplicitRaises, tmp_assign_source_56 );
    tmp_assign_source_57 = MAKE_FUNCTION_Options$$$function_26_shallWarnUnusualCode(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallWarnUnusualCode, tmp_assign_source_57 );
    tmp_assign_source_58 = MAKE_FUNCTION_Options$$$function_27_assumeYesForDownloads(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_assumeYesForDownloads, tmp_assign_source_58 );
    tmp_assign_source_59 = MAKE_FUNCTION_Options$$$function_28_isDebug(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isDebug, tmp_assign_source_59 );
    tmp_assign_source_60 = MAKE_FUNCTION_Options$$$function_29_isPythonDebug(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isPythonDebug, tmp_assign_source_60 );
    tmp_assign_source_61 = MAKE_FUNCTION_Options$$$function_30_isUnstripped(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isUnstripped, tmp_assign_source_61 );
    tmp_assign_source_62 = MAKE_FUNCTION_Options$$$function_31_isProfile(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isProfile, tmp_assign_source_62 );
    tmp_assign_source_63 = MAKE_FUNCTION_Options$$$function_32_shallCreateGraph(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallCreateGraph, tmp_assign_source_63 );
    tmp_assign_source_64 = MAKE_FUNCTION_Options$$$function_33_getOutputPath(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getOutputPath, tmp_assign_source_64 );
    tmp_assign_source_65 = MAKE_FUNCTION_Options$$$function_34_getOutputDir(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getOutputDir, tmp_assign_source_65 );
    tmp_assign_source_66 = MAKE_FUNCTION_Options$$$function_35_getPositionalArgs(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPositionalArgs, tmp_assign_source_66 );
    tmp_assign_source_67 = MAKE_FUNCTION_Options$$$function_36_getMainArgs(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getMainArgs, tmp_assign_source_67 );
    tmp_assign_source_68 = MAKE_FUNCTION_Options$$$function_37_shallOptimizeStringExec(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallOptimizeStringExec, tmp_assign_source_68 );
    tmp_assign_source_69 = MAKE_FUNCTION_Options$$$function_38_shallClearPythonPathEnvironment(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallClearPythonPathEnvironment, tmp_assign_source_69 );
    tmp_assign_source_70 = MAKE_FUNCTION_Options$$$function_39_isShowScons(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isShowScons, tmp_assign_source_70 );
    tmp_assign_source_71 = MAKE_FUNCTION_Options$$$function_40_getJobLimit(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getJobLimit, tmp_assign_source_71 );
    tmp_assign_source_72 = MAKE_FUNCTION_Options$$$function_41_isLto(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isLto, tmp_assign_source_72 );
    tmp_assign_source_73 = MAKE_FUNCTION_Options$$$function_42_isClang(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isClang, tmp_assign_source_73 );
    tmp_assign_source_74 = MAKE_FUNCTION_Options$$$function_43_isMingw(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isMingw, tmp_assign_source_74 );
    tmp_assign_source_75 = MAKE_FUNCTION_Options$$$function_44_getMsvcVersion(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getMsvcVersion, tmp_assign_source_75 );
    tmp_assign_source_76 = MAKE_FUNCTION_Options$$$function_45_shallDisableConsoleWindow(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallDisableConsoleWindow, tmp_assign_source_76 );
    tmp_assign_source_77 = MAKE_FUNCTION_Options$$$function_46_isFullCompat(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isFullCompat, tmp_assign_source_77 );
    tmp_assign_source_78 = MAKE_FUNCTION_Options$$$function_47_isShowProgress(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isShowProgress, tmp_assign_source_78 );
    tmp_assign_source_79 = MAKE_FUNCTION_Options$$$function_48_isShowMemory(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isShowMemory, tmp_assign_source_79 );
    tmp_assign_source_80 = MAKE_FUNCTION_Options$$$function_49_isShowInclusion(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isShowInclusion, tmp_assign_source_80 );
    tmp_assign_source_81 = MAKE_FUNCTION_Options$$$function_50_isRemoveBuildDir(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isRemoveBuildDir, tmp_assign_source_81 );
    tmp_assign_source_82 = MAKE_FUNCTION_Options$$$function_51_getIntendedPythonVersion(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getIntendedPythonVersion, tmp_assign_source_82 );
    tmp_assign_source_83 = MAKE_FUNCTION_Options$$$function_52_getIntendedPythonArch(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getIntendedPythonArch, tmp_assign_source_83 );
    tmp_assign_source_84 = MAKE_FUNCTION_Options$$$function_53_isExperimental(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isExperimental, tmp_assign_source_84 );
    tmp_assign_source_85 = MAKE_FUNCTION_Options$$$function_54_getExperimentalIndications(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getExperimentalIndications, tmp_assign_source_85 );
    tmp_assign_source_86 = MAKE_FUNCTION_Options$$$function_55_shallExplainImports(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallExplainImports, tmp_assign_source_86 );
    tmp_assign_source_87 = MAKE_FUNCTION_Options$$$function_56_isStandaloneMode(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_isStandaloneMode, tmp_assign_source_87 );
    tmp_assign_source_88 = MAKE_FUNCTION_Options$$$function_57_getIconPath(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getIconPath, tmp_assign_source_88 );
    tmp_assign_source_89 = Py_None;
    UPDATE_STRING_DICT0( moduledict_Options, (Nuitka_StringObject *)const_str_plain__python_flags, tmp_assign_source_89 );
    tmp_assign_source_90 = MAKE_FUNCTION_Options$$$function_58_getPythonFlags(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPythonFlags, tmp_assign_source_90 );
    tmp_assign_source_91 = MAKE_FUNCTION_Options$$$function_59_shallFreezeAllStdlib(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallFreezeAllStdlib, tmp_assign_source_91 );
    tmp_assign_source_92 = MAKE_FUNCTION_Options$$$function_60_shallNotUseDependsExeCachedResults(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallNotUseDependsExeCachedResults, tmp_assign_source_92 );
    tmp_assign_source_93 = MAKE_FUNCTION_Options$$$function_61_shallNotStoreDependsExeCachedResults(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallNotStoreDependsExeCachedResults, tmp_assign_source_93 );
    tmp_assign_source_94 = MAKE_FUNCTION_Options$$$function_62_shallListPlugins(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallListPlugins, tmp_assign_source_94 );
    tmp_assign_source_95 = MAKE_FUNCTION_Options$$$function_63_getPluginsEnabled(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPluginsEnabled, tmp_assign_source_95 );
    tmp_assign_source_96 = MAKE_FUNCTION_Options$$$function_64_getPluginOptions(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPluginOptions, tmp_assign_source_96 );
    tmp_assign_source_97 = MAKE_FUNCTION_Options$$$function_65_getPluginsDisabled(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPluginsDisabled, tmp_assign_source_97 );
    tmp_assign_source_98 = MAKE_FUNCTION_Options$$$function_66_shallDetectMissingPlugins(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_shallDetectMissingPlugins, tmp_assign_source_98 );
    tmp_assign_source_99 = MAKE_FUNCTION_Options$$$function_67_getPythonPathForScons(  );
    UPDATE_STRING_DICT1( moduledict_Options, (Nuitka_StringObject *)const_str_plain_getPythonPathForScons, tmp_assign_source_99 );

    return MOD_RETURN_VALUE( module_Options );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
