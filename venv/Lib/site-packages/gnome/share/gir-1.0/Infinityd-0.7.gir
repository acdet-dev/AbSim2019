<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Infinity" version="0.7"/>
  <package name="libinfinity-0.7"/>
  <namespace name="Infinityd"
             version="0.7"
             shared-library="libinfinity-0.7-0.dll"
             c:identifier-prefixes="Infd"
             c:symbol-prefixes="infd">
    <interface name="AccountStorage"
               c:symbol-prefix="account_storage"
               c:type="InfdAccountStorage"
               glib:type-name="InfdAccountStorage"
               glib:get-type="infd_account_storage_get_type"
               glib:type-struct="AccountStorageInterface">
      <doc xml:space="preserve">#InfdAccountStorage is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="account_added" invoker="account_added">
        <doc xml:space="preserve">Emits the #InfdAccountStorage::account-added signal on @storage. This
should only be used by interface implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount that was added to the storage.</doc>
            <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="account_removed" invoker="account_removed">
        <doc xml:space="preserve">Emits the #InfdAccountStorage::account-removed signal on @storage. This
should only be used by interface implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount with the account information for the removed
account.</doc>
            <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_account" invoker="add_account" throws="1">
        <doc xml:space="preserve">Adds a new account to @storage. The account will have the given name. The
account ID is determined by the storage backend and if the operation is
successful it is returned.

If the operation does not support storing certificates and/or passwords,
the function will fail if @certs or @password are not set to %NULL,
respectively. Note also that this function might not be supported at all
by the backend. See infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #InfAclAccountId of the added account, or 0
on error.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the new account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="certs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of certificates that
can be used to login to the new account, or %NULL.</doc>
            <array length="2" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certs" transfer-ownership="none">
            <doc xml:space="preserve">The length of the certificate array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="password"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A password that can be used to login to the
new account, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_support" invoker="get_support">
        <doc xml:space="preserve">Returns a bitmask of operations supported by the account storage backend.
If unsupported operations are attempted on @storage, an @error with code
%INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED will be generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A bitmask of supported operations.</doc>
          <type name="AccountStorageSupport"
                c:type="InfdAccountStorageSupport"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_accounts" throws="1">
        <return-value transfer-ownership="full">
          <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="login_by_certificate"
                      invoker="login_by_certificate"
                      throws="1">
        <doc xml:space="preserve">This function returns the ID of the account which belongs to the given
client certificate. If there is no such account on an error occurs,
the function returns 0, and, in the case of an error, @error is set as
well.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID of the account associated to
@cert, or 0 on error or if there is no such account.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">The certificate presented by the client.</doc>
            <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="login_by_password"
                      invoker="login_by_password"
                      throws="1">
        <doc xml:space="preserve">This function returns the account ID which matches to the given username
and password. If there is no such account or if the password is incorrect,
the function returns 0. If an error occurs, the function returns 0 and
@error is set.

Note that when the password is incorrect, @error is not set. It is only set
if there was an internal error and the login procedure could not be carried
out due to technical reasons, such as a database outage.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID of the account associated to
@username if @password is correct, or 0 otherwise.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">The username of the account to log into.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The password of the corresponding account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_accounts" throws="1">
        <return-value transfer-ownership="full">
          <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="accounts" transfer-ownership="none">
            <type name="Infinity.AclAccountId"
                  c:type="const InfAclAccountId*"/>
          </parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_accounts_by_name" throws="1">
        <return-value transfer-ownership="full">
          <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_account"
                      invoker="remove_account"
                      throws="1">
        <doc xml:space="preserve">Removes the account with the given ID from @storage.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account to remove.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_certificate"
                      invoker="set_certificate"
                      throws="1">
        <doc xml:space="preserve">Changes the certificate(s) associated to the account with ID @account.
All certificates that are currently associated to it are removed, and the
given certificates are associated instead. If @n_certs is 0, there will
be no associated certificates and login by certificate will be disabled
for @account.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful or %FALSE if an error
occured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account whose certificate to set.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="certs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of certificates,
or %NULL if n_certs is 0.</doc>
            <array length="2" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certs" transfer-ownership="none">
            <doc xml:space="preserve">The number of certificates in the certificate array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_password" invoker="set_password" throws="1">
        <doc xml:space="preserve">Changes the password for the account with the given ID. If this call
succeeds, the new password will have to be provided to
infd_account_storage_login_by_password() for the login to succeed. If
@password is %NULL, the password will be unset and login by password
will no longer be possible.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account whose password to change.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The new password for the account, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="account_added"
              c:identifier="infd_account_storage_account_added">
        <doc xml:space="preserve">Emits the #InfdAccountStorage::account-added signal on @storage. This
should only be used by interface implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount that was added to the storage.</doc>
            <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
        </parameters>
      </method>
      <method name="account_removed"
              c:identifier="infd_account_storage_account_removed">
        <doc xml:space="preserve">Emits the #InfdAccountStorage::account-removed signal on @storage. This
should only be used by interface implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount with the account information for the removed
account.</doc>
            <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_account"
              c:identifier="infd_account_storage_add_account"
              throws="1">
        <doc xml:space="preserve">Adds a new account to @storage. The account will have the given name. The
account ID is determined by the storage backend and if the operation is
successful it is returned.

If the operation does not support storing certificates and/or passwords,
the function will fail if @certs or @password are not set to %NULL,
respectively. Note also that this function might not be supported at all
by the backend. See infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #InfAclAccountId of the added account, or 0
on error.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the new account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="certs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of certificates that
can be used to login to the new account, or %NULL.</doc>
            <array length="2" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certs" transfer-ownership="none">
            <doc xml:space="preserve">The length of the certificate array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="password"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A password that can be used to login to the
new account, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_support"
              c:identifier="infd_account_storage_get_support">
        <doc xml:space="preserve">Returns a bitmask of operations supported by the account storage backend.
If unsupported operations are attempted on @storage, an @error with code
%INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED will be generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A bitmask of supported operations.</doc>
          <type name="AccountStorageSupport"
                c:type="InfdAccountStorageSupport"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_accounts"
              c:identifier="infd_account_storage_list_accounts"
              throws="1">
        <doc xml:space="preserve">Returns an array of all accounts in @storage. The length of the array
is stored in the output parameter @n_accounts. The functions returns %NULL
and sets @n_accounts to 0 if there are no accounts in @storage. If there is
an error, the function returns %NULL, @n_accounts is undefined, and @error
is set.  Therefore, to reliably find out whether an error occurred or
whether there are really no accounts present, a non-%NULL error pointer
should be passed and checked after the function call.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An array
of #InfAclAccount structures with length @n_accounts, or %NULL if
@n_accounts is 0 or @error is set. Free with
inf_acl_account_array_free().</doc>
          <array length="0" zero-terminated="0" c:type="InfAclAccount*">
            <type name="Infinity.AclAccount" c:type="InfAclAccount"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="n_accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">An output parameter holding the number of accounts
in @storage.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_by_certificate"
              c:identifier="infd_account_storage_login_by_certificate"
              throws="1">
        <doc xml:space="preserve">This function returns the ID of the account which belongs to the given
client certificate. If there is no such account on an error occurs,
the function returns 0, and, in the case of an error, @error is set as
well.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID of the account associated to
@cert, or 0 on error or if there is no such account.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">The certificate presented by the client.</doc>
            <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="login_by_password"
              c:identifier="infd_account_storage_login_by_password"
              throws="1">
        <doc xml:space="preserve">This function returns the account ID which matches to the given username
and password. If there is no such account or if the password is incorrect,
the function returns 0. If an error occurs, the function returns 0 and
@error is set.

Note that when the password is incorrect, @error is not set. It is only set
if there was an internal error and the login procedure could not be carried
out due to technical reasons, such as a database outage.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID of the account associated to
@username if @password is correct, or 0 otherwise.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">The username of the account to log into.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The password of the corresponding account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_accounts"
              c:identifier="infd_account_storage_lookup_accounts"
              throws="1">
        <doc xml:space="preserve">Looks up the #InfAclAccount structure for all IDs present in @accounts.
The return value is an array of #InfAclAccount structures which is in the
same order as the @accounts array. If an element in the output array has
the #InfAclAccount.id field set to 0, it means that the account with the
corresponding ID in the @accounts array does not exist in @storage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An array of
#InfAclAccount structures with @n_accounts entries. Free with
inf_acl_account_array_free().</doc>
          <array length="1" zero-terminated="0" c:type="InfAclAccount*">
            <type name="Infinity.AclAccount" c:type="InfAclAccount"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="accounts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #InfAclAccountId&lt;!-- --&gt;s
to look up.</doc>
            <array length="1" zero-terminated="0" c:type="InfAclAccountId*">
              <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
            </array>
          </parameter>
          <parameter name="n_accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The number of elements in @accounts.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_accounts_by_name"
              c:identifier="infd_account_storage_lookup_accounts_by_name"
              throws="1">
        <doc xml:space="preserve">This function performs the &amp;quot;reverse&amp;quot; lookup: Given an account
name, the function returns an array with all accounts that have this name.
Many backends make sure that there cannot be duplicated names, in which
case this can at most return one account, however in principle accounts
with the same name are supported.

If there is no account with the given name, the function returns %NULL and
sets @n_accounts to 0. If an error occurs, %NULL is returned, @n_accounts
is undefined, and @error is set. Therefore, to reliably find out whether a
lookup error occured or this is no account with the given name, a non-%NULL
error pointer should be passed and checked after the function call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An array of
#InfAclAccount structures with length @n_accounts, or %NULL on error
or when @n_accounts is 0 or @error is set. Free with
inf_acl_account_array_free().</doc>
          <array length="1" zero-terminated="0" c:type="InfAclAccount*">
            <type name="Infinity.AclAccount" c:type="InfAclAccount"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">An output parameter holding the number of returned
accounts.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_account"
              c:identifier="infd_account_storage_remove_account"
              throws="1">
        <doc xml:space="preserve">Removes the account with the given ID from @storage.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account to remove.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_certificate"
              c:identifier="infd_account_storage_set_certificate"
              throws="1">
        <doc xml:space="preserve">Changes the certificate(s) associated to the account with ID @account.
All certificates that are currently associated to it are removed, and the
given certificates are associated instead. If @n_certs is 0, there will
be no associated certificates and login by certificate will be disabled
for @account.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful or %FALSE if an error
occured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account whose certificate to set.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="certs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of certificates,
or %NULL if n_certs is 0.</doc>
            <array length="2" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certs" transfer-ownership="none">
            <doc xml:space="preserve">The number of certificates in the certificate array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password"
              c:identifier="infd_account_storage_set_password"
              throws="1">
        <doc xml:space="preserve">Changes the password for the account with the given ID. If this call
succeeds, the new password will have to be provided to
infd_account_storage_login_by_password() for the login to succeed. If
@password is %NULL, the password will be unset and login by password
will no longer be possible.

Note that this function might not be supported by the backend. See
infd_account_storage_get_support().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account whose password to change.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The new password for the account, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports" c:identifier="infd_account_storage_supports">
        <doc xml:space="preserve">Checks whether support for all operations specified in @support is
available for @storage. This is equivalent to calling
infd_account_storage_get_support() and testing the returned value for
containing the bits in @support.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if all operations in @support are supported or %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdAccountStorage.</doc>
            <type name="AccountStorage" c:type="InfdAccountStorage*"/>
          </instance-parameter>
          <parameter name="support" transfer-ownership="none">
            <doc xml:space="preserve">A bitmask of operations to test.</doc>
            <type name="AccountStorageSupport"
                  c:type="InfdAccountStorageSupport"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="account-added" when="last">
        <doc xml:space="preserve">This signal is emitted whenever an account has been added to the
account storage. However, the signal is only emitted if the storage
implementations supports the %INFD_ACCOUNT_STORAGE_SUPPORT_NOTIFICATION
support flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount containing the account ID and account name
of the added account.</doc>
            <type name="Infinity.AclAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" when="last">
        <doc xml:space="preserve">This signal is emitted whenever an account has been permanently removed
from the storage. However, the signal is only emitted if the storage
implementations supports the %INFD_ACCOUNT_STORAGE_SUPPORT_NOTIFICATION
support flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount containing the account ID and account name
of the removed account.</doc>
            <type name="Infinity.AclAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="AccountStorageInterface"
            c:type="InfdAccountStorageInterface"
            glib:is-gtype-struct-for="AccountStorage">
      <doc xml:space="preserve">The virtual methods and default signal handlers of #InfdAccountStorage.
Implementing these allows an infinote server to set a specific source of
user accounts.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_support">
        <callback name="get_support">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A bitmask of supported operations.</doc>
            <type name="AccountStorageSupport"
                  c:type="InfdAccountStorageSupport"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_accounts">
        <callback name="lookup_accounts" throws="1">
          <return-value transfer-ownership="full">
            <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="accounts" transfer-ownership="none">
              <type name="Infinity.AclAccountId"
                    c:type="const InfAclAccountId*"/>
            </parameter>
            <parameter name="n_accounts" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_accounts_by_name">
        <callback name="lookup_accounts_by_name" throws="1">
          <return-value transfer-ownership="full">
            <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="n_accounts" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_accounts">
        <callback name="list_accounts" throws="1">
          <return-value transfer-ownership="full">
            <type name="Infinity.AclAccount" c:type="InfAclAccount*"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="n_accounts" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_account">
        <callback name="add_account" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The #InfAclAccountId of the added account, or 0
on error.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the new account.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="certs"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">An array of certificates that
can be used to login to the new account, or %NULL.</doc>
              <array length="3"
                     zero-terminated="0"
                     c:type="gnutls_x509_crt_t*">
                <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
              </array>
            </parameter>
            <parameter name="n_certs" transfer-ownership="none">
              <doc xml:space="preserve">The length of the certificate array.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="password"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A password that can be used to login to the
new account, or %NULL.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_account">
        <callback name="remove_account" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The ID of the account to remove.</doc>
              <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="login_by_certificate">
        <callback name="login_by_certificate" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The account ID of the account associated to
@cert, or 0 on error or if there is no such account.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="cert" transfer-ownership="none">
              <doc xml:space="preserve">The certificate presented by the client.</doc>
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="login_by_password">
        <callback name="login_by_password" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The account ID of the account associated to
@username if @password is correct, or 0 otherwise.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="username" transfer-ownership="none">
              <doc xml:space="preserve">The username of the account to log into.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">The password of the corresponding account.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_certificate">
        <callback name="set_certificate" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the operation was successful or %FALSE if an error
occured.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The ID of the account whose certificate to set.</doc>
              <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
            </parameter>
            <parameter name="certs"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">An array of certificates,
or %NULL if n_certs is 0.</doc>
              <array length="3"
                     zero-terminated="0"
                     c:type="gnutls_x509_crt_t*">
                <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
              </array>
            </parameter>
            <parameter name="n_certs" transfer-ownership="none">
              <doc xml:space="preserve">The number of certificates in the certificate array.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_password">
        <callback name="set_password" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The ID of the account whose password to change.</doc>
              <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">The new password for the account, or %NULL.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="account_added">
        <callback name="account_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAclAccount that was added to the storage.</doc>
              <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="account_removed">
        <callback name="account_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdAccountStorage.</doc>
              <type name="AccountStorage" c:type="InfdAccountStorage*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAclAccount with the account information for the removed
account.</doc>
              <type name="Infinity.AclAccount" c:type="const InfAclAccount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="AccountStorageSupport"
              glib:type-name="InfdAccountStorageSupport"
              glib:get-type="infd_account_storage_support_get_type"
              c:type="InfdAccountStorageSupport">
      <doc xml:space="preserve">This enumeration specifies operations that might or might not be supported
by a particular #InfdAccountStorage implementation. Looking up an account
by ID or name must always be supported.</doc>
      <member name="notification"
              value="1"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_NOTIFICATION"
              glib:nick="notification">
        <doc xml:space="preserve">Whether the
#InfdAccountStorage::account-added and #InfdAccountStorage::account-removed
signals are emitted when accounts are added or removed externally.</doc>
      </member>
      <member name="list_accounts"
              value="2"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_LIST_ACCOUNTS"
              glib:nick="list-accounts">
        <doc xml:space="preserve">Whether obtaining a full list
of available accounts is supported.</doc>
      </member>
      <member name="add_account"
              value="4"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_ADD_ACCOUNT"
              glib:nick="add-account">
        <doc xml:space="preserve">Whether adding a new account to
the storage is supported.</doc>
      </member>
      <member name="remove_account"
              value="8"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_REMOVE_ACCOUNT"
              glib:nick="remove-account">
        <doc xml:space="preserve">Whether removing an existing
account from the storage is supported.</doc>
      </member>
      <member name="certificate_login"
              value="16"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_CERTIFICATE_LOGIN"
              glib:nick="certificate-login">
        <doc xml:space="preserve">Whether the account
storage supports authenticating users via client certificates.</doc>
      </member>
      <member name="password_login"
              value="32"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_PASSWORD_LOGIN"
              glib:nick="password-login">
        <doc xml:space="preserve">Whether the account storage
supports authenticating users via username and password.</doc>
      </member>
      <member name="certificate_change"
              value="64"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_CERTIFICATE_CHANGE"
              glib:nick="certificate-change">
        <doc xml:space="preserve">Whether the account
storage supports changing the certificate associated to a user.</doc>
      </member>
      <member name="password_change"
              value="128"
              c:identifier="INFD_ACCOUNT_STORAGE_SUPPORT_PASSWORD_CHANGE"
              glib:nick="password-change">
        <doc xml:space="preserve">Whether the account storage
supports changing a user's password.</doc>
      </member>
    </bitfield>
    <enumeration name="ChatFilesystemFormatError"
                 c:type="InfdChatFilesystemFormatError">
      <doc xml:space="preserve">Errors that can occur when reading a #InfChatSession from a
#InfdFilesystemStorage.</doc>
      <member name="chat_filesystem_format_error_not_a_chat_session"
              value="0"
              c:identifier="INFD_CHAT_FILESYSTEM_FORMAT_ERROR_NOT_A_CHAT_SESSION">
        <doc xml:space="preserve">The file to be read
is not a serialized chat session.</doc>
      </member>
    </enumeration>
    <class name="Directory"
           c:symbol-prefix="directory"
           c:type="InfdDirectory"
           parent="GObject.Object"
           glib:type-name="InfdDirectory"
           glib:get-type="infd_directory_get_type"
           glib:type-struct="DirectoryClass">
      <doc xml:space="preserve">#InfdDirectory is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="Infinity.Browser"/>
      <implements name="Infinity.CommunicationObject"/>
      <constructor name="new" c:identifier="infd_directory_new">
        <doc xml:space="preserve">Creates a new #InfdDirectory. If @storage is %NULL then the directory
keeps all content in memory. This can make sense for ad-hoc sessions where
no central document storage is required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdDirectory.</doc>
          <type name="Directory" c:type="InfdDirectory*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">IO object to watch connections and schedule timeouts.</doc>
            <type name="Infinity.Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">Storage backend that is used to read/write notes from
permanent memory into #InfBuffer objects, or %NULL.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </parameter>
          <parameter name="comm_manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager to register added
connections to and which forwards incoming data to the directory
or running sessions.</doc>
            <type name="Infinity.CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="connection_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connection_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_connection"
              c:identifier="infd_directory_add_connection">
        <doc xml:space="preserve">Adds @connection to the connections of @directory. The directory will then
receive requests from @connection. If the directory's method manager does
not contain a "central" method for connection's network, then the
connection will not be added and the function returns %FALSE.

The connection is removed again automatically if it is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the connection was added to the directory.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_plugin" c:identifier="infd_directory_add_plugin">
        <doc xml:space="preserve">Adds @plugin to @directory. This allows the directory to create sessions
of the plugin's type. Only one plugin of each type can be added to the
directory. The plugin's storage_type must match the storage of @directory.
If the directory's storage is %NULL, then the plugin's storage type does
not matter, and the plugin's @session_read and @session_write functions
will not be used (and can therefore be %NULL).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the plugin was added successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdNotePlugin.</doc>
            <type name="NotePlugin" c:type="const InfdNotePlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_acl_account"
              c:identifier="infd_directory_create_acl_account"
              throws="1">
        <doc xml:space="preserve">Creates a new account on the directory with the given @account_name. If
the @certificates array is not empty and a clients connects with one of
the certificates, the client will automatically be logged into the account.

If the @transient parameter is %TRUE then the account is made transient,
i.e. it will not be stored to permanent storage. When the server is
re-started, the account will no longer exist. If the parameter is %FALSE,
then the account is persistent.

This function is similar to inf_browser_create_acl_account(), but it
allows more options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID of the created account, or 0
in case of error.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="account_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the new account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="transient" transfer-ownership="none">
            <doc xml:space="preserve">Whether the account should be transient or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="certificates"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">An array of
certificates to be associated to the account, or %NULL.</doc>
            <array length="3" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certificates" transfer-ownership="none">
            <doc xml:space="preserve">The number of certificates.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="enable_chat" c:identifier="infd_directory_enable_chat">
        <doc xml:space="preserve">If @enable is %TRUE, this enables the chat on the server. This allows
clients subscribing to the chat via infc_browser_subscribe_chat(). If
@enable is %FALSE the chat is disabled which means closing an existing
chat session if any and no longer allowing subscription to the chat.
The chat is initially disabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve">Whether to enable or disable the chat.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_connection"
              c:identifier="infd_directory_foreach_connection">
        <doc xml:space="preserve">Calls @func for each connection in @directory that has previously been
added to the directory. It is allowed to add and remove connections while
this function is being called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">The function to call for each connection in
@directory.</doc>
            <type name="DirectoryForeachConnectionFunc"
                  c:type="InfdDirectoryForeachConnectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to the callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_acl_account_for_connection"
              c:identifier="infd_directory_get_acl_account_for_connection">
        <doc xml:space="preserve">This function returns the #InfAclAccountId that the given connection is
logged into. The @connection must have been added to the directory before
with infd_directory_add_connection(). If no special login was performed,
the default account is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfAclAccountId.</doc>
          <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A @connection added to @directory.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_chat_session"
              c:identifier="infd_directory_get_chat_session">
        <doc xml:space="preserve">Returns a #InfdSessionProxy for the chat session, if any. If the chat is
enabled (see infd_directory_enable_chat()) this returns a #InfdSessionProxy
that can be used to join local users to the chat, or to get chat contents
(by getting the #InfChatBuffer from the proxy's #InfChatSession). If the
chat is disabled the function returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfdSessionProxy, or %NULL if
the chat is disabled.</doc>
          <type name="SessionProxy" c:type="InfdSessionProxy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_communication_manager"
              c:identifier="infd_directory_get_communication_manager">
        <doc xml:space="preserve">Returns the connection manager of the directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An #InfCommunicationManager.</doc>
          <type name="Infinity.CommunicationManager"
                c:type="InfCommunicationManager*"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_io" c:identifier="infd_directory_get_io">
        <doc xml:space="preserve">Returns the IO object in use by the directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIo.</doc>
          <type name="Infinity.Io" c:type="InfIo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_storage" c:identifier="infd_directory_get_storage">
        <doc xml:space="preserve">Returns the storage backend in use by the directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An #InfdStorage.</doc>
          <type name="Storage" c:type="InfdStorage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory:</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_support_mask"
              c:identifier="infd_directory_get_support_mask">
        <doc xml:space="preserve">This function writes all operations supported by @directory to @mask. If
an operation is unsupported by the server, the corresponding field in the
mask will not be set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="mask"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #InfAclMask that will be filled.</doc>
            <type name="Infinity.AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_save_session"
              c:identifier="infd_directory_iter_save_session"
              throws="1">
        <doc xml:space="preserve">Attempts to store the session the node @iter points to represents into the
background storage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a note in @directory.</doc>
            <type name="Infinity.BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_plugin" c:identifier="infd_directory_lookup_plugin">
        <doc xml:space="preserve">Returns the #InfdNotePlugin that handles the given note type, or %NULL
in case no corresponding plugin was added.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfdNotePlugin, or %NULL.</doc>
          <type name="NotePlugin" c:type="const InfdNotePlugin*"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="note_type" transfer-ownership="none">
            <doc xml:space="preserve">A note type for which to lookup the plugin.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_plugin" c:identifier="infd_directory_remove_plugin">
        <doc xml:space="preserve">Removes a note plugin from the directory. If there are any sessions running
using this plugin, they are unsubscribed from the directory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">The plugin to remove.</doc>
            <type name="NotePlugin" c:type="const InfdNotePlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_acl_account_for_connection"
              c:identifier="infd_directory_set_acl_account_for_connection"
              throws="1">
        <doc xml:space="preserve">This function changes the account that the given connection is
logged into. The @connection must have been added to the directory before
with infd_directory_add_connection(). In order to remove a login,
@account_id should be set to the default account.

The function might fail if there is no account that corresponds to
@account, or if the account storage reports an error when looking up the
account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A @connection added to @directory.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="account_id" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccountId representing a valid account in @directory.</doc>
            <type name="Infinity.AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_certificate"
              c:identifier="infd_directory_set_certificate">
        <doc xml:space="preserve">Sets the private key and certificate chain of the directory. The directory
does not use these for certificate authentication with added connections.
Connections should already be authenticated, for example with the means of
#InfXmppConnection.

At the moment, the directory certificate is used to sign incoming
certificate requests. Selected clients can request a certificate signed
with the server's certificates, see inf_browser_create_acl_account().
If the server certificate is set with this function, the request is handled
properly. If no certificate is set with this function, such a request is
rejected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The private key of the directory.</doc>
            <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
          </parameter>
          <parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">The certificate chain of the directory.</doc>
            <type name="Infinity.CertificateChain"
                  c:type="InfCertificateChain*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account-storage"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="AccountStorage"/>
      </property>
      <property name="certificate" writable="1" transfer-ownership="none">
        <type name="Infinity.CertificateChain"/>
      </property>
      <property name="chat-session" transfer-ownership="none">
        <type name="SessionProxy"/>
      </property>
      <property name="communication-manager"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.CommunicationManager"/>
      </property>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.Io"/>
      </property>
      <property name="private-key" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="storage"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Storage"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="connection-added" when="last">
        <doc xml:space="preserve">This signal is emitted when a connection that is served by the
#InfdDirectory was added. The only way this can happen is by a call to
infd_directory_add_connection(). This can be done automatically by an
#InfdServerPool instance, however.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection that was added.</doc>
            <type name="Infinity.XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-removed" when="last">
        <doc xml:space="preserve">This signal is emitted when a connection stopes being served by
@directory. Usually this happens only when the connection is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection that was removed.</doc>
            <type name="Infinity.XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DirectoryClass"
            c:type="InfdDirectoryClass"
            glib:is-gtype-struct-for="Directory">
      <doc xml:space="preserve">Default signal handlers for #InfdDirectory.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="connection_added">
        <callback name="connection_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="directory" transfer-ownership="none">
              <type name="Directory" c:type="InfdDirectory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_removed">
        <callback name="connection_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="directory" transfer-ownership="none">
              <type name="Directory" c:type="InfdDirectory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="DirectoryForeachConnectionFunc"
              c:type="InfdDirectoryForeachConnectionFunc">
      <doc xml:space="preserve">This is the signature of the callback function passed to
infd_directory_foreach_connection().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="conn" transfer-ownership="none">
          <doc xml:space="preserve">The connection corresponding to the current iteration.</doc>
          <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">Additional data passed to the call to
infd_directory_foreach_connection().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FilesystemAccountStorage"
           c:symbol-prefix="filesystem_account_storage"
           c:type="InfdFilesystemAccountStorage"
           parent="GObject.Object"
           glib:type-name="InfdFilesystemAccountStorage"
           glib:get-type="infd_filesystem_account_storage_get_type"
           glib:type-struct="FilesystemAccountStorageClass">
      <doc xml:space="preserve">#InfdFilesystemAccountStorage is an opaque data type. You should only
access it via the public API functions.</doc>
      <implements name="AccountStorage"/>
      <constructor name="new"
                   c:identifier="infd_filesystem_account_storage_new">
        <doc xml:space="preserve">Creates a new #InfdFilesystemAccountStorage that stores its account list as
a file in the filesystem. Use
infd_filesystem_account_storage_set_filesystem() to set the underlying
#InfdFilesystemStorage object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdFilesystemAccountStorage.</doc>
          <type name="FilesystemAccountStorage"
                c:type="InfdFilesystemAccountStorage*"/>
        </return-value>
      </constructor>
      <method name="set_filesystem"
              c:identifier="infd_filesystem_account_storage_set_filesystem"
              throws="1">
        <doc xml:space="preserve">Uses @fs as the underlying #InfdFilesystemStorage for @s. The
#InfdFilesystemStorage:root-directory property specifies where the account
list is stored.

If an error occurs while loading the account list, the function returns
%FALSE and @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdFilesystemAccountStorage.</doc>
            <type name="FilesystemAccountStorage"
                  c:type="InfdFilesystemAccountStorage*"/>
          </instance-parameter>
          <parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">The underlying #InfdFilesystemStorage to use.</doc>
            <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
          </parameter>
        </parameters>
      </method>
      <property name="filesystem-storage"
                writable="1"
                transfer-ownership="none">
        <type name="FilesystemStorage"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="FilesystemAccountStorageClass"
            c:type="InfdFilesystemAccountStorageClass"
            glib:is-gtype-struct-for="FilesystemAccountStorage">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="FilesystemAccountStorageError"
                 c:type="InfdFilesystemAccountStorageError">
      <doc xml:space="preserve">Specifies the possible error codes in the
&lt;literal&gt;INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR&lt;/literal&gt; error domain.
Such errors can occur when reading the accounts file from disk.</doc>
      <member name="invalid_format"
              value="0"
              c:identifier="INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR_INVALID_FORMAT">
        <doc xml:space="preserve">An on-disk XML file
is not formatted correctly.</doc>
      </member>
      <member name="duplicate_name"
              value="1"
              c:identifier="INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR_DUPLICATE_NAME">
        <doc xml:space="preserve">An account name is
already in use.</doc>
      </member>
      <member name="duplicate_certificate"
              value="2"
              c:identifier="INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR_DUPLICATE_CERTIFICATE">
        <doc xml:space="preserve">An account
which uses the same certificate to login exists already.</doc>
      </member>
      <member name="ids_exhausted"
              value="3"
              c:identifier="INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR_IDS_EXHAUSTED">
        <doc xml:space="preserve">Could not
obtain a unique account ID.</doc>
      </member>
      <member name="no_such_account"
              value="4"
              c:identifier="INFD_FILESYSTEM_ACCOUNT_STORAGE_ERROR_NO_SUCH_ACCOUNT">
        <doc xml:space="preserve">The account with
the given ID does not exist.</doc>
      </member>
    </enumeration>
    <class name="FilesystemStorage"
           c:symbol-prefix="filesystem_storage"
           c:type="InfdFilesystemStorage"
           parent="GObject.Object"
           glib:type-name="InfdFilesystemStorage"
           glib:get-type="infd_filesystem_storage_get_type"
           glib:type-struct="FilesystemStorageClass">
      <implements name="Storage"/>
      <constructor name="new" c:identifier="infd_filesystem_storage_new">
        <doc xml:space="preserve">Creates a new #InfdFilesystemStorage that stores its nodes in the
given directory on the file system. The directory is created if it does
not exist.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdFilesystemStorage.</doc>
          <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
        </return-value>
        <parameters>
          <parameter name="root_directory" transfer-ownership="none">
            <doc xml:space="preserve">A directory name in UTF-8.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="stream_close"
                c:identifier="infd_filesystem_storage_stream_close">
        <doc xml:space="preserve">This is a thin wrapper around fclose(). Use this function instead of
fclose() if you have opened the file with infd_filesystem_storage_open(),
to make sure that the same C runtime is closing the file that has opened
it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The return value of fclose().</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #FILE opened with infd_filesystem_storage_open().</doc>
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </function>
      <function name="stream_read"
                c:identifier="infd_filesystem_storage_stream_read">
        <doc xml:space="preserve">This is a thin wrapper around fread(). Use this function instead of
fread() if you have opened the file with infd_filesystem_storage_open(),
to make sure that the same C runtime is closing the file that has opened
it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The return value of fread().</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #FILE opened with infd_filesystem_storage_open().</doc>
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A buffer
into which to read data.</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Maximum number of bytes to read.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="stream_write"
                c:identifier="infd_filesystem_storage_stream_write">
        <doc xml:space="preserve">This is a thin wrapper around fwrite(). Use this function instead of
fwrite() if you have opened the file with infd_filesystem_storage_open(),
to make sure that the same C runtime is closing the file that has opened
it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The return value of fwrite().</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">A #FILE opened with infd_filesystem_storage_open().</doc>
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The data to write.</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">Maximum number of bytes to write.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_path"
              c:identifier="infd_filesystem_storage_get_path"
              throws="1">
        <doc xml:space="preserve">Returns the full file name to the given path within the storage's root
directory. The function might fail if @path contains invalid characters.
If the function fails, %NULL is returned and @error is set.

Only if @identifier starts with &amp;quot;Inf&amp;quot;, the file will show up in
the directory listing of infd_storage_read_subdirectory(). Other
identifiers can be used to store custom data in the filesystem, linked to
this #InfdFilesystemStorage object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An absolute
filename path to be freed with g_free(), or %NULL.</doc>
          <type name="filename" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
            <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of node to open.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path to open, in UTF-8.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open"
              c:identifier="infd_filesystem_storage_open"
              throws="1">
        <doc xml:space="preserve">Opens a file in the given path within the storage's root directory. If
the file exists already, and @mode is set to "w", the file is overwritten.

If @full_path is not %NULL, then it will be set to a newly allocated
string which contains the full name of the opened file, in the Glib file
name encoding. Note that @full_path will also be set if the function fails.

Only if @identifier starts with &amp;quot;Inf&amp;quot;, the file will show up in
the directory listing of infd_storage_read_subdirectory(). Other
identifiers can be used to store custom data in the filesystem, linked to
this #InfdFilesystemStorage object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A stream for the open file. Close with
infd_filesystem_storage_stream_close().</doc>
          <type name="gpointer" c:type="FILE*"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
            <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of node to open.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path to open, in UTF-8.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">Either "r" for reading or "w" for writing.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="full_path"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Return location
of the full filename, or %NULL.</doc>
            <type name="filename" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_xml_file"
              c:identifier="infd_filesystem_storage_read_xml_file"
              introspectable="0"
              throws="1">
        <doc xml:space="preserve">Opens a file in the given path, and parses its XML content. See
infd_filesystem_storage_open() for how @identifier and @path should be
interpreted.

If @toplevel_tag is non-%NULL, then this function generates an error if
the XML document read has a toplevel tag with a different name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new XML document, or %NULL on
error. Free with xmlDocFree().</doc>
          <type name="libxml2.DocPtr" c:type="xmlDocPtr"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
            <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of node to open.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path to open, in UTF-8.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="toplevel_tag" transfer-ownership="none">
            <doc xml:space="preserve">The expected toplevel XML tag name, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_xml_file"
              c:identifier="infd_filesystem_storage_write_xml_file"
              throws="1">
        <doc xml:space="preserve">Writes the XML doument in @doc into a file in the filesystem indicated
by @identifier and @path. See infd_filesystem_storage_open() for how
@identifier and @path should be interpreted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
            <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of node to write.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path to write to, in UTF-8.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="doc" transfer-ownership="none">
            <doc xml:space="preserve">The XML document to write.</doc>
            <type name="libxml2.DocPtr" c:type="xmlDocPtr"/>
          </parameter>
        </parameters>
      </method>
      <property name="root-directory"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="FilesystemStorageClass"
            c:type="InfdFilesystemStorageClass"
            glib:is-gtype-struct-for="FilesystemStorage">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="FilesystemStorageError"
                 c:type="InfdFilesystemStorageError">
      <member name="invalid_path"
              value="0"
              c:identifier="INFD_FILESYSTEM_STORAGE_ERROR_INVALID_PATH">
      </member>
      <member name="remove_files"
              value="1"
              c:identifier="INFD_FILESYSTEM_STORAGE_ERROR_REMOVE_FILES">
      </member>
      <member name="invalid_format"
              value="2"
              c:identifier="INFD_FILESYSTEM_STORAGE_ERROR_INVALID_FORMAT">
      </member>
      <member name="failed"
              value="3"
              c:identifier="INFD_FILESYSTEM_STORAGE_ERROR_FAILED">
      </member>
    </enumeration>
    <record name="NotePlugin" c:type="InfdNotePlugin">
      <field name="user_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="storage_type" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="note_type" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="session_new" introspectable="0" writable="1">
        <type name="NotePluginSessionNew" c:type="InfdNotePluginSessionNew"/>
      </field>
      <field name="session_read" introspectable="0" writable="1">
        <type name="NotePluginSessionRead" c:type="InfdNotePluginSessionRead"/>
      </field>
      <field name="session_write" writable="1">
        <type name="NotePluginSessionWrite"
              c:type="InfdNotePluginSessionWrite"/>
      </field>
    </record>
    <callback name="NotePluginSessionNew"
              c:type="InfdNotePluginSessionNew"
              introspectable="0">
      <return-value>
        <type name="Infinity.Session" c:type="InfSession*"/>
      </return-value>
      <parameters>
        <parameter name="arg0" transfer-ownership="none">
          <type name="Infinity.Io" c:type="InfIo*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="Infinity.CommunicationManager"
                c:type="InfCommunicationManager*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="Infinity.SessionStatus" c:type="InfSessionStatus"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <type name="Infinity.CommunicationGroup"
                c:type="InfCommunicationGroup*"/>
        </parameter>
        <parameter name="arg4" transfer-ownership="none">
          <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
        </parameter>
        <parameter name="arg5" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg6" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="NotePluginSessionRead"
              c:type="InfdNotePluginSessionRead"
              introspectable="0"
              throws="1">
      <return-value>
        <type name="Infinity.Session" c:type="InfSession*"/>
      </return-value>
      <parameters>
        <parameter name="arg0" transfer-ownership="none">
          <type name="Storage" c:type="InfdStorage*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="Infinity.Io" c:type="InfIo*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="Infinity.CommunicationManager"
                c:type="InfCommunicationManager*"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="arg4" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="NotePluginSessionWrite"
              c:type="InfdNotePluginSessionWrite"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="arg0" transfer-ownership="none">
          <type name="Storage" c:type="InfdStorage*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="Infinity.Session" c:type="InfSession*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ProgressRequest"
           c:symbol-prefix="progress_request"
           c:type="InfdProgressRequest"
           parent="Request"
           glib:type-name="InfdProgressRequest"
           glib:get-type="infd_progress_request_get_type"
           glib:type-struct="ProgressRequestClass">
      <doc xml:space="preserve">#InfdProgressRequest is an opaque data type. You should only access it via
the public API functions.</doc>
      <implements name="Infinity.Request"/>
      <method name="initiated" c:identifier="infd_progress_request_initiated">
        <doc xml:space="preserve">Initiates the request. A progress request is considered initiated as soon
as the total number of operations is known.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdProgressRequest.</doc>
            <type name="ProgressRequest" c:type="InfdProgressRequest*"/>
          </instance-parameter>
          <parameter name="total" transfer-ownership="none">
            <doc xml:space="preserve">The total number of operations.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="progress" c:identifier="infd_progress_request_progress">
        <doc xml:space="preserve">Indicates that one more operation has been finished and changes the
#InfdProgressRequest:current property accordingly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdProgressRequest.</doc>
            <type name="ProgressRequest" c:type="InfdProgressRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="current" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="total" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Request" c:type="InfdRequest"/>
      </field>
    </class>
    <record name="ProgressRequestClass"
            c:type="InfdProgressRequestClass"
            glib:is-gtype-struct-for="ProgressRequest">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="RequestClass" c:type="InfdRequestClass"/>
      </field>
    </record>
    <class name="Request"
           c:symbol-prefix="request"
           c:type="InfdRequest"
           parent="GObject.Object"
           glib:type-name="InfdRequest"
           glib:get-type="infd_request_get_type"
           glib:type-struct="RequestClass">
      <doc xml:space="preserve">#InfdRequest is an opaque data type. You should only access it
via the public API functions.</doc>
      <implements name="Infinity.Request"/>
      <property name="node-id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="requestor"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.XmlConnection"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="RequestClass"
            c:type="InfdRequestClass"
            glib:is-gtype-struct-for="Request">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="ServerPool"
           c:symbol-prefix="server_pool"
           c:type="InfdServerPool"
           parent="GObject.Object"
           glib:type-name="InfdServerPool"
           glib:get-type="infd_server_pool_get_type"
           glib:type-struct="ServerPoolClass">
      <doc xml:space="preserve">#InfdServerPool is an opaque data type. You should only access it via the
public API functions.</doc>
      <constructor name="new" c:identifier="infd_server_pool_new">
        <doc xml:space="preserve">Creates a new #InfdServerPool.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdServerPool.</doc>
          <type name="ServerPool" c:type="InfdServerPool*"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdDirectory to which to add incoming connections.</doc>
            <type name="Directory" c:type="InfdDirectory*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_local_publisher"
              c:identifier="infd_server_pool_add_local_publisher">
        <doc xml:space="preserve">Publishes a service offered by @server on the local network via
@publisher. This can safely be called when @server is not yet open. The
service will be published as soon as the server opens.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server_pool" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdServerPool.</doc>
            <type name="ServerPool" c:type="InfdServerPool*"/>
          </instance-parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmppServer added to @server_pool.</doc>
            <type name="XmppServer" c:type="InfdXmppServer*"/>
          </parameter>
          <parameter name="publisher" transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisher.</doc>
            <type name="Infinity.LocalPublisher" c:type="InfLocalPublisher*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_server" c:identifier="infd_server_pool_add_server">
        <doc xml:space="preserve">Adds @server to @server_pool. The server pool accepts incoming connections
and gives them to its directory which processes incoming requests.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server_pool" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdServerPool.</doc>
            <type name="ServerPool" c:type="InfdServerPool*"/>
          </instance-parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_server"
              c:identifier="infd_server_pool_foreach_server">
        <doc xml:space="preserve">Calls @func for each server in pool registered with
infd_server_pool_add_server().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server_pool" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdServerPool.</doc>
            <type name="ServerPool" c:type="InfdServerPool*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">The function to be called for each server.</doc>
            <type name="ServerPoolForeachServerFunc"
                  c:type="InfdServerPoolForeachServerFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_server"
              c:identifier="infd_server_pool_remove_server">
        <doc xml:space="preserve">Removed @server from @servor_pool. If @server was published via
some publishers then it will be unpublished automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server_pool" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdServerPool.</doc>
            <type name="ServerPool" c:type="InfdServerPool*"/>
          </instance-parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer which was previously added to @server_pool.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </parameter>
        </parameters>
      </method>
      <property name="directory"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Directory"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="ServerPoolClass"
            c:type="InfdServerPoolClass"
            glib:is-gtype-struct-for="ServerPool">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="ServerPoolForeachServerFunc"
              c:type="InfdServerPoolForeachServerFunc">
      <doc xml:space="preserve">This is the callback signature of the callback passed to
infd_server_pool_foreach_server().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="server" transfer-ownership="none">
          <doc xml:space="preserve">The currently iterated server.</doc>
          <type name="XmlServer" c:type="InfdXmlServer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">Additional data passed to infd_server_pool_foreach_server().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SessionProxy"
           c:symbol-prefix="session_proxy"
           c:type="InfdSessionProxy"
           parent="GObject.Object"
           glib:type-name="InfdSessionProxy"
           glib:get-type="infd_session_proxy_get_type"
           glib:type-struct="SessionProxyClass">
      <doc xml:space="preserve">#InfdSessionProxy is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="Infinity.CommunicationObject"/>
      <implements name="Infinity.SessionProxy"/>
      <virtual-method name="add_subscription">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="seq_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reject_user_join" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="user_properties" transfer-ownership="none">
            <array name="GLib.Array" c:type="const GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="rejoin_user" transfer-ownership="none">
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_subscription">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="has_subscriptions"
              c:identifier="infd_session_proxy_has_subscriptions">
        <doc xml:space="preserve">Returns whether there are subscribed connections to the session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether there are subscribed connections.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_idle" c:identifier="infd_session_proxy_is_idle">
        <doc xml:space="preserve">Returns whether the session is idle. The session is considered idle when
there are no subscriptions and no synchronizations (in either direction).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the session is idle.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_subscribed"
              c:identifier="infd_session_proxy_is_subscribed">
        <doc xml:space="preserve">Returns %TRUE when @connection is subscribed to the session and %FALSE
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @connection is subscribed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to check for being subscribed.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe_to"
              c:identifier="infd_session_proxy_subscribe_to">
        <doc xml:space="preserve">Subscribes @connection to @proxy's session. The first thing that will be
done is a synchronization (see inf_session_synchronize_to()). Then, all
changes to the session are propagated to @connection.

@seq_id should be a unique number for @connection, and the same number must
be passed on the client side to the #InfcSessionProxy object. Normally
#InfdDirectory and #InfcBrowser take care of choosing an appropriate
sequence identifier.

Normally, you want to set @synchronize to %TRUE in which case the whole
session state will be synchronized to @connection (within the subscription
group). However, if for whatever reason the remote site already has a
copy of the session, then you may set @synchronize to %FALSE to skip
synchronization. This happens for example for newly created documents, or
when the remote site synchronized the local site and wants to be
initially subscribed.

If @proxy's session is not in %INF_SESSION_RUNNING status, but in
%INF_SESSION_SYNCHRONIZING, then @connection must be the connection that
synchronizes the session and @synchronize needs to be set to %FALSE. This
causes the synchronizing connection to initially be subscribed. This
needs to be called directly after having created the session proxy (i.e.
without returning to the main loop before) so that the synchronization
connection is added to the subscription group for synchronization.

Otherwise a subscription can only be initiated if @proxy's session is in
state %INF_SESSION_RUNNING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is not yet subscribed.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="seq_id" transfer-ownership="none">
            <doc xml:space="preserve">The sequence identifier for @connection.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="synchronize" transfer-ownership="none">
            <doc xml:space="preserve">If %TRUE, then synchronize the session to @connection first.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe" c:identifier="infd_session_proxy_unsubscribe">
        <doc xml:space="preserve">Unsubscribes a subscribed connection from @proxy's session. This will
prevent all users joined via @connection to continue modifying the
session's buffer, and it will cancel ongoing synchronization to
@connection, if not yet finished.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfdSessionProxy*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to unsubscribe.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <property name="idle" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.Io"/>
      </property>
      <property name="subscription-group"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.CommunicationHostedGroup"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="add-subscription" when="last">
        <doc xml:space="preserve">Emitted every time a connection is subscribed to the session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The subscribed #InfXmlConnection.</doc>
            <type name="Infinity.XmlConnection"/>
          </parameter>
          <parameter name="seq_id" transfer-ownership="none">
            <doc xml:space="preserve">The sequence identifier for @connection as passed to
infd_session_proxy_subscribe_to().</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reject-user-join" when="last" introspectable="0">
        <doc xml:space="preserve">This signal is emitted before every remote user join. The signal handler
can return %TRUE in which case the #InfdSessionProxy does not allow the
user join with %INF_REQUEST_ERROR_NOT_AUTHORIZED error. If there is more
than one signal handler, then if one of them returns %TRUE the user
join is rejected.

The @user_properties parameter is a #GArray of #GParameter values. It
contains the construct properties for the #InfUser object that would be
created if the user join is not rejected. It must not be modified, but
it can be used to make the decision whether to reject the user join or
not dependent on the parameters, such as allowing the user join only if
the user has a predefined name. The function
inf_session_lookup_user_property() can be used to look up a named
parameter in the array.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A subscribed #InfXmlConnection requesting the user join.</doc>
            <type name="Infinity.XmlConnection"/>
          </parameter>
          <parameter name="user_properties" transfer-ownership="none">
            <doc xml:space="preserve">An array with the properties for the new user.</doc>
            <array name="GLib.Array">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="rejoin_user" transfer-ownership="none">
            <doc xml:space="preserve">The existing unavailable user that is being rejoined, or
%NULL.</doc>
            <type name="Infinity.User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-subscription" when="last">
        <doc xml:space="preserve">Emitted every time a connection is unsubscribed to the session, or a
subscription is removed because the session is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The unsubscribed #InfXmlConnection.</doc>
            <type name="Infinity.XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SessionProxyClass"
            c:type="InfdSessionProxyClass"
            glib:is-gtype-struct-for="SessionProxy">
      <doc xml:space="preserve">This structure contains the default signal handlers of the
#InfdSessionProxy class.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_subscription">
        <callback name="add_subscription">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="SessionProxy" c:type="InfdSessionProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="seq_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_subscription">
        <callback name="remove_subscription">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="SessionProxy" c:type="InfdSessionProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reject_user_join" introspectable="0">
        <callback name="reject_user_join" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="SessionProxy" c:type="InfdSessionProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="user_properties" transfer-ownership="none">
              <array name="GLib.Array" c:type="const GArray*">
                <type name="gpointer" c:type="gpointer"/>
              </array>
            </parameter>
            <parameter name="rejoin_user" transfer-ownership="none">
              <type name="Infinity.User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="Storage"
               c:symbol-prefix="storage"
               c:type="InfdStorage"
               glib:type-name="InfdStorage"
               glib:get-type="infd_storage_get_type"
               glib:type-struct="StorageInterface">
      <virtual-method name="create_subdirectory"
                      invoker="create_subdirectory"
                      throws="1">
        <doc xml:space="preserve">Creates a new subdirectory at the given path that is initially empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to non-existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_acl" invoker="read_acl" throws="1">
        <doc xml:space="preserve">Reads the ACL for the node at the path @path from the storage. It returns
a list of #InfdStorageAcl objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
possibly empty list of #InfdStorageAcl objects. Free with
infd_storage_acl_list_free() when no longer needed.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageAcl"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_subdirectory"
                      invoker="read_subdirectory"
                      throws="1">
        <doc xml:space="preserve">Reads a subdirectory from the storage. Returns a list of
InfdStorageNode objects. Both the list and the objects need to
be freed by the caller via infd_storage_node_list_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
#GSList that contains #InfdStorageNode objects, or %NULL if either the
subdirectory is empty or an error occured.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageNode"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to a subdirectory node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_node" invoker="remove_node" throws="1">
        <doc xml:space="preserve">Removes the node at path from storage. If it is a subdirectory node, all
containing nodes and subdirectory nodes are removed recursively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of the node to remove, or %NULL to remove a
subdirectory (TODO: This shouldn't be necessary).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_acl" invoker="write_acl" throws="1">
        <doc xml:space="preserve">Writes the ACL defined by @sheet_set into storage. If @sheet_set is %NULL
this is equivalent to an empty set. Returns %TRUE on success or %FALSE on
error. If the function fails, @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">Sheets to set for the node at @path, or %NULL.</doc>
            <type name="Infinity.AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_subdirectory"
              c:identifier="infd_storage_create_subdirectory"
              throws="1">
        <doc xml:space="preserve">Creates a new subdirectory at the given path that is initially empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to non-existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_acl" c:identifier="infd_storage_read_acl" throws="1">
        <doc xml:space="preserve">Reads the ACL for the node at the path @path from the storage. It returns
a list of #InfdStorageAcl objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
possibly empty list of #InfdStorageAcl objects. Free with
infd_storage_acl_list_free() when no longer needed.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageAcl"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_subdirectory"
              c:identifier="infd_storage_read_subdirectory"
              throws="1">
        <doc xml:space="preserve">Reads a subdirectory from the storage. Returns a list of
InfdStorageNode objects. Both the list and the objects need to
be freed by the caller via infd_storage_node_list_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A
#GSList that contains #InfdStorageNode objects, or %NULL if either the
subdirectory is empty or an error occured.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageNode"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to a subdirectory node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_node"
              c:identifier="infd_storage_remove_node"
              throws="1">
        <doc xml:space="preserve">Removes the node at path from storage. If it is a subdirectory node, all
containing nodes and subdirectory nodes are removed recursively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">The type of the node to remove, or %NULL to remove a
subdirectory (TODO: This shouldn't be necessary).</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path pointing to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_acl"
              c:identifier="infd_storage_write_acl"
              throws="1">
        <doc xml:space="preserve">Writes the ACL defined by @sheet_set into storage. If @sheet_set is %NULL
this is equivalent to an empty set. Returns %TRUE on success or %FALSE on
error. If the function fails, @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="storage" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorage.</doc>
            <type name="Storage" c:type="InfdStorage*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A path to an existing node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">Sheets to set for the node at @path, or %NULL.</doc>
            <type name="Infinity.AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="StorageAcl"
            c:type="InfdStorageAcl"
            glib:type-name="InfdStorageAcl"
            glib:get-type="infd_storage_acl_get_type"
            c:symbol-prefix="storage_acl">
      <field name="account_id" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="mask" writable="1">
        <type name="Infinity.AclMask" c:type="InfAclMask"/>
      </field>
      <field name="perms" writable="1">
        <type name="Infinity.AclMask" c:type="InfAclMask"/>
      </field>
      <method name="copy" c:identifier="infd_storage_acl_copy">
        <doc xml:space="preserve">Creates a copy of a #InfdStorageAcl object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @acl.</doc>
          <type name="StorageAcl" c:type="InfdStorageAcl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="acl" transfer-ownership="none">
            <doc xml:space="preserve">ACL settings from which to make a copy.</doc>
            <type name="StorageAcl" c:type="const InfdStorageAcl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="infd_storage_acl_free">
        <doc xml:space="preserve">Frees a #InfdStorageAcl allocated with
infd_storage_acl_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="acl" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorageAcl.</doc>
            <type name="StorageAcl" c:type="InfdStorageAcl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="list_free" c:identifier="infd_storage_acl_list_free">
        <doc xml:space="preserve">Frees a singly-linked list of #InfdStorageAcl as returned by
infd_storage_read_acls().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="acl_list" transfer-ownership="none">
            <doc xml:space="preserve">A list of #InfdStorageAcl
objects.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="StorageAcl"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="StorageInterface"
            c:type="InfdStorageInterface"
            glib:is-gtype-struct-for="Storage">
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="read_subdirectory">
        <callback name="read_subdirectory" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A
#GSList that contains #InfdStorageNode objects, or %NULL if either the
subdirectory is empty or an error occured.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="StorageNode"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdStorage</doc>
              <type name="Storage" c:type="InfdStorage*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">A path pointing to a subdirectory node.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_subdirectory">
        <callback name="create_subdirectory" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdStorage.</doc>
              <type name="Storage" c:type="InfdStorage*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">A path pointing to non-existing node.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_node">
        <callback name="remove_node" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdStorage</doc>
              <type name="Storage" c:type="InfdStorage*"/>
            </parameter>
            <parameter name="identifier" transfer-ownership="none">
              <doc xml:space="preserve">The type of the node to remove, or %NULL to remove a
subdirectory (TODO: This shouldn't be necessary).</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">A path pointing to an existing node.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_acl">
        <callback name="read_acl" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A
possibly empty list of #InfdStorageAcl objects. Free with
infd_storage_acl_list_free() when no longer needed.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="StorageAcl"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdStorage.</doc>
              <type name="Storage" c:type="InfdStorage*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">A path pointing to an existing node.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_acl">
        <callback name="write_acl" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="storage" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdStorage.</doc>
              <type name="Storage" c:type="InfdStorage*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:space="preserve">A path to an existing node.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="sheet_set" transfer-ownership="none">
              <doc xml:space="preserve">Sheets to set for the node at @path, or %NULL.</doc>
              <type name="Infinity.AclSheetSet"
                    c:type="const InfAclSheetSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="StorageNode"
            c:type="InfdStorageNode"
            glib:type-name="InfdStorageNode"
            glib:get-type="infd_storage_node_get_type"
            c:symbol-prefix="storage_node">
      <field name="type" writable="1">
        <type name="StorageNodeType" c:type="InfdStorageNodeType"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="identifier" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new_note" c:identifier="infd_storage_node_new_note">
        <doc xml:space="preserve">Creates a new #InfdStorageNode with type
%INFD_STORAGE_NODE_NOTE and the given path and identifier. This
is most likely only going to be used by #InfdStorage
implementations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdStorageNode.</doc>
          <type name="StorageNode" c:type="InfdStorageNode*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve">Identifier of the note type, for example 'InfText' for text
notes.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_subdirectory"
                   c:identifier="infd_storage_node_new_subdirectory">
        <doc xml:space="preserve">Creates a new #InfdStorageNode with type
%INFD_STORAGE_NODE_SUBDIRECTORY and the given path. This
is most likely only going to be used by #InfdStorage
implementations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdStorageNode.</doc>
          <type name="StorageNode" c:type="InfdStorageNode*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the node.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="infd_storage_node_copy">
        <doc xml:space="preserve">Creates a copy of a #InfdStorageNode object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @node.</doc>
          <type name="StorageNode" c:type="InfdStorageNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">Node from which to make a copy.</doc>
            <type name="StorageNode" c:type="const InfdStorageNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="infd_storage_node_free">
        <doc xml:space="preserve">Frees a #InfdStorageNode allocated with
infd_storage_node_new_subdirectory(), infd_storage_node_new_note() or
infd_storage_node_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdStorageNode.</doc>
            <type name="StorageNode" c:type="InfdStorageNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="list_free" c:identifier="infd_storage_node_list_free">
        <doc xml:space="preserve">Frees a singly-linked list of #InfdStorageNode as returned by
infd_storage_read_subdirectory().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="node_list" transfer-ownership="none">
            <doc xml:space="preserve">A list of #InfdStorageNode
objects.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="StorageNode"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="StorageNodeType"
                 glib:type-name="InfdStorageNodeType"
                 glib:get-type="infd_storage_node_type_get_type"
                 c:type="InfdStorageNodeType">
      <member name="subdirectory"
              value="0"
              c:identifier="INFD_STORAGE_NODE_SUBDIRECTORY"
              glib:nick="subdirectory">
      </member>
      <member name="note"
              value="1"
              c:identifier="INFD_STORAGE_NODE_NOTE"
              glib:nick="note">
      </member>
    </enumeration>
    <class name="TcpServer"
           c:symbol-prefix="tcp_server"
           c:type="InfdTcpServer"
           parent="GObject.Object"
           glib:type-name="InfdTcpServer"
           glib:get-type="infd_tcp_server_get_type"
           glib:type-struct="TcpServerClass">
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connection">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Infinity.TcpConnection" c:type="InfTcpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="bind" c:identifier="infd_tcp_server_bind" throws="1">
        <doc xml:space="preserve">Binds the server to the address and port given by the
#InfdTcpServer:local-address and #InfdTcpServer:local-port properties. If
the former is %NULL, it will bind on all interfaces on IPv4. If the latter
is 0, a random available port will be assigned. If the function fails,
%FALSE is returned and an error is set.

@server must be in %INFD_TCP_SERVER_CLOSED state for this function to be
called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if an error occured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="infd_tcp_server_close">
        <doc xml:space="preserve">Closes a TCP server that is open or bound.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_keepalive"
              c:identifier="infd_tcp_server_get_keepalive">
        <doc xml:space="preserve">Obtains the current keepalive settings for accepted connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfKeepalive representing the keepalive configuration for
accepted connections, owned by @server.</doc>
          <type name="Infinity.Keepalive" c:type="const InfKeepalive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="infd_tcp_server_open" throws="1">
        <doc xml:space="preserve">Attempts to open @server. This means binding its local address and port
if not already (see infd_tcp_server_bind()) and accepting incoming
connections.

@server needs to be in %INFD_TCP_SERVER_CLOSED or %INFD_TCP_SERVER_BOUND
status for this function to be called. If @server's status is
%INFD_TCP_SERVER_CLOSED, then infd_tcp_server_bind() is called before
actually opening the server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if an error occured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_keepalive"
              c:identifier="infd_tcp_server_set_keepalive">
        <doc xml:space="preserve">Sets the keepalive settings for new connections accepted by the server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </instance-parameter>
          <parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">The keepalive settings for accepted connections.</doc>
            <type name="Infinity.Keepalive" c:type="const InfKeepalive*"/>
          </parameter>
        </parameters>
      </method>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.Io"/>
      </property>
      <property name="keepalive" writable="1" transfer-ownership="none">
        <type name="Infinity.Keepalive"/>
      </property>
      <property name="local-address" writable="1" transfer-ownership="none">
        <type name="Infinity.IpAddress"/>
      </property>
      <property name="local-port" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="status" transfer-ownership="none">
        <type name="TcpServerStatus"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="error" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-connection" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Infinity.TcpConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TcpServerClass"
            c:type="InfdTcpServerClass"
            glib:is-gtype-struct-for="TcpServer">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_connection">
        <callback name="new_connection">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="TcpServer" c:type="InfdTcpServer*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Infinity.TcpConnection" c:type="InfTcpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="TcpServer" c:type="InfdTcpServer*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="TcpServerStatus"
                 glib:type-name="InfdTcpServerStatus"
                 glib:get-type="infd_tcp_server_status_get_type"
                 c:type="InfdTcpServerStatus">
      <member name="closed"
              value="0"
              c:identifier="INFD_TCP_SERVER_CLOSED"
              glib:nick="closed">
      </member>
      <member name="open"
              value="2"
              c:identifier="INFD_TCP_SERVER_OPEN"
              glib:nick="open">
      </member>
    </enumeration>
    <interface name="XmlServer"
               c:symbol-prefix="xml_server"
               c:type="InfdXmlServer"
               glib:type-name="InfdXmlServer"
               glib:get-type="infd_xml_server_get_type"
               glib:type-struct="XmlServerInterface">
      <virtual-method name="close" invoker="close">
        <doc xml:space="preserve">Closes @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connection" invoker="new_connection">
        <doc xml:space="preserve">Emits the "new-connection" signal on @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="infd_xml_server_close">
        <doc xml:space="preserve">Closes @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_connection"
              c:identifier="infd_xml_server_new_connection">
        <doc xml:space="preserve">Emits the "new-connection" signal on @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmlServer.</doc>
            <type name="XmlServer" c:type="InfdXmlServer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <property name="status" transfer-ownership="none">
        <type name="XmlServerStatus"/>
      </property>
      <glib:signal name="new-connection" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Infinity.XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="XmlServerInterface"
            c:type="InfdXmlServerInterface"
            glib:is-gtype-struct-for="XmlServer">
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdXmlServer.</doc>
              <type name="XmlServer" c:type="InfdXmlServer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_connection">
        <callback name="new_connection">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <doc xml:space="preserve">A #InfdXmlServer.</doc>
              <type name="XmlServer" c:type="InfdXmlServer*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="XmlServerStatus"
                 glib:type-name="InfdXmlServerStatus"
                 glib:get-type="infd_xml_server_status_get_type"
                 c:type="InfdXmlServerStatus">
      <member name="closed"
              value="0"
              c:identifier="INFD_XML_SERVER_CLOSED"
              glib:nick="closed">
      </member>
      <member name="closing"
              value="1"
              c:identifier="INFD_XML_SERVER_CLOSING"
              glib:nick="closing">
      </member>
      <member name="open"
              value="2"
              c:identifier="INFD_XML_SERVER_OPEN"
              glib:nick="open">
      </member>
      <member name="opening"
              value="3"
              c:identifier="INFD_XML_SERVER_OPENING"
              glib:nick="opening">
      </member>
    </enumeration>
    <class name="XmppServer"
           c:symbol-prefix="xmpp_server"
           c:type="InfdXmppServer"
           parent="GObject.Object"
           glib:type-name="InfdXmppServer"
           glib:get-type="infd_xmpp_server_get_type"
           glib:type-struct="XmppServerClass">
      <implements name="XmlServer"/>
      <constructor name="new" c:identifier="infd_xmpp_server_new">
        <doc xml:space="preserve">Creates a new #InfdXmppServer with @tcp as underlaying TCP server object.
No attempt is being made to open @tcp, if it is not already open. When a
new connection comes in, the XMPP server creates a XMPP connection that
may be used to communicate with the client. Note however that the
resulting connection will be in status OPENING until authentication has
completed.

If @policy is %INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED, then @creds may
be %NULL. If @creds is non-%NULL nevertheless, then it is possible to change
the security policy later using infd_xmpp_server_set_security_policy().
@creds can also be changed later while the server is running. So just set
valid credentials before changing @policy to allow TLS.

If @sasl_context is %NULL, the server uses a built-in context that only
supports ANONYMOUS authentication. If @sasl_context is not %NULL, then
@sasl_mechanisms specifies the mechanisms offered to clients. If
@sasl_mechanisms is %NULL, then all available mechanims will be offered.
If @sasl_context is %NULL, then this parameter is ignored.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfdXmppServer.</doc>
          <type name="XmppServer" c:type="InfdXmppServer*"/>
        </return-value>
        <parameters>
          <parameter name="tcp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdTcpServer.</doc>
            <type name="TcpServer" c:type="InfdTcpServer*"/>
          </parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">The initial security policy.</doc>
            <type name="Infinity.XmppConnectionSecurityPolicy"
                  c:type="InfXmppConnectionSecurityPolicy"/>
          </parameter>
          <parameter name="creds" transfer-ownership="none">
            <doc xml:space="preserve">Certificate credentials used to secure any communication.</doc>
            <type name="Infinity.CertificateCredentials"
                  c:type="InfCertificateCredentials*"/>
          </parameter>
          <parameter name="sasl_context" transfer-ownership="none">
            <doc xml:space="preserve">A SASL context used for authentication.</doc>
            <type name="Infinity.SaslContext" c:type="InfSaslContext*"/>
          </parameter>
          <parameter name="sasl_mechanisms" transfer-ownership="none">
            <doc xml:space="preserve">A whitespace-sparated list of SASL mechanisms.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="XmppServer" c:type="InfdXmppServer*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_security_policy"
              c:identifier="infd_xmpp_server_get_security_policy">
        <doc xml:space="preserve">Returns the current security policy for newly accepted
#InfXmppConnection&lt;!-- --&gt;s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current security policy.</doc>
          <type name="Infinity.XmppConnectionSecurityPolicy"
                c:type="InfXmppConnectionSecurityPolicy"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmppServer.</doc>
            <type name="XmppServer" c:type="InfdXmppServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_security_policy"
              c:identifier="infd_xmpp_server_set_security_policy">
        <doc xml:space="preserve">Sets the security policy for newly accepted #InfXmppConnection&lt;!-- --&gt;s.
Does not already established connections.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #InfdXmppServer.</doc>
            <type name="XmppServer" c:type="InfdXmppServer*"/>
          </instance-parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">The new security policy.</doc>
            <type name="Infinity.XmppConnectionSecurityPolicy"
                  c:type="InfXmppConnectionSecurityPolicy"/>
          </parameter>
        </parameters>
      </method>
      <property name="credentials"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Infinity.CertificateCredentials"/>
      </property>
      <property name="local-hostname"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sasl-context"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Infinity.SaslContext"/>
      </property>
      <property name="sasl-mechanisms"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="security-policy"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Infinity.XmppConnectionSecurityPolicy"/>
      </property>
      <property name="tcp-server"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="TcpServer"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="error" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="XmppServerClass"
            c:type="InfdXmppServerClass"
            glib:is-gtype-struct-for="XmppServer">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="XmppServer" c:type="InfdXmppServer*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function name="chat_filesystem_format_read"
              c:identifier="infd_chat_filesystem_format_read"
              throws="1">
      <doc xml:space="preserve">Reads a chat session from @path in @storage. The file is expected to have
been saved with infd_chat_filesystem_format_write() before. The @buffer
parameter should be an empty #InfChatBuffer, and the document will be
written into this buffer. If the function succeeds, the buffer can be used
to create an #InfChatSession with inf_chat_session_new(). If the function
fails, %FALSE is returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="storage" transfer-ownership="none">
          <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
          <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Storage path to retrieve the session from.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">An empty #InfTextBuffer to use as the new session's buffer.</doc>
          <type name="Infinity.ChatBuffer" c:type="InfChatBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="chat_filesystem_format_write"
              c:identifier="infd_chat_filesystem_format_write"
              throws="1">
      <doc xml:space="preserve">Writes the given buffer into the filesystem storage at @path. If
successful, the session can then be read back with
infd_chat_filesystem_format_read(). If the function fails, %FALSE is
returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="storage" transfer-ownership="none">
          <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
          <type name="FilesystemStorage" c:type="InfdFilesystemStorage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Storage path where to write the session to.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">The #InfChatBuffer to write.</doc>
          <type name="Infinity.ChatBuffer" c:type="InfChatBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="storage_acl_list_free"
              c:identifier="infd_storage_acl_list_free"
              moved-to="StorageAcl.list_free">
      <doc xml:space="preserve">Frees a singly-linked list of #InfdStorageAcl as returned by
infd_storage_read_acls().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="acl_list" transfer-ownership="none">
          <doc xml:space="preserve">A list of #InfdStorageAcl
objects.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageAcl"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="storage_node_list_free"
              c:identifier="infd_storage_node_list_free"
              moved-to="StorageNode.list_free">
      <doc xml:space="preserve">Frees a singly-linked list of #InfdStorageNode as returned by
infd_storage_read_subdirectory().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node_list" transfer-ownership="none">
          <doc xml:space="preserve">A list of #InfdStorageNode
objects.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="StorageNode"/>
          </type>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
