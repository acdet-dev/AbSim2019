<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="dee-1.0"/>
  <c:include name="dee.h"/>
  <namespace name="Dee"
             version="1.0"
             shared-library="libdee-1.0-4.dll"
             c:identifier-prefixes="Dee"
             c:symbol-prefixes="dee">
    <class name="Analyzer"
           c:symbol-prefix="analyzer"
           c:type="DeeAnalyzer"
           parent="GObject.Object"
           glib:type-name="DeeAnalyzer"
           glib:get-type="dee_analyzer_get_type"
           glib:type-struct="AnalyzerClass">
      <doc xml:space="preserve">All fields in the DeeAnalyzer structure are private and should never be
accessed directly</doc>
      <constructor name="new" c:identifier="dee_analyzer_new">
        <return-value transfer-ownership="full">
          <type name="Analyzer" c:type="DeeAnalyzer*"/>
        </return-value>
      </constructor>
      <function name="collate_cmp_func"
                c:identifier="dee_analyzer_collate_cmp_func">
        <doc xml:space="preserve">A #GCompareDataFunc using a #DeeAnalyzer to compare the keys. This is just
a convenience wrapper around dee_analyzer_collate_cmp().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1, if @key1 is &amp;lt;, == or &amp;gt; than @key2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="key1" transfer-ownership="none">
            <doc xml:space="preserve">The first key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key2" transfer-ownership="none">
            <doc xml:space="preserve">The second key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="analyzer" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeAnalyzer to use for the comparison</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="add_term_filter" invoker="add_term_filter">
        <doc xml:space="preserve">Register a #DeeTermFilterFunc to be called whenever dee_analyzer_analyze()
is called.

Term filters can be used to normalize, add, or remove terms from an input
data stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to add a term filter to</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="filter_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">Function to call</doc>
            <type name="TermFilterFunc" c:type="DeeTermFilterFunc"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none">
            <doc xml:space="preserve">Data to pass to @filter_func when it is invoked</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="filter_destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">Called on @filter_data when the #DeeAnalyzer
                               owning the filter is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="analyze" invoker="analyze">
        <doc xml:space="preserve">Extract terms and or collation keys from some input data (which is normally,
but not necessarily, a UTF-8 string).

The terms and corresponding collation keys will be written in order to the
provided #DeeTermList&lt;!-- --&gt;s.

Implementation notes for subclasses:
The analysis process must call dee_analyzer_tokenize() and run the tokens
through all term filters added with dee_analyzer_add_term_filter().
Collation keys must be generated with dee_analyzer_collate_key().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to analyze</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="terms_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #DeeTermList to place the generated terms in.
                          If %NULL to terms are generated</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
          <parameter name="colkeys_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #DeeTermList to place generated collation keys in.
                            If %NULL no collation keys are generated</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="collate_cmp" invoker="collate_cmp">
        <doc xml:space="preserve">Compare collation keys generated by dee_analyzer_collate_key() with similar
semantics as strcmp(). See also dee_analyzer_collate_cmp_func() if you
need a version of this function that works as a #GCompareDataFunc.

The default implementation in #DeeAnalyzer just uses strcmp().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1, if @key1 is &amp;lt;, == or &amp;gt; than @key2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use when comparing collation keys</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="key1" transfer-ownership="none">
            <doc xml:space="preserve">The first collation key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key2" transfer-ownership="none">
            <doc xml:space="preserve">The second collation key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="collate_key" invoker="collate_key">
        <doc xml:space="preserve">Generate a collation key for a set of input data (usually a UTF-8 string
passed through tokenization and term filters of the analyzer).

The default implementation just calls g_strdup().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated collation key. Use dee_analyzer_collate_cmp() or
         dee_analyzer_collate_cmp_func() to compare collation keys. Free
         with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to generate a collation key with</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to generate a collation key for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tokenize" invoker="tokenize">
        <doc xml:space="preserve">Tokenize some input data (which is normally, but not necessarily,
a UTF-8 string).

Tokenization splits the input data into constituents (in most cases words),
but does not run it through any of the term filters set for the analyzer.
It is undefined if the tokenization process itself does any normalization.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to analyze</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="terms_out" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeTermList to place the generated tokens in.</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_term_filter"
              c:identifier="dee_analyzer_add_term_filter">
        <doc xml:space="preserve">Register a #DeeTermFilterFunc to be called whenever dee_analyzer_analyze()
is called.

Term filters can be used to normalize, add, or remove terms from an input
data stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to add a term filter to</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="filter_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">Function to call</doc>
            <type name="TermFilterFunc" c:type="DeeTermFilterFunc"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none">
            <doc xml:space="preserve">Data to pass to @filter_func when it is invoked</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="filter_destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">Called on @filter_data when the #DeeAnalyzer
                               owning the filter is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="analyze" c:identifier="dee_analyzer_analyze">
        <doc xml:space="preserve">Extract terms and or collation keys from some input data (which is normally,
but not necessarily, a UTF-8 string).

The terms and corresponding collation keys will be written in order to the
provided #DeeTermList&lt;!-- --&gt;s.

Implementation notes for subclasses:
The analysis process must call dee_analyzer_tokenize() and run the tokens
through all term filters added with dee_analyzer_add_term_filter().
Collation keys must be generated with dee_analyzer_collate_key().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to analyze</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="terms_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #DeeTermList to place the generated terms in.
                          If %NULL to terms are generated</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
          <parameter name="colkeys_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #DeeTermList to place generated collation keys in.
                            If %NULL no collation keys are generated</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="collate_cmp" c:identifier="dee_analyzer_collate_cmp">
        <doc xml:space="preserve">Compare collation keys generated by dee_analyzer_collate_key() with similar
semantics as strcmp(). See also dee_analyzer_collate_cmp_func() if you
need a version of this function that works as a #GCompareDataFunc.

The default implementation in #DeeAnalyzer just uses strcmp().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1, if @key1 is &amp;lt;, == or &amp;gt; than @key2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use when comparing collation keys</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="key1" transfer-ownership="none">
            <doc xml:space="preserve">The first collation key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key2" transfer-ownership="none">
            <doc xml:space="preserve">The second collation key to compare</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="collate_key" c:identifier="dee_analyzer_collate_key">
        <doc xml:space="preserve">Generate a collation key for a set of input data (usually a UTF-8 string
passed through tokenization and term filters of the analyzer).

The default implementation just calls g_strdup().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated collation key. Use dee_analyzer_collate_cmp() or
         dee_analyzer_collate_cmp_func() to compare collation keys. Free
         with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to generate a collation key with</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to generate a collation key for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tokenize" c:identifier="dee_analyzer_tokenize">
        <doc xml:space="preserve">Tokenize some input data (which is normally, but not necessarily,
a UTF-8 string).

Tokenization splits the input data into constituents (in most cases words),
but does not run it through any of the term filters set for the analyzer.
It is undefined if the tokenization process itself does any normalization.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The analyzer to use</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The input data to analyze</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="terms_out" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeTermList to place the generated tokens in.</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AnalyzerPrivate" c:type="DeeAnalyzerPrivate*"/>
      </field>
    </class>
    <record name="AnalyzerClass"
            c:type="DeeAnalyzerClass"
            glib:is-gtype-struct-for="Analyzer">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="analyze">
        <callback name="analyze">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The analyzer to use</doc>
              <type name="Analyzer" c:type="DeeAnalyzer*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">The input data to analyze</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="terms_out"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #DeeTermList to place the generated terms in.
                          If %NULL to terms are generated</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
            <parameter name="colkeys_out"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #DeeTermList to place generated collation keys in.
                            If %NULL no collation keys are generated</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="tokenize">
        <callback name="tokenize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The analyzer to use</doc>
              <type name="Analyzer" c:type="DeeAnalyzer*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">The input data to analyze</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="terms_out" transfer-ownership="none">
              <doc xml:space="preserve">A #DeeTermList to place the generated tokens in.</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_term_filter">
        <callback name="add_term_filter">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The analyzer to add a term filter to</doc>
              <type name="Analyzer" c:type="DeeAnalyzer*"/>
            </parameter>
            <parameter name="filter_func"
                       transfer-ownership="none"
                       scope="notified"
                       closure="2"
                       destroy="3">
              <doc xml:space="preserve">Function to call</doc>
              <type name="TermFilterFunc" c:type="DeeTermFilterFunc"/>
            </parameter>
            <parameter name="filter_data" transfer-ownership="none">
              <doc xml:space="preserve">Data to pass to @filter_func when it is invoked</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="filter_destroy"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async">
              <doc xml:space="preserve">Called on @filter_data when the #DeeAnalyzer
                               owning the filter is destroyed</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="collate_key">
        <callback name="collate_key">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A newly allocated collation key. Use dee_analyzer_collate_cmp() or
         dee_analyzer_collate_cmp_func() to compare collation keys. Free
         with g_free().</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The analyzer to generate a collation key with</doc>
              <type name="Analyzer" c:type="DeeAnalyzer*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">The input data to generate a collation key for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="collate_cmp">
        <callback name="collate_cmp">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">-1, 0 or 1, if @key1 is &amp;lt;, == or &amp;gt; than @key2.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The analyzer to use when comparing collation keys</doc>
              <type name="Analyzer" c:type="DeeAnalyzer*"/>
            </parameter>
            <parameter name="key1" transfer-ownership="none">
              <doc xml:space="preserve">The first collation key to compare</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="key2" transfer-ownership="none">
              <doc xml:space="preserve">The second collation key to compare</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_analyzer_1" introspectable="0">
        <callback name="_dee_analyzer_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_analyzer_2" introspectable="0">
        <callback name="_dee_analyzer_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_analyzer_3" introspectable="0">
        <callback name="_dee_analyzer_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_analyzer_4" introspectable="0">
        <callback name="_dee_analyzer_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="AnalyzerPrivate" c:type="DeeAnalyzerPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <class name="Client"
           c:symbol-prefix="client"
           c:type="DeeClient"
           parent="Peer"
           glib:type-name="DeeClient"
           glib:get-type="dee_client_get_type"
           glib:type-struct="ClientClass">
      <constructor name="new" c:identifier="dee_client_new">
        <doc xml:space="preserve">Creates a new instance of #DeeClient and tries to connect to #DeeServer
created using dee_server_new(). The #DeePeer:swarm-leader property will
be set once the client connects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #DeeClient.</doc>
          <type name="Client" c:type="DeeClient*"/>
        </return-value>
        <parameters>
          <parameter name="swarm_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of swarm to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address"
                   c:identifier="dee_client_new_for_address">
        <doc xml:space="preserve">Creates a new instance of #DeeClient and tries to connect to @bus_address.
The #DeePeer:swarm-leader property will be set once the client connects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #DeeClient.</doc>
          <type name="Client" c:type="DeeClient*"/>
        </return-value>
        <parameters>
          <parameter name="swarm_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of swarm to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="bus_address" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus address to use when connecting to the server.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="bus-address"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Peer" c:type="DeePeer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ClientPrivate" c:type="DeeClientPrivate*"/>
      </field>
    </class>
    <record name="ClientClass"
            c:type="DeeClientClass"
            glib:is-gtype-struct-for="Client">
      <field name="parent_class" readable="0" private="1">
        <type name="PeerClass" c:type="DeePeerClass"/>
      </field>
    </record>
    <record name="ClientPrivate" c:type="DeeClientPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <callback name="CollatorFunc" c:type="DeeCollatorFunc">
      <doc xml:space="preserve">A collator takes an input string, most often a term produced from a
#DeeAnalyzer, and outputs a collation key.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The collation key. Free with g_free() when done
                          using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="input" transfer-ownership="none">
          <doc xml:space="preserve">The string to produce a collation key for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">User data set when registering the collator</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CompareRowFunc" c:type="DeeCompareRowFunc">
      <doc xml:space="preserve">Compares @row1 and @row2. Mainly used with dee_model_insert_sorted() and
dee_model_find_sorted().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1, 0, or 1 if @row1 is respectively less than, equal, or greater
than @row2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="row1" transfer-ownership="none">
          <doc xml:space="preserve">The model being indexed</doc>
          <array zero-terminated="0" c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </parameter>
        <parameter name="row2" transfer-ownership="none">
          <doc xml:space="preserve">The row to extract terms for</doc>
          <array zero-terminated="0" c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">User data to pass to comparison function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CompareRowSizedFunc" c:type="DeeCompareRowSizedFunc">
      <doc xml:space="preserve">Compares @row1 and @row2. Mainly used with
dee_model_insert_row_sorted_with_sizes() and
dee_model_find_row_sorted_with_sizes().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1, 0, or 1 if @row1 is respectively less than, equal, or greater
than @row2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="row1" transfer-ownership="none">
          <doc xml:space="preserve">Row data</doc>
          <array length="1" zero-terminated="0" c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </parameter>
        <parameter name="row1_length" transfer-ownership="none">
          <doc xml:space="preserve">The number of elements in row1 array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="row2" transfer-ownership="none">
          <doc xml:space="preserve">Row data to compare with</doc>
          <array length="3" zero-terminated="0" c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </parameter>
        <parameter name="row2_length" transfer-ownership="none">
          <doc xml:space="preserve">The number of elements in row2 array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">User data passed to comparison function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FileResourceManager"
           c:symbol-prefix="file_resource_manager"
           c:type="DeeFileResourceManager"
           parent="GObject.Object"
           glib:type-name="DeeFileResourceManager"
           glib:get-type="dee_file_resource_manager_get_type"
           glib:type-struct="FileResourceManagerClass">
      <implements name="ResourceManager"/>
      <constructor name="new" c:identifier="dee_file_resource_manager_new">
        <doc xml:space="preserve">Create a new #DeeFileResourceManager with its primary store- and load
path set to @primary_path.

You can manually add fallback search paths by calling
dee_file_resource_manager_add_search_path().

You normally don't need to create you own resource managers. Instead
you should call dee_resource_manager_get_default().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #DeeFileResourceManager.
              Free with g_object_unref().</doc>
          <type name="FileResourceManager" c:type="DeeResourceManager*"/>
        </return-value>
        <parameters>
          <parameter name="primary_path" transfer-ownership="none">
            <doc xml:space="preserve">The primary path used to store and load resources.
               If you pass %NULL the manager will use a default path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_search_path"
              c:identifier="dee_file_resource_manager_add_search_path">
        <doc xml:space="preserve">Add a path to the set of paths searched for resources. The manager will
first search the primary path as specified in the constructor and then
search paths in the order they where added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to add a search
path to</doc>
            <type name="FileResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path to add to the set of searched paths</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_primary_path"
              c:identifier="dee_file_resource_manager_get_primary_path">
        <doc xml:space="preserve">Helper method to access the :primary-path property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the :primary-path property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to inspect</doc>
            <type name="FileResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="primary-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Property holding the primary path used to store and load resources</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="FileResourceManagerClass"
            c:type="DeeFileResourceManagerClass"
            glib:is-gtype-struct-for="FileResourceManager">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="Filter" c:type="DeeFilter">
      <doc xml:space="preserve">Structure encapsulating the mapping logic used to construct a #DeeFilterModel</doc>
      <field name="map_func" writable="1">
        <doc xml:space="preserve">The #DeeModelMapFunc used to construct
                             the initial contents of a #DeeFilterModel</doc>
        <type name="FilterMapFunc" c:type="DeeFilterMapFunc"/>
      </field>
      <field name="map_notify" writable="1">
        <doc xml:space="preserve">Callback invoked when the original model changes</doc>
        <type name="FilterMapNotify" c:type="DeeFilterMapNotify"/>
      </field>
      <field name="destroy" writable="1">
        <doc xml:space="preserve">Callback for freeing the @user_data
@userdata (closure): Free form user data associated with the filter.
                      This pointer will be passed to @map_func and @map_notify</doc>
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="userdata" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="destroy" c:identifier="dee_filter_destroy">
        <doc xml:space="preserve">Call the #GDestroyNotify function on the userdata pointer of a #DeeFilter
(if the destroy member is set, that is).

When using a #DeeFilterModel you should not call this method yourself.

This method will not free the memory allocated for @filter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">The filter to destroy</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="dee_filter_map">
        <doc xml:space="preserve">Call the #DeeFilterMapFunc function of a #DeeFilter.
When using a #DeeFilterModel you should not call this method yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">The filter to apply</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </instance-parameter>
          <parameter name="orig_model" transfer-ownership="none">
            <doc xml:space="preserve">The model that is being filtered</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="filter_model" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeFilterModel that holds the
               filtered subset of @orig_model</doc>
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify" c:identifier="dee_filter_notify">
        <doc xml:space="preserve">Call the #DeeFilterMapNotify function of a #DeeFilter.
When using a #DeeFilterModel you should not call this method yourself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The return value from the #DeeFilterMapNotify. That is; %TRUE
         if @orig_iter was added to @filter_model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">The filter to apply</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </instance-parameter>
          <parameter name="orig_iter" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelIter added to @orig_model</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="orig_model" transfer-ownership="none">
            <doc xml:space="preserve">The model that is being filtered</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="filter_model" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeFilterModel that holds the
               filtered subset of @orig_model</doc>
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="dee_filter_new">
        <doc xml:space="preserve">Create a new #DeeFilter with the given parameters. This call will zero
the @out_filter struct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="map_func"
                     transfer-ownership="none"
                     scope="notified">
            <doc xml:space="preserve">The #DeeFilterMapFunc to use for the filter</doc>
            <type name="FilterMapFunc" c:type="DeeFilterMapFunc"/>
          </parameter>
          <parameter name="map_notify"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">The #DeeFilterMapNotify to use for the filter</doc>
            <type name="FilterMapNotify" c:type="DeeFilterMapNotify"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:space="preserve">The user data to pass to @map_func and @map_notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">The #GDestroyNotify to call on
                        @userdata when disposing of the filter</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_collator" c:identifier="dee_filter_new_collator">
        <doc xml:space="preserve">Create a #DeeFilter that takes string values from a column in the model
and builds a #DeeFilterModel with the rows sorted according to the
collation rules of the current locale.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The index of a column containing the strings to sort after</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_collator_desc"
                c:identifier="dee_filter_new_collator_desc">
        <doc xml:space="preserve">Create a #DeeFilter that takes string values from a column in the model
and builds a #DeeFilterModel with the rows sorted descending according to the
collation rules of the current locale.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The index of a column containing the strings to sort after</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_any_column"
                c:identifier="dee_filter_new_for_any_column">
        <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which match a variant value in a given column. A #DeeFilterModel
created with this filter will be ordered in accordance with its parent model.

This method will work on any column, disregarding its schema, since the
value comparison is done using g_variant_equal(). This means you can use
this filter as a convenient fallback when there is no predefined filter
for your column type if raw performance is not paramount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The index of a column containing the string to match</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A #GVariant value columns must match exactly.
        The matching semantics are those of g_variant_equal(). If @value
        is floating the ownership will be transfered to the filter</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_key_column"
                c:identifier="dee_filter_new_for_key_column">
        <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which has an exact match on some string column. A #DeeFilterModel created
with this filter will be ordered in accordance with its parent model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The index of a column containing the string key to match</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_regex" c:identifier="dee_filter_new_regex">
        <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which match a regular expression on some string column. A #DeeFilterModel
created with this filter will be ordered in accordance with its parent model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The index of a column containing the string to match</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">The regular expression @column must match</doc>
            <type name="GLib.Regex" c:type="GRegex*"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_sort" c:identifier="dee_filter_new_sort">
        <doc xml:space="preserve">Create a new #DeeFilter sorting a model according to a #DeeCompareRowFunc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cmp_row"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">A #DeeCompareRowFunc to use for sorting</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="cmp_user_data" transfer-ownership="none">
            <doc xml:space="preserve">User data passed to @cmp_row</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="cmp_destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">The #GDestroyNotify to call on
                        @cmp_user_data when disposing of the filter</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="out_filter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="FilterMapFunc" c:type="DeeFilterMapFunc">
      <doc xml:space="preserve">Function used to collect the rows from a model that should be included in
a #DeeFilterModel. To add rows to @filter_model use the methods
dee_filter_model_append_iter(), dee_filter_model_prepend_iter(),
dee_filter_model_insert_iter(), and dee_filter_model_insert_iter_before().

The iteration over the original model is purposely left to the map func
in order to allow optimized iterations if the the caller has a priori
knowledge of the sorting and grouping of the data in the original model.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="orig_model" transfer-ownership="none">
          <doc xml:space="preserve">The model containing the original data to filter</doc>
          <type name="Model" c:type="DeeModel*"/>
        </parameter>
        <parameter name="filter_model" transfer-ownership="none">
          <doc xml:space="preserve">The model that will contain the filtered results. The
               filter func must iterate over @orig_model and add all relevant
               rows to @filter_model. This model is guaranteed to be empty
               when the filter func is invoked</doc>
          <type name="FilterModel" c:type="DeeFilterModel*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">User data passed together with the filter func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FilterMapNotify" c:type="DeeFilterMapNotify">
      <doc xml:space="preserve">Callback invoked when a row is added to @orig_model. To add rows to
@filter_model use the methods dee_filter_model_append_iter(),
dee_filter_model_prepend_iter(), dee_filter_model_insert_iter(),
and dee_filter_model_insert_iter_before().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @orig_iter was added to @filter_model</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="orig_model" transfer-ownership="none">
          <doc xml:space="preserve">The model containing the added row</doc>
          <type name="Model" c:type="DeeModel*"/>
        </parameter>
        <parameter name="orig_iter" transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row in @orig_model</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </parameter>
        <parameter name="filter_model" transfer-ownership="none">
          <doc xml:space="preserve">The model that was also passed to the #DeeModelMapFunc
               of the #DeeFilter this functions is a part of</doc>
          <type name="FilterModel" c:type="DeeFilterModel*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">User data for the #DeeFilter</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FilterModel"
           c:symbol-prefix="filter_model"
           c:type="DeeFilterModel"
           parent="ProxyModel"
           glib:type-name="DeeFilterModel"
           glib:get-type="dee_filter_model_get_type"
           glib:type-struct="FilterModelClass">
      <doc xml:space="preserve">All fields in the DeeFilterModel structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <constructor name="new" c:identifier="dee_filter_model_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #DeeFilterModel. Free with g_object_unref().</doc>
          <type name="FilterModel" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <parameter name="orig_model" transfer-ownership="none">
            <doc xml:space="preserve">The back end model. This will be set as the
             #DeeProxyModel:back-end property</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">Structure containing the logic used to create the filter model.
         The filter model will create it's own copy of @filter so unless
         @filter is allocated statically or on the stack you need to free it
         after calling this method.</doc>
            <type name="Filter" c:type="DeeFilter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_iter" c:identifier="dee_filter_model_append_iter">
        <doc xml:space="preserve">Includes @iter from the back end model in the filtered model, appending
it to the end of the filtered rows.

This method is usually called when implementing #DeeFilterMapFunc or
#DeeFilterMapNotify methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @iter</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="dee_filter_model_contains">
        <doc xml:space="preserve">Check if @iter from the back end model is mapped in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if @iter is contained in @self.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeFilterModel to check</doc>
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelIter to check</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_iter" c:identifier="dee_filter_model_insert_iter">
        <doc xml:space="preserve">Includes @iter from the back end model in the filtered model, inserting it at
@pos pushing other rows down.

This method is usually called when implementing #DeeFilterMapFunc or
#DeeFilterMapNotify methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @iter</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_iter_before"
              c:identifier="dee_filter_model_insert_iter_before">
        <doc xml:space="preserve">Includes @iter from the back end model in the filtered model, inserting it at
the position before @pos pushing other rows down.

This method is usually called when implementing #DeeFilterMapFunc or
#DeeFilterMapNotify methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @iter</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_iter_with_original_order"
              c:identifier="dee_filter_model_insert_iter_with_original_order">
        <doc xml:space="preserve">Inserts @iter in @self in a way that is consistent with the ordering of the
rows in the original #DeeModel behind @self. THis method assumes that @self
is already ordered this way. If that's not the case then this method has
undefined behaviour.

This method is mainly intended as a helper for #DeeFilterMapNotify functions
of #DeeFilter implementations that creates filter models sorted in
accordance with the original models.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @iter</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeFilterModel instance</doc>
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">Iterator</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_iter" c:identifier="dee_filter_model_prepend_iter">
        <doc xml:space="preserve">Includes @iter from the back end model in the filtered model, prepending
it to the beginning of the filtered rows.

This method is usually called when implementing #DeeFilterMapFunc or
#DeeFilterMapNotify methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @iter</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterModel" c:type="DeeFilterModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <property name="filter"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Property holding the #DeeFilter used to filter the model
defined in the #DeeFilterModel:back-end property.</doc>
        <type name="Filter" c:type="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="ProxyModel" c:type="DeeProxyModel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FilterModelPrivate" c:type="DeeFilterModelPrivate*"/>
      </field>
    </class>
    <record name="FilterModelClass"
            c:type="DeeFilterModelClass"
            glib:is-gtype-struct-for="FilterModel">
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyModelClass" c:type="DeeProxyModelClass"/>
      </field>
      <field name="_dee_filter_model_1" introspectable="0">
        <callback name="_dee_filter_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_filter_model_2" introspectable="0">
        <callback name="_dee_filter_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_filter_model_3" introspectable="0">
        <callback name="_dee_filter_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_filter_model_4" introspectable="0">
        <callback name="_dee_filter_model_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FilterModelPrivate"
            c:type="DeeFilterModelPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <class name="GListResultSet"
           c:symbol-prefix="glist_result_set"
           c:type="DeeGListResultSet"
           parent="GObject.Object"
           glib:type-name="DeeGListResultSet"
           glib:get-type="dee_glist_result_set_get_type"
           glib:type-struct="GListResultSetClass">
      <implements name="ResultSet"/>
      <function name="new"
                c:identifier="dee_glist_result_set_new"
                introspectable="0">
        <return-value>
          <type name="ResultSet" c:type="DeeResultSet*"/>
        </return-value>
        <parameters>
          <parameter name="rows" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="model" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="row_owner" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="GListResultSetClass"
            c:type="DeeGListResultSetClass"
            glib:is-gtype-struct-for="GListResultSet">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="HashIndex"
           c:symbol-prefix="hash_index"
           c:type="DeeHashIndex"
           parent="Index"
           glib:type-name="DeeHashIndex"
           glib:get-type="dee_hash_index_get_type"
           glib:type-struct="HashIndexClass">
      <doc xml:space="preserve">All fields in the DeeHashIndex structure are private and should never be
accessed directly</doc>
      <constructor name="new" c:identifier="dee_hash_index_new">
        <doc xml:space="preserve">Create a new hash index.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated hash index. Free with g_object_unref().</doc>
          <type name="HashIndex" c:type="DeeHashIndex*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">The model to index</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="analyzer" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeAnalyzer used to tokenize and filter the terms extracted
           by @reader</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </parameter>
          <parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelReader used to extract terms from the model</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Index" c:type="DeeIndex"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="HashIndexPrivate" c:type="DeeHashIndexPrivate*"/>
      </field>
    </class>
    <record name="HashIndexClass"
            c:type="DeeHashIndexClass"
            glib:is-gtype-struct-for="HashIndex">
      <field name="parent_class">
        <type name="IndexClass" c:type="DeeIndexClass"/>
      </field>
    </record>
    <record name="HashIndexPrivate" c:type="DeeHashIndexPrivate" disguised="1">
    </record>
    <enumeration name="ICUError"
                 c:type="DeeICUError"
                 glib:error-domain="dee-icu-error-quark">
      <doc xml:space="preserve">Error codes for the ICU extension to Dee. These codes will be set when the
error domain is #DEE_ICU_ERROR.</doc>
      <member name="bad_rule" value="0" c:identifier="DEE_ICU_ERROR_BAD_RULE">
        <doc xml:space="preserve">Error parsing a transliteration rule</doc>
      </member>
      <member name="bad_id" value="1" c:identifier="DEE_ICU_ERROR_BAD_ID">
        <doc xml:space="preserve">Error parsing a transliterator system id</doc>
      </member>
      <member name="unknown" value="2" c:identifier="DEE_ICU_ERROR_UNKNOWN">
        <doc xml:space="preserve">The ICU subsystem returned an error that is not
                        handled in Dee</doc>
      </member>
    </enumeration>
    <record name="ICUTermFilter" c:type="DeeICUTermFilter" disguised="1">
      <method name="apply" c:identifier="dee_icu_term_filter_apply">
        <doc xml:space="preserve">Apply a #DeeICUTermFilter on a piece of UTF-8 text.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The filter to apply</doc>
            <type name="ICUTermFilter" c:type="DeeICUTermFilter*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">The text to apply the filter on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="dee_icu_term_filter_destroy">
        <doc xml:space="preserve">Free all resources allocated by a #DeeICUTermFilter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">The filter to free</doc>
            <type name="ICUTermFilter" c:type="DeeICUTermFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="dee_icu_term_filter_new"
                introspectable="0"
                throws="1">
        <doc xml:space="preserve">Create a new #DeeICUTermFilter for a given ICU transliterator system id
and/or set of transliteration rules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #DeeICUTermFilter.
                          Free with dee_icu_term_filter_destroy().</doc>
          <type name="ICUTermFilter" c:type="DeeICUTermFilter*"/>
        </return-value>
        <parameters>
          <parameter name="system_id" transfer-ownership="none">
            <doc xml:space="preserve">A system id for the transliterator to use.
            See &lt;link anchor="http://userguide.icu-project.org/transforms/general"&gt;userguide.icu-project.org/transforms/general&lt;/link&gt;</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="rules"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A set of transliteration rules to use.
                      See &lt;link anchor="http://userguide.icu-project.org/transforms/general/rules"&gt;userguide.icu-project.org/transforms/general/rules&lt;/link&gt;</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_ascii_folder"
                c:identifier="dee_icu_term_filter_new_ascii_folder"
                introspectable="0">
        <doc xml:space="preserve">Construct a term filter that folds any UTF-8 string into ASCII.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #DeeICUTermFilter. Free with
                          dee_icu_term_filter_destroy().</doc>
          <type name="ICUTermFilter" c:type="DeeICUTermFilter*"/>
        </return-value>
      </function>
    </record>
    <class name="Index"
           c:symbol-prefix="index"
           c:type="DeeIndex"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="DeeIndex"
           glib:get-type="dee_index_get_type"
           glib:type-struct="IndexClass">
      <doc xml:space="preserve">All fields in the DeeIndex structure are private and should never be
accessed directly</doc>
      <virtual-method name="foreach" invoker="foreach">
        <doc xml:space="preserve">Iterate over an index optionally starting from some given term. Note that
unordered indexes (like #DeeHashIndex) has undefined behaviour with
this method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to iterate over</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="start_term" transfer-ownership="none">
            <doc xml:space="preserve">The term to start from or %NULL to iterate over all terms</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Called for each term in the index</doc>
            <type name="IndexIterFunc" c:type="DeeIndexIterFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary data to pass back to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_rows" invoker="get_n_rows">
        <doc xml:space="preserve">Get the number of indexed rows. A row is only indexed if it has at least one
term associated with it. If the analyzer has returned 0 terms then the row
is omitted from the index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows in the index. Note that this may less than or
         equal to dee_model_get_n_rows().</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the number of rows for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_rows_for_term" invoker="get_n_rows_for_term">
        <doc xml:space="preserve">Get the number of rows that matches a given term</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows in the index registered for the given term</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to inspect</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to look for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_terms" invoker="get_n_terms">
        <doc xml:space="preserve">Get the number of terms in the index</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of unique terms in the index</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the number of terms for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_supported_term_match_flags"
                      invoker="get_supported_term_match_flags">
        <doc xml:space="preserve">Get the #DeeTermMatchFlag&lt;!-- --&gt; supported by this #DeeIndex instance</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A bit mask of the acceptedd #DeeTermMatchFlag&lt;!-- --&gt;s</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to inspect</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup" invoker="lookup">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #DeeResultSet. Free with g_object_unref().</doc>
          <type name="ResultSet" c:type="DeeResultSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to perform the lookup in</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to look up on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">A bitmask of #DeeTermMatchFlag&lt;!-- --&gt; to control how matching is
        done</doc>
            <type name="TermMatchFlag" c:type="DeeTermMatchFlag"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="foreach" c:identifier="dee_index_foreach">
        <doc xml:space="preserve">Iterate over an index optionally starting from some given term. Note that
unordered indexes (like #DeeHashIndex) has undefined behaviour with
this method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to iterate over</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="start_term" transfer-ownership="none">
            <doc xml:space="preserve">The term to start from or %NULL to iterate over all terms</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Called for each term in the index</doc>
            <type name="IndexIterFunc" c:type="DeeIndexIterFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary data to pass back to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_analyzer" c:identifier="dee_index_get_analyzer">
        <doc xml:space="preserve">Get the analyzer being used to analyze terms extracted with the
#DeeModelReader used by this index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeAnalyzer used to analyze terms with</doc>
          <type name="Analyzer" c:type="DeeAnalyzer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the analyzer for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_model" c:identifier="dee_index_get_model">
        <doc xml:space="preserve">Get the model being indexed by this index</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModel being indexed by this index</doc>
          <type name="Model" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the model for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_rows" c:identifier="dee_index_get_n_rows">
        <doc xml:space="preserve">Get the number of indexed rows. A row is only indexed if it has at least one
term associated with it. If the analyzer has returned 0 terms then the row
is omitted from the index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows in the index. Note that this may less than or
         equal to dee_model_get_n_rows().</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the number of rows for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_rows_for_term"
              c:identifier="dee_index_get_n_rows_for_term">
        <doc xml:space="preserve">Get the number of rows that matches a given term</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows in the index registered for the given term</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to inspect</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to look for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_terms" c:identifier="dee_index_get_n_terms">
        <doc xml:space="preserve">Get the number of terms in the index</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of unique terms in the index</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the number of terms for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reader" c:identifier="dee_index_get_reader">
        <doc xml:space="preserve">Get the reader being used to extract terms from rows in the model</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModelReader used to extract terms with</doc>
          <type name="ModelReader" c:type="DeeModelReader*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to get the reader for</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_supported_term_match_flags"
              c:identifier="dee_index_get_supported_term_match_flags">
        <doc xml:space="preserve">Get the #DeeTermMatchFlag&lt;!-- --&gt; supported by this #DeeIndex instance</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A bit mask of the acceptedd #DeeTermMatchFlag&lt;!-- --&gt;s</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to inspect</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="dee_index_lookup">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #DeeResultSet. Free with g_object_unref().</doc>
          <type name="ResultSet" c:type="DeeResultSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to perform the lookup in</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to look up on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">A bitmask of #DeeTermMatchFlag&lt;!-- --&gt; to control how matching is
        done</doc>
            <type name="TermMatchFlag" c:type="DeeTermMatchFlag"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_one" c:identifier="dee_index_lookup_one">
        <doc xml:space="preserve">Convenience function in for cases where you have a priori guarantee that
a dee_index_lookup() call will return exactly 0 or 1 row. If the lookup
returns more than 1 row a warning will be printed on standard error and
%NULL will be returned.

The typical use case for this function is if you need something akin to
a primary key in a relational database.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the matching
              row or %NULL in case no rows matches @term</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The index to do the lookup in</doc>
            <type name="Index" c:type="DeeIndex*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The exact term to match</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="analyzer"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DeeAnalyzer used to analyze terms extracted by the model reader</doc>
        <type name="Analyzer"/>
      </property>
      <property name="model"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DeeModel being indexed</doc>
        <type name="Model"/>
      </property>
      <property name="reader"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DeeModelReader used to extract terms from rows in the model</doc>
        <type name="ModelReader" c:type="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="IndexPrivate" c:type="DeeIndexPrivate*"/>
      </field>
    </class>
    <record name="IndexClass"
            c:type="DeeIndexClass"
            glib:is-gtype-struct-for="Index">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="lookup">
        <callback name="lookup">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #DeeResultSet. Free with g_object_unref().</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to perform the lookup in</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
            <parameter name="term" transfer-ownership="none">
              <doc xml:space="preserve">The term to look up on</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">A bitmask of #DeeTermMatchFlag&lt;!-- --&gt; to control how matching is
        done</doc>
              <type name="TermMatchFlag" c:type="DeeTermMatchFlag"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="foreach">
        <callback name="foreach">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to iterate over</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
            <parameter name="start_term" transfer-ownership="none">
              <doc xml:space="preserve">The term to start from or %NULL to iterate over all terms</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="call"
                       closure="3">
              <doc xml:space="preserve">Called for each term in the index</doc>
              <type name="IndexIterFunc" c:type="DeeIndexIterFunc"/>
            </parameter>
            <parameter name="userdata" transfer-ownership="none">
              <doc xml:space="preserve">Arbitrary data to pass back to @func</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_terms">
        <callback name="get_n_terms">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of unique terms in the index</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to get the number of terms for</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_rows">
        <callback name="get_n_rows">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of rows in the index. Note that this may less than or
         equal to dee_model_get_n_rows().</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to get the number of rows for</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_rows_for_term">
        <callback name="get_n_rows_for_term">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of rows in the index registered for the given term</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to inspect</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
            <parameter name="term" transfer-ownership="none">
              <doc xml:space="preserve">The term to look for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_supported_term_match_flags">
        <callback name="get_supported_term_match_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A bit mask of the acceptedd #DeeTermMatchFlag&lt;!-- --&gt;s</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The index to inspect</doc>
              <type name="Index" c:type="DeeIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_index_1" introspectable="0">
        <callback name="_dee_index_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_index_2" introspectable="0">
        <callback name="_dee_index_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_index_3" introspectable="0">
        <callback name="_dee_index_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_index_4" introspectable="0">
        <callback name="_dee_index_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_index_5" introspectable="0">
        <callback name="_dee_index_5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="IndexIterFunc" c:type="DeeIndexIterFunc">
      <doc xml:space="preserve">The signature of the function passed to dee_index_foreach().

Be cautious if you plan on modifying the rows in the model via the
DeeModelIter&lt;!-- --&gt;s you find. Your code may have to be reentrant since
the index may change in reaction to the changes in the model. It's not
impossible to do this in a non-broken manner, but it may likely require
you calling dee_model_freeze_signals() and dee_model_thaw_signals() at
strategic points.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if iteration should stop, %TRUE if it should continue</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">A key in the index being traversed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="rows" transfer-ownership="none">
          <doc xml:space="preserve">A #DeeResultSet. Do not free or modify.</doc>
          <type name="ResultSet" c:type="DeeResultSet*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">The pointer passed to dee_index_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IndexPrivate" c:type="DeeIndexPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <interface name="Model"
               c:symbol-prefix="model"
               c:type="DeeModel"
               glib:type-name="DeeModel"
               glib:get-type="dee_model_get_type"
               glib:type-struct="ModelIface">
      <virtual-method name="append_row" invoker="append_row">
        <doc xml:space="preserve">Like dee_model_append() but intended for language bindings or
situations where you work with models on a meta level and may not have
a prior knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to prepend a row to</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of  #GVariants with type
              signature matching those of the column schemas of @self.
              If any of the variants have floating references they will be
              consumed</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="begin_changeset" invoker="begin_changeset">
        <doc xml:space="preserve">Notify listeners that the model is about to be changed, which means that
multiple row additions / changes / removals will follow.
The default implementation of this method will emit
the ::changeset-started signal.

It is not stricly necessary to enclose every change to a model
in a dee_model_begin_changeset() and dee_model_end_changeset() calls, but
doing so is highly recommended and allows implementing various optimizations.

The usual way to perform multiple changes to a model is as follows:

&lt;programlisting&gt;
void update_model (DeeModel *model)
{
  GVariant **added_row_data1 = ...;
  GVariant **added_row_data2 = ...;

  dee_model_begin_changeset (model);

  dee_model_remove (model, dee_model_get_first_iter (model));
  dee_model_append_row (model, added_row_data1);
  dee_model_append_row (model, added_row_data2);

  dee_model_end_changeset (model);
}
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changeset_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changeset_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear" invoker="clear">
        <doc xml:space="preserve">Removes all rows in the model. Signals are emitted for each row in the model</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel object to clear</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="end_changeset" invoker="end_changeset">
        <doc xml:space="preserve">Notify listeners that all changes have been committed to the model.
The default implementation of this method will emit
the ::changeset-finished signal.

See also dee_model_begin_changeset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_row_sorted" invoker="find_row_sorted">
        <doc xml:space="preserve">Finds a row in @self according to the sorting specified by @cmp_func.
This method will assume that @self is already sorted by @cmp_func.

If you use this method for searching you should only use
dee_model_insert_row_sorted() to insert rows in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">If @out_was_found is set to
          %TRUE then a #DeeModelIter pointing to the last matching row.
          If it is %FALSE then the iter pointing to the row just after where
          @row_spec_would have been inserted.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to search</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_spec" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. No references will be taken on the variants.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_was_found"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A place to store a boolean value that will be set when
                this method returns. If %TRUE then an exact match was found.
                If %FALSE then the returned iter points to a row just after
                where @row_spec would have been inserted.
                Pass %NULL to ignore.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_bool" invoker="get_bool">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the boolean stored at @column.
              Otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a boolean from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_column_index" invoker="get_column_index">
        <doc xml:space="preserve">Get the column index of a column.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0-based index of the column or -1 if column with this name
              wasn't found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_name" transfer-ownership="none">
            <doc xml:space="preserve">the column name to retrieve the index of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_column_names" invoker="get_column_names">
        <doc xml:space="preserve">Get a %NULL-terminated array of column names for the columns of @self.
These names can be used in calls to dee_model_build_named_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_column_schema" invoker="get_column_schema">
        <doc xml:space="preserve">Get the #GVariant signature of a column</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant signature of the column at index @column</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to get retrieve the #GVariant type string of</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_double" invoker="get_double">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the double stored at @column.
 Otherwise 0.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a double from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_field_schema" invoker="get_field_schema">
        <doc xml:space="preserve">Get the #GVariant signature of field previously registered with
dee_model_register_vardict_schema().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant signature for the field, or %NULL if given field
              wasn't registered with dee_model_register_vardict_schema().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:space="preserve">name of vardict field to get schema of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="out_column"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">column index of the associated vardict</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_first_iter" invoker="get_first_iter">
        <doc xml:space="preserve">Retrieves a #DeeModelIter representing the first row in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_int32" invoker="get_int32">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the int stored at @column.
 Otherwise 0.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a int from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_int64" invoker="get_int64">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the int64 stored at @column.
 Otherwise 0.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a int64 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_iter_at_row" invoker="get_iter_at_row">
        <doc xml:space="preserve">Retrieves a #DeeModelIter representing the row at the given index.

Note that this method does not have any performance guarantees. In particular
it is not guaranteed to be &lt;emphasis&gt;O(1)&lt;/emphasis&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #DeeModelIter, or %NULL if @row
  was out of bounds. The returned iter is owned by @self, so do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row" transfer-ownership="none">
            <doc xml:space="preserve">position of the row to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_last_iter" invoker="get_last_iter">
        <doc xml:space="preserve">Retrieves a #DeeModelIter pointing right &lt;emphasis&gt;after&lt;/emphasis&gt; the
last row in @self. This is refered to also the the
&lt;emphasis&gt;end iter&lt;/emphasis&gt;.

As with other iters the end iter, in particular, is stable over inserts,
changes, or removals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_columns" invoker="get_n_columns">
        <doc xml:space="preserve">Gets the number of columns in @self</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of columns per row in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_rows" invoker="get_n_rows">
        <doc xml:space="preserve">Gets the number of rows in @self</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of rows in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_position" invoker="get_position">
        <doc xml:space="preserve">Get the numeric offset of @iter into @self. Note that this method is
&lt;emphasis&gt;not&lt;/emphasis&gt;  guaranteed to be &lt;emphasis&gt;O(1)&lt;/emphasis&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The integer offset of @iter in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The iter to get the position of</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_row">
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant**"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="out_row_members" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_schema" invoker="get_schema">
        <doc xml:space="preserve">Get a %NULL-terminated array of #GVariant type strings that defines the
required formats for the columns of @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_string" invoker="get_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the string stored at @column.
              Otherwise %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a string from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_tag" invoker="get_tag">
        <doc xml:space="preserve">Look up a tag value for a given row in a model. This method is guaranteed
to be O(1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns %NULL if @tag is unset otherwise the
              value of the tag as it was set with dee_model_set_tag().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to get a tag from</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the row to get the tag from</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">The tag handle to retrieve the tag value for</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uchar" invoker="get_uchar">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uchar stored at @column.
 Otherwise 0.</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uchar from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uint32" invoker="get_uint32">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uint stored at @column.
 Otherwise 0.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uint from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uint64" invoker="get_uint64">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uint64 stored at @column.
 Otherwise 0.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uint64 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_value" invoker="get_value">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">column number to retrieve the value from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_value_by_name" invoker="get_value_by_name">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_vardict_schema" invoker="get_vardict_schema">
        <doc xml:space="preserve">Get a schema for variant dictionary column previously registered using
dee_model_register_vardict_schema().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">Hashtable
              containing a mapping from field names to schemas or NULL.
              Note that keys and values in the hashtable may be owned
              by the model, so you need to create a deep copy if you
              intend to keep the hashtable around.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_column" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="insert_row" invoker="insert_row">
        <doc xml:space="preserve">As dee_model_insert(), but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The index to insert the row on. The existing row will be pushed down.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="insert_row_before" invoker="insert_row_before">
        <doc xml:space="preserve">As dee_model_insert_before(), but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iter pointing to the row before which to insert the new one</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="insert_row_sorted" invoker="insert_row_sorted">
        <doc xml:space="preserve">Inserts a row in @self according to the sorting specified by @cmp_func.
If you use this method for insertion you should not use other methods as this
method assumes the model to be already sorted by @cmp_func.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to do a sorted insert on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_first" invoker="is_first">
        <doc xml:space="preserve">Checks if @iter is the very first iter @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if @iter is the first iter in the model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_last" invoker="is_last">
        <doc xml:space="preserve">Whether @iter is the end iter of @self. Note that the end iter points
right &lt;emphasis&gt;after&lt;/emphasis&gt; the last valid row in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if @iter is the last iter in the model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next" invoker="next">
        <doc xml:space="preserve">Returns a #DeeModelIter that points to the next position in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter, pointing to the next row in
  the model. The iter is owned by @self, do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepend_row" invoker="prepend_row">
        <doc xml:space="preserve">Like dee_model_prepend() but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to prepend a row to</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prev" invoker="prev">
        <doc xml:space="preserve">Returns a #DeeModelIter that points to the previous position in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter, pointing to the previous
  row in the model. The iter is owned by @self, do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="register_tag" invoker="register_tag">
        <doc xml:space="preserve">Register a new tag on a #DeeModel. A &lt;emphasis&gt;tag&lt;/emphasis&gt; is an extra
value attached to a given row on a model. The tags are invisible to all
that doesn't have the tag handle returned by this method. #DeeModel
implementations must ensure that dee_model_get_tag() is an O(1) operation.

Tags can be very useful in associating some extra data to a row in a model
and have that automatically synced when the model changes. If you're
writing a tiled view for a model you might want to tag each row with the
tile widget for that row. That way you have very convenient access to the
tile widget given any row in the model.

The private nature of tags and the fact that you can store arbitrary pointers
and binary data in them also means that they are not serialized if you
utilize a model implementation that exposes the #DeeSerializable interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelTag handle
              that you can use to set and get tags with</doc>
          <type name="ModelTag" c:type="DeeModelTag*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to register a tag on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="tag_destroy"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">Function called when a tagged row is removed from the model.
              This function will also be called on all tagged rows when the
              model is finalized.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="register_vardict_schema"
                      invoker="register_vardict_schema">
        <doc xml:space="preserve">Register schema for fields in a model containing column with variant
dictionary schema ('a{sv}').
The keys registered with this function can be later used
with dee_model_build_named_row() function, as well as
dee_model_get_value_by_name(). Note that it is possible to register
the same field name for multiple columns, in which case you need to use
fully-qualified "column_name::field" name in the calls to
dee_model_build_named_row() and dee_model_get_field_schema().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_column" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="schemas" transfer-ownership="none">
            <doc xml:space="preserve">hashtable with keys specifying
          names of the fields and values defining their schema</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove" invoker="remove">
        <doc xml:space="preserve">Removes the row at the given position from the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to remove</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="row_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="row_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="row_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_column_names_full"
                      invoker="set_column_names_full">
        <doc xml:space="preserve">Set column names used by @self.
This method must be called exactly once, but only after setting
a schema of the model. Note that some constructors will do this for you.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModel.</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_names" transfer-ownership="none">
            <doc xml:space="preserve">A list of column names terminated by a %NULL</doc>
            <array length="1" zero-terminated="1" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="num_columns" transfer-ownership="none">
            <doc xml:space="preserve">an integer specifying the array length for @annotations</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_row" invoker="set_row">
        <doc xml:space="preserve">Sets all columns in the row @iter points to, to those found in
@row_members. The variants in @row_members must match the types defined in
the model's schema.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">And array of
              #GVariant&lt;!-- --&gt;s with type signature matching
              those from the model schema. If any of the variants have
              floating references these will be consumed</doc>
            <array zero-terminated="0" c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_schema_full" invoker="set_schema_full">
        <doc xml:space="preserve">Set the #GVariant types and the number of columns used by @self.
This method must be called exactly once before using @self. Note that
some constructors will do this for you.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to set the column layout for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_schemas" transfer-ownership="none">
            <doc xml:space="preserve">A list of #GVariant type strings terminated by a %NULL</doc>
            <array length="1" zero-terminated="1" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="num_columns" transfer-ownership="none">
            <doc xml:space="preserve">an integer specifying the array length for @VarArgs</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_tag" invoker="set_tag">
        <doc xml:space="preserve">Set a tag on a row in a model. This function is guaranteed to be O(1).
See also dee_model_register_tag().

If @tag is already set on this row the existing tag value will be destroyed
with the #GDestroyNotify passed to the dee_model_register_tag().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to set a tag on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The row to set the tag on</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">The tag handle for the tag as obtained from dee_model_register_tag()</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set for @tag. Note that %NULL represents an unset tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_value" invoker="set_value">
        <doc xml:space="preserve">Sets the data in @column for the row @iter points to, to @value. The type
of @value must be convertible to the type of the column.

When this method call completes the model will emit ::row-changed. You can
edit the model in place without triggering the change signals by calling
dee_model_set_value_silently().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">column number to set the value</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">New value for cell. If @value is a floating reference the model
        will assume ownership of the variant</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="append" c:identifier="dee_model_append" introspectable="0">
        <doc xml:space="preserve">Creates and appends a new row to the end of a #DeeModel, setting the row
values upon creation.

For and example see dee_model_insert_before().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="append_row" c:identifier="dee_model_append_row">
        <doc xml:space="preserve">Like dee_model_append() but intended for language bindings or
situations where you work with models on a meta level and may not have
a prior knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to prepend a row to</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of  #GVariants with type
              signature matching those of the column schemas of @self.
              If any of the variants have floating references they will be
              consumed</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="begin_changeset" c:identifier="dee_model_begin_changeset">
        <doc xml:space="preserve">Notify listeners that the model is about to be changed, which means that
multiple row additions / changes / removals will follow.
The default implementation of this method will emit
the ::changeset-started signal.

It is not stricly necessary to enclose every change to a model
in a dee_model_begin_changeset() and dee_model_end_changeset() calls, but
doing so is highly recommended and allows implementing various optimizations.

The usual way to perform multiple changes to a model is as follows:

&lt;programlisting&gt;
void update_model (DeeModel *model)
{
  GVariant **added_row_data1 = ...;
  GVariant **added_row_data2 = ...;

  dee_model_begin_changeset (model);

  dee_model_remove (model, dee_model_get_first_iter (model));
  dee_model_append_row (model, added_row_data1);
  dee_model_append_row (model, added_row_data2);

  dee_model_end_changeset (model);
}
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="build_named_row"
              c:identifier="dee_model_build_named_row"
              introspectable="0">
        <doc xml:space="preserve">Build an array of #GVariant&lt;!-- --&gt;s with values from the variadic argument
list according to the column names and model schema for @self.
The caller must call g_variant_ref_sink() and g_variant_unref()
on all the returned variants and g_free() the array itself if %NULL
was passed as @out_row_members.

This is utility function and will not touch or modify @self in any way.

For example, to append a row to model with signature ("s", "u", "s") and
column names set to ("uri", "count", "description") you could do:
&lt;informalexample&gt;&lt;programlisting&gt;
 GVariant    *row_buf[3];

 dee_model_append_row (model,
   dee_model_build_named_row (model, row_buf,
                              "uri", "http://example.org",
                              "count", 435,
                              "description", "Example.org site", NULL));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">If @out_row_members is %NULL a newly allocated array of variants
         will be returned and the array must be freed with g_free().
         If @out_row_members is non-%NULL it will be reused, and variants in
         the array may or may not have floating references, which means the
         caller must make sure that g_variant_ref_sink() and
         g_variant_unref() are called on them.</doc>
          <type name="GLib.Variant" c:type="GVariant**"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to create a row for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="out_row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array to write the values to or %NULL to allocate
                  a new array. If non-%NULL it must have a length
                  that is longer or equal to the number of columns in @self</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="first_column_name" transfer-ownership="none">
            <doc xml:space="preserve">A column name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="build_named_row_sunk"
              c:identifier="dee_model_build_named_row_sunk"
              introspectable="0">
        <doc xml:space="preserve">Version of dee_model_build_named_row() for language bindings - as opposed to
dee_model_build_named_row(), the returned variants will be strong
references, therefore you always have to call g_variant_unref() on the items
and g_free() the array itself if %NULL was passed as @out_row_members.

If @out_row_members is non-%NULL, g_variant_unref() will be called
on its elements (if also non-%NULL), which allows easy reuse of the array
memory in loops.

This is utility function and will not touch or modify @self in any way.

Example of memory management for model with schema ("s", "i") and
column names ("uri", "count"):
&lt;informalexample&gt;&lt;programlisting&gt;
 GVariant    **row_buf;

 row_buf = dee_model_build_named_row_sunk (model, NULL, "uri", "file:///",
                                           "count", 0, NULL);
 dee_model_append_row (model, row_buf);

 for (int i = 1; i &lt; 100; i++)
 {
   dee_model_append_row (model,
     dee_model_build_named_row_sunk (model, row_buf, "uri", "file:///",
                                     "count", i, NULL));
 }
 
 g_variant_unref (row_buf[0]);
 g_variant_unref (row_buf[1]);
 g_free (row_buf);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">If @out_row_members is %NULL
         a newly allocated array of variants will be returned and the array
         must be freed with g_free().
         If @out_row_members is non-%NULL it will be reused. Variants in
         the array will have strong references, which means the
         caller must make sure that g_variant_unref() is called on them.</doc>
          <array length="1" zero-terminated="0" c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to create a row for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="out_row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array to write the values to or %NULL to
                  allocate a new array. If non-%NULL it must have a length
                  that is longer or equal to the number of columns in @self</doc>
            <array zero-terminated="0" c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="out_array_length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Length of the returned variant array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="first_column_name" transfer-ownership="none">
            <doc xml:space="preserve">A column name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="build_named_row_valist"
              c:identifier="dee_model_build_named_row_valist"
              introspectable="0">
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant**"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="out_row_members" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="first_column_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <type name="va_list" c:type="va_list*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_row"
              c:identifier="dee_model_build_row"
              introspectable="0">
        <doc xml:space="preserve">Build an array of #GVariant&lt;!-- --&gt;s with values from the variadic argument
list according to the model schema for @self. The caller must call
g_variant_ref_sink() and g_variant_unref() on all the returned variants and
g_free() the array itself if %NULL was passed as @out_row_members.

This is utility function and will not touch or modify @self in any way.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">If @out_row_members is %NULL a newly allocated array of variants
         will be returned and the array must be freed with g_free().
         If @out_row_members is non-%NULL it will be reused, and variants in
         the array may or may not have floating references, which means the
         caller must make sure that g_variant_ref_sink() and
         g_variant_unref() are called on them.</doc>
          <type name="GLib.Variant" c:type="GVariant**"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to create a row for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="out_row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array to write the values to or %NULL to allocate
                  a new array. If non-%NULL it must have a length
                  that is longer or equal to the number of columns in @self</doc>
            <type name="GLib.Variant" c:type="GVariant**"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="dee_model_clear">
        <doc xml:space="preserve">Removes all rows in the model. Signals are emitted for each row in the model</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel object to clear</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_tag" c:identifier="dee_model_clear_tag">
        <doc xml:space="preserve">This method is purely syntactic sugar for calling dee_model_set_tag() with
a @value of %NULL. It's included in order to help developers write more
readable code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to clear a tag on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The row to clear the tag from</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">The tag to clear from @iter</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end_changeset" c:identifier="dee_model_end_changeset">
        <doc xml:space="preserve">Notify listeners that all changes have been committed to the model.
The default implementation of this method will emit
the ::changeset-finished signal.

See also dee_model_begin_changeset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find_row_sorted" c:identifier="dee_model_find_row_sorted">
        <doc xml:space="preserve">Finds a row in @self according to the sorting specified by @cmp_func.
This method will assume that @self is already sorted by @cmp_func.

If you use this method for searching you should only use
dee_model_insert_row_sorted() to insert rows in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">If @out_was_found is set to
          %TRUE then a #DeeModelIter pointing to the last matching row.
          If it is %FALSE then the iter pointing to the row just after where
          @row_spec_would have been inserted.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to search</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_spec" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. No references will be taken on the variants.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_was_found"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A place to store a boolean value that will be set when
                this method returns. If %TRUE then an exact match was found.
                If %FALSE then the returned iter points to a row just after
                where @row_spec would have been inserted.
                Pass %NULL to ignore.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_row_sorted_with_sizes"
              c:identifier="dee_model_find_row_sorted_with_sizes">
        <doc xml:space="preserve">Like dee_model_find_row_sorted(), but uses DeeCompareRowSizedFunc and
therefore doesn't cause trouble when used from introspected languages.

Finds a row in @self according to the sorting specified by @cmp_func.
This method will assume that @self is already sorted by @cmp_func.

If you use this method for searching you should only use
dee_model_insert_row_sorted() (or dee_model_insert_row_sorted_with_sizes())
to insert rows in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">If @out_was_found is set to
          %TRUE then a #DeeModelIter pointing to the last matching row.
          If it is %FALSE then the iter pointing to the row just after where
          @row_spec_would have been inserted.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to search</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_spec" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. No references will be taken on the variants.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowSizedFunc" c:type="DeeCompareRowSizedFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_was_found"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A place to store a boolean value that will be set when
                this method returns. If %TRUE then an exact match was found.
                If %FALSE then the returned iter points to a row just after
                where @row_spec would have been inserted.
                Pass %NULL to ignore.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_sorted"
              c:identifier="dee_model_find_sorted"
              introspectable="0">
        <doc xml:space="preserve">Finds a row in @self according to the sorting specified by @cmp_func.
This method will assume that @self is already sorted by @cmp_func.

If you use this method for searching you should only use
dee_model_insert_row_sorted() to insert rows in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">If @out_was_found is set to
          %TRUE then a #DeeModelIter pointing to the last matching row.
          If it is %FALSE then the iter pointing to the row just after where
          @row_spec_would have been inserted.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to search</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_was_found"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A place to store a boolean value that will be set when
                this method returns. If %TRUE then an exact match was found.
                If %FALSE then the returned iter points to a row just after
                where @row_spec would have been inserted.
                Pass %NULL to ignore.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="dee_model_get" introspectable="0">
        <doc xml:space="preserve">Gets all the values across the entire row referenced by @iter. The
variable argument list should contain pointers to variables that match
the column schemas of this model.

For all basic variant types (see g_variant_type_is_basic()) this method
expects pointers to their native C types while for all other types it
expects a pointer to a pointer to a #GVariant.

For string values you are passed a constant reference which is owned by the
model, but any returned variants must be freed with g_variant_unref ().

For example, to get all values a model with signature ("u", "s", "as") you
would do:
&lt;informalexample&gt;&lt;programlisting&gt;
 guint32      u;
 const gchar *s;
 GVariant    *v;

 dee_model_get (model, iter, &amp;u, &amp;s, &amp;v);

 // do stuff

 g_variant_unref (v);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bool" c:identifier="dee_model_get_bool">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the boolean stored at @column.
              Otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a boolean from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_column_index"
              c:identifier="dee_model_get_column_index">
        <doc xml:space="preserve">Get the column index of a column.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0-based index of the column or -1 if column with this name
              wasn't found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_name" transfer-ownership="none">
            <doc xml:space="preserve">the column name to retrieve the index of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_column_names"
              c:identifier="dee_model_get_column_names">
        <doc xml:space="preserve">Get a %NULL-terminated array of column names for the columns of @self.
These names can be used in calls to dee_model_build_named_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_column_schema"
              c:identifier="dee_model_get_column_schema">
        <doc xml:space="preserve">Get the #GVariant signature of a column</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant signature of the column at index @column</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to get retrieve the #GVariant type string of</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="dee_model_get_double">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the double stored at @column.
 Otherwise 0.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a double from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_field_schema"
              c:identifier="dee_model_get_field_schema">
        <doc xml:space="preserve">Get the #GVariant signature of field previously registered with
dee_model_register_vardict_schema().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariant signature for the field, or %NULL if given field
              wasn't registered with dee_model_register_vardict_schema().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:space="preserve">name of vardict field to get schema of</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="out_column"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">column index of the associated vardict</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_iter" c:identifier="dee_model_get_first_iter">
        <doc xml:space="preserve">Retrieves a #DeeModelIter representing the first row in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int32" c:identifier="dee_model_get_int32">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the int stored at @column.
 Otherwise 0.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a int from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="dee_model_get_int64">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the int64 stored at @column.
 Otherwise 0.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a int64 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_iter_at_row" c:identifier="dee_model_get_iter_at_row">
        <doc xml:space="preserve">Retrieves a #DeeModelIter representing the row at the given index.

Note that this method does not have any performance guarantees. In particular
it is not guaranteed to be &lt;emphasis&gt;O(1)&lt;/emphasis&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #DeeModelIter, or %NULL if @row
  was out of bounds. The returned iter is owned by @self, so do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row" transfer-ownership="none">
            <doc xml:space="preserve">position of the row to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_last_iter" c:identifier="dee_model_get_last_iter">
        <doc xml:space="preserve">Retrieves a #DeeModelIter pointing right &lt;emphasis&gt;after&lt;/emphasis&gt; the
last row in @self. This is refered to also the the
&lt;emphasis&gt;end iter&lt;/emphasis&gt;.

As with other iters the end iter, in particular, is stable over inserts,
changes, or removals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_columns" c:identifier="dee_model_get_n_columns">
        <doc xml:space="preserve">Gets the number of columns in @self</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of columns per row in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_rows" c:identifier="dee_model_get_n_rows">
        <doc xml:space="preserve">Gets the number of rows in @self</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of rows in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_position" c:identifier="dee_model_get_position">
        <doc xml:space="preserve">Get the numeric offset of @iter into @self. Note that this method is
&lt;emphasis&gt;not&lt;/emphasis&gt;  guaranteed to be &lt;emphasis&gt;O(1)&lt;/emphasis&gt;.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The integer offset of @iter in @self</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The iter to get the position of</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_row" c:identifier="dee_model_get_row">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@out_row_members if it was not %NULL
         or a newly allocated array otherwise which you must free
         with g_free(). The variants in the array will have a strong
         reference and needs to be freed with g_variant_unref().</doc>
          <array c:type="GVariant**">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModel to get a row from</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the row to get</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="out_row_members"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
                  An array of variants with a length bigger than or equal to
                  the number of columns in @self, or %NULL. If you pass
                  %NULL here a new array will be allocated for you. The
                  returned variants will have a non-floating reference</doc>
            <array zero-terminated="0" c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_schema" c:identifier="dee_model_get_schema">
        <doc xml:space="preserve">Get a %NULL-terminated array of #GVariant type strings that defines the
required formats for the columns of @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="num_columns"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="dee_model_get_string">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the string stored at @column.
              Otherwise %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a string from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tag" c:identifier="dee_model_get_tag">
        <doc xml:space="preserve">Look up a tag value for a given row in a model. This method is guaranteed
to be O(1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns %NULL if @tag is unset otherwise the
              value of the tag as it was set with dee_model_set_tag().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to get a tag from</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the row to get the tag from</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">The tag handle to retrieve the tag value for</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uchar" c:identifier="dee_model_get_uchar">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uchar stored at @column.
 Otherwise 0.</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uchar from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32" c:identifier="dee_model_get_uint32">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uint stored at @column.
 Otherwise 0.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uint from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="dee_model_get_uint64">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @iter and @column are valid, the uint64 stored at @column.
 Otherwise 0.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column to retrieve a uint64 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="dee_model_get_value">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">column number to retrieve the value from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_by_name"
              c:identifier="dee_model_get_value_by_name">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to inspect</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vardict_schema"
              c:identifier="dee_model_get_vardict_schema">
        <doc xml:space="preserve">Get a schema for variant dictionary column previously registered using
dee_model_register_vardict_schema().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">Hashtable
              containing a mapping from field names to schemas or NULL.
              Note that keys and values in the hashtable may be owned
              by the model, so you need to create a deep copy if you
              intend to keep the hashtable around.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column index to get the schemas for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="dee_model_insert" introspectable="0">
        <doc xml:space="preserve">Creates and inserts a new row into a #DeeModel, pushing the existing
rows down.

For and example see dee_model_insert_before().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The index to insert the row on. The existing row will be pushed down</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_before"
              c:identifier="dee_model_insert_before"
              introspectable="0">
        <doc xml:space="preserve">Creates and inserts a new row into a #DeeModel just before the row pointed
to by @iter.

For example, to insert a new row in a model with schema ("u", "s", "as")
you would do:

&lt;informalexample&gt;&lt;programlisting&gt;
 DeeModelIter    *iter;
 GVariantBuilder  b;

 g_variant_builder_init (&amp;amp;b, "as");
 g_variant_builder_add (&amp;amp;b, "s", "Hello");
 g_variant_builder_add (&amp;amp;b, "s", "World");

 iter = find_my_special_row (model);
 dee_model_insert_before (model, iter,
                          27,
                          "Howdy",
                          g_variant_builder_end (&amp;amp;b));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iter pointing to the row before which to insert the new one</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_row" c:identifier="dee_model_insert_row">
        <doc xml:space="preserve">As dee_model_insert(), but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The index to insert the row on. The existing row will be pushed down.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="insert_row_before"
              c:identifier="dee_model_insert_row_before">
        <doc xml:space="preserve">As dee_model_insert_before(), but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iter pointing to the row before which to insert the new one</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="insert_row_sorted"
              c:identifier="dee_model_insert_row_sorted">
        <doc xml:space="preserve">Inserts a row in @self according to the sorting specified by @cmp_func.
If you use this method for insertion you should not use other methods as this
method assumes the model to be already sorted by @cmp_func.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to do a sorted insert on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_row_sorted_with_sizes"
              c:identifier="dee_model_insert_row_sorted_with_sizes">
        <doc xml:space="preserve">Inserts a row in @self according to the sorting specified by @cmp_func.
If you use this method for insertion you should not use other methods as this
method assumes the model to be already sorted by @cmp_func.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to do a sorted insert on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowSizedFunc" c:type="DeeCompareRowSizedFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_sorted"
              c:identifier="dee_model_insert_sorted"
              introspectable="0">
        <doc xml:space="preserve">Convenience function for calling dee_model_insert_row_sorted().
Inserts a row in @self according to the sorting specified by @cmp_func.
If you use this method for insertion you should not use other methods as this
method assumes the model to be already sorted by @cmp_func.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to do a sorted insert on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="cmp_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">Callback used for comparison or rows</doc>
            <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="is_first" c:identifier="dee_model_is_first">
        <doc xml:space="preserve">Checks if @iter is the very first iter @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if @iter is the first iter in the model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_last" c:identifier="dee_model_is_last">
        <doc xml:space="preserve">Whether @iter is the end iter of @self. Note that the end iter points
right &lt;emphasis&gt;after&lt;/emphasis&gt; the last valid row in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if @iter is the last iter in the model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="dee_model_next">
        <doc xml:space="preserve">Returns a #DeeModelIter that points to the next position in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter, pointing to the next row in
  the model. The iter is owned by @self, do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend"
              c:identifier="dee_model_prepend"
              introspectable="0">
        <doc xml:space="preserve">Creates and prepends a new row to the beginning of a #DeeModel, setting the
row values upon creation.

Example:

&lt;informalexample&gt;&lt;programlisting&gt;
 DeeModel *model;
 model = ...
 dee_model_set_schema (model, "i", "s", NULL);
 dee_model_prepend (model, 10, "Rooney");
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_row" c:identifier="dee_model_prepend_row">
        <doc xml:space="preserve">Like dee_model_prepend() but intended for language bindings or
situations where you work with models on a meta level and may not have
a priori knowledge of the column schemas of the models. See also
dee_model_build_row().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to prepend a row to</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
            <array c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="prev" c:identifier="dee_model_prev">
        <doc xml:space="preserve">Returns a #DeeModelIter that points to the previous position in the model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelIter, pointing to the previous
  row in the model. The iter is owned by @self, do not free it.</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_tag" c:identifier="dee_model_register_tag">
        <doc xml:space="preserve">Register a new tag on a #DeeModel. A &lt;emphasis&gt;tag&lt;/emphasis&gt; is an extra
value attached to a given row on a model. The tags are invisible to all
that doesn't have the tag handle returned by this method. #DeeModel
implementations must ensure that dee_model_get_tag() is an O(1) operation.

Tags can be very useful in associating some extra data to a row in a model
and have that automatically synced when the model changes. If you're
writing a tiled view for a model you might want to tag each row with the
tile widget for that row. That way you have very convenient access to the
tile widget given any row in the model.

The private nature of tags and the fact that you can store arbitrary pointers
and binary data in them also means that they are not serialized if you
utilize a model implementation that exposes the #DeeSerializable interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #DeeModelTag handle
              that you can use to set and get tags with</doc>
          <type name="ModelTag" c:type="DeeModelTag*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to register a tag on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="tag_destroy"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">Function called when a tagged row is removed from the model.
              This function will also be called on all tagged rows when the
              model is finalized.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_vardict_schema"
              c:identifier="dee_model_register_vardict_schema">
        <doc xml:space="preserve">Register schema for fields in a model containing column with variant
dictionary schema ('a{sv}').
The keys registered with this function can be later used
with dee_model_build_named_row() function, as well as
dee_model_get_value_by_name(). Note that it is possible to register
the same field name for multiple columns, in which case you need to use
fully-qualified "column_name::field" name in the calls to
dee_model_build_named_row() and dee_model_get_field_schema().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">the column index to register the schemas with</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="schemas" transfer-ownership="none">
            <doc xml:space="preserve">hashtable with keys specifying
          names of the fields and values defining their schema</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="dee_model_remove">
        <doc xml:space="preserve">Removes the row at the given position from the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the row to remove</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="dee_model_set" introspectable="0">
        <doc xml:space="preserve">Sets all values across the entire row referenced by @iter. The
variable argument list should contain values that match the column schemas
for the model. All basic variant type (see g_variant_type_is_basic()) are
passed in as their raw C type while all other types are passed in boxed in
a #GVariant. Any floating references on variants passed to this method are
consumed.

For example, to set the values for a row on model with the schema
("u", "s", "as"):
&lt;informalexample&gt;&lt;programlisting&gt;
  GVariantBuilder b;

  g_variant_builder_init (&amp;amp;b, "as");
  g_variant_builder_add (&amp;amp;b, "Hello");
  g_variant_builder_add (&amp;amp;b, "World");

  dee_model_set (model, iter, 27, "foo", g_variant_builder_end (&amp;amp;b));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_column_names"
              c:identifier="dee_model_set_column_names"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="first_column_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_column_names_full"
              c:identifier="dee_model_set_column_names_full">
        <doc xml:space="preserve">Set column names used by @self.
This method must be called exactly once, but only after setting
a schema of the model. Note that some constructors will do this for you.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModel.</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_names" transfer-ownership="none">
            <doc xml:space="preserve">A list of column names terminated by a %NULL</doc>
            <array length="1" zero-terminated="1" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="num_columns" transfer-ownership="none">
            <doc xml:space="preserve">an integer specifying the array length for @annotations</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_row" c:identifier="dee_model_set_row">
        <doc xml:space="preserve">Sets all columns in the row @iter points to, to those found in
@row_members. The variants in @row_members must match the types defined in
the model's schema.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="row_members" transfer-ownership="none">
            <doc xml:space="preserve">And array of
              #GVariant&lt;!-- --&gt;s with type signature matching
              those from the model schema. If any of the variants have
              floating references these will be consumed</doc>
            <array zero-terminated="0" c:type="GVariant**">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_schema"
              c:identifier="dee_model_set_schema"
              introspectable="0">
        <doc xml:space="preserve">Set the #GVariant types and the number of columns used by @self.
This method must be called exactly once before using @self. Note that
some constructors will do this for you.

To create a model with three columns; a 32 bit integer, a string,
and lastly an array of strings, you would do:
&lt;informalexample&gt;&lt;programlisting&gt;
 DeeModel *model;
 model = dee_sequence_model_new ();
 dee_model_set_schema (model, "i", "s", "as", NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to set the column layout for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_schema_full" c:identifier="dee_model_set_schema_full">
        <doc xml:space="preserve">Set the #GVariant types and the number of columns used by @self.
This method must be called exactly once before using @self. Note that
some constructors will do this for you.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to set the column layout for</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="column_schemas" transfer-ownership="none">
            <doc xml:space="preserve">A list of #GVariant type strings terminated by a %NULL</doc>
            <array length="1" zero-terminated="1" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="num_columns" transfer-ownership="none">
            <doc xml:space="preserve">an integer specifying the array length for @VarArgs</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tag" c:identifier="dee_model_set_tag">
        <doc xml:space="preserve">Set a tag on a row in a model. This function is guaranteed to be O(1).
See also dee_model_register_tag().

If @tag is already set on this row the existing tag value will be destroyed
with the #GDestroyNotify passed to the dee_model_register_tag().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to set a tag on</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The row to set the tag on</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">The tag handle for the tag as obtained from dee_model_register_tag()</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set for @tag. Note that %NULL represents an unset tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="dee_model_set_value">
        <doc xml:space="preserve">Sets the data in @column for the row @iter points to, to @value. The type
of @value must be convertible to the type of the column.

When this method call completes the model will emit ::row-changed. You can
edit the model in place without triggering the change signals by calling
dee_model_set_value_silently().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModel</doc>
            <type name="Model" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">column number to set the value</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">New value for cell. If @value is a floating reference the model
        will assume ownership of the variant</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="changeset-finished" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when a changeset that can contain
multiple row additions / changes / removals has been committed
to the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="changeset-started" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when a changeset that can contain
multiple row additions / changes / removals is about to be committed
to the model.
Note that not all model implementations use the changeset approach and
you might still get a row change signal outside of changeset-started and
changeset-finished signals. It also isn't guaranteed that a changeset
would always be non-empty.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="row-added" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when a row is added to @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the newly added row</doc>
            <type name="ModelIter"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="row-changed" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when a row is changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the changed row</doc>
            <type name="ModelIter"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="row-removed" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when a row is removed from @self.
  The row is still valid while the signal is being emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #DeeModelIter pointing to the removed row</doc>
            <type name="ModelIter"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ModelIface"
            c:type="DeeModelIface"
            glib:is-gtype-struct-for="Model">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="row_added">
        <callback name="row_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="row_removed">
        <callback name="row_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="row_changed">
        <callback name="row_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_schema_full">
        <callback name="set_schema_full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeModel to set the column layout for</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="column_schemas" transfer-ownership="none">
              <doc xml:space="preserve">A list of #GVariant type strings terminated by a %NULL</doc>
              <array length="2" zero-terminated="1" c:type="char**">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="num_columns" transfer-ownership="none">
              <doc xml:space="preserve">an integer specifying the array length for @VarArgs</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_schema">
        <callback name="get_schema">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
            <array length="1" zero-terminated="0" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="num_columns"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_column_schema">
        <callback name="get_column_schema">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #GVariant signature of the column at index @column</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to get retrieve the #GVariant type string of</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_field_schema">
        <callback name="get_field_schema">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #GVariant signature for the field, or %NULL if given field
              wasn't registered with dee_model_register_vardict_schema().</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="field_name" transfer-ownership="none">
              <doc xml:space="preserve">name of vardict field to get schema of</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="out_column"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">column index of the associated vardict</doc>
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_column_index">
        <callback name="get_column_index">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">0-based index of the column or -1 if column with this name
              wasn't found</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="column_name" transfer-ownership="none">
              <doc xml:space="preserve">the column name to retrieve the index of</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_column_names_full">
        <callback name="set_column_names_full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">A #DeeModel.</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="column_names" transfer-ownership="none">
              <doc xml:space="preserve">A list of column names terminated by a %NULL</doc>
              <array length="2" zero-terminated="1" c:type="gchar**">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="num_columns" transfer-ownership="none">
              <doc xml:space="preserve">an integer specifying the array length for @annotations</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_column_names">
        <callback name="get_column_names">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">
         A %NULL-terminated array of #GVariant type strings. The length of
         the returned array is written to @num_columns. The returned array
         should not be freed or modified. It is owned by the model.</doc>
            <array length="1" zero-terminated="0" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeModel to get the the schema for</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="num_columns"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <doc xml:space="preserve">Address of an integer in which to store the
              number of columns in @self. Or %NULL to ignore the array length.</doc>
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="register_vardict_schema">
        <callback name="register_vardict_schema">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="num_column" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="schemas" transfer-ownership="none">
              <doc xml:space="preserve">hashtable with keys specifying
          names of the fields and values defining their schema</doc>
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="utf8"/>
                <type name="utf8"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_vardict_schema">
        <callback name="get_vardict_schema">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">Hashtable
              containing a mapping from field names to schemas or NULL.
              Note that keys and values in the hashtable may be owned
              by the model, so you need to create a deep copy if you
              intend to keep the hashtable around.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="num_column" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_columns">
        <callback name="get_n_columns">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of columns per row in @self</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_n_rows">
        <callback name="get_n_rows">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of rows in @self</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_row">
        <callback name="append_row">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to prepend a row to</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">An array of  #GVariants with type
              signature matching those of the column schemas of @self.
              If any of the variants have floating references they will be
              consumed</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepend_row">
        <callback name="prepend_row">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to prepend a row to</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="insert_row">
        <callback name="insert_row">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">The index to insert the row on. The existing row will be pushed down.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">An array of
              #GVariants with type signature matching those of
              the column schemas of @self. If any of the variants have
              floating references they will be consumed.</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="insert_row_before">
        <callback name="insert_row_before">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iter pointing to the row before which to insert the new one</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="insert_row_sorted">
        <callback name="insert_row_sorted">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter pointing to the new row</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to do a sorted insert on</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. If any of the variants have floating
      references they will be consumed.</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
            <parameter name="cmp_func"
                       transfer-ownership="none"
                       scope="call"
                       closure="3">
              <doc xml:space="preserve">Callback used for comparison or rows</doc>
              <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_row_sorted">
        <callback name="find_row_sorted">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">If @out_was_found is set to
          %TRUE then a #DeeModelIter pointing to the last matching row.
          If it is %FALSE then the iter pointing to the row just after where
          @row_spec_would have been inserted.</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to search</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="row_spec" transfer-ownership="none">
              <doc xml:space="preserve">An array of
      #GVariants with type signature matching those of the
      column schemas of @self. No references will be taken on the variants.</doc>
              <array c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
            <parameter name="cmp_func"
                       transfer-ownership="none"
                       scope="call"
                       closure="3">
              <doc xml:space="preserve">Callback used for comparison or rows</doc>
              <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Arbitrary pointer passed to @cmp_func during search</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="out_was_found"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">A place to store a boolean value that will be set when
                this method returns. If %TRUE then an exact match was found.
                If %FALSE then the returned iter points to a row just after
                where @row_spec would have been inserted.
                Pass %NULL to ignore.</doc>
              <type name="gboolean" c:type="gboolean*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove">
        <callback name="remove">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter pointing to the row to remove</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear">
        <callback name="clear">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel object to clear</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_value">
        <callback name="set_value">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">column number to set the value</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">New value for cell. If @value is a floating reference the model
        will assume ownership of the variant</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_row">
        <callback name="set_row">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="row_members" transfer-ownership="none">
              <doc xml:space="preserve">And array of
              #GVariant&lt;!-- --&gt;s with type signature matching
              those from the model schema. If any of the variants have
              floating references these will be consumed</doc>
              <array zero-terminated="0" c:type="GVariant**">
                <type name="GLib.Variant" c:type="GVariant*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_value">
        <callback name="get_value">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeModel to inspect</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">column number to retrieve the value from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_value_by_name">
        <callback name="get_value_by_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A, guaranteed non-floating, reference to a
         #GVariant containing the row data. Free with g_variant_unref().</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeModel to inspect</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter pointing to the row to inspect</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_first_iter">
        <callback name="get_first_iter">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_last_iter">
        <callback name="get_last_iter">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter (owned by @self, do not
 free it)</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_iter_at_row">
        <callback name="get_iter_at_row">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A new #DeeModelIter, or %NULL if @row
  was out of bounds. The returned iter is owned by @self, so do not free it.</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="row" transfer-ownership="none">
              <doc xml:space="preserve">position of the row to retrieve</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_bool">
        <callback name="get_bool">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the boolean stored at @column.
              Otherwise %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a boolean from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uchar">
        <callback name="get_uchar">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the uchar stored at @column.
 Otherwise 0.</doc>
            <type name="guint8" c:type="guchar"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a uchar from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_int32">
        <callback name="get_int32">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the int stored at @column.
 Otherwise 0.</doc>
            <type name="gint32" c:type="gint32"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a int from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uint32">
        <callback name="get_uint32">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the uint stored at @column.
 Otherwise 0.</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a uint from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_int64">
        <callback name="get_int64">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the int64 stored at @column.
 Otherwise 0.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a int64 from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uint64">
        <callback name="get_uint64">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the uint64 stored at @column.
 Otherwise 0.</doc>
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a uint64 from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_double">
        <callback name="get_double">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the double stored at @column.
 Otherwise 0.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a double from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_string">
        <callback name="get_string">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">if @iter and @column are valid, the string stored at @column.
              Otherwise %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="column" transfer-ownership="none">
              <doc xml:space="preserve">the column to retrieve a string from</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next">
        <callback name="next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter, pointing to the next row in
  the model. The iter is owned by @self, do not free it.</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prev">
        <callback name="prev">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelIter, pointing to the previous
  row in the model. The iter is owned by @self, do not free it.</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_first">
        <callback name="is_first">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if @iter is the first iter in the model</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_last">
        <callback name="is_last">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if @iter is the last iter in the model</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModelIter</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_position">
        <callback name="get_position">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The integer offset of @iter in @self</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to inspect</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">The iter to get the position of</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="register_tag">
        <callback name="register_tag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #DeeModelTag handle
              that you can use to set and get tags with</doc>
            <type name="ModelTag" c:type="DeeModelTag*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to register a tag on</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="tag_destroy"
                       transfer-ownership="none"
                       scope="async">
              <doc xml:space="preserve">Function called when a tagged row is removed from the model.
              This function will also be called on all tagged rows when the
              model is finalized.</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_tag">
        <callback name="get_tag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Returns %NULL if @tag is unset otherwise the
              value of the tag as it was set with dee_model_set_tag().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to get a tag from</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #DeeModelIter pointing to the row to get the tag from</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:space="preserve">The tag handle to retrieve the tag value for</doc>
              <type name="ModelTag" c:type="DeeModelTag*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_tag">
        <callback name="set_tag">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The model to set a tag on</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">The row to set the tag on</doc>
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:space="preserve">The tag handle for the tag as obtained from dee_model_register_tag()</doc>
              <type name="ModelTag" c:type="DeeModelTag*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">The value to set for @tag. Note that %NULL represents an unset tag</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_row">
        <callback name="get_row">
          <return-value transfer-ownership="full">
            <type name="GLib.Variant" c:type="GVariant**"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <type name="ModelIter" c:type="DeeModelIter*"/>
            </parameter>
            <parameter name="out_row_members" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="begin_changeset">
        <callback name="begin_changeset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_changeset">
        <callback name="end_changeset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeeModel</doc>
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changeset_started">
        <callback name="changeset_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changeset_finished">
        <callback name="changeset_finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_model_1" introspectable="0">
        <callback name="_dee_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_model_2" introspectable="0">
        <callback name="_dee_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_model_3" introspectable="0">
        <callback name="_dee_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ModelIter"
            c:type="DeeModelIter"
            glib:type-name="DeeModelIter"
            glib:get-type="dee_model_iter_get_type"
            c:symbol-prefix="model_iter">
      <doc xml:space="preserve">The DeeModelIter structure is private and should only be used with the
provided #DeeModel API. It is owned by DeeModel and should not be freed.</doc>
    </record>
    <record name="ModelReader" c:type="DeeModelReader">
      <doc xml:space="preserve">Structure encapsulating the information needed to read strings from a
model. Used for example by #DeeIndex.</doc>
      <field name="reader_func" writable="1">
        <doc xml:space="preserve">The #DeeModelReaderFunc used to extract
                                string from a model</doc>
        <type name="ModelReaderFunc" c:type="DeeModelReaderFunc"/>
      </field>
      <field name="userdata" writable="1">
        <doc xml:space="preserve">user data to pass to @reader_func</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy" writable="1">
        <doc xml:space="preserve">Called when the reader is destroyed</doc>
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_padding1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_padding5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="destroy" c:identifier="dee_model_reader_destroy">
        <doc xml:space="preserve">Release resources associated with @reader, but does not free the
#DeeModelReader structure itself.

This will call the destroy() function registered with the reader
if it is set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">The reader to destroy</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="dee_model_reader_read">
        <doc xml:space="preserve">Read data from a row in a #DeeModel and extract a string representation from
it.

Note that generally a #DeeModelReader need not be confined to reading from
one specific column, although in practice most are.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelReader used to read @model</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel to read a string from</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The row to read a string from</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="dee_model_reader_new">
        <doc xml:space="preserve">Create a new #DeeModelReader with the given parameters. This call will zero
the @out_reader struct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reader_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">The #DeeModelReaderFunc to use for the reader</doc>
            <type name="ModelReaderFunc" c:type="DeeModelReaderFunc"/>
          </parameter>
          <parameter name="userdata"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The user data to pass to @reader_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">The #GDestroyNotify to call on
                                       @userdata when disposing of the reader</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="out_reader"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an uninitialized #DeeModelReader struct</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_int32_column"
                c:identifier="dee_model_reader_new_for_int32_column">
        <doc xml:space="preserve">A #DeeModelReader reading a %gint32 from a #DeeModel at a given column</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The column index to read a %gint32 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_reader"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_string_column"
                c:identifier="dee_model_reader_new_for_string_column">
        <doc xml:space="preserve">A #DeeModelReader reading a string from a #DeeModel at a given column</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The column index to read a string from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_reader"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_uint32_column"
                c:identifier="dee_model_reader_new_for_uint32_column">
        <doc xml:space="preserve">A #DeeModelReader reading a %guint32 from a #DeeModel at a given column</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve">The column index to read a %guint32 from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_reader"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="ModelReaderFunc" c:type="DeeModelReaderFunc">
      <doc xml:space="preserve">Extracts a string from a row in a model.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly allocated string with the row data to be indexed.
         Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="model" transfer-ownership="none">
          <doc xml:space="preserve">The model being indexed</doc>
          <type name="Model" c:type="DeeModel*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">The row to extract terms for</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">The data set when registering the reader</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ModelTag" c:type="DeeModelTag" disguised="1">
      <doc xml:space="preserve">The DeeModelTag structure is private and should only be used with the
provided #DeeModel API. It is owned by DeeModel and should not be freed.</doc>
    </record>
    <constant name="PEER_DBUS_IFACE"
              value="com.canonical.Dee.Peer"
              c:type="DEE_PEER_DBUS_IFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Peer"
           c:symbol-prefix="peer"
           c:type="DeePeer"
           parent="GObject.Object"
           glib:type-name="DeePeer"
           glib:get-type="dee_peer_get_type"
           glib:type-struct="PeerClass">
      <doc xml:space="preserve">All fields in the DeePeer structure are private and should never be
accessed directly</doc>
      <constructor name="new" c:identifier="dee_peer_new">
        <doc xml:space="preserve">Create a new #DeePeer. The peer will immediately connect to the swarm
and start the peer discovery.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #DeePeer.
              Free with g_object_unref().</doc>
          <type name="Peer" c:type="DeePeer*"/>
        </return-value>
        <parameters>
          <parameter name="swarm_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the swarm to join.
             Fx &amp;quot;org.example.DataProviders&amp;quot;</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="connection_acquired">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connection_closed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_connections" invoker="get_connections">
        <doc xml:space="preserve">Gets list of #GDBusConnection instances used by this #DeePeer instance.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
              List of connections.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Gio.DBusConnection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_swarm_leader" invoker="get_swarm_leader">
        <doc xml:space="preserve">In case this peer is connected to a message bus, gets the unique DBus
address of the current swarm leader, otherwise returns id of the leader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Unique DBus address of the current swarm leader,
   possibly %NULL if the leader has not been detected yet</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_swarm_leader" invoker="is_swarm_leader">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if this peer owns the swarm name on
              the session bus</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_peers" invoker="list_peers">
        <doc xml:space="preserve">Gets list of all peers currently in this swarm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">List of peers (free using g_strfreev()).</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="peer_found">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="peer_lost">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connections" c:identifier="dee_peer_get_connections">
        <doc xml:space="preserve">Gets list of #GDBusConnection instances used by this #DeePeer instance.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
              List of connections.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Gio.DBusConnection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_swarm_leader" c:identifier="dee_peer_get_swarm_leader">
        <doc xml:space="preserve">In case this peer is connected to a message bus, gets the unique DBus
address of the current swarm leader, otherwise returns id of the leader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Unique DBus address of the current swarm leader,
   possibly %NULL if the leader has not been detected yet</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_swarm_name" c:identifier="dee_peer_get_swarm_name">
        <doc xml:space="preserve">Gets the unique name for this swarm. The swarm leader is the Peer owning
this name on the session bus.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The swarm name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_swarm_leader" c:identifier="dee_peer_is_swarm_leader">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if this peer owns the swarm name on
              the session bus</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_swarm_owner" c:identifier="dee_peer_is_swarm_owner">
        <doc xml:space="preserve">Gets the value of the :swarm-owner property.

Note that this does NOT mean that the peer is leader of the swarm! Check also
dee_peer_is_swarm_leader().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the :swarm-owner property was set during construction.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_peers" c:identifier="dee_peer_list_peers">
        <doc xml:space="preserve">Gets list of all peers currently in this swarm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">List of peers (free using g_strfreev()).</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #DeePeer</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="swarm-leader" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="swarm-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="swarm-owner"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PeerPrivate" c:type="DeePeerPrivate*"/>
      </field>
      <glib:signal name="connection-acquired" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Gio.DBusConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-closed" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when peers close
their #GDBusConnection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the closed #GDBusConnection</doc>
            <type name="Gio.DBusConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="peer-found" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified of existing and new peers that are
  in your swarm.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the DBus name of the object found</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="peer-lost" when="last">
        <doc xml:space="preserve">Connect to this signal to be notified when peers disconnect from the swarm</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the DBus name of the object that disconnected</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="PeerClass"
            c:type="DeePeerClass"
            glib:is-gtype-struct-for="Peer">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="peer_found">
        <callback name="peer_found">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="peer_lost">
        <callback name="peer_lost">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_acquired">
        <callback name="connection_acquired">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_closed">
        <callback name="connection_closed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_swarm_leader">
        <callback name="get_swarm_leader">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Unique DBus address of the current swarm leader,
   possibly %NULL if the leader has not been detected yet</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeePeer</doc>
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_swarm_leader">
        <callback name="is_swarm_leader">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if and only if this peer owns the swarm name on
              the session bus</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeePeer</doc>
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_connections">
        <callback name="get_connections">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">
              List of connections.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Gio.DBusConnection"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeePeer</doc>
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_peers">
        <callback name="list_peers">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">List of peers (free using g_strfreev()).</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #DeePeer</doc>
              <type name="Peer" c:type="DeePeer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_peer_1" introspectable="0">
        <callback name="_dee_peer_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_peer_2" introspectable="0">
        <callback name="_dee_peer_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_peer_3" introspectable="0">
        <callback name="_dee_peer_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="PeerPrivate" c:type="DeePeerPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <class name="ProxyModel"
           c:symbol-prefix="proxy_model"
           c:type="DeeProxyModel"
           parent="SerializableModel"
           glib:type-name="DeeProxyModel"
           glib:get-type="dee_proxy_model_get_type"
           glib:type-struct="ProxyModelClass">
      <doc xml:space="preserve">All fields in the DeeProxyModel structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <property name="back-end"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The backend model used by this proxy model.</doc>
        <type name="Model"/>
      </property>
      <property name="inherit-seqnums"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Boolean property defining whether sequence numbers will be inherited
from the back end model.
You will most likely want to set this property to false
if the implementation manipulates with the rows in the model and keep
track of seqnums yourself.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="proxy-signals"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Boolean property defining whether or not to automatically forward signals
from the back end model. This is especially useful for sub classes wishing
to do their own more advanced signal forwarding.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="SerializableModel" c:type="DeeSerializableModel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyModelPrivate" c:type="DeeProxyModelPrivate*"/>
      </field>
    </class>
    <record name="ProxyModelClass"
            c:type="DeeProxyModelClass"
            glib:is-gtype-struct-for="ProxyModel">
      <field name="parent_class" readable="0" private="1">
        <type name="SerializableModelClass"
              c:type="DeeSerializableModelClass"/>
      </field>
      <field name="_dee_proxy_model_1" introspectable="0">
        <callback name="_dee_proxy_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_proxy_model_2" introspectable="0">
        <callback name="_dee_proxy_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_proxy_model_3" introspectable="0">
        <callback name="_dee_proxy_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_proxy_model_4" introspectable="0">
        <callback name="_dee_proxy_model_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ProxyModelPrivate"
            c:type="DeeProxyModelPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <interface name="ResourceManager"
               c:symbol-prefix="resource_manager"
               c:type="DeeResourceManager"
               glib:type-name="DeeResourceManager"
               glib:get-type="dee_resource_manager_get_type"
               glib:type-struct="ResourceManagerIface">
      <function name="get_default"
                c:identifier="dee_resource_manager_get_default">
        <doc xml:space="preserve">Get a pointer to the platform default #DeeResourceManager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The default resource manager for the platform.
              Do not unreference. If you need to keep the instance around
              you must manually reference it.</doc>
          <type name="ResourceManager" c:type="DeeResourceManager*"/>
        </return-value>
      </function>
      <virtual-method name="load" invoker="load" throws="1">
        <doc xml:space="preserve">Load a resource from persistent storage. The loaded resource will be of the
same GType as when it was stored (provided that the same serialization and
parse functions are registered).

In case of an error the error will be in the #GFileError domain. Specifically
if there is no resource with the name @resource_name the error code will
be #G_FILE_ERROR_NOENT.

Important note: This call may do blocking IO. The resource manager must
guarantee that this call is reasonably fast, like writing the externalized
resource to a file, but not blocking IO over a network socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #GObject in case of success
              and %NULL otherwise. In case of a runtime error the @error
              pointer will be set.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to invoke</doc>
            <type name="ResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
          <parameter name="resource_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the resource to retrieve</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store" invoker="store" throws="1">
        <doc xml:space="preserve">Store a resource under a given name. The resource manager must guarantee
that the stored data survives system reboots and that you can recreate a
copy of @resource by calling dee_resource_manager_load() using the
same @resource_name.

Important note: This call may do blocking IO. The resource manager must
guarantee that this call is reasonably fast, like writing the externalized
resource to a file, but not blocking IO over a network socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success and %FALSE otherwise. In case of a runtime
              error the @error pointer will point to a #GError in the
              #DeeResourceError domain.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to invoke</doc>
            <type name="ResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSerializable to store under @resource_name</doc>
            <type name="Serializable" c:type="DeeSerializable*"/>
          </parameter>
          <parameter name="resource_name" transfer-ownership="none">
            <doc xml:space="preserve">The name to store the resource under. Will overwrite any
                existing resource with the same name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="load" c:identifier="dee_resource_manager_load" throws="1">
        <doc xml:space="preserve">Load a resource from persistent storage. The loaded resource will be of the
same GType as when it was stored (provided that the same serialization and
parse functions are registered).

In case of an error the error will be in the #GFileError domain. Specifically
if there is no resource with the name @resource_name the error code will
be #G_FILE_ERROR_NOENT.

Important note: This call may do blocking IO. The resource manager must
guarantee that this call is reasonably fast, like writing the externalized
resource to a file, but not blocking IO over a network socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #GObject in case of success
              and %NULL otherwise. In case of a runtime error the @error
              pointer will be set.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to invoke</doc>
            <type name="ResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
          <parameter name="resource_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the resource to retrieve</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="store"
              c:identifier="dee_resource_manager_store"
              throws="1">
        <doc xml:space="preserve">Store a resource under a given name. The resource manager must guarantee
that the stored data survives system reboots and that you can recreate a
copy of @resource by calling dee_resource_manager_load() using the
same @resource_name.

Important note: This call may do blocking IO. The resource manager must
guarantee that this call is reasonably fast, like writing the externalized
resource to a file, but not blocking IO over a network socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success and %FALSE otherwise. In case of a runtime
              error the @error pointer will point to a #GError in the
              #DeeResourceError domain.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The resource manager to invoke</doc>
            <type name="ResourceManager" c:type="DeeResourceManager*"/>
          </instance-parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSerializable to store under @resource_name</doc>
            <type name="Serializable" c:type="DeeSerializable*"/>
          </parameter>
          <parameter name="resource_name" transfer-ownership="none">
            <doc xml:space="preserve">The name to store the resource under. Will overwrite any
                existing resource with the same name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ResourceManagerIface"
            c:type="DeeResourceManagerIface"
            glib:is-gtype-struct-for="ResourceManager">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="store">
        <callback name="store" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success and %FALSE otherwise. In case of a runtime
              error the @error pointer will point to a #GError in the
              #DeeResourceError domain.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The resource manager to invoke</doc>
              <type name="ResourceManager" c:type="DeeResourceManager*"/>
            </parameter>
            <parameter name="resource" transfer-ownership="none">
              <doc xml:space="preserve">A #DeeSerializable to store under @resource_name</doc>
              <type name="Serializable" c:type="DeeSerializable*"/>
            </parameter>
            <parameter name="resource_name" transfer-ownership="none">
              <doc xml:space="preserve">The name to store the resource under. Will overwrite any
                existing resource with the same name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load">
        <callback name="load" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A newly allocated #GObject in case of success
              and %NULL otherwise. In case of a runtime error the @error
              pointer will be set.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The resource manager to invoke</doc>
              <type name="ResourceManager" c:type="DeeResourceManager*"/>
            </parameter>
            <parameter name="resource_name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the resource to retrieve</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_resource_manager_1" introspectable="0">
        <callback name="_dee_resource_manager_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_2" introspectable="0">
        <callback name="_dee_resource_manager_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_3" introspectable="0">
        <callback name="_dee_resource_manager_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_4" introspectable="0">
        <callback name="_dee_resource_manager_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_5" introspectable="0">
        <callback name="_dee_resource_manager_5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_6" introspectable="0">
        <callback name="_dee_resource_manager_6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_7" introspectable="0">
        <callback name="_dee_resource_manager_7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_resource_manager_8" introspectable="0">
        <callback name="_dee_resource_manager_8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <interface name="ResultSet"
               c:symbol-prefix="result_set"
               c:type="DeeResultSet"
               glib:type-name="DeeResultSet"
               glib:get-type="dee_result_set_get_type"
               glib:type-struct="ResultSetIface">
      <virtual-method name="get_model" invoker="get_model">
        <doc xml:space="preserve">Get the model associated with a result set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The model that the rows point into</doc>
          <type name="Model" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get the mode for</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_n_rows" invoker="get_n_rows">
        <doc xml:space="preserve">Get the number of #DeeModelIter&lt;!-- --&gt;s held in a #DeeResultSet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows held in the result set</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get the size of</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_next" invoker="has_next">
        <doc xml:space="preserve">Check if a call to dee_result_set_next() will succeed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if more rows can be retrieved by calling
         dee_result_set_next()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to check</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next" invoker="next">
        <doc xml:space="preserve">Get the current row from the result set and advance the cursor.
To ensure that calls to this method will succeed you can call
dee_result_set_has_next().

To retrieve the current row without advancing the cursor call
dee_result_set_peek() in stead of this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="peek" invoker="peek">
        <doc xml:space="preserve">Get the row at the current cursor position.

To retrieve the current row and advance the cursor position call
dee_result_set_next() in stead of this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" invoker="seek">
        <doc xml:space="preserve">Set the cursor position. Following calls to dee_result_set_peek()
or dee_result_set_next() will read the row at position @pos.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to seek in</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to seek to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell" invoker="tell">
        <doc xml:space="preserve">Get the current position of the cursor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current position of the cursor</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to check the cursor position for</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_model" c:identifier="dee_result_set_get_model">
        <doc xml:space="preserve">Get the model associated with a result set</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The model that the rows point into</doc>
          <type name="Model" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get the mode for</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_rows" c:identifier="dee_result_set_get_n_rows">
        <doc xml:space="preserve">Get the number of #DeeModelIter&lt;!-- --&gt;s held in a #DeeResultSet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of rows held in the result set</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get the size of</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_next" c:identifier="dee_result_set_has_next">
        <doc xml:space="preserve">Check if a call to dee_result_set_next() will succeed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if more rows can be retrieved by calling
         dee_result_set_next()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to check</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="dee_result_set_next">
        <doc xml:space="preserve">Get the current row from the result set and advance the cursor.
To ensure that calls to this method will succeed you can call
dee_result_set_has_next().

To retrieve the current row without advancing the cursor call
dee_result_set_peek() in stead of this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="dee_result_set_peek">
        <doc xml:space="preserve">Get the row at the current cursor position.

To retrieve the current row and advance the cursor position call
dee_result_set_next() in stead of this method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
          <type name="ModelIter" c:type="DeeModelIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="dee_result_set_seek">
        <doc xml:space="preserve">Set the cursor position. Following calls to dee_result_set_peek()
or dee_result_set_next() will read the row at position @pos.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to seek in</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to seek to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="dee_result_set_tell">
        <doc xml:space="preserve">Get the current position of the cursor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current position of the cursor</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeResultSet to check the cursor position for</doc>
            <type name="ResultSet" c:type="DeeResultSet*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="ResultSetIface"
            c:type="DeeResultSetIface"
            glib:is-gtype-struct-for="ResultSet">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_n_rows">
        <callback name="get_n_rows">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of rows held in the result set</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to get the size of</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next">
        <callback name="next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_next">
        <callback name="has_next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if and only if more rows can be retrieved by calling
         dee_result_set_next()</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to check</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="peek">
        <callback name="peek">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelIter at the current cursor position</doc>
            <type name="ModelIter" c:type="DeeModelIter*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to get a row from</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to seek in</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">The position to seek to</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The current position of the cursor</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to check the cursor position for</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_model">
        <callback name="get_model">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The model that the rows point into</doc>
            <type name="Model" c:type="DeeModel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The #DeeResultSet to get the mode for</doc>
              <type name="ResultSet" c:type="DeeResultSet*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_result_set_1" introspectable="0">
        <callback name="_dee_result_set_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_result_set_2" introspectable="0">
        <callback name="_dee_result_set_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_result_set_3" introspectable="0">
        <callback name="_dee_result_set_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_result_set_4" introspectable="0">
        <callback name="_dee_result_set_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_result_set_5" introspectable="0">
        <callback name="_dee_result_set_5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="SEQUENCE_MODEL_DBUS_IFACE"
              value="com.canonical.Dee.Model"
              c:type="DEE_SEQUENCE_MODEL_DBUS_IFACE">
      <doc xml:space="preserve">String constant defining the name of the DBus Model interface.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SHARED_MODEL_DBUS_IFACE"
              value="com.canonical.Dee.Model"
              c:type="DEE_SHARED_MODEL_DBUS_IFACE">
      <doc xml:space="preserve">String constant defining the name of the DBus Model interface.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="SequenceModel"
           c:symbol-prefix="sequence_model"
           c:type="DeeSequenceModel"
           parent="SerializableModel"
           glib:type-name="DeeSequenceModel"
           glib:get-type="dee_sequence_model_get_type"
           glib:type-struct="SequenceModelClass">
      <doc xml:space="preserve">All fields in the DeeSequenceModel structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <constructor name="new" c:identifier="dee_sequence_model_new">
        <doc xml:space="preserve">Create a new #DeeSequenceModel. Before using it you must normally set a
schema on it by calling dee_model_set_schema().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created
              #DeeSequenceModel. Free with g_object_unref().</doc>
          <type name="SequenceModel" c:type="DeeModel*"/>
        </return-value>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="SerializableModel" c:type="DeeSerializableModel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SequenceModelPrivate" c:type="DeeSequenceModelPrivate*"/>
      </field>
    </class>
    <record name="SequenceModelClass"
            c:type="DeeSequenceModelClass"
            glib:is-gtype-struct-for="SequenceModel">
      <field name="parent_class" readable="0" private="1">
        <type name="SerializableModelClass"
              c:type="DeeSerializableModelClass"/>
      </field>
      <field name="_dee_sequence_model_1" introspectable="0">
        <callback name="_dee_sequence_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_sequence_model_2" introspectable="0">
        <callback name="_dee_sequence_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_sequence_model_3" introspectable="0">
        <callback name="_dee_sequence_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_sequence_model_4" introspectable="0">
        <callback name="_dee_sequence_model_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SequenceModelPrivate"
            c:type="DeeSequenceModelPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <interface name="Serializable"
               c:symbol-prefix="serializable"
               c:type="DeeSerializable"
               glib:type-name="DeeSerializable"
               glib:get-type="dee_serializable_get_type"
               glib:type-struct="SerializableIface">
      <function name="parse" c:identifier="dee_serializable_parse">
        <doc xml:space="preserve">Reconstruct a #DeeSerializable from #GVariant data. For this function
to work you need to register a parser with
dee_serializable_register_parser(). Any native Dee class will do so
automatically.

This method only works on data created with dee_serializable_serialize()
and &lt;emphasis&gt;not&lt;/emphasis&gt; with data from dee_serializable_externalize().

Since a #DeeSerializableParseFunc is not allowed to fail - by contract -
it can be guaranteed that this function only returns %NULL in case there
is no known parser for @type and #GVariant signature of @data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #GObject build from @data
              or %NULL in case no parser has been registered for the given
              #GType or variant signature. Free with g_object_unref().</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The #GVariant data to parse. If this is a floating reference it will
       be consumed</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the class to instantiate from @data</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_external"
                c:identifier="dee_serializable_parse_external">
        <doc xml:space="preserve">Reconstruct a #DeeSerializable from #GVariant data. For this function
to work you need to register a parser with
dee_serializable_register_parser(). Any native Dee class will do so
automatically.

This method only works on data created with dee_serializable_externalize()
and &lt;emphasis&gt;not&lt;/emphasis&gt; with data from  dee_serializable_serialize().

Since a #DeeSerializableParseFunc is not allowed to fail - by contract -
it can be guaranteed that this function only returns %NULL in case there
is no known parser for the #GType or #GVariant signature of @data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #GObject build from @data
              or %NULL in case no parser has been registered for the given
              #GType or variant signature. Free with g_object_unref().</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The #GVariant data to parse</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_parser"
                c:identifier="dee_serializable_register_parser"
                introspectable="0">
        <doc xml:space="preserve">Register a parser that can convert #GVariant data into an instance of
a given #GType. Note that you can register more than one parser for the
same #GType provided that you give them different variant type signatures.

If there is already a parser registered for the given @type and @vtype
it will be silently replaced.

The recommended behaviour is that #GObject classes register their parsers in
their respective class init functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the object class to register a parser for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="vtype" transfer-ownership="none">
            <doc xml:space="preserve">Variants to be converted must have this signature</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="parse_func" transfer-ownership="none">
            <doc xml:space="preserve">A function to convert #GVariant data into an instance of the
             given @type.</doc>
            <type name="SerializableParseFunc"
                  c:type="DeeSerializableParseFunc"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="serialize" invoker="serialize">
        <doc xml:space="preserve">Build a clean serialized representation of @self. The signature of the
returned variant is entirely determined by the underlying implementation.
You can recreate a serialized instance by calling dee_serializable_parse()
provided that you know the correct #GType for the serialized instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A reference to a #GVariant with
              the serialized data. The variants type signature is entirely
              dependent of the underlying implementation. Free using
              g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The instance to serialize</doc>
            <type name="Serializable" c:type="DeeSerializable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="externalize" c:identifier="dee_serializable_externalize">
        <doc xml:space="preserve">Build an externalized form of @self which can be used together with
dee_serializable_parse_external() to rebuild a copy of @self.

It is important to note that the variant returned from this method does
not have the same type signature as returned from a call to
dee_serializable_serialize(). Externalization will wrap the serialized data
in a container format with versioning information and headers with type
information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A floating reference to a #GVariant with the externalized data.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The instance to externalize</doc>
            <type name="Serializable" c:type="DeeSerializable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="dee_serializable_serialize">
        <doc xml:space="preserve">Build a clean serialized representation of @self. The signature of the
returned variant is entirely determined by the underlying implementation.
You can recreate a serialized instance by calling dee_serializable_parse()
provided that you know the correct #GType for the serialized instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A reference to a #GVariant with
              the serialized data. The variants type signature is entirely
              dependent of the underlying implementation. Free using
              g_variant_unref().</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The instance to serialize</doc>
            <type name="Serializable" c:type="DeeSerializable*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="SerializableIface"
            c:type="DeeSerializableIface"
            glib:is-gtype-struct-for="Serializable">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="serialize">
        <callback name="serialize">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A reference to a #GVariant with
              the serialized data. The variants type signature is entirely
              dependent of the underlying implementation. Free using
              g_variant_unref().</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The instance to serialize</doc>
              <type name="Serializable" c:type="DeeSerializable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_serializable_1" introspectable="0">
        <callback name="_dee_serializable_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_2" introspectable="0">
        <callback name="_dee_serializable_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_3" introspectable="0">
        <callback name="_dee_serializable_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_4" introspectable="0">
        <callback name="_dee_serializable_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_5" introspectable="0">
        <callback name="_dee_serializable_5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="SerializableModel"
           c:symbol-prefix="serializable_model"
           c:type="DeeSerializableModel"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="DeeSerializableModel"
           glib:get-type="dee_serializable_model_get_type"
           glib:type-struct="SerializableModelClass">
      <doc xml:space="preserve">All fields in the DeeSerializableModel structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <method name="get_seqnum"
              c:identifier="dee_serializable_model_get_seqnum">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Sequence number of this #DeeSerializableModel.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSerializableModel instance</doc>
            <type name="SerializableModel" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="inc_seqnum"
              c:identifier="dee_serializable_model_inc_seqnum">
        <doc xml:space="preserve">Increments sequence number of this #DeeSerializableModel.</doc>
        <return-value transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSerializableModel instance</doc>
            <type name="SerializableModel" c:type="DeeModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_seqnum"
              c:identifier="dee_serializable_model_set_seqnum">
        <doc xml:space="preserve">Sets sequence number of this #DeeSerializableModel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSerializableModel instance</doc>
            <type name="SerializableModel" c:type="DeeModel*"/>
          </instance-parameter>
          <parameter name="seqnum" transfer-ownership="none">
            <doc xml:space="preserve">Sequence number</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SerializableModelPrivate"
              c:type="DeeSerializableModelPrivate*"/>
      </field>
    </class>
    <record name="SerializableModelClass"
            c:type="DeeSerializableModelClass"
            glib:is-gtype-struct-for="SerializableModel">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_seqnum">
        <callback name="get_seqnum">
          <return-value transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_seqnum">
        <callback name="set_seqnum">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
            <parameter name="seqnum" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="inc_seqnum">
        <callback name="inc_seqnum">
          <return-value transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Model" c:type="DeeModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_serializable_model_1" introspectable="0">
        <callback name="_dee_serializable_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_model_2" introspectable="0">
        <callback name="_dee_serializable_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_model_3" introspectable="0">
        <callback name="_dee_serializable_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_serializable_model_4" introspectable="0">
        <callback name="_dee_serializable_model_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SerializableModelPrivate"
            c:type="DeeSerializableModelPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <callback name="SerializableParseFunc" c:type="DeeSerializableParseFunc">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly constructed #GObject of the #GType
              used when registering the parser. Note that since
              the environment guarantees that the input data is valid
              according to the registration information this function
              can not fail. Thus %NULL is not a valid return value.</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant with type signature as passed to
       dee_serializable_register_parser() when the parser was registered.
       The variant is not referenced.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Server"
           c:symbol-prefix="server"
           c:type="DeeServer"
           parent="Peer"
           glib:type-name="DeeServer"
           glib:get-type="dee_server_get_type"
           glib:type-struct="ServerClass">
      <constructor name="new" c:identifier="dee_server_new">
        <doc xml:space="preserve">Creates a new instance of #DeeServer and tries to bind
to #DeeServer:bus-address. The #DeePeer:swarm-leader property will be set
when the binding succeeds.

&lt;note&gt;
  &lt;para&gt;
    Note that this function will automatically determine the value
    of #DeeServer:bus-address property and will generally cause your
    application to use new socket for every #DeeServer with different swarm
    name. See dee_server_new_for_address() if you'd like to share one
    connection between multiple #DeeServer instances.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #DeeServer.</doc>
          <type name="Server" c:type="DeeServer*"/>
        </return-value>
        <parameters>
          <parameter name="swarm_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of swarm to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address"
                   c:identifier="dee_server_new_for_address">
        <doc xml:space="preserve">Creates a new instance of #DeeServer and tries to bind to @bus_address.
The #DeePeer:swarm-leader property will be set when the binding succeeds.

If there is already a #DeeServer instance bound to @bus_address,
the connection will be shared with the newly constructed instance.

&lt;note&gt;
  &lt;para&gt;
    This function is primarily meant for sharing of one connection (socket)
    between multiple DeeServers, so that you can create #DeeServer instances
    with varying swarm names, but the same bus address, which will cause
    them to share the connection (the sharing is possible only within
    the same process though).
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly constructed #DeeServer.</doc>
          <type name="Server" c:type="DeeServer*"/>
        </return-value>
        <parameters>
          <parameter name="swarm_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of swarm to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="bus_address" transfer-ownership="none">
            <doc xml:space="preserve">D-Bus address to use for the connection.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bus_address_for_name"
                c:identifier="dee_server_bus_address_for_name">
        <doc xml:space="preserve">Helper method which creates bus address string for the given name, which
should have the same format as a DBus unique name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Newly allocated string with bus address.
                               Use g_free() to free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A name to create bus address for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="include_username" transfer-ownership="none">
            <doc xml:space="preserve">Include current user name as part of the bus address.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_client_address"
              c:identifier="dee_server_get_client_address">
        <doc xml:space="preserve">Gets a D-Bus address string that can be used by clients to connect to server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A D-Bus address string. Do not free.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeServer.</doc>
            <type name="Server" c:type="DeeServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bus-address"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="same-user-only"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Peer" c:type="DeePeer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ServerPrivate" c:type="DeeServerPrivate*"/>
      </field>
    </class>
    <record name="ServerClass"
            c:type="DeeServerClass"
            glib:is-gtype-struct-for="Server">
      <field name="parent_class" readable="0" private="1">
        <type name="PeerClass" c:type="DeePeerClass"/>
      </field>
    </record>
    <record name="ServerPrivate" c:type="DeeServerPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <class name="SharedModel"
           c:symbol-prefix="shared_model"
           c:type="DeeSharedModel"
           parent="ProxyModel"
           glib:type-name="DeeSharedModel"
           glib:get-type="dee_shared_model_get_type"
           glib:type-struct="SharedModelClass">
      <doc xml:space="preserve">All fields in the DeeSharedModel structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <constructor name="new" c:identifier="dee_shared_model_new">
        <doc xml:space="preserve">Create a new empty shared model without any column schema associated.
The column schema will be set in one of two ways: firstly you may set it
manually with dee_model_set_schema() or secondly it will be set once
the first rows are exchanged with a peer model.

A #DeeSharedModel with a schema manually set has to be created before
creating more #DeeSharedModel with the same @name.

A shared model created with this constructor will store row data in a
suitably picked memory backed model.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #DeeSharedModel</doc>
          <type name="SharedModel" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A well known name to publish this model under. Models sharing this name
       will synchronize with each other</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_peer"
                   c:identifier="dee_shared_model_new_for_peer">
        <doc xml:space="preserve">Create a new empty shared model without any column schema associated.
The column schema will be set in one of two ways: firstly you may set it
manually with dee_model_set_schema() or secondly it will be set once
the first rows are exchanged with a peer model.

A #DeeSharedModel with a schema manually set has to be created before
creating more #DeeSharedModel with the same @name.

A shared model created with this constructor will store row data in a
suitably picked memory backed model.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #DeeSharedModel</doc>
          <type name="SharedModel" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="full">
            <doc xml:space="preserve">A #DeePeer instance.</doc>
            <type name="Peer" c:type="DeePeer*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_back_end"
                   c:identifier="dee_shared_model_new_with_back_end">
        <doc xml:space="preserve">Create a new shared model storing all data in @back_end.

The model will start synchronizing with peer models as soon as possible and
the #DeeSharedModel:synchronized property will be set once finished.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #DeeSharedModel</doc>
          <type name="SharedModel" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">A well known name to publish this model under.
       Models sharing this name will synchronize with each other</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="back_end" transfer-ownership="full">
            <doc xml:space="preserve">The #DeeModel that will actually store
           the model data. Ownership of the ref to @back_end is transfered to
           the shared model.</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="flush_revision_queue"
              c:identifier="dee_shared_model_flush_revision_queue">
        <doc xml:space="preserve">Expert: All changes to @self that has not yet been propagated to the peer
models are send. If you also want to block the mainloop until
all the underlying transport streams have been flushed use
dee_shared_model_flush_revision_queue_sync().

Normally #DeeSharedModel collects changes to @self into batches and sends
them automatically to all peers. You can use this call to provide fine
grained control of exactly when changes to @self are synchronized to its
peers. This may for example be useful to improve the interactivity of your
application if you have a model-process which intermix small and light
changes with big and expensive changes. Using this call you can make sure
the model-process dispatches small changes more aggresively to the
view-process, while holding on to the expensive changes a bit longer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of revisions flushed.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The shared model to flush the revision queue on</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush_revision_queue_sync"
              c:identifier="dee_shared_model_flush_revision_queue_sync">
        <doc xml:space="preserve">Similar to dee_shared_model_flush_revision_queue(), but also blocks
the mainloop until all the underlying transport streams have been flushed.

&lt;emphasis&gt;Important&lt;/emphasis&gt;: This method &lt;emphasis&gt;may&lt;/emphasis&gt; flush
your internal queue of DBus messages forcing them to be send before this call
returns.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of revisions flushed.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The shared model to flush the revision queue on</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flush_mode"
              c:identifier="dee_shared_model_get_flush_mode">
        <doc xml:space="preserve">Convenience function for accessing the #DeeSharedModel:flush-mode property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeeSharedModelFlushMode used by the model</doc>
          <type name="SharedModelFlushMode" c:type="DeeSharedModelFlushMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSharedModel</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer" c:identifier="dee_shared_model_get_peer">
        <doc xml:space="preserve">Convenience function for accessing the #DeeSharedModel:peer property</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #DeePeer used to interact with the peer models</doc>
          <type name="Peer" c:type="DeePeer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to get the #DeePeer for</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_swarm_name"
              c:identifier="dee_shared_model_get_swarm_name">
        <doc xml:space="preserve">Convenience function for accessing the #DeePeer:swarm-name property of the
#DeePeer defined in the #DeeSharedModel:peer property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the swarm this model synchrnonizes with</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to get the name for</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_leader" c:identifier="dee_shared_model_is_leader">
        <doc xml:space="preserve">Check if the model is the swarm leader. This is a convenience function for
accessing the #DeeSharedModel:peer property and checking if it's the swarm
leader.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of dee_peer_is_swarm_leader() for the #DeePeer used by
         this shared model</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to inspect</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_synchronized"
              c:identifier="dee_shared_model_is_synchronized">
        <doc xml:space="preserve">Check if the model is synchronized with its peers. Before modifying a
shared model in any way (except dee_model_set_schema()) you should wait for
it to become synchronized. This is normally done by waiting for the
&amp;quot;notify::synchronized&amp;quot; signal.

This method is purely a convenience function for accessing the
#DeeSharedModel:synchronized property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the :synchronized property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The model to inspect</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_flush_mode"
              c:identifier="dee_shared_model_set_flush_mode">
        <doc xml:space="preserve">Convenience function for setting the #DeeSharedModel:flush-mode property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #DeeSharedModel</doc>
            <type name="SharedModel" c:type="DeeSharedModel*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">Flush mode to use</doc>
            <type name="SharedModelFlushMode"
                  c:type="DeeSharedModelFlushMode"/>
          </parameter>
        </parameters>
      </method>
      <property name="access-mode"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Enumeration defining behavior of this model when trying to write to it.

Setting this to #DEE_SHARED_MODEL_ACCESS_MODE_LEADER_WRITABLE is useful
when one process is considered an "owner" of a model and all the other
peers are supposed to only synchronize it for reading.

See also DeePeer:swarm-owner property to ensure ownership of a swarm.</doc>
        <type name="SharedModelAccessMode"/>
      </property>
      <property name="flush-mode" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Enumeration defining the flushing behavior.

Setting this to #DEE_SHARED_MODEL_FLUSH_MODE_MANUAL will disable
automatic flushing that usually happens when the application's main event
loop is idle. Automatic flushing should be primarily disabled when
a shared model is used from multiple threads, or when not using #GMainLoop.
When disabled, dee_shared_model_flush_revision_queue() needs to be called
explicitely.</doc>
        <type name="SharedModelFlushMode"/>
      </property>
      <property name="peer"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DeePeer that this model uses to connect to the swarm</doc>
        <type name="Peer"/>
      </property>
      <property name="synchronized" transfer-ownership="none">
        <doc xml:space="preserve">Boolean property defining whether or not the model has synchronized with
its peers (if any) yet.

You should not modify a #DeeSharedModel that is not synchronized. Before
modifying the model in any way (except calling dee_model_set_schema())
you should wait for it to become synchronized.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="ProxyModel" c:type="DeeProxyModel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SharedModelPrivate" c:type="DeeSharedModelPrivate*"/>
      </field>
      <glib:signal name="begin-transaction" when="last">
        <doc xml:space="preserve">Emitted right before a remote transaction will be committed to the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="begin_seqnum" transfer-ownership="none">
            <doc xml:space="preserve">The seqnum the model has now</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="end_seqnum" transfer-ownership="none">
            <doc xml:space="preserve">The seqnum the model will have after the transaction is applied</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="end-transaction" when="last">
        <doc xml:space="preserve">Emitted right after a remote transaction has been committed to the model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="begin_seqnum" transfer-ownership="none">
            <doc xml:space="preserve">The seqnum the model had before the transaction was applied</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="end_seqnum" transfer-ownership="none">
            <doc xml:space="preserve">The seqnum the model has now</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="SharedModelAccessMode"
                 glib:type-name="DeeSharedModelAccessMode"
                 glib:get-type="dee_shared_model_access_mode_get_type"
                 c:type="DeeSharedModelAccessMode">
      <doc xml:space="preserve">Enumeration defining behavior of the model with regards to writes from
other peers in the swarm.</doc>
      <member name="world_writable"
              value="0"
              c:identifier="DEE_SHARED_MODEL_ACCESS_MODE_WORLD_WRITABLE"
              glib:nick="world-writable">
      </member>
      <member name="leader_writable"
              value="1"
              c:identifier="DEE_SHARED_MODEL_ACCESS_MODE_LEADER_WRITABLE"
              glib:nick="leader-writable">
      </member>
    </enumeration>
    <record name="SharedModelClass"
            c:type="DeeSharedModelClass"
            glib:is-gtype-struct-for="SharedModel">
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyModelClass" c:type="DeeProxyModelClass"/>
      </field>
      <field name="_dee_shared_model_1" introspectable="0">
        <callback name="_dee_shared_model_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_shared_model_2" introspectable="0">
        <callback name="_dee_shared_model_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_shared_model_3" introspectable="0">
        <callback name="_dee_shared_model_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_shared_model_4" introspectable="0">
        <callback name="_dee_shared_model_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SharedModelError" c:type="DeeSharedModelError">
      <member name="shared_model_error_leader_invalidated"
              value="0"
              c:identifier="DEE_SHARED_MODEL_ERROR_LEADER_INVALIDATED">
      </member>
    </enumeration>
    <enumeration name="SharedModelFlushMode"
                 glib:type-name="DeeSharedModelFlushMode"
                 glib:get-type="dee_shared_model_flush_mode_get_type"
                 c:type="DeeSharedModelFlushMode">
      <doc xml:space="preserve">Enumeration defining flushing behavior of a shared model.</doc>
      <member name="automatic"
              value="0"
              c:identifier="DEE_SHARED_MODEL_FLUSH_MODE_AUTOMATIC"
              glib:nick="automatic">
      </member>
      <member name="manual"
              value="1"
              c:identifier="DEE_SHARED_MODEL_FLUSH_MODE_MANUAL"
              glib:nick="manual">
      </member>
    </enumeration>
    <record name="SharedModelPrivate"
            c:type="DeeSharedModelPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <callback name="TermFilterFunc" c:type="DeeTermFilterFunc">
      <doc xml:space="preserve">A term filter takes a list of terms and runs it through a filtering and/or
set of transformations and stores the output in a #DeeTermList.

You can register term filters on a #DeeAnalyzer with
dee_analyzer_add_term_filter().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Nothing. Output is stored in @terms_out.</doc>
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="terms_in" transfer-ownership="none">
          <doc xml:space="preserve">A #DeeTermList with the terms to filter</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </parameter>
        <parameter name="terms_out" transfer-ownership="none">
          <doc xml:space="preserve">A #DeeTermList to write the filtered terms to</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </parameter>
        <parameter name="filter_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">User data set when registering the filter</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TermList"
           c:symbol-prefix="term_list"
           c:type="DeeTermList"
           parent="GObject.Object"
           glib:type-name="DeeTermList"
           glib:get-type="dee_term_list_get_type"
           glib:type-struct="TermListClass">
      <doc xml:space="preserve">All fields in the DeeTermList structure are private and should never be
accessed directly</doc>
      <virtual-method name="add_term" invoker="add_term">
        <doc xml:space="preserve">Add a term to the termlist. Note that it is possible to add a term multiple
times. The effect of this is determined by the #DeeModelIndex consuming the
#DeeTermList.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @self</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to add a term to</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear" invoker="clear">
        <doc xml:space="preserve">Remove all terms from a term list making it ready for reuse. Note that
term list implementations will often have optimized memory allocation
schemes so reuse is often more efficient than allocating a new term list
each time you need it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @self</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to clear</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clone" invoker="clone">
        <doc xml:space="preserve">Create a copy of @self that shares the underlying string pool and containing
a list of terms as currently set in @self.

Subsequently freeing the original and keeping the clone around is not a
problem. The clone works as a standalone term list. The only gotcha may be
threading issues because of concurrent access to the shared string pool.

Creating a clone very efficient since only very little memory allocation
is required. It's advised that you use a clone instead a new instance
whenever you work over a common corpus of strings.

It is also worth noting that terms obtained from the original term list
and a clone can be compared directly as pointers (fx. with g_direct_equal()).
This is because they share the underlying string pool.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated term list.
                          Free with g_object_unref().</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to clone</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_term" invoker="get_term">
        <doc xml:space="preserve">Get the n'th term in the list.

Note that in the default implementation it is guaranteed that the returned
string is valid for the entire lifetime of the #DeeTermList.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The @n&lt;!-- --&gt;th string held in the term list</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to get the @n&lt;!-- --&gt;th term from</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The (zero based) offset into the term list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="num_terms" invoker="num_terms">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of terms in the term list</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to check the number of terms in</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_term" c:identifier="dee_term_list_add_term">
        <doc xml:space="preserve">Add a term to the termlist. Note that it is possible to add a term multiple
times. The effect of this is determined by the #DeeModelIndex consuming the
#DeeTermList.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @self</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to add a term to</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">The term to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="dee_term_list_clear">
        <doc xml:space="preserve">Remove all terms from a term list making it ready for reuse. Note that
term list implementations will often have optimized memory allocation
schemes so reuse is often more efficient than allocating a new term list
each time you need it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Always returns @self</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to clear</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clone" c:identifier="dee_term_list_clone">
        <doc xml:space="preserve">Create a copy of @self that shares the underlying string pool and containing
a list of terms as currently set in @self.

Subsequently freeing the original and keeping the clone around is not a
problem. The clone works as a standalone term list. The only gotcha may be
threading issues because of concurrent access to the shared string pool.

Creating a clone very efficient since only very little memory allocation
is required. It's advised that you use a clone instead a new instance
whenever you work over a common corpus of strings.

It is also worth noting that terms obtained from the original term list
and a clone can be compared directly as pointers (fx. with g_direct_equal()).
This is because they share the underlying string pool.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated term list.
                          Free with g_object_unref().</doc>
          <type name="TermList" c:type="DeeTermList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to clone</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_term" c:identifier="dee_term_list_get_term">
        <doc xml:space="preserve">Get the n'th term in the list.

Note that in the default implementation it is guaranteed that the returned
string is valid for the entire lifetime of the #DeeTermList.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The @n&lt;!-- --&gt;th string held in the term list</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to get the @n&lt;!-- --&gt;th term from</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The (zero based) offset into the term list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="num_terms" c:identifier="dee_term_list_num_terms">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of terms in the term list</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The term list to check the number of terms in</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TermListPrivate" c:type="DeeTermListPrivate*"/>
      </field>
    </class>
    <record name="TermListClass"
            c:type="DeeTermListClass"
            glib:is-gtype-struct-for="TermList">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_term">
        <callback name="get_term">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The @n&lt;!-- --&gt;th string held in the term list</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The term list to get the @n&lt;!-- --&gt;th term from</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
            <parameter name="n" transfer-ownership="none">
              <doc xml:space="preserve">The (zero based) offset into the term list</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_term">
        <callback name="add_term">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Always returns @self</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The term list to add a term to</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
            <parameter name="term" transfer-ownership="none">
              <doc xml:space="preserve">The term to add</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="num_terms">
        <callback name="num_terms">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of terms in the term list</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The term list to check the number of terms in</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear">
        <callback name="clear">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Always returns @self</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The term list to clear</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clone">
        <callback name="clone">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A newly allocated term list.
                          Free with g_object_unref().</doc>
            <type name="TermList" c:type="DeeTermList*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The term list to clone</doc>
              <type name="TermList" c:type="DeeTermList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_dee_term_list_1" introspectable="0">
        <callback name="_dee_term_list_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_term_list_2" introspectable="0">
        <callback name="_dee_term_list_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_term_list_3" introspectable="0">
        <callback name="_dee_term_list_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_term_list_4" introspectable="0">
        <callback name="_dee_term_list_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="TermListPrivate" c:type="DeeTermListPrivate" disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <bitfield name="TermMatchFlag" c:type="DeeTermMatchFlag">
      <doc xml:space="preserve">Flags passed to dee_index_lookup() to control how matching is done.
Note that it is not required that index backends support more than just
#DEE_TERM_MATCH_EXACT.

You can query for the supported flags with
dee_index_get_supported_term_match_flags().</doc>
      <member name="exact" value="1" c:identifier="DEE_TERM_MATCH_EXACT">
        <doc xml:space="preserve">Match terms byte for byte as specified in the
                       query string</doc>
      </member>
      <member name="prefix" value="2" c:identifier="DEE_TERM_MATCH_PREFIX">
        <doc xml:space="preserve">Match if the indexed term begins with the byte string
                        being queried by. This is also sometimes known as
                        truncated- or wildcard queries</doc>
      </member>
    </bitfield>
    <class name="TextAnalyzer"
           c:symbol-prefix="text_analyzer"
           c:type="DeeTextAnalyzer"
           parent="Analyzer"
           glib:type-name="DeeTextAnalyzer"
           glib:get-type="dee_text_analyzer_get_type"
           glib:type-struct="TextAnalyzerClass">
      <doc xml:space="preserve">All fields in the DeeTextAnalyzer structure are private and should never be
accessed directly</doc>
      <constructor name="new" c:identifier="dee_text_analyzer_new">
        <return-value transfer-ownership="full">
          <type name="TextAnalyzer" c:type="DeeTextAnalyzer*"/>
        </return-value>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Analyzer" c:type="DeeAnalyzer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TextAnalyzerPrivate" c:type="DeeTextAnalyzerPrivate*"/>
      </field>
    </class>
    <record name="TextAnalyzerClass"
            c:type="DeeTextAnalyzerClass"
            glib:is-gtype-struct-for="TextAnalyzer">
      <field name="parent_class" readable="0" private="1">
        <type name="AnalyzerClass" c:type="DeeAnalyzerClass"/>
      </field>
    </record>
    <record name="TextAnalyzerPrivate"
            c:type="DeeTextAnalyzerPrivate"
            disguised="1">
    </record>
    <class name="Transaction"
           c:symbol-prefix="transaction"
           c:type="DeeTransaction"
           parent="SerializableModel"
           glib:type-name="DeeTransaction"
           glib:get-type="dee_transaction_get_type"
           glib:type-struct="TransactionClass">
      <doc xml:space="preserve">All fields in the DeeTransaction structure are private and should never be
accessed directly</doc>
      <implements name="Model"/>
      <implements name="Serializable"/>
      <constructor name="new" c:identifier="dee_transaction_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
    A newly allocated #DeeTransaction. Free with g_object_unref() when
    done using it - no matter if you call dee_transaction_commit() or not.</doc>
          <type name="Transaction" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModel the transaction applies against</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="error_quark" c:identifier="dee_transaction_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="commit" c:identifier="dee_transaction_commit" throws="1">
        <doc xml:space="preserve">Apply a transaction to its target model. After this call the transaction
is invalidated and must be freed with g_object_unref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if the transaction successfully applies to :target.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The transaction to commit</doc>
            <type name="Transaction" c:type="DeeTransaction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target" c:identifier="dee_transaction_get_target">
        <doc xml:space="preserve">Get the target model of a transaction. This is just a convenience method
for accessing the :target property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The target model</doc>
          <type name="Model" c:type="DeeModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The transaction to retrieve the target model for</doc>
            <type name="Transaction" c:type="DeeTransaction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_committed" c:identifier="dee_transaction_is_committed">
        <doc xml:space="preserve">Check if a #DeeTransaction has been committed. This method is mainly for
debugging and testing purposes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if dee_transaction_commit() has completed
         successfully on the transaction.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The transaction to inspect</doc>
            <type name="Transaction" c:type="DeeTransaction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="target"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Model"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="SerializableModel" c:type="DeeSerializableModel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TransactionPrivate" c:type="DeeTransactionPrivate*"/>
      </field>
    </class>
    <record name="TransactionClass"
            c:type="DeeTransactionClass"
            glib:is-gtype-struct-for="Transaction">
      <field name="parent_class" readable="0" private="1">
        <type name="SerializableModelClass"
              c:type="DeeSerializableModelClass"/>
      </field>
      <field name="_dee_transaction_1" introspectable="0">
        <callback name="_dee_transaction_1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_transaction_2" introspectable="0">
        <callback name="_dee_transaction_2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_transaction_3" introspectable="0">
        <callback name="_dee_transaction_3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_dee_transaction_4" introspectable="0">
        <callback name="_dee_transaction_4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="TransactionError" c:type="DeeTransactionError">
      <doc xml:space="preserve">Error codes for the #DeeTransaction class. These codes will be set when the
error domain is #DEE_TRANSACTION_ERROR.</doc>
      <member name="concurrent_modification"
              value="1"
              c:identifier="DEE_TRANSACTION_ERROR_CONCURRENT_MODIFICATION">
        <doc xml:space="preserve">The target model has been
  modified while the transaction was open.</doc>
      </member>
      <member name="committed"
              value="2"
              c:identifier="DEE_TRANSACTION_ERROR_COMMITTED">
        <doc xml:space="preserve">Raised when someone tries to commit a
  transaction that has already been committed</doc>
      </member>
    </enumeration>
    <record name="TransactionPrivate"
            c:type="DeeTransactionPrivate"
            disguised="1">
      <doc xml:space="preserve">Ignore this structure.</doc>
    </record>
    <class name="TreeIndex"
           c:symbol-prefix="tree_index"
           c:type="DeeTreeIndex"
           parent="Index"
           glib:type-name="DeeTreeIndex"
           glib:get-type="dee_tree_index_get_type"
           glib:type-struct="TreeIndexClass">
      <doc xml:space="preserve">All fields in the DeeTreeIndex structure are private and should never be
accessed directly</doc>
      <constructor name="new" c:identifier="dee_tree_index_new">
        <doc xml:space="preserve">Create a new tree index.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated tree index. Free with g_object_unref().</doc>
          <type name="TreeIndex" c:type="DeeTreeIndex*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">The model to index</doc>
            <type name="Model" c:type="DeeModel*"/>
          </parameter>
          <parameter name="analyzer" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeAnalyzer used to tokenize and filter the terms extracted
           by @reader</doc>
            <type name="Analyzer" c:type="DeeAnalyzer*"/>
          </parameter>
          <parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve">The #DeeModelReader used to extract terms from the model</doc>
            <type name="ModelReader" c:type="DeeModelReader*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Index" c:type="DeeIndex"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TreeIndexPrivate" c:type="DeeTreeIndexPrivate*"/>
      </field>
    </class>
    <record name="TreeIndexClass"
            c:type="DeeTreeIndexClass"
            glib:is-gtype-struct-for="TreeIndex">
      <field name="parent_class">
        <type name="IndexClass" c:type="DeeIndexClass"/>
      </field>
    </record>
    <record name="TreeIndexPrivate" c:type="DeeTreeIndexPrivate" disguised="1">
    </record>
    <function name="filter_new"
              c:identifier="dee_filter_new"
              moved-to="Filter.new">
      <doc xml:space="preserve">Create a new #DeeFilter with the given parameters. This call will zero
the @out_filter struct.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="map_func" transfer-ownership="none" scope="notified">
          <doc xml:space="preserve">The #DeeFilterMapFunc to use for the filter</doc>
          <type name="FilterMapFunc" c:type="DeeFilterMapFunc"/>
        </parameter>
        <parameter name="map_notify"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:space="preserve">The #DeeFilterMapNotify to use for the filter</doc>
          <type name="FilterMapNotify" c:type="DeeFilterMapNotify"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:space="preserve">The user data to pass to @map_func and @map_notify</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async">
          <doc xml:space="preserve">The #GDestroyNotify to call on
                        @userdata when disposing of the filter</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_collator"
              c:identifier="dee_filter_new_collator"
              moved-to="Filter.new_collator">
      <doc xml:space="preserve">Create a #DeeFilter that takes string values from a column in the model
and builds a #DeeFilterModel with the rows sorted according to the
collation rules of the current locale.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The index of a column containing the strings to sort after</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_collator_desc"
              c:identifier="dee_filter_new_collator_desc"
              moved-to="Filter.new_collator_desc">
      <doc xml:space="preserve">Create a #DeeFilter that takes string values from a column in the model
and builds a #DeeFilterModel with the rows sorted descending according to the
collation rules of the current locale.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The index of a column containing the strings to sort after</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_for_any_column"
              c:identifier="dee_filter_new_for_any_column"
              moved-to="Filter.new_for_any_column">
      <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which match a variant value in a given column. A #DeeFilterModel
created with this filter will be ordered in accordance with its parent model.

This method will work on any column, disregarding its schema, since the
value comparison is done using g_variant_equal(). This means you can use
this filter as a convenient fallback when there is no predefined filter
for your column type if raw performance is not paramount.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The index of a column containing the string to match</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">A #GVariant value columns must match exactly.
        The matching semantics are those of g_variant_equal(). If @value
        is floating the ownership will be transfered to the filter</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_for_key_column"
              c:identifier="dee_filter_new_for_key_column"
              moved-to="Filter.new_for_key_column">
      <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which has an exact match on some string column. A #DeeFilterModel created
with this filter will be ordered in accordance with its parent model.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The index of a column containing the string key to match</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_regex"
              c:identifier="dee_filter_new_regex"
              moved-to="Filter.new_regex">
      <doc xml:space="preserve">Create a #DeeFilter that only includes rows from the original model
which match a regular expression on some string column. A #DeeFilterModel
created with this filter will be ordered in accordance with its parent model.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The index of a column containing the string to match</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="regex" transfer-ownership="none">
          <doc xml:space="preserve">The regular expression @column must match</doc>
          <type name="GLib.Regex" c:type="GRegex*"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_new_sort"
              c:identifier="dee_filter_new_sort"
              moved-to="Filter.new_sort">
      <doc xml:space="preserve">Create a new #DeeFilter sorting a model according to a #DeeCompareRowFunc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cmp_row"
                   transfer-ownership="none"
                   scope="notified"
                   closure="1"
                   destroy="2">
          <doc xml:space="preserve">A #DeeCompareRowFunc to use for sorting</doc>
          <type name="CompareRowFunc" c:type="DeeCompareRowFunc"/>
        </parameter>
        <parameter name="cmp_user_data" transfer-ownership="none">
          <doc xml:space="preserve">User data passed to @cmp_row</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cmp_destroy"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async">
          <doc xml:space="preserve">The #GDestroyNotify to call on
                        @cmp_user_data when disposing of the filter</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="out_filter"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeFilter struct.
                    This struct will zeroed and configured with the filter
                    parameters</doc>
          <type name="Filter" c:type="DeeFilter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icu_error_quark" c:identifier="dee_icu_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="model_reader_new"
              c:identifier="dee_model_reader_new"
              moved-to="ModelReader.new">
      <doc xml:space="preserve">Create a new #DeeModelReader with the given parameters. This call will zero
the @out_reader struct.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="reader_func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="1"
                   destroy="2">
          <doc xml:space="preserve">The #DeeModelReaderFunc to use for the reader</doc>
          <type name="ModelReaderFunc" c:type="DeeModelReaderFunc"/>
        </parameter>
        <parameter name="userdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The user data to pass to @reader_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async">
          <doc xml:space="preserve">The #GDestroyNotify to call on
                                       @userdata when disposing of the reader</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="out_reader"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to an uninitialized #DeeModelReader struct</doc>
          <type name="ModelReader" c:type="DeeModelReader*"/>
        </parameter>
      </parameters>
    </function>
    <function name="model_reader_new_for_int32_column"
              c:identifier="dee_model_reader_new_for_int32_column"
              moved-to="ModelReader.new_for_int32_column">
      <doc xml:space="preserve">A #DeeModelReader reading a %gint32 from a #DeeModel at a given column</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The column index to read a %gint32 from</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_reader"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
          <type name="ModelReader" c:type="DeeModelReader*"/>
        </parameter>
      </parameters>
    </function>
    <function name="model_reader_new_for_string_column"
              c:identifier="dee_model_reader_new_for_string_column"
              moved-to="ModelReader.new_for_string_column">
      <doc xml:space="preserve">A #DeeModelReader reading a string from a #DeeModel at a given column</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The column index to read a string from</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_reader"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
          <type name="ModelReader" c:type="DeeModelReader*"/>
        </parameter>
      </parameters>
    </function>
    <function name="model_reader_new_for_uint32_column"
              c:identifier="dee_model_reader_new_for_uint32_column"
              moved-to="ModelReader.new_for_uint32_column">
      <doc xml:space="preserve">A #DeeModelReader reading a %guint32 from a #DeeModel at a given column</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="column" transfer-ownership="none">
          <doc xml:space="preserve">The column index to read a %guint32 from</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_reader"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a #DeeModelReader instance which will have
                    all fields initialized appropriately</doc>
          <type name="ModelReader" c:type="DeeModelReader*"/>
        </parameter>
      </parameters>
    </function>
    <function name="resource_manager_get_default"
              c:identifier="dee_resource_manager_get_default"
              moved-to="ResourceManager.get_default">
      <doc xml:space="preserve">Get a pointer to the platform default #DeeResourceManager.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The default resource manager for the platform.
              Do not unreference. If you need to keep the instance around
              you must manually reference it.</doc>
        <type name="ResourceManager" c:type="DeeResourceManager*"/>
      </return-value>
    </function>
    <function name="serializable_parse"
              c:identifier="dee_serializable_parse"
              moved-to="Serializable.parse">
      <doc xml:space="preserve">Reconstruct a #DeeSerializable from #GVariant data. For this function
to work you need to register a parser with
dee_serializable_register_parser(). Any native Dee class will do so
automatically.

This method only works on data created with dee_serializable_serialize()
and &lt;emphasis&gt;not&lt;/emphasis&gt; with data from dee_serializable_externalize().

Since a #DeeSerializableParseFunc is not allowed to fail - by contract -
it can be guaranteed that this function only returns %NULL in case there
is no known parser for @type and #GVariant signature of @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly constructed #GObject build from @data
              or %NULL in case no parser has been registered for the given
              #GType or variant signature. Free with g_object_unref().</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The #GVariant data to parse. If this is a floating reference it will
       be consumed</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">The #GType of the class to instantiate from @data</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="serializable_parse_external"
              c:identifier="dee_serializable_parse_external"
              moved-to="Serializable.parse_external">
      <doc xml:space="preserve">Reconstruct a #DeeSerializable from #GVariant data. For this function
to work you need to register a parser with
dee_serializable_register_parser(). Any native Dee class will do so
automatically.

This method only works on data created with dee_serializable_externalize()
and &lt;emphasis&gt;not&lt;/emphasis&gt; with data from  dee_serializable_serialize().

Since a #DeeSerializableParseFunc is not allowed to fail - by contract -
it can be guaranteed that this function only returns %NULL in case there
is no known parser for the #GType or #GVariant signature of @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly constructed #GObject build from @data
              or %NULL in case no parser has been registered for the given
              #GType or variant signature. Free with g_object_unref().</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The #GVariant data to parse</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
