<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <namespace name="Cattle"
             version="1.0"
             shared-library=""
             c:identifier-prefixes="Cattle"
             c:symbol-prefixes="cattle">
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="CattleBuffer"
           parent="GObject.Object"
           glib:type-name="CattleBuffer"
           glib:get-type="cattle_buffer_get_type"
           glib:type-struct="BufferClass">
      <doc xml:space="preserve">Opaque data structure representing a memory buffer. It should never
be accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_buffer_new">
        <doc xml:space="preserve">Create and initialize a new memory buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleBuffer</doc>
          <type name="Buffer" c:type="CattleBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_size" c:identifier="cattle_buffer_get_size">
        <doc xml:space="preserve">Get the size of the memory buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the memory buffer</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleBuffer</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="cattle_buffer_get_value">
        <doc xml:space="preserve">Get the value of a specific byte inside the memory buffer.

The value of @position must be smaller than the size of the
memory buffer, as returned by cattle_buffer_get_size().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the selected byte.</doc>
          <type name="gint8" c:type="gint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleBuffer</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">offset inside the memory buffer</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contents"
              c:identifier="cattle_buffer_set_contents"
              shadowed-by="set_contents_full"
              introspectable="0">
        <doc xml:space="preserve">Set the contents of a memory buffer.

The size of @contents is assumed to be the same as the size of @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleBuffer</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:space="preserve">data to copy inside the memory buffer</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contents_full"
              c:identifier="cattle_buffer_set_contents_full"
              shadows="set_contents">
        <doc xml:space="preserve">Set the contents of the memory buffer.

This method exists mainly for bindings; cattle_buffer_set_contents() is
more convenient when writing C code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleBuffer</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:space="preserve">data to copy inside the memory buffer</doc>
            <array length="1" zero-terminated="0" c:type="gint8*">
              <type name="gint8" c:type="gint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of @contents</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="cattle_buffer_set_value">
        <doc xml:space="preserve">Set the value of a specific byte inside the memory buffer.

The value of @position must be smaller than the size of the
memory buffer, as returned by cattle_buffer_get_size().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleBuffer</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">offset inside the memory buffer</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">new value</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <property name="size"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Size of the memory buffer.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="BufferPrivate" c:type="CattleBufferPrivate*"/>
      </field>
    </class>
    <record name="BufferClass"
            c:type="CattleBufferClass"
            glib:is-gtype-struct-for="Buffer">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="BufferPrivate" c:type="CattleBufferPrivate" disguised="1">
    </record>
    <class name="Configuration"
           c:symbol-prefix="configuration"
           c:type="CattleConfiguration"
           parent="GObject.Object"
           glib:type-name="CattleConfiguration"
           glib:get-type="cattle_configuration_get_type"
           glib:type-struct="ConfigurationClass">
      <doc xml:space="preserve">Opaque data structure representing a configuration. It should never
be accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_configuration_new">
        <doc xml:space="preserve">Create and initialize a new configuration.

A single configuration object can be shared between multiple
interpreters, but modifying it while an interpreter is running can
lead to unexpected and unpredictable results.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleConfiguration</doc>
          <type name="Configuration" c:type="CattleConfiguration*"/>
        </return-value>
      </constructor>
      <method name="get_debug_is_enabled"
              c:identifier="cattle_configuration_get_debug_is_enabled">
        <doc xml:space="preserve">Get the current status of the debugging support.
See cattle_configuration_set_debug_is_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if debugging is enabled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="configuration" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleConfiguration</doc>
            <type name="Configuration" c:type="CattleConfiguration*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_end_of_input_action"
              c:identifier="cattle_configuration_get_end_of_input_action">
        <doc xml:space="preserve">Get the action to be performed when the end of input is reached.
See cattle_configuration_set_end_of_input_action().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current action</doc>
          <type name="EndOfInputAction" c:type="CattleEndOfInputAction"/>
        </return-value>
        <parameters>
          <instance-parameter name="configuration" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleConfiguration</doc>
            <type name="Configuration" c:type="CattleConfiguration*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_debug_is_enabled"
              c:identifier="cattle_configuration_set_debug_is_enabled">
        <doc xml:space="preserve">Set the status of the debugging support. It is disabled by default.

If debugging is disabled, instructions whose value is
%CATTLE_INSTRUCTION_DEBUG will be ignored by the interpreter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="configuration" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleConfiguration</doc>
            <type name="Configuration" c:type="CattleConfiguration*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable debug, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_end_of_input_action"
              c:identifier="cattle_configuration_set_end_of_input_action">
        <doc xml:space="preserve">Set the action to be performed when the end of input is reached.

Accepted values are from the #CattleEndOfInputAction enumeration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="configuration" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleConfiguration</doc>
            <type name="Configuration" c:type="CattleConfiguration*"/>
          </instance-parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">the action to be performed</doc>
            <type name="EndOfInputAction" c:type="CattleEndOfInputAction"/>
          </parameter>
        </parameters>
      </method>
      <property name="debug-is-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If %FALSE, instructions whose value is
%CATTLE_INSTRUCTION_DEBUG are not executed by the interpreter.

Changes to this property are not notified.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="end-of-input-action"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Action to be performed when the end of input is reached.

Changes to this property are not notified.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ConfigurationPrivate"
              c:type="CattleConfigurationPrivate*"/>
      </field>
    </class>
    <record name="ConfigurationClass"
            c:type="CattleConfigurationClass"
            glib:is-gtype-struct-for="Configuration">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ConfigurationPrivate"
            c:type="CattleConfigurationPrivate"
            disguised="1">
    </record>
    <callback name="DebugHandler" c:type="CattleDebugHandler" throws="1">
      <doc xml:space="preserve">Handler for a debug operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="interpreter" transfer-ownership="none">
          <doc xml:space="preserve">a #CattleInterpreter</doc>
          <type name="Interpreter" c:type="CattleInterpreter*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data passed to the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="EndOfInputAction" c:type="CattleEndOfInputAction">
      <doc xml:space="preserve">Possible actions to be performed by a #CattleInterpreter when the end
of input is reached.</doc>
      <member name="store_zero"
              value="0"
              c:identifier="CATTLE_END_OF_INPUT_ACTION_STORE_ZERO">
        <doc xml:space="preserve">Store a zero in the current cell. This is
the default behaviour</doc>
      </member>
      <member name="store_eof"
              value="1"
              c:identifier="CATTLE_END_OF_INPUT_ACTION_STORE_EOF">
        <doc xml:space="preserve">Store %CATTLE_EOF in the current cell</doc>
      </member>
      <member name="do_nothing"
              value="2"
              c:identifier="CATTLE_END_OF_INPUT_ACTION_DO_NOTHING">
        <doc xml:space="preserve">Do nothing.</doc>
      </member>
    </enumeration>
    <enumeration name="Error"
                 c:type="CattleError"
                 glib:error-domain="cattle-error-quark">
      <doc xml:space="preserve">Errors detected either on code loading or at runtime.</doc>
      <member name="io" value="0" c:identifier="CATTLE_ERROR_IO">
        <doc xml:space="preserve">Generic I/O error</doc>
      </member>
      <member name="unbalanced_brackets"
              value="1"
              c:identifier="CATTLE_ERROR_UNBALANCED_BRACKETS">
        <doc xml:space="preserve">The number of open and closed
brackets don't match</doc>
      </member>
      <member name="input_out_of_range"
              value="2"
              c:identifier="CATTLE_ERROR_INPUT_OUT_OF_RANGE">
        <doc xml:space="preserve">The input cannot be stored in a
tape cell</doc>
      </member>
    </enumeration>
    <callback name="InputHandler" c:type="CattleInputHandler" throws="1">
      <doc xml:space="preserve">Handler for an input operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="interpreter" transfer-ownership="none">
          <doc xml:space="preserve">a #CattleInterpreter</doc>
          <type name="Interpreter" c:type="CattleInterpreter*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data passed to the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Instruction"
           c:symbol-prefix="instruction"
           c:type="CattleInstruction"
           parent="GObject.Object"
           glib:type-name="CattleInstruction"
           glib:get-type="cattle_instruction_get_type"
           glib:type-struct="InstructionClass">
      <doc xml:space="preserve">Opaque data structure representing an instruction. It should never be
accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_instruction_new">
        <doc xml:space="preserve">Create and initialize a new instruction.

The newly-created instruction has a #CattleInstruction:quantity of
one, and its #CattleInstruction:value is %CATTLE_INSTRUCTION_NONE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleInstruction</doc>
          <type name="Instruction" c:type="CattleInstruction*"/>
        </return-value>
      </constructor>
      <method name="get_loop" c:identifier="cattle_instruction_get_loop">
        <doc xml:space="preserve">Get the first instruction of the loop.

This method should only be called on instructions whose value is
%CATTLE_INSTRUCTION_LOOP_BEGIN.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CattleInstruction, or %NULL</doc>
          <type name="Instruction" c:type="CattleInstruction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next" c:identifier="cattle_instruction_get_next">
        <doc xml:space="preserve">Get the next instruction.

Please note that the returned instruction might not be the next
instruction in the execution flow: if @instruction marks the
beginning of a loop (its value is %CATTLE_INSTRUCTION_LOOP_BEGIN),
the returned instruction will be executed only after the loop has
ended.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the next instruction, or %NULL</doc>
          <type name="Instruction" c:type="CattleInstruction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_quantity"
              c:identifier="cattle_instruction_get_quantity">
        <doc xml:space="preserve">Get the quantity of @instruction.
See cattle_instruction_set_quantity().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quantity of @instruction</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="cattle_instruction_get_value">
        <doc xml:space="preserve">Get the value of @instruction. See cattle_instruction_set_value().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of @instruction</doc>
          <type name="InstructionValue" c:type="CattleInstructionValue"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_loop" c:identifier="cattle_instruction_set_loop">
        <doc xml:space="preserve">Set the instructions to be executed in the loop.

This method should only be called on instructions whose value is
%CATTLE_INSTRUCTION_LOOP_BEGIN.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
          <parameter name="loop"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">first #CattleInstruction in the loop, or %NULL</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next" c:identifier="cattle_instruction_set_next">
        <doc xml:space="preserve">Set the next instruction to be executed.

If @instruction has value %CATTLE_INSTRUCTION_LOOP_BEGIN, @next
will be executed only after the loop has returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
          <parameter name="next"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">next #CattleInstruction to execute, or %NULL</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_quantity"
              c:identifier="cattle_instruction_set_quantity">
        <doc xml:space="preserve">Set the number of times @instruction has to be executed.

This value is used at runtime for faster execution, and allows to
use less memory for storing the code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
          <parameter name="quantity" transfer-ownership="none">
            <doc xml:space="preserve">quantity of @instruction</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="cattle_instruction_set_value">
        <doc xml:space="preserve">Set the value of @instruction. Accepted values are from the
#CattleInstructionValue enumeration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="instruction" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInstruction</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of @instruction</doc>
            <type name="InstructionValue" c:type="CattleInstructionValue"/>
          </parameter>
        </parameters>
      </method>
      <property name="loop" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Instructions to be executed in the loop. Should be %NULL unless
the value of the instruction is %CATTLE_INSTRUCTION_LOOP_BEGIN.

Changes to this property are not notified.</doc>
        <type name="Instruction"/>
      </property>
      <property name="next" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Next instruction in the execution flow. Can be %NULL if there
are no more instructions to be executed.

Changes to this property are not notified.</doc>
        <type name="Instruction"/>
      </property>
      <property name="quantity" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Number of times the instruction has to be executed.

Changes to this property are not notified.</doc>
        <type name="gulong" c:type="gulong"/>
      </property>
      <property name="value"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Value of the instruction. Accepted values are in the
#CattleInstructionValue enumeration.

Changes to this property are not notified.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="InstructionPrivate" c:type="CattleInstructionPrivate*"/>
      </field>
    </class>
    <record name="InstructionClass"
            c:type="CattleInstructionClass"
            glib:is-gtype-struct-for="Instruction">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="InstructionPrivate"
            c:type="CattleInstructionPrivate"
            disguised="1">
    </record>
    <enumeration name="InstructionValue" c:type="CattleInstructionValue">
      <doc xml:space="preserve">Brainfuck instructions supported by Cattle, as #gunichar&lt;!-- --&gt;s.

%CATTLE_INSTRUCTION_DEBUG is not part of the Brainfuck language, but
it's often used for debugging and implemented in many interpreters,
so it's included in Cattle as well.</doc>
      <member name="none" value="120" c:identifier="CATTLE_INSTRUCTION_NONE">
        <doc xml:space="preserve">Do nothing</doc>
      </member>
      <member name="move_left"
              value="60"
              c:identifier="CATTLE_INSTRUCTION_MOVE_LEFT">
        <doc xml:space="preserve">Move the tape to the left</doc>
      </member>
      <member name="move_right"
              value="62"
              c:identifier="CATTLE_INSTRUCTION_MOVE_RIGHT">
        <doc xml:space="preserve">Move the tape to the right</doc>
      </member>
      <member name="increase"
              value="43"
              c:identifier="CATTLE_INSTRUCTION_INCREASE">
        <doc xml:space="preserve">Increase the current value</doc>
      </member>
      <member name="decrease"
              value="45"
              c:identifier="CATTLE_INSTRUCTION_DECREASE">
        <doc xml:space="preserve">Decrease the current value</doc>
      </member>
      <member name="loop_begin"
              value="91"
              c:identifier="CATTLE_INSTRUCTION_LOOP_BEGIN">
        <doc xml:space="preserve">Execute the loop until the current
value is zero, then proceed to the next instruction</doc>
      </member>
      <member name="loop_end"
              value="93"
              c:identifier="CATTLE_INSTRUCTION_LOOP_END">
        <doc xml:space="preserve">Exit from the currently-executing loop</doc>
      </member>
      <member name="read" value="44" c:identifier="CATTLE_INSTRUCTION_READ">
        <doc xml:space="preserve">Get one character from the input and save
its value at the current position</doc>
      </member>
      <member name="print" value="46" c:identifier="CATTLE_INSTRUCTION_PRINT">
        <doc xml:space="preserve">Send the current value to the output.</doc>
      </member>
      <member name="debug" value="35" c:identifier="CATTLE_INSTRUCTION_DEBUG">
        <doc xml:space="preserve">Show debugging information. This usually
means dumping the contents of the tape.</doc>
      </member>
    </enumeration>
    <class name="Interpreter"
           c:symbol-prefix="interpreter"
           c:type="CattleInterpreter"
           parent="GObject.Object"
           glib:type-name="CattleInterpreter"
           glib:get-type="cattle_interpreter_get_type"
           glib:type-struct="InterpreterClass">
      <doc xml:space="preserve">Opaque data structure representing an interpreter. It should never be
accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_interpreter_new">
        <doc xml:space="preserve">Create and initialize a new interpreter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleInterpreter</doc>
          <type name="Interpreter" c:type="CattleInterpreter*"/>
        </return-value>
      </constructor>
      <method name="feed" c:identifier="cattle_interpreter_feed">
        <doc xml:space="preserve">Feed @interpreter with more input.

This method is meant to be used inside an input handler assigned to
@interpreter; calling it in any other context is pointless, since the
input is reset each time cattle_interpreter_run() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="full">
            <doc xml:space="preserve">more input to be used by @interpreter</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_configuration"
              c:identifier="cattle_interpreter_get_configuration">
        <doc xml:space="preserve">Get the configuration for @interpreter.
See cattle_interpreter_set_configuration().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">configuration for @interpreter</doc>
          <type name="Configuration" c:type="CattleConfiguration*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_program" c:identifier="cattle_interpreter_get_program">
        <doc xml:space="preserve">Get the program for @interpreter.
See cattle_interpreter_set_program().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the program for @interpreter</doc>
          <type name="Program" c:type="CattleProgram*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tape" c:identifier="cattle_interpreter_get_tape">
        <doc xml:space="preserve">Get the memory tape used by @interpreter.
See cattle_interpreter_set_tape().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the memory tape for @interpreter</doc>
          <type name="Tape" c:type="CattleTape*"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="cattle_interpreter_run" throws="1">
        <doc xml:space="preserve">Make the interpreter run the loaded program.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_configuration"
              c:identifier="cattle_interpreter_set_configuration">
        <doc xml:space="preserve">Set the configuration for @interpreter.

The same configuration can be used for several interpreters, but
modifying it after it has been assigned to an interpreter may result
in undefined behaviour, and as such is discouraged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="configuration" transfer-ownership="full">
            <doc xml:space="preserve">configuration for @interpreter</doc>
            <type name="Configuration" c:type="CattleConfiguration*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_debug_handler"
              c:identifier="cattle_interpreter_set_debug_handler">
        <doc xml:space="preserve">Set the debug handler for @interpreter.

The handler will be invoked every time @interpreter needs to perform
a debug action; if @handler is %NULL, the default debug handler will
be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve">debug handler, or %NULL</doc>
            <type name="InputHandler" c:type="CattleInputHandler"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_input_handler"
              c:identifier="cattle_interpreter_set_input_handler">
        <doc xml:space="preserve">Set the input handler for @interpreter.

The handler will be invoked every time @interpreter needs to perform
an input action; if @handler is %NULL, the default input handler will
be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve">input handler, or %NULL</doc>
            <type name="InputHandler" c:type="CattleInputHandler"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_output_handler"
              c:identifier="cattle_interpreter_set_output_handler">
        <doc xml:space="preserve">Set the output handler for @interpreter.

The handler will be invoked every time @interpreter needs to perform
an output action; if @handler is %NULL, the default output handler will
be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve">output handler, or %NULL</doc>
            <type name="OutputHandler" c:type="CattleOutputHandler"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_program" c:identifier="cattle_interpreter_set_program">
        <doc xml:space="preserve">Set the program to be executed by @interpreter.

A single program can be shared between multiple interpreters,
as long as care is taken not to modify it after it has been
assigned to any of them.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="full">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tape" c:identifier="cattle_interpreter_set_tape">
        <doc xml:space="preserve">Set the memory tape used by @interpreter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interpreter" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleInterpreter</doc>
            <type name="Interpreter" c:type="CattleInterpreter*"/>
          </instance-parameter>
          <parameter name="tape" transfer-ownership="full">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </parameter>
        </parameters>
      </method>
      <property name="configuration" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Configuration used by the interpreter.

Changes to this property are not notified.</doc>
        <type name="Configuration"/>
      </property>
      <property name="program" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Program executed by the interpreter.

Changes to this property are not notified.</doc>
        <type name="Program"/>
      </property>
      <property name="tape" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Tape used to store the data needed by the program.

Changes to this property are not notified.</doc>
        <type name="Tape"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="InterpreterPrivate" c:type="CattleInterpreterPrivate*"/>
      </field>
    </class>
    <record name="InterpreterClass"
            c:type="CattleInterpreterClass"
            glib:is-gtype-struct-for="Interpreter">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="InterpreterPrivate"
            c:type="CattleInterpreterPrivate"
            disguised="1">
    </record>
    <constant name="MAJOR_VERSION" value="1" c:type="CATTLE_MAJOR_VERSION">
      <doc xml:space="preserve">Major version of the Cattle library used for compilation.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="CATTLE_MICRO_VERSION">
      <doc xml:space="preserve">Micro version of the Cattle library used for compilation.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="2" c:type="CATTLE_MINOR_VERSION">
      <doc xml:space="preserve">Minor version of the Cattle library used for compilation.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="OutputHandler" c:type="CattleOutputHandler" throws="1">
      <doc xml:space="preserve">Handler for an output operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="interpreter" transfer-ownership="none">
          <doc xml:space="preserve">a #CattleInterpreter</doc>
          <type name="Interpreter" c:type="CattleInterpreter*"/>
        </parameter>
        <parameter name="output" transfer-ownership="none">
          <doc xml:space="preserve">a #gchar to output</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">user data passed to the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Program"
           c:symbol-prefix="program"
           c:type="CattleProgram"
           parent="GObject.Object"
           glib:type-name="CattleProgram"
           glib:get-type="cattle_program_get_type"
           glib:type-struct="ProgramClass">
      <doc xml:space="preserve">Opaque data structure representing a program. It should never be
accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_program_new">
        <doc xml:space="preserve">Create a new #CattleProgram.

A single instance of a program can be shared between multiple
interpreters, as long as the object is not modified after it
has been initialized.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleProgram</doc>
          <type name="Program" c:type="CattleProgram*"/>
        </return-value>
      </constructor>
      <method name="get_input" c:identifier="cattle_program_get_input">
        <doc xml:space="preserve">Get the input for @program.
See cattle_program_set_input().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">input for @program</doc>
          <type name="Buffer" c:type="CattleBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_instructions"
              c:identifier="cattle_program_get_instructions">
        <doc xml:space="preserve">Get the instructions for @program.
See cattle_program_load() and cattle_program_set_instructions().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the first instruction in @program</doc>
          <type name="Instruction" c:type="CattleInstruction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load" c:identifier="cattle_program_load" throws="1">
        <doc xml:space="preserve">Load @program from @buffer.

The buffer can optionally contain also the input for the program:
in that case, the input must be separated from the code by a bang
(!) character.

In case of failure, @error is filled with detailed information.
The error domain is %CATTLE_ERROR, and the error code is from the
#CattleError enumeration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:space="preserve">a #CattleBuffer containing the code</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_input" c:identifier="cattle_program_set_input">
        <doc xml:space="preserve">Set the input for @program.

If the size of @input is zero, the program's input will be retrieved
at runtime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="full">
            <doc xml:space="preserve">input for @program</doc>
            <type name="Buffer" c:type="CattleBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_instructions"
              c:identifier="cattle_program_set_instructions">
        <doc xml:space="preserve">Set the instructions for @program.

You shouldn't usually need to use this: see cattle_program_load()
for the standard way to load a program.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleProgram</doc>
            <type name="Program" c:type="CattleProgram*"/>
          </instance-parameter>
          <parameter name="instructions" transfer-ownership="full">
            <doc xml:space="preserve">instructions for @program</doc>
            <type name="Instruction" c:type="CattleInstruction*"/>
          </parameter>
        </parameters>
      </method>
      <property name="input" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Input for the program, or %NULL if no input was available
at the time of loading.

Changes to this property are not notified.</doc>
        <type name="Buffer"/>
      </property>
      <property name="instructions" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Instructions for the program.

Changes to this property are not notified.</doc>
        <type name="Instruction"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ProgramPrivate" c:type="CattleProgramPrivate*"/>
      </field>
    </class>
    <record name="ProgramClass"
            c:type="CattleProgramClass"
            glib:is-gtype-struct-for="Program">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ProgramPrivate" c:type="CattleProgramPrivate" disguised="1">
    </record>
    <class name="Tape"
           c:symbol-prefix="tape"
           c:type="CattleTape"
           parent="GObject.Object"
           glib:type-name="CattleTape"
           glib:get-type="cattle_tape_get_type"
           glib:type-struct="TapeClass">
      <doc xml:space="preserve">Opaque data structure representing a memory tape. It should never
be accessed directly; use the methods below instead.</doc>
      <constructor name="new" c:identifier="cattle_tape_new">
        <doc xml:space="preserve">Create and initialize a new memory tape.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CattleTape</doc>
          <type name="Tape" c:type="CattleTape*"/>
        </return-value>
      </constructor>
      <method name="decrease_current_value"
              c:identifier="cattle_tape_decrease_current_value">
        <doc xml:space="preserve">Decrease the value in the current cell by one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="decrease_current_value_by"
              c:identifier="cattle_tape_decrease_current_value_by">
        <doc xml:space="preserve">Decrease the value in the current cell by @value.

Decreasing the value this way is much faster than calling
cattle_tape_decrease_current_value() multiple times.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">decrease amount</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_value"
              c:identifier="cattle_tape_get_current_value">
        <doc xml:space="preserve">Get the value of the current cell. See
cattle_tape_set_current_value().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the current cell</doc>
          <type name="gint8" c:type="gint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="increase_current_value"
              c:identifier="cattle_tape_increase_current_value">
        <doc xml:space="preserve">Increase the value in the current cell by one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="increase_current_value_by"
              c:identifier="cattle_tape_increase_current_value_by">
        <doc xml:space="preserve">Increase the value in the current cell by @value.

Increasing the value this way is much faster than calling
cattle_tape_increase_current_value() multiple times.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">increase amount</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_at_beginning"
              c:identifier="cattle_tape_is_at_beginning">
        <doc xml:space="preserve">Check if the current cell is the first one of @tape.

Since the tape grows automatically as more cells are needed, it is
possible to move left from the first cell.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the current cell is the first one, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_at_end" c:identifier="cattle_tape_is_at_end">
        <doc xml:space="preserve">Check if the current cell is the last one of @tape.

Since the tape grows automatically as more cells are needed, it is
possible to move right from the last cell.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the current cell is the last one, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move_left" c:identifier="cattle_tape_move_left">
        <doc xml:space="preserve">Move @tape one cell to the left.

If there are no memory cells on the left of the current one,
one will be created on the fly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move_left_by" c:identifier="cattle_tape_move_left_by">
        <doc xml:space="preserve">Move @tape @steps cells to the left.

Moving this way is much faster than calling
cattle_tape_move_left() multiple times.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
          <parameter name="steps" transfer-ownership="none">
            <doc xml:space="preserve">number of steps</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_right" c:identifier="cattle_tape_move_right">
        <doc xml:space="preserve">Move @tape one cell to the right.

If there are no memory cells on the right of the current one,
one will be created on the fly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move_right_by" c:identifier="cattle_tape_move_right_by">
        <doc xml:space="preserve">Move @tape @steps cells to the right.

Moving this way is much faster than calling
cattle_tape_move_right() multiple times.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
          <parameter name="steps" transfer-ownership="none">
            <doc xml:space="preserve">number of steps</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_bookmark" c:identifier="cattle_tape_pop_bookmark">
        <doc xml:space="preserve">Restore the previously-saved tape position.
See cattle_tape_push_bookmark().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the bookmarks stack is empty, %TRUE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_bookmark" c:identifier="cattle_tape_push_bookmark">
        <doc xml:space="preserve">Create a bookmark to the current tape position and save it on the
bookmark stack.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_current_value"
              c:identifier="cattle_tape_set_current_value">
        <doc xml:space="preserve">Set the value of the current cell.

Accepted values range from %G_MININT8 to %G_MAXINT8.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tape" transfer-ownership="none">
            <doc xml:space="preserve">a #CattleTape</doc>
            <type name="Tape" c:type="CattleTape*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the current cell's new value</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <property name="current-value" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Value of the current cell.

Changes to this property are not notified.</doc>
        <type name="gchar" c:type="gchar"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="TapePrivate" c:type="CattleTapePrivate*"/>
      </field>
    </class>
    <record name="TapeClass"
            c:type="CattleTapeClass"
            glib:is-gtype-struct-for="Tape">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="TapePrivate" c:type="CattleTapePrivate" disguised="1">
    </record>
    <function name="check_version" c:identifier="cattle_check_version">
      <doc xml:space="preserve">Check the Cattle library used at runtime is compatible with the
required version described by @required_major, @required_minor and
@required_micro.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the runtime library is compatible, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="required_major" transfer-ownership="none">
          <doc xml:space="preserve">required major version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_minor" transfer-ownership="none">
          <doc xml:space="preserve">required minor version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_micro" transfer-ownership="none">
          <doc xml:space="preserve">required micro version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark" c:identifier="cattle_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
