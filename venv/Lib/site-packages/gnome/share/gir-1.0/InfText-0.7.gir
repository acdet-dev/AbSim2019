<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Infinity" version="0.7"/>
  <include name="Infinityd" version="0.7"/>
  <package name="libinftext-0.7"/>
  <namespace name="InfText"
             version="0.7"
             shared-library="libinftext-0.7-0.dll"
             c:identifier-prefixes="InfText"
             c:symbol-prefixes="inf_text">
    <interface name="Buffer"
               c:symbol-prefix="buffer"
               c:type="InfTextBuffer"
               glib:type-name="InfTextBuffer"
               glib:get-type="inf_text_buffer_get_type"
               glib:type-struct="BufferInterface">
      <doc xml:space="preserve">#InfTextBuffer is an opaque data type. You should only access it
via the public API functions.</doc>
      <prerequisite name="Infinity.Buffer"/>
      <virtual-method name="create_begin_iter" invoker="create_begin_iter">
        <doc xml:space="preserve">Creates a #InfTextBufferIter pointing to the first segment of @buffer.
A #InfTextBufferIter is used to traverse the buffer contents in steps of
so-called segments each of which is written by the same user. The function
returns %NULL if there are no segments (i.e. the buffer is empty).

The iterator stays valid as long as the buffer remains unmodified and
must be freed with inf_text_buffer_destroy_iter() before.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
          <type name="BufferIter" c:type="InfTextBufferIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_end_iter" invoker="create_end_iter">
        <doc xml:space="preserve">Creates a #InfTextBufferIter pointing to the last segment of @buffer.
A #InfTextBufferIter is used to traverse the buffer contents in steps of
so-called segments each of which is written by the same user. The function
returns %NULL if there are no segments (i.e. the buffer is empty).

The iterator stays valid as long as the buffer remains unmodified and
must be freed with inf_text_buffer_destroy_iter() before.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
          <type name="BufferIter" c:type="InfTextBufferIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="destroy_iter" invoker="destroy_iter">
        <doc xml:space="preserve">Destroys a #InfTextBufferIter created by
inf_text_buffer_create_begin_iter() or inf_text_buffer_create_end_iter().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="full">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="erase_text" invoker="erase_text">
        <doc xml:space="preserve">Erases characters from the text buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to begin deleting characters from.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The amount of characters to delete.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_encoding" invoker="get_encoding">
        <doc xml:space="preserve">Returns the character encoding that the buffer uses. This means that all
#InfTextChunk return values are encoded in this encoding and all
#InfTextChunk parameters are expected to be encoded in that encoding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The character encoding for @buffer.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_length" invoker="get_length">
        <doc xml:space="preserve">Returns the number of characters in @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_slice" invoker="get_slice">
        <doc xml:space="preserve">Reads @len characters, starting at @pos, from the buffer, and returns them
as a #InfTextChunk.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextChunk.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">Character offset of where to start extracting.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">Number of characters to extract.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="insert_text">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_author" invoker="iter_get_author">
        <doc xml:space="preserve">Returns the user ID of the user that has written the segment @iter points
to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user ID of the user that wrote the segment @iter points
to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_bytes" invoker="iter_get_bytes">
        <doc xml:space="preserve">Returns the length of the segment @iter points to, in bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes of the segment @iter points to.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_length" invoker="iter_get_length">
        <doc xml:space="preserve">Returns the length of the segment @iter points to, in characters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of characters of the segment @iter points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_offset" invoker="iter_get_offset">
        <doc xml:space="preserve">Returns the offset of the first character in the segment @iter points
to, in characters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The offset of the first character in the segment @iter
points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_text" invoker="iter_get_text">
        <doc xml:space="preserve">Returns the text of the segment @iter points to. It is encoded in
@buffer's encoding (see inf_text_buffer_get_encoding()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The text of the segment @iter points to. Free
with g_free() when done using it.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_next" invoker="iter_next">
        <doc xml:space="preserve">Moves @iter to point to the next segment in the buffer. If @iter already
points to the last segment, @iter is left unmodified and the function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was moved.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_prev" invoker="iter_prev">
        <doc xml:space="preserve">Moves @iter to point to the previous segment in the buffer. If @iter
already points to the first segment, @iter is left unmodified and the
function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was moved.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="text_erased" invoker="text_erased">
        <doc xml:space="preserve">Emits the #InfTextBuffer::text-erased signal. This is meant to be used
by interface implementations in their @erase_text function, or when text
was erased by other means.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to begin deleting characters from.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk containing the erased text.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="text_inserted" invoker="text_inserted">
        <doc xml:space="preserve">Emits the #InfTextBuffer::text-inserted signal. This is meant to be used
by interface implementations in their @insert_text function, or when text
was inserted by other means.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @buffer.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser inserting @chunk, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_begin_iter"
              c:identifier="inf_text_buffer_create_begin_iter">
        <doc xml:space="preserve">Creates a #InfTextBufferIter pointing to the first segment of @buffer.
A #InfTextBufferIter is used to traverse the buffer contents in steps of
so-called segments each of which is written by the same user. The function
returns %NULL if there are no segments (i.e. the buffer is empty).

The iterator stays valid as long as the buffer remains unmodified and
must be freed with inf_text_buffer_destroy_iter() before.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
          <type name="BufferIter" c:type="InfTextBufferIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_end_iter"
              c:identifier="inf_text_buffer_create_end_iter">
        <doc xml:space="preserve">Creates a #InfTextBufferIter pointing to the last segment of @buffer.
A #InfTextBufferIter is used to traverse the buffer contents in steps of
so-called segments each of which is written by the same user. The function
returns %NULL if there are no segments (i.e. the buffer is empty).

The iterator stays valid as long as the buffer remains unmodified and
must be freed with inf_text_buffer_destroy_iter() before.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
          <type name="BufferIter" c:type="InfTextBufferIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy_iter" c:identifier="inf_text_buffer_destroy_iter">
        <doc xml:space="preserve">Destroys a #InfTextBufferIter created by
inf_text_buffer_create_begin_iter() or inf_text_buffer_create_end_iter().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="full">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="erase_text" c:identifier="inf_text_buffer_erase_text">
        <doc xml:space="preserve">Erases characters from the text buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to begin deleting characters from.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The amount of characters to delete.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_encoding" c:identifier="inf_text_buffer_get_encoding">
        <doc xml:space="preserve">Returns the character encoding that the buffer uses. This means that all
#InfTextChunk return values are encoded in this encoding and all
#InfTextChunk parameters are expected to be encoded in that encoding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The character encoding for @buffer.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="inf_text_buffer_get_length">
        <doc xml:space="preserve">Returns the number of characters in @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slice" c:identifier="inf_text_buffer_get_slice">
        <doc xml:space="preserve">Reads @len characters, starting at @pos, from the buffer, and returns them
as a #InfTextChunk.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextChunk.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">Character offset of where to start extracting.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">Number of characters to extract.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_chunk" c:identifier="inf_text_buffer_insert_chunk">
        <doc xml:space="preserve">Inserts a #InfTextChunk into @buffer. @user must not necessarily be the
author of @chunk (@chunk may even consist of multiple segments). This
happens when undoing a delete operation that erased another user's text.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @buffer.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser inserting @chunk, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_text" c:identifier="inf_text_buffer_insert_text">
        <doc xml:space="preserve">Inserts @text into @buffer as written by @author. @text must be encoded in
the character encoding of the buffer, see inf_text_buffer_get_encoding().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @buffer.
@text (type=guint8*) (array length=bytes) (transfer none): A pointer to
the text to insert.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">The length (in bytes) of @text.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length (in characters) of @text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser that has inserted the new text, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_author"
              c:identifier="inf_text_buffer_iter_get_author">
        <doc xml:space="preserve">Returns the user ID of the user that has written the segment @iter points
to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user ID of the user that wrote the segment @iter points
to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_bytes"
              c:identifier="inf_text_buffer_iter_get_bytes">
        <doc xml:space="preserve">Returns the length of the segment @iter points to, in bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes of the segment @iter points to.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_length"
              c:identifier="inf_text_buffer_iter_get_length">
        <doc xml:space="preserve">Returns the length of the segment @iter points to, in characters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of characters of the segment @iter points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_offset"
              c:identifier="inf_text_buffer_iter_get_offset">
        <doc xml:space="preserve">Returns the offset of the first character in the segment @iter points
to, in characters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The offset of the first character in the segment @iter
points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_text"
              c:identifier="inf_text_buffer_iter_get_text">
        <doc xml:space="preserve">Returns the text of the segment @iter points to. It is encoded in
@buffer's encoding (see inf_text_buffer_get_encoding()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The text of the segment @iter points to. Free
with g_free() when done using it.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_next" c:identifier="inf_text_buffer_iter_next">
        <doc xml:space="preserve">Moves @iter to point to the next segment in the buffer. If @iter already
points to the last segment, @iter is left unmodified and the function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was moved.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_prev" c:identifier="inf_text_buffer_iter_prev">
        <doc xml:space="preserve">Moves @iter to point to the previous segment in the buffer. If @iter
already points to the first segment, @iter is left unmodified and the
function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was moved.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_erased" c:identifier="inf_text_buffer_text_erased">
        <doc xml:space="preserve">Emits the #InfTextBuffer::text-erased signal. This is meant to be used
by interface implementations in their @erase_text function, or when text
was erased by other means.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position to begin deleting characters from.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk containing the erased text.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_inserted"
              c:identifier="inf_text_buffer_text_inserted">
        <doc xml:space="preserve">Emits the #InfTextBuffer::text-inserted signal. This is meant to be used
by interface implementations in their @insert_text function, or when text
was inserted by other means.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @buffer.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
          <parameter name="user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfUser inserting @chunk, or %NULL.</doc>
            <type name="Infinity.User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="text-erased" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="Chunk"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="Infinity.User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="text-inserted" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="Chunk"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="Infinity.User"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="BufferInterface"
            c:type="InfTextBufferInterface"
            glib:is-gtype-struct-for="Buffer">
      <doc xml:space="preserve">This structure contains virtual functions and signal handlers of the
#InfTextBuffer interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_encoding">
        <callback name="get_encoding">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The character encoding for @buffer.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_slice">
        <callback name="get_slice">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">Character offset of where to start extracting.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <doc xml:space="preserve">Number of characters to extract.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="insert_text">
        <callback name="insert_text">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="chunk" transfer-ownership="none">
              <type name="Chunk" c:type="InfTextChunk*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="Infinity.User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="erase_text">
        <callback name="erase_text">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">The position to begin deleting characters from.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <doc xml:space="preserve">The amount of characters to delete.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="user"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
              <type name="Infinity.User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_begin_iter">
        <callback name="create_begin_iter">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_end_iter">
        <callback name="create_end_iter">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #InfTextBufferIter to be freed by
inf_text_buffer_destroy_iter() when done using it, or %NULL.</doc>
            <type name="BufferIter" c:type="InfTextBufferIter*"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="destroy_iter">
        <callback name="destroy_iter">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="full">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_next">
        <callback name="iter_next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether @iter was moved.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_prev">
        <callback name="iter_prev">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether @iter was moved.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_text">
        <callback name="iter_get_text">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The text of the segment @iter points to. Free
with g_free() when done using it.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_offset">
        <callback name="iter_get_offset">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The offset of the first character in the segment @iter
points to.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_length">
        <callback name="iter_get_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of characters of the segment @iter points to.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_bytes">
        <callback name="iter_get_bytes">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of bytes of the segment @iter points to.</doc>
            <type name="gsize" c:type="gsize"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_author">
        <callback name="iter_get_author">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The user ID of the user that wrote the segment @iter points
to.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBufferIter pointing into @buffer.</doc>
              <type name="BufferIter" c:type="InfTextBufferIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="text_inserted">
        <callback name="text_inserted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">A character offset into @buffer.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="chunk" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextChunk.</doc>
              <type name="Chunk" c:type="InfTextChunk*"/>
            </parameter>
            <parameter name="user"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfUser inserting @chunk, or %NULL.</doc>
              <type name="Infinity.User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="text_erased">
        <callback name="text_erased">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextBuffer.</doc>
              <type name="Buffer" c:type="InfTextBuffer*"/>
            </parameter>
            <parameter name="pos" transfer-ownership="none">
              <doc xml:space="preserve">The position to begin deleting characters from.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="chunk" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextChunk containing the erased text.</doc>
              <type name="Chunk" c:type="InfTextChunk*"/>
            </parameter>
            <parameter name="user"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfUser that erases the text, or %NULL.</doc>
              <type name="Infinity.User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="BufferIter"
            c:type="InfTextBufferIter"
            disguised="1"
            foreign="1">
      <doc xml:space="preserve">#InfTextBufferIter is an opaque data type. You should only access it
via the public API functions.</doc>
    </record>
    <record name="Chunk"
            c:type="InfTextChunk"
            glib:type-name="InfTextChunk"
            glib:get-type="inf_text_chunk_get_type"
            c:symbol-prefix="chunk">
      <doc xml:space="preserve">#InfTextChunk is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_text_chunk_new">
        <doc xml:space="preserve">Creates a new #InfTextChunk with no initial content that holds text
in the given encoding. TODO: Allow binary data with %NULL encoding.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextChunk.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">A content encoding, such as "UTF-8" or "LATIN1".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="inf_text_chunk_copy">
        <doc xml:space="preserve">Returns a copy of @self.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextChunk.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="inf_text_chunk_equal">
        <doc xml:space="preserve">Returns whether the two text chunks contain the same text and the same
segments were written by the same authors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the two chunks are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
        </parameters>
      </method>
      <method name="erase" c:identifier="inf_text_chunk_erase">
        <doc xml:space="preserve">Removes @length characters of @self, starting from character offset @begin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @self.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">Number of characters to erase.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_text_chunk_free">
        <doc xml:space="preserve">Frees a #InfTextChunk allocated with inf_text_chunk_new(),
inf_text_chunk_copy() or inf_text_chunk_substring().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encoding" c:identifier="inf_text_chunk_get_encoding">
        <doc xml:space="preserve">Returns the character encoding in which the content of @self is encoded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The encoding of @self.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="inf_text_chunk_get_length">
        <doc xml:space="preserve">Returns the number of characters contained in @self.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of characters of @self.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text" c:identifier="inf_text_chunk_get_text">
        <doc xml:space="preserve">Returns the content of @self as an array. The text is encoded in
@self's encoding. @length is set to the number of bytes in the returned
buffer, if non-%NULL. The result is _not_ zero-terminated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Content of
@self. Free with g_free() if no longer in use.</doc>
          <array length="0" zero-terminated="0" c:type="gpointer">
            <type name="guint8" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Location to write the number of bytes to, or %NULL.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_chunk" c:identifier="inf_text_chunk_insert_chunk">
        <doc xml:space="preserve">Inserts @text into @self at position @offset. @text and @self must
have the same encoding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">Character offset at which to insert text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">Chunk to insert into @self.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_text" c:identifier="inf_text_chunk_insert_text">
        <doc xml:space="preserve">Inserts text written by @author into @self. @text is expected to be in
the chunk's encoding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">Character offset at which to insert text
@text (type const guint8*) (array length=bytes) (transfer none): Text
to insert.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">Number of bytes of @text.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">Number of characters contained in @text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="author" transfer-ownership="none">
            <doc xml:space="preserve">User that wrote @text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_init_begin"
              c:identifier="inf_text_chunk_iter_init_begin">
        <doc xml:space="preserve">Sets @iter to point to the first segment of @self. If there are no
segments (i.e. @self is empty), @iter is left untouched and the function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_init_end" c:identifier="inf_text_chunk_iter_init_end">
        <doc xml:space="preserve">Sets @iter to point to the last segment of @self. If there are no
segments (i.e. @self is empty), @iter is left untouched and the function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="substring" c:identifier="inf_text_chunk_substring">
        <doc xml:space="preserve">Returns a new #InfTextChunk containing a substring of @self, beginning
at character offset @begin and @length characters long.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextChunk.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunk.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">A character offset into @self.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The length of the text to extract.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ChunkIter"
            c:type="InfTextChunkIter"
            glib:type-name="InfTextChunkIter"
            glib:get-type="inf_text_chunk_iter_get_type"
            c:symbol-prefix="chunk_iter">
      <doc xml:space="preserve">#InfTextChunkIter is an opaque data type. You should only access it
via the public API functions.

#InfTextChunkIter can be safely allocated on the stack and copied by value.
Use inf_text_chunk_iter_init_begin() or inf_text_chunk_iter_init_end() to
initialize a #InfTextChunkIter. There is no deinitialization required. A
#InfTextChunkIter is valid as long as the chunk is not modified.</doc>
      <field name="chunk" readable="0" private="1">
        <type name="Chunk" c:type="InfTextChunk*"/>
      </field>
      <field name="first" readable="0" private="1">
        <type name="GLib.SequenceIter" c:type="GSequenceIter*"/>
      </field>
      <field name="second" readable="0" private="1">
        <type name="GLib.SequenceIter" c:type="GSequenceIter*"/>
      </field>
      <method name="copy" c:identifier="inf_text_chunk_iter_copy">
        <doc xml:space="preserve">Makes a dynamically-allocated copy of @iter. This is typically not needed
because #InfTextChunkIter can be copied by value, however it might be
useful to language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @iter. Free with
inf_text_chunk_iter_free().</doc>
          <type name="ChunkIter" c:type="InfTextChunkIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="const InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_text_chunk_iter_free">
        <doc xml:space="preserve">Frees all resources allocated with inf_text_chunk_iter_copy(). Must not
be used with stack-allocated #InfTextChunkIter&lt;!-- --&gt;s.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">The #InfTextChunkIter to free.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_author" c:identifier="inf_text_chunk_iter_get_author">
        <doc xml:space="preserve">Returns the user ID of the author of the segment @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user ID of the author of the segment @iter points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bytes" c:identifier="inf_text_chunk_iter_get_bytes">
        <doc xml:space="preserve">Returns the number of bytes in the segment @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes in the segment @iter points to.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="inf_text_chunk_iter_get_length">
        <doc xml:space="preserve">Returns the number of characters in the segment @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of characters in the segment @iter points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="inf_text_chunk_iter_get_offset">
        <doc xml:space="preserve">Returns the offset of the first character in the segment @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The offset of the first characters in the segment @iter
points to.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text" c:identifier="inf_text_chunk_iter_get_text">
        <doc xml:space="preserve">Returns the text of the segment @iter points to. The text is in the
underlaying #InfTextChunk's encoding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The text of the segment @iter points to.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="inf_text_chunk_iter_next">
        <doc xml:space="preserve">Sets @iter to point to the next segment. If @iter already points to the
last segment, the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter was set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prev" c:identifier="inf_text_chunk_iter_prev">
        <doc xml:space="preserve">Sets @iter to point to the previous segment. If @iter already points to
the first segment, the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter has changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #InfTextChunkIter.</doc>
            <type name="ChunkIter" c:type="InfTextChunkIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="DefaultBuffer"
           c:symbol-prefix="default_buffer"
           c:type="InfTextDefaultBuffer"
           parent="GObject.Object"
           glib:type-name="InfTextDefaultBuffer"
           glib:get-type="inf_text_default_buffer_get_type"
           glib:type-struct="DefaultBufferClass">
      <implements name="Buffer"/>
      <implements name="Infinity.Buffer"/>
      <constructor name="new" c:identifier="inf_text_default_buffer_new">
        <doc xml:space="preserve">Creates a new, empty #InfTextDefaultBuffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextDefaultBuffer.</doc>
          <type name="DefaultBuffer" c:type="InfTextDefaultBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">The character encoding to use for the buffer.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="encoding"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="DefaultBufferClass"
            c:type="InfTextDefaultBufferClass"
            glib:is-gtype-struct-for="DefaultBuffer">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="DefaultDeleteOperation"
           c:symbol-prefix="default_delete_operation"
           c:type="InfTextDefaultDeleteOperation"
           parent="GObject.Object"
           glib:type-name="InfTextDefaultDeleteOperation"
           glib:get-type="inf_text_default_delete_operation_get_type"
           glib:type-struct="DefaultDeleteOperationClass">
      <implements name="DeleteOperation"/>
      <implements name="Infinity.AdoptedOperation"/>
      <constructor name="new"
                   c:identifier="inf_text_default_delete_operation_new">
        <doc xml:space="preserve">Creates a new delete operation that, when applied, deletes the text @chunk
that starts at character offset @position in the buffer. The operation
cannot be applied, if there is some other text at that position in the
buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextDefaultDeleteOperation.</doc>
          <type name="DefaultDeleteOperation"
                c:type="InfTextDefaultDeleteOperation*"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">The position at which to delete text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">The text to delete.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_chunk"
              c:identifier="inf_text_default_delete_operation_get_chunk">
        <doc xml:space="preserve">Returns the text deleted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfTextChunk, owned by the operation.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDefaultDeleteOperation.</doc>
            <type name="DefaultDeleteOperation"
                  c:type="InfTextDefaultDeleteOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="chunk"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Chunk"/>
      </property>
      <property name="position"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="DefaultDeleteOperationClass"
            c:type="InfTextDefaultDeleteOperationClass"
            glib:is-gtype-struct-for="DefaultDeleteOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="DefaultInsertOperation"
           c:symbol-prefix="default_insert_operation"
           c:type="InfTextDefaultInsertOperation"
           parent="GObject.Object"
           glib:type-name="InfTextDefaultInsertOperation"
           glib:get-type="inf_text_default_insert_operation_get_type"
           glib:type-struct="DefaultInsertOperationClass">
      <implements name="InsertOperation"/>
      <implements name="Infinity.AdoptedOperation"/>
      <constructor name="new"
                   c:identifier="inf_text_default_insert_operation_new">
        <doc xml:space="preserve">Creates a new insert operation that, when applied, inserts @chunk
at @pos.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextDefaultInsertOperation.</doc>
          <type name="DefaultInsertOperation"
                c:type="InfTextDefaultInsertOperation*"/>
        </return-value>
        <parameters>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">The position at which to insert text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">The text to insert.</doc>
            <type name="Chunk" c:type="InfTextChunk*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_chunk"
              c:identifier="inf_text_default_insert_operation_get_chunk">
        <doc xml:space="preserve">Returns the text inserted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfTextChunk, owned by the operation.</doc>
          <type name="Chunk" c:type="InfTextChunk*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDefaultInsertOperation.</doc>
            <type name="DefaultInsertOperation"
                  c:type="InfTextDefaultInsertOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="chunk"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Chunk"/>
      </property>
      <property name="position"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="DefaultInsertOperationClass"
            c:type="InfTextDefaultInsertOperationClass"
            glib:is-gtype-struct-for="DefaultInsertOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="DeleteOperation"
               c:symbol-prefix="delete_operation"
               c:type="InfTextDeleteOperation"
               glib:type-name="InfTextDeleteOperation"
               glib:get-type="inf_text_delete_operation_get_type"
               glib:type-struct="DeleteOperationInterface">
      <doc xml:space="preserve">#InfTextDeleteOperation is an opaque data type. You should only access it
via the public API functions.</doc>
      <prerequisite name="Infinity.AdoptedOperation"/>
      <virtual-method name="get_length" invoker="get_length">
        <doc xml:space="preserve">Returns the number of characters deleted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_position" invoker="get_position">
        <doc xml:space="preserve">Returns the position at which @operation starts to delete dext.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The position of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_overlap" introspectable="0">
        <return-value>
          <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="begin" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="other_begin" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_position" introspectable="0">
        <return-value>
          <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_split" introspectable="0">
        <return-value>
          <type name="Infinity.AdoptedSplitOperation"
                c:type="InfAdoptedSplitOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="split_pos" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="split_length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_length"
              c:identifier="inf_text_delete_operation_get_length">
        <doc xml:space="preserve">Returns the number of characters deleted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_position"
              c:identifier="inf_text_delete_operation_get_position">
        <doc xml:space="preserve">Returns the position at which @operation starts to delete dext.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The position of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="need_concurrency_id"
              c:identifier="inf_text_delete_operation_need_concurrency_id">
        <doc xml:space="preserve">Returns whether transforming @op against @against requires a concurrency ID
(see inf_adopted_operation_need_concurrency_id() for further information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether transforming @op against @against requires a concurrency
ID.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedOperation.</doc>
            <type name="Infinity.AdoptedOperation"
                  c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_delete"
              c:identifier="inf_text_delete_operation_transform_delete">
        <doc xml:space="preserve">Returns a new operation that includes the effect of @against into
@operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedOperation.</doc>
          <type name="Infinity.AdoptedOperation"
                c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_insert"
              c:identifier="inf_text_delete_operation_transform_insert">
        <doc xml:space="preserve">Returns a new operation that includes the effect of @against into
@operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedOperation.</doc>
          <type name="Infinity.AdoptedOperation"
                c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="DeleteOperationInterface"
            c:type="InfTextDeleteOperationInterface"
            glib:is-gtype-struct-for="DeleteOperation">
      <doc xml:space="preserve">This structure contains virtual methods of the #InfTextDeleteOperation
interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_position">
        <callback name="get_position">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The position of @operation.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The length of @operation.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_position" introspectable="0">
        <callback name="transform_position" introspectable="0">
          <return-value>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
            <parameter name="position" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_overlap" introspectable="0">
        <callback name="transform_overlap" introspectable="0">
          <return-value>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
            <parameter name="other" transfer-ownership="none">
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
            <parameter name="position" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="begin" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="other_begin" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_split" introspectable="0">
        <callback name="transform_split" introspectable="0">
          <return-value>
            <type name="Infinity.AdoptedSplitOperation"
                  c:type="InfAdoptedSplitOperation*"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
            </parameter>
            <parameter name="split_pos" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="split_length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="FilesystemFormatError"
                 c:type="InfTextFilesystemFormatError">
      <doc xml:space="preserve">Errors that can occur when reading a #InfTextSession from a
#InfdFilesystemStorage.</doc>
      <member name="not_a_text_session"
              value="0"
              c:identifier="INF_TEXT_FILESYSTEM_FORMAT_ERROR_NOT_A_TEXT_SESSION">
        <doc xml:space="preserve">The file to be read
is not a serialized text session.</doc>
      </member>
      <member name="user_exists"
              value="1"
              c:identifier="INF_TEXT_FILESYSTEM_FORMAT_ERROR_USER_EXISTS">
        <doc xml:space="preserve">The user table of the
session contains users with duplicate ID or duplicate name.</doc>
      </member>
      <member name="no_such_user"
              value="2"
              c:identifier="INF_TEXT_FILESYSTEM_FORMAT_ERROR_NO_SUCH_USER">
        <doc xml:space="preserve">A segment of the text
document is written by a user which does not exist.</doc>
      </member>
    </enumeration>
    <class name="FixlineBuffer"
           c:symbol-prefix="fixline_buffer"
           c:type="InfTextFixlineBuffer"
           parent="GObject.Object"
           glib:type-name="InfTextFixlineBuffer"
           glib:get-type="inf_text_fixline_buffer_get_type"
           glib:type-struct="FixlineBufferClass">
      <doc xml:space="preserve">#InfTextFixlineBuffer is an opaque data type. You should only access it
via the public API functions.</doc>
      <implements name="Buffer"/>
      <implements name="Infinity.Buffer"/>
      <constructor name="new" c:identifier="inf_text_fixline_buffer_new">
        <doc xml:space="preserve">Creates a new #InfTextFixlineBuffer which keeps the number of trailing
lines of the given underlying buffer fixed to @n_lines.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfTextFixlineBuffer.</doc>
          <type name="FixlineBuffer" c:type="InfTextFixlineBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object to schedule timeouts.</doc>
            <type name="Infinity.Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The underlying buffer for which to keep a fixed line count.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </parameter>
          <parameter name="n_lines" transfer-ownership="none">
            <doc xml:space="preserve">The number of lines to be kept fixed.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="buffer"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Buffer"/>
      </property>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Infinity.Io"/>
      </property>
      <property name="lines"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="FixlineBufferClass"
            c:type="InfTextFixlineBufferClass"
            glib:is-gtype-struct-for="FixlineBuffer">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="InsertOperation"
               c:symbol-prefix="insert_operation"
               c:type="InfTextInsertOperation"
               glib:type-name="InfTextInsertOperation"
               glib:get-type="inf_text_insert_operation_get_type"
               glib:type-struct="InsertOperationInterface">
      <doc xml:space="preserve">#InfTextInsertOperation is an opaque data type. You should only access it
via the public API functions.</doc>
      <prerequisite name="Infinity.AdoptedOperation"/>
      <virtual-method name="get_length" invoker="get_length">
        <doc xml:space="preserve">Returns the length of the text inserted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_position" invoker="get_position">
        <doc xml:space="preserve">Returns the position at which @operation inserts text.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The position to insert text.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_position" introspectable="0">
        <return-value>
          <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_length"
              c:identifier="inf_text_insert_operation_get_length">
        <doc xml:space="preserve">Returns the length of the text inserted by @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_position"
              c:identifier="inf_text_insert_operation_get_position">
        <doc xml:space="preserve">Returns the position at which @operation inserts text.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The position to insert text.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="need_concurrency_id"
              c:identifier="inf_text_insert_operation_need_concurrency_id">
        <doc xml:space="preserve">Returns whether transforming @op against @against requires a concurrency ID
(see inf_adopted_operation_need_concurrency_id() for further information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether transforming @op against @against requires a concurrency
ID.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedOperation.</doc>
            <type name="Infinity.AdoptedOperation"
                  c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_delete"
              c:identifier="inf_text_insert_operation_transform_delete">
        <doc xml:space="preserve">Returns a new operation that includes the effect of @against into
@operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedOperation.</doc>
          <type name="Infinity.AdoptedOperation"
                c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextDeleteOperation.</doc>
            <type name="DeleteOperation" c:type="InfTextDeleteOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_insert"
              c:identifier="inf_text_insert_operation_transform_insert">
        <doc xml:space="preserve">Returns a new operation that includes the effect of @against into
@operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedOperation.</doc>
          <type name="Infinity.AdoptedOperation"
                c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfTextInsertOperation.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </parameter>
          <parameter name="op_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The given operation in a previous state, or %NULL.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </parameter>
          <parameter name="ag_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The @against operation in a previous state, or %NULL.</doc>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </parameter>
          <parameter name="cid" transfer-ownership="none">
            <doc xml:space="preserve">The concurrency ID for the transformation.</doc>
            <type name="Infinity.AdoptedConcurrencyId"
                  c:type="InfAdoptedConcurrencyId"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="InsertOperationInterface"
            c:type="InfTextInsertOperationInterface"
            glib:is-gtype-struct-for="InsertOperation">
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_position">
        <callback name="get_position">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The position to insert text.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
              <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The length of @operation.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfTextInsertOperation.</doc>
              <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_position" introspectable="0">
        <callback name="transform_position" introspectable="0">
          <return-value>
            <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="InsertOperation" c:type="InfTextInsertOperation*"/>
            </parameter>
            <parameter name="position" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="MoveOperation"
           c:symbol-prefix="move_operation"
           c:type="InfTextMoveOperation"
           parent="GObject.Object"
           glib:type-name="InfTextMoveOperation"
           glib:get-type="inf_text_move_operation_get_type"
           glib:type-struct="MoveOperationClass">
      <implements name="Infinity.AdoptedOperation"/>
      <constructor name="new" c:identifier="inf_text_move_operation_new">
        <doc xml:space="preserve">Creates a new move operation that, when applied, changes the caret and
selection of the applying user.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextMoveOperation.</doc>
          <type name="MoveOperation" c:type="InfTextMoveOperation*"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">The position to place the user's caret at.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The number of characters to select. Negative means selection
towards the beginning of the buffer.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="transform_delete"
                c:identifier="inf_text_move_operation_transform_delete">
        <doc xml:space="preserve">Changes *@move_position and *@move_length so that they point to the same
region when @delete_length characters are deleted starting from
@delete_position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delete_position" transfer-ownership="none">
            <doc xml:space="preserve">The position at which text is deleted.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="delete_length" transfer-ownership="none">
            <doc xml:space="preserve">The number of deleted characters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="move_position"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Points to the character offset to which the caret
is moved.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="move_length"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Points to the number of characters selected.
Negative means towards the beginning.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="transform_insert"
                c:identifier="inf_text_move_operation_transform_insert">
        <doc xml:space="preserve">Changes *@move_position and *@move_length so that they point to the same
region when @insert_length characters are inserted at @insert_position.

If text is inserted at the same position as @move_position, then
@move_position is kept at the position it currently is if @left_gravity is
%TRUE, otherwise it is shifted to the right.

If *@move_length is nonzero, then the selection length is never enlarged if
text is inserted at the selection bounds, not depending on whether
@left_gravity is set or not.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="insert_position" transfer-ownership="none">
            <doc xml:space="preserve">The position at which text is inserted.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="insert_length" transfer-ownership="none">
            <doc xml:space="preserve">The number of inserted characters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="move_position"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Points to the character offset to which the caret
is moved.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="move_length"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Points to the number of characters selected.
Negative means towards the beginning.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="left_gravity" transfer-ownership="none">
            <doc xml:space="preserve">Whether the move position and length have left gravity.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_length"
              c:identifier="inf_text_move_operation_get_length">
        <doc xml:space="preserve">Returns the length to which @operation changes the user's selection.
Negative means selection towards the beginning of the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of @operation.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextMoveOperation.</doc>
            <type name="MoveOperation" c:type="InfTextMoveOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_position"
              c:identifier="inf_text_move_operation_get_position">
        <doc xml:space="preserve">Returns the position at which @operation places the user's cursor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The position of @operation.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextMoveOperation.</doc>
            <type name="MoveOperation" c:type="InfTextMoveOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="length"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="position"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="MoveOperationClass"
            c:type="InfTextMoveOperationClass"
            glib:is-gtype-struct-for="MoveOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="OperationError" c:type="InfTextOperationError">
      <doc xml:space="preserve">Error codes that can occur when applying a #InfTextInsertOperation,
#InfTextDeleteOperation or #InfTextMoveOperation to the buffer.</doc>
      <member name="invalid_insert"
              value="0"
              c:identifier="INF_TEXT_OPERATION_ERROR_INVALID_INSERT">
        <doc xml:space="preserve">A #InfTextInsertOperation
attempted to insert text after the end of the buffer.</doc>
      </member>
      <member name="invalid_delete"
              value="1"
              c:identifier="INF_TEXT_OPERATION_ERROR_INVALID_DELETE">
        <doc xml:space="preserve">A #InfTextDeleteOperation
attempted to delete text from after the end of the buffer.</doc>
      </member>
      <member name="invalid_move"
              value="2"
              c:identifier="INF_TEXT_OPERATION_ERROR_INVALID_MOVE">
        <doc xml:space="preserve">A #InfTextMoveOperation attempted
to move the cursor of a user behind the end of the buffer.</doc>
      </member>
      <member name="failed"
              value="3"
              c:identifier="INF_TEXT_OPERATION_ERROR_FAILED">
        <doc xml:space="preserve">No further specified error code.</doc>
      </member>
    </enumeration>
    <class name="RemoteDeleteOperation"
           c:symbol-prefix="remote_delete_operation"
           c:type="InfTextRemoteDeleteOperation"
           parent="GObject.Object"
           glib:type-name="InfTextRemoteDeleteOperation"
           glib:get-type="inf_text_remote_delete_operation_get_type"
           glib:type-struct="RemoteDeleteOperationClass">
      <implements name="DeleteOperation"/>
      <implements name="Infinity.AdoptedOperation"/>
      <constructor name="new"
                   c:identifier="inf_text_remote_delete_operation_new">
        <doc xml:space="preserve">Creates a new delete operation that, when applied, deletes @length
characters starting from position @position. Note that this operation is
not reversible because it does not know the text to delete and is therefore
only used to transmit a delete operation through the network to reduce
bandwidth usage. The remote part can then reconstruct the deleted text
using inf_adopted_operation_apply_transformed().

However, it is easier to just use #InfTextDefaultDeleteOperation if you
want the operation to be reversible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextRemoteDeleteOperation.</doc>
          <type name="RemoteDeleteOperation"
                c:type="InfTextRemoteDeleteOperation*"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">The position at which to delete text.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The number of characters to delete.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="length"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="position"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="RemoteDeleteOperationClass"
            c:type="InfTextRemoteDeleteOperationClass"
            glib:is-gtype-struct-for="RemoteDeleteOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="InfTextSession"
           parent="Infinity.AdoptedSession"
           glib:type-name="InfTextSession"
           glib:get-type="inf_text_session_get_type"
           glib:type-struct="SessionClass">
      <implements name="Infinity.CommunicationObject"/>
      <constructor name="new" c:identifier="inf_text_session_new">
        <doc xml:space="preserve">Creates a new #InfTextSession. The communication manager is used to send
and receive requests from subscription and synchronization. @buffer will be
set to be initially empty if the session is initially synchronized
(see below). @io is required to trigger timeouts.

If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
session will initially be sychronized, meaning the initial content is
retrieved from @sync_connection. If you are subscribed to the session, set
the subscription group via inf_session_set_subscription_group().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextSession.</doc>
          <type name="Session" c:type="InfTextSession*"/>
        </return-value>
        <parameters>
          <parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="Infinity.CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">An initial #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </parameter>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object.</doc>
            <type name="Infinity.Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The initial status of the session.</doc>
            <type name="Infinity.SessionStatus" c:type="InfSessionStatus"/>
          </parameter>
          <parameter name="sync_group"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A group in which the session is synchronized.
Ignored if @status is %INF_SESSION_RUNNING.</doc>
            <type name="Infinity.CommunicationGroup"
                  c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="sync_connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A connection to synchronize the session
from. Ignored if @status is %INF_SESSION_RUNNING.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_user_table"
                   c:identifier="inf_text_session_new_with_user_table">
        <doc xml:space="preserve">Creates a new #InfTextSession. The connection manager is used to send and
receive requests from subscription and synchronization. @buffer will be
set to be initially empty if the session is initially synchronized
(see below). @io is required to trigger timeouts.

If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
session will initially be sychronized, meaning the initial content is
retrieved from @sync_connection. If you are subscribed to the session, set
the subscription group via inf_session_set_subscription_group().

@user_table is used as an initial user table. The user table should only
contain unavailable users, if any, that may rejoin during the session. If
there was an available user in the user table, it would probably belong
to another session, but different sessions cannot share the same user
object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextSession.</doc>
          <type name="Session" c:type="InfTextSession*"/>
        </return-value>
        <parameters>
          <parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="Infinity.CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">An initial #InfTextBuffer.</doc>
            <type name="Buffer" c:type="InfTextBuffer*"/>
          </parameter>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object.</doc>
            <type name="Infinity.Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="Infinity.UserTable" c:type="InfUserTable*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The initial status for the session.</doc>
            <type name="Infinity.SessionStatus" c:type="InfSessionStatus"/>
          </parameter>
          <parameter name="sync_group"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A group in which the session is synchronized.
Ignored if @status is %INF_SESSION_RUNNING.</doc>
            <type name="Infinity.CommunicationGroup"
                  c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="sync_connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A connection to synchronize the session
from. Ignored if @status is %INF_SESSION_RUNNING.</doc>
            <type name="Infinity.XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="join_user" c:identifier="inf_text_session_join_user">
        <doc xml:space="preserve">This functions creates a user join request for an #InfTextSession. This is
a shortcut for inf_session_proxy_join_user().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfRequest, or %NULL.</doc>
          <type name="Infinity.Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSessionProxy with a #InfTextSession session.</doc>
            <type name="Infinity.SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the user to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The initial status of the user to join. Must not be
@INF_USER_UNAVAILABLE.</doc>
            <type name="Infinity.UserStatus" c:type="InfUserStatus"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve">The user color of the user to join.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="caret_position" transfer-ownership="none">
            <doc xml:space="preserve">The initial position of the new user's cursor.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="selection_length" transfer-ownership="none">
            <doc xml:space="preserve">The initial length of the new user's selection.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve">Function to call after completion of the request,
or %NULL.</doc>
            <type name="Infinity.RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="flush_requests_for_user"
              c:identifier="inf_text_session_flush_requests_for_user">
        <doc xml:space="preserve">This function sends all pending requests for @user immediately. Requests
that modify the buffer are not queued normally, but cursor movement
requests are delayed in case are issued frequently, to save bandwidth.

The main purpose of this function is to send all pending requests before
changing a user's status to inactive or unavailable since inactive users
are automatically activated as soon as they issue a request.

TODO: We should probably detect this automatically, without requiring
people to call this function, i.e. flush requests for local users just
before they become inactive.

@user must have the %INF_USER_LOCAL flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextSession.</doc>
            <type name="Session" c:type="InfTextSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfTextUser for which to flush messages.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_color"
              c:identifier="inf_text_session_set_user_color">
        <doc xml:space="preserve">Changes the user color of @user. @user must have the %INF_USER_LOCAL flag
set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextSession.</doc>
            <type name="Session" c:type="InfTextSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfTextUser from @session's user table.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve">New hue value for @user's color. Ranges from 0.0 (red) to 1.0 (red).</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="caret-update-interval"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Infinity.AdoptedSession" c:type="InfAdoptedSession"/>
      </field>
    </class>
    <record name="SessionClass"
            c:type="InfTextSessionClass"
            glib:is-gtype-struct-for="Session">
      <field name="parent_class">
        <type name="Infinity.AdoptedSessionClass"
              c:type="InfAdoptedSessionClass"/>
      </field>
    </record>
    <enumeration name="SessionError" c:type="InfTextSessionError">
      <member name="invalid_hue"
              value="0"
              c:identifier="INF_TEXT_SESSION_ERROR_INVALID_HUE">
      </member>
      <member name="failed"
              value="1"
              c:identifier="INF_TEXT_SESSION_ERROR_FAILED">
      </member>
    </enumeration>
    <class name="UndoGrouping"
           c:symbol-prefix="undo_grouping"
           c:type="InfTextUndoGrouping"
           parent="Infinity.AdoptedUndoGrouping"
           glib:type-name="InfTextUndoGrouping"
           glib:get-type="inf_text_undo_grouping_get_type"
           glib:type-struct="UndoGroupingClass">
      <doc xml:space="preserve">#InfTextUndoGrouping is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_text_undo_grouping_new">
        <doc xml:space="preserve">Creates a new #InfTextUndoGrouping.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextUndoGrouping. To be freed with
g_object_unref().</doc>
          <type name="UndoGrouping" c:type="InfTextUndoGrouping*"/>
        </return-value>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Infinity.AdoptedUndoGrouping"
              c:type="InfAdoptedUndoGrouping"/>
      </field>
    </class>
    <record name="UndoGroupingClass"
            c:type="InfTextUndoGroupingClass"
            glib:is-gtype-struct-for="UndoGrouping">
      <field name="parent_class" readable="0" private="1">
        <type name="Infinity.AdoptedUndoGroupingClass"
              c:type="InfAdoptedUndoGroupingClass"/>
      </field>
    </record>
    <class name="User"
           c:symbol-prefix="user"
           c:type="InfTextUser"
           parent="Infinity.AdoptedUser"
           glib:type-name="InfTextUser"
           glib:get-type="inf_text_user_get_type"
           glib:type-struct="UserClass">
      <constructor name="new" c:identifier="inf_text_user_new">
        <doc xml:space="preserve">Creates a new #InfTextUser. @id should be unique for all users working
together. #InfUserTable will refuse to add users with duplicate id. If
@vector is %NULL, then the vector with all components zero is used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTextUser. Free with g_object_unref()
when no longer needed.</doc>
          <type name="User" c:type="InfTextUser*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The user ID for this user.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The user's name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="vector"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The state at which the user is at, or %NULL.</doc>
            <type name="Infinity.AdoptedStateVector"
                  c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve">The hue value of the user's color.</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="selection_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfTextUser*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="by_request" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_caret_position"
              c:identifier="inf_text_user_get_caret_position">
        <doc xml:space="preserve">Returns the position of @user's caret.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@user's caret position.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextUser.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hue" c:identifier="inf_text_user_get_hue">
        <doc xml:space="preserve">Returns the hue of the user's color as a double ranging from 0 to 1.
The other components (saturation and lightness) are not specific to the
user and may be chosen indivudually to optimize the actual visual display.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The hue of the @user's color.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextUser.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_selection_length"
              c:identifier="inf_text_user_get_selection_length">
        <doc xml:space="preserve">Returns the number of characters this user has selected, starting from
the caret position. Negative number mean selection towards the beginning
of the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@user's selection length in characters.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextUser.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_selection" c:identifier="inf_text_user_set_selection">
        <doc xml:space="preserve">Changes @user's selection (i.e. caret position and selection length). The
@by_request parameter should be set to %TRUE if the selection change was
requested explicitly, for example by the user actively moving the cursor
using the mouse or the keyboard. If the cursor position changes only
because another user inserted text at a position before the user's cursor
and this results in a change of the selection position, the @by_request
parameter should be set to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTextUser.</doc>
            <type name="User" c:type="InfTextUser*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">The new position for the user's caret.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The number of characters to select. Negative numbers mean
selection towards the beginning.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="by_request" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if explicitly requested or %FALSE when just an effect
of another operation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="caret-position"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hue"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="selection-length"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="Infinity.AdoptedUser" c:type="InfAdoptedUser"/>
      </field>
      <glib:signal name="selection-changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="UserClass"
            c:type="InfTextUserClass"
            glib:is-gtype-struct-for="User">
      <field name="parent_class">
        <type name="Infinity.AdoptedUserClass" c:type="InfAdoptedUserClass"/>
      </field>
      <field name="selection_changed">
        <callback name="selection_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfTextUser*"/>
            </parameter>
            <parameter name="position" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="by_request" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function name="filesystem_format_read"
              c:identifier="inf_text_filesystem_format_read"
              throws="1">
      <doc xml:space="preserve">Reads a text session from @path in @storage. The file is expected to have
been saved with inf_text_filesystem_format_write() before. The @user_table
parameter should be an empty user table that will be used for the session,
and the @buffer parameter should be an empty #InfTextBuffer, and the
document will be written into this buffer. If the function succeeds, the
user table and buffer can be used to create an #InfTextSession with
inf_text_session_new_with_user_table(). If the function fails, %FALSE is
returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="storage" transfer-ownership="none">
          <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
          <type name="Infinityd.FilesystemStorage"
                c:type="InfdFilesystemStorage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Storage path to retrieve the session from.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_table" transfer-ownership="none">
          <doc xml:space="preserve">An empty #InfUserTable to use as the new session's user table.</doc>
          <type name="Infinity.UserTable" c:type="InfUserTable*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">An empty #InfTextBuffer to use as the new session's buffer.</doc>
          <type name="Buffer" c:type="InfTextBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filesystem_format_write"
              c:identifier="inf_text_filesystem_format_write"
              throws="1">
      <doc xml:space="preserve">Writes the given user table and buffer into the filesystem storage at
@path. If successful, the session can then be read back with
inf_text_filesystem_format_read(). If the function fails, %FALSE is
returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="storage" transfer-ownership="none">
          <doc xml:space="preserve">A #InfdFilesystemStorage.</doc>
          <type name="Infinityd.FilesystemStorage"
                c:type="InfdFilesystemStorage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Storage path where to write the session to.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_table" transfer-ownership="none">
          <doc xml:space="preserve">The #InfUserTable to write.</doc>
          <type name="Infinity.UserTable" c:type="InfUserTable*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">The #InfTextBuffer to write.</doc>
          <type name="Buffer" c:type="InfTextBuffer*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
