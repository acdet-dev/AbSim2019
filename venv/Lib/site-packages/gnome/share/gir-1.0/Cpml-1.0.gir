<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="cairo" version="1.0"/>
  <c:include name="cpml.h"/>
  <namespace name="Cpml"
             version="1.0"
             shared-library="libcpml-1-2.dll"
             c:identifier-prefixes="Cpml"
             c:symbol-prefixes="cpml">
    <alias name="Vector" c:type="CpmlVector">
      <doc xml:space="preserve">Another name for #CpmlPair. It is used to clarify when a function
expects a generic pair (usually coordinates) or a vector.

A vector represents a line starting from the origin (0,0) and ending
to the given coordinates pair. Vectors are useful to define direction
and length at once. Keep in mind the cairo default coordinates system
is not problably what you expect: the x axis increases at right
(as usual) but the y axis increases at down (the reverse of a usual
cartesian plan). An angle of 0 is at V=(1; 0) (middle right).</doc>
      <type name="Pair" c:type="CpmlPair"/>
    </alias>
    <constant name="ARC" value="19" c:type="CPML_ARC">
      <type name="PrimitiveType" c:type="CpmlPrimitiveType"/>
    </constant>
    <enumeration name="CurveOffsetAlgorithm"
                 version="1.0"
                 glib:type-name="CpmlCurveOffsetAlgorithm"
                 glib:get-type="cpml_curve_offset_algorithm_get_type"
                 c:type="CpmlCurveOffsetAlgorithm">
      <doc xml:space="preserve">Enumeration of all available algorithms for offsetting the B(t) cubic
Bézier curve.

The geometrical algorithm offset the control polygon, further applying a
factor of 4/3 on the control points along the vector normal to B(0.5). That
factor mix well with curves approximating arcs (the most common case). It
is a stable algorithm, i.e. it can be used for every Bézier.

The handcraft algorithm offsets the point at B(0.5) and it forces the
condition the offset curve at t=0.5 must pass through that point. If it
fails, falls back to geometrical.

The BAIOCA algorithm offsets a specific set of t values and try to minimize
the error between those points and the offset curve at the same t values.
If it fails, falls back to geometrical. By default the set of t values is
{ 0, 0.25, 0.5, 0.75, 1 }. As implied by this description, using the set
{ 0, 0.5, 1 } is logically equivalent to the handcraft algorithm.

The default algorith is #CPML_CURVE_OFFSET_ALGORITHM_HANDCRAFT.</doc>
      <member name="none"
              value="0"
              c:identifier="CPML_CURVE_OFFSET_ALGORITHM_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unknown or no specific algorithm</doc>
      </member>
      <member name="default"
              value="1"
              c:identifier="CPML_CURVE_OFFSET_ALGORITHM_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">default algorithm</doc>
      </member>
      <member name="handcraft"
              value="3"
              c:identifier="CPML_CURVE_OFFSET_ALGORITHM_HANDCRAFT"
              glib:nick="handcraft">
        <doc xml:space="preserve">handcraft algorithm</doc>
      </member>
      <member name="baioca"
              value="4"
              c:identifier="CPML_CURVE_OFFSET_ALGORITHM_BAIOCA"
              glib:nick="baioca">
        <doc xml:space="preserve">B.A.I.O.C.A. algorithm</doc>
      </member>
    </enumeration>
    <record name="Extents" c:type="CpmlExtents" version="1.0">
      <doc xml:space="preserve">A structure defining a bounding box area. These APIs expect the
size of the extents to be always positives, so be careful while
directly accessing the @size field.</doc>
      <field name="is_defined" writable="1">
        <doc xml:space="preserve">set to 0 when these extents are undefined</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="org" writable="1">
        <doc xml:space="preserve">the lowest x,y coordinates</doc>
        <type name="Pair" c:type="CpmlPair"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve">the width (x) and height (y) of the extents</doc>
        <type name="Vector" c:type="CpmlVector"/>
      </field>
      <method name="add" c:identifier="cpml_extents_add" version="1.0">
        <doc xml:space="preserve">Merges @extents and @src and store the result in @extents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">the destination #CpmlExtents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the extents to add</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="cpml_extents_equal" version="1.0">
        <doc xml:space="preserve">Compares @extents to @src and returns 1 if the extents are equals.
Two &lt;constant&gt;NULL&lt;/constant&gt; or two undefined extents are considered equal,
although &lt;constant&gt;NULL&lt;/constant&gt; extents are not equal to undefined extents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @extents is equal to @src, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the first extents to compare</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the second extents to compare</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_inside"
              c:identifier="cpml_extents_is_inside"
              version="1.0">
        <doc xml:space="preserve">Checks wheter @src is enterely contained by @extents. If @extents
is undefined, 0 will be returned. If @src is undefined, 1 will
be returned. The border of @extents is considered inside.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @src is totally inside @extents, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the container #CpmlExtents</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the subject #CpmlExtents</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pair_add"
              c:identifier="cpml_extents_pair_add"
              version="1.0">
        <doc xml:space="preserve">Extends @extents, if required, to include @src. If @extents is
undefined, the origin of @extents is set to @src and its size
will be (0,0).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">the source and destination #CpmlExtents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlPair to add</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pair_is_inside"
              c:identifier="cpml_extents_pair_is_inside"
              version="1.0">
        <doc xml:space="preserve">Checks wheter @src is inside @extents. If @extents is undefined,
0 will be returned. The border of @extents is considered inside.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @src is inside @extents, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the container #CpmlExtents</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the subject #CpmlPair</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform"
              c:identifier="cpml_extents_transform"
              version="1.0">
        <doc xml:space="preserve">Transforms the four corners of @extents with @matrix and
recomputes @extents. This will logically equivalent to transform
an extents box and gets the extents of the resulting shape.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="extents"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">the container #CpmlExtents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the transformation matrix</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="copy" c:identifier="cpml_extents_copy" version="1.0">
        <doc xml:space="preserve">Copies @src in @extents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="extents"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlExtents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source #CpmlExtents</doc>
            <type name="Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_cairo_text"
                c:identifier="cpml_extents_from_cairo_text"
                version="1.0">
        <doc xml:space="preserve">Converts @cairo_extents in a #CpmlExtents format and stores the
result in @extents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="extents"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlExtents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </parameter>
          <parameter name="cairo_extents" transfer-ownership="none">
            <doc xml:space="preserve">the source #cairo_text_extents_t</doc>
            <type name="gpointer" c:type="cairo_text_extents_t*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Pair"
            c:type="CpmlPair"
            version="1.0"
            glib:type-name="CpmlPair"
            glib:get-type="cpml_pair_get_type"
            c:symbol-prefix="pair">
      <doc xml:space="preserve">A generic 2D structure.</doc>
      <field name="x" writable="1">
        <doc xml:space="preserve">the x component of the pair</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve">the y component of the pair</doc>
        <type name="gdouble" c:type="double"/>
      </field>
      <method name="copy" c:identifier="cpml_pair_copy" version="1.0">
        <doc xml:space="preserve">Copies @src in @pair. If @src or @pair is &lt;constant&gt;NULL&lt;/constant&gt;,
this function does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </instance-parameter>
          <parameter name="src"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the source #CpmlPair</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="distance" c:identifier="cpml_pair_distance" version="1.0">
        <doc xml:space="preserve">Gets the distance between @from and @to. If you need this value only
for comparation purpose, you could use cpml_pair_squared_distance()
instead.

@from or @to could be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the
fallback &lt;constant&gt;(0, 0)&lt;/constant&gt; pair will be used.

The algorithm used is adapted from:
"Replacing Square Roots by Pythagorean Sums"
by Clave Moler and Donald Morrison (1983)
IBM Journal of Research and Development 27 (6): 577–581
http://www.research.ibm.com/journal/rd/276/ibmrd2706P.pdf</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="from"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the first #CpmlPair struct</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </instance-parameter>
          <parameter name="to"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second #CpmlPair struct</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="cpml_pair_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @pair.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the duplicate of @pair: must be freed with g_free() when no longer needed.</doc>
          <type name="Pair" c:type="CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPair structure</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="cpml_pair_equal" version="1.0">
        <doc xml:space="preserve">Compares @pair to @src and returns 1 if the pairs are equals.
Two &lt;constant&gt;NULL&lt;/constant&gt; pairs are considered equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @pair is equal to @src, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the first pair to compare</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </instance-parameter>
          <parameter name="src"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second pair to compare</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="from_cairo"
              c:identifier="cpml_pair_from_cairo"
              version="1.0">
        <doc xml:space="preserve">Sets @pair from a #cairo_path_data_t struct. @path_data should contains
a point data: it is up to the caller to be sure @path_data is valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </instance-parameter>
          <parameter name="path_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the original path data point</doc>
            <type name="gpointer" c:type="cairo_path_data_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="squared_distance"
              c:identifier="cpml_pair_squared_distance"
              version="1.0">
        <doc xml:space="preserve">Gets the squared distance between @from and @to. This value is useful
for comparation purpose: if you need to get the real distance, use
cpml_pair_distance().

@from or @to could be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the
fallback &lt;constant&gt;(0, 0)&lt;/constant&gt; pair will be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the squared distance</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="from"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the first #CpmlPair struct</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </instance-parameter>
          <parameter name="to"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second #CpmlPair struct</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_cairo" c:identifier="cpml_pair_to_cairo" version="1.0">
        <doc xml:space="preserve">Sets a #cairo_path_data_t struct to @pair. This is exactly the reverse
operation of cpml_pair_from_cairo().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the source #CpmlPair</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </instance-parameter>
          <parameter name="path_data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the path data point to modify</doc>
            <type name="gpointer" c:type="cairo_path_data_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform"
              c:identifier="cpml_pair_transform"
              version="1.0">
        <doc xml:space="preserve">Shortcut to apply a specific transformation matrix to @pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair struct</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </instance-parameter>
          <parameter name="matrix"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the transformation matrix</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Primitive"
            c:type="CpmlPrimitive"
            version="1.0"
            glib:type-name="CpmlPrimitive"
            glib:get-type="cpml_primitive_get_type"
            c:symbol-prefix="primitive">
      <doc xml:space="preserve">As for #CpmlSegment, also the primitive is unobtrusive. This
means CpmlPrimitive does not include any coordinates but instead
keeps pointers to the original segment (and, by transition, to
the underlying #cairo_data_path_t struct).</doc>
      <field name="segment" writable="1">
        <doc xml:space="preserve">the source #CpmlSegment</doc>
        <type name="Segment" c:type="CpmlSegment*"/>
      </field>
      <field name="org" introspectable="0" writable="1">
        <doc xml:space="preserve">a pointer to the first point of the primitive</doc>
        <type c:type="cairo_path_data_t*"/>
      </field>
      <field name="data" introspectable="0" writable="1">
        <doc xml:space="preserve">the array of the path data, prepended by the header</doc>
        <type c:type="cairo_path_data_t*"/>
      </field>
      <method name="copy_data"
              c:identifier="cpml_primitive_copy_data"
              version="1.0">
        <doc xml:space="preserve">Copies the memory referenced by the &lt;structfield&gt;org&lt;/structfield&gt;
and &lt;structfield&gt;data&lt;/structfield&gt; fields from @src to @primitive.
For a shallow copy, check out cpml_primitive_copy().

This could seem a somewhat unusual operation because @primitive
should contain the same primitive as @src (i.e., the
&lt;structfield&gt;data-&gt;header&lt;/structfield&gt; field must be the same)
but it can be convenient in some situation, such as when restoring
the original data from a backup primitive, e.g.:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
CpmlPrimitive *backup;

backup = cpml_primitive_deep_dup(&amp;primitive);
// Now &amp;primitive points can be freely modified
...
// Let's restore &amp;primitive original points
cpml_primitive_copy_data(&amp;primitive, backup);
g_free(backup);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if the data has been succesfully copied, 0 on errors.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source primitive to copy</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deep_dup"
              c:identifier="cpml_primitive_deep_dup"
              version="1.0">
        <doc xml:space="preserve">Duplicates @primitive. This function makes a deep duplication of
@primitive, that is it duplicates also the definition data (both
&lt;structfield&gt;org&lt;/structfield&gt; and &lt;structfield&gt;data&lt;/structfield&gt;).

Furthermore, the new &lt;structfield&gt;segment&lt;/structfield&gt; field will
point to a fake duplicated segment with only its first primitive
set (the first primitive of a segment should be a #CPML_MOVE).
This is needed in order to let a #CPML_CLOSE work as expected.

All the data is allocated in the same chunk of memory so freeing
the returned pointer releases all the occupied memory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a deep duplicate of @primitive: must be
                          freed with g_free() when no longer needed</doc>
          <type name="Primitive" c:type="CpmlPrimitive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive structure</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="cpml_primitive_dump" version="1.0">
        <doc xml:space="preserve">Dumps info on the specified @primitive to stdout: useful for
debugging purposes. If @org_also is 1, a #CPML_MOVE to the
origin is prepended to the data otherwise the
&lt;structfield&gt;org&lt;/structfield&gt; field is not used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="org_also" transfer-ownership="none">
            <doc xml:space="preserve">whether to output also the origin coordinates</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="cpml_primitive_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @primitive. This function makes a shallow duplication of
@primitives, that is the internal pointers of the resulting primitive
struct refer to the same memory as the original @primitive. Check
out cpml_primitive_deep_dup() if it is required also the content
duplication.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a shallow duplicate of @primitive: must be
                          freed with g_free() when no longer needed.</doc>
          <type name="Primitive" c:type="CpmlPrimitive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive structure</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_closest_pos"
              c:identifier="cpml_primitive_get_closest_pos"
              version="1.0">
        <doc xml:space="preserve">Returns the pos value of the point on @primitive nearest to @pair.
The returned value is always clamped between 0 and 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested pos value between 0 and 1, or -1 on errors.

&lt;!-- Virtual: get_closest_pos --&gt;</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates of the subject point</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="cpml_primitive_get_length"
              version="1.0">
        <doc xml:space="preserve">Abstracts the length() family functions by providing a common
way to access the underlying primitive-specific implementation.
The function returns the length of @primitive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested length or 0 on errors

&lt;!-- Virtual: get_length --&gt;</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_points"
              c:identifier="cpml_primitive_get_n_points"
              version="1.0">
        <doc xml:space="preserve">Gets the number of points required to identify @primitive.
It is similar to cpml_primitive_type_get_n_points() but using
a @primitive instance instead of a type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of points or 0 on errors.

&lt;!-- Virtual: n_points --&gt;</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_inside"
              c:identifier="cpml_primitive_is_inside"
              version="1.0">
        <doc xml:space="preserve">Checks if @pair is inside the bounding box of @primitive. This
can be useful e.g. to verify if an intersection point is a real
intersection or an hypothetical one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @pair is inside the bounding box of @primitive, 0 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates of the subject point</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="join" c:identifier="cpml_primitive_join" version="1.0">
        <doc xml:space="preserve">Joins two primitive modifying the end point of @primitive and the
start point of @primitive2 so that the resulting points will overlap.

&lt;important&gt;
&lt;title&gt;TODO&lt;/title&gt;
&lt;itemizedlist&gt;
&lt;listitem&gt;Actually, the join is done by extending the end vector
          of @primitive and the start vector of @primitive2 and
          interpolating the intersection: this means no primitive
          dependent code is needed. Anyway, it is likely to change
          in the future because this approach is quite naive when
          curves are involved.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/important&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 on success, 0 if the primitives cannot be joined.

&lt;!-- Virtual: join --&gt;</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">the first #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="primitive2"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the second #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="cpml_primitive_next" version="1.0">
        <doc xml:space="preserve">Changes @primitive so it refers to the next primitive on the
source segment. If there are no more primitives, @primitive is
not changed and 0 is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 on success, 0 if no next primitive found or errors.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="cpml_primitive_offset" version="1.0">
        <doc xml:space="preserve">Given a primitive, computes the same (or approximated) parallel
primitive distant @offset from the original one and returns
the result by changing @primitive.

On errors, that is if the offset primitive cannot be calculated
for some reason, this function does nothing.

&lt;!-- Virtual: offset --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">distance for the computed offset primitive</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_extents"
              c:identifier="cpml_primitive_put_extents"
              version="1.0">
        <doc xml:space="preserve">Abstracts the extents() family functions by providing a common
way to access the underlying primitive-specific implementation.

This function stores in @extents the bounding box of @primitive.

On errors, that is if the extents cannot be calculated for some
reason, this function does nothing.

&lt;!-- Virtual: put_extents --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="extents"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">where to store the extents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_intersections"
              c:identifier="cpml_primitive_put_intersections"
              version="1.0">
        <doc xml:space="preserve">Finds the intersection points between the given primitives and
returns the result in @dest. The size of @dest should be enough
to store @n_dest #CpmlPair. The maximum number of intersections
is dependent on the type of the primitive involved in the
operation. If there are at least one Bézier curve involved, up to
4 intersections could be returned. Otherwise, if there is an arc
the intersections will be 2 at maximum. For line primitives, there
is only 1 point (or 0 if the lines are parallel).

Also hypothetical intersections are returned, that is intersections
made by extending the primitives outside their bounds. This means e.g.
two lines always return one intersection if they are not parallel. To
discriminate real intersections you should check the returned points
with cpml_primitive_is_inside(), for example:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
if (cpml_primitive_put_intersections(line1, line2, 1, &amp;pair) == 0) {
    // line1 and line2 are parallels
} else if (cpml_primitive_is_inside(line1, &amp;pair) &amp;&amp;
           cpml_primitive_is_inside(line2, &amp;pair)) {
    // This is a real intersection
} else {
    // This is an hypothetical intersection
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;note&gt;
&lt;para&gt;
The convention used by the CPML library is that a primitive should
implement only the intersection algorithms with lower degree
primitives. This is required to avoid code duplication: intersection
between arc and Bézier curves must be implemented by #CPML_CURVE and
intersection between lines and arcs must be implemented by #CPML_ARC.
cpml_primitive_put_intersections() will take care of swapping the
arguments if they are not properly ordered.
&lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of intersection points found or 0 if the
         primitives do not intersect or on errors

&lt;!-- Virtual: put_intersections --&gt;</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">the first #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="primitive2" transfer-ownership="none">
            <doc xml:space="preserve">the second #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </parameter>
          <parameter name="n_dest"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">maximum number of intersections to return</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination buffer that can contain @n_dest #CpmlPair</doc>
            <array length="1" zero-terminated="0" c:type="CpmlPair*">
              <type name="Pair" c:type="CpmlPair"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_intersections_with_segment"
              c:identifier="cpml_primitive_put_intersections_with_segment"
              version="1.0">
        <doc xml:space="preserve">Computes the intersections between @segment and @primitive by
sequentially scanning the primitives in @segment and looking
for their intersections with @primitive.

If the intersections are more than @n_dest, only the first
@n_dest pairs are stored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of intersections found</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </parameter>
          <parameter name="n_dest"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">maximum number of intersections to return</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination buffer that can contain @n_dest #CpmlPair</doc>
            <array length="1" zero-terminated="0" c:type="CpmlPair*">
              <type name="Pair" c:type="CpmlPair"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_pair_at"
              c:identifier="cpml_primitive_put_pair_at"
              version="1.0">
        <doc xml:space="preserve">Abstracts the &lt;function&gt;put_pair_at&lt;/function&gt; family functions by
providing a common way to access the underlying primitive-specific
implementation.

It gets the coordinates of the point lying on @primitive
at position @pos. @pos is an homogeneous factor where 0 is the
start point, 1 the end point, 0.5 the mid point and so on.
@pos can be less than 0 or greater than 1, in which case the
coordinates of @pair are interpolated.

On errors, that is if the coordinates cannot be calculated for
some reason, this function does nothing.

&lt;!-- Virtual: put_pair_at --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="pair"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_point"
              c:identifier="cpml_primitive_put_point"
              version="1.0">
        <doc xml:space="preserve">Gets the specified @n_point from @primitive and stores it into
@pair. The @n_point index is subject to the same rules explained
in the cpml_primitive_set_point() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if the point is found, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="n_point" transfer-ownership="none">
            <doc xml:space="preserve">the index of the point to retrieve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="pair"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_vector_at"
              c:identifier="cpml_primitive_put_vector_at"
              version="1.0">
        <doc xml:space="preserve">Abstracts the &lt;function&gt;put_vector_at&lt;/function&gt; family functions by
providing a common way to access the underlying primitive-specific
implementation.

It gets the steepness of the point at position @pos on @primitive.
@pos is an homogeneous factor where 0 is the start point, 1 the
end point, 0.5 the mid point and so on.
@pos can be less than 0 or greater than 1, in which case the
coordinates of @pair are interpolated.

On errors, that is if the steepness cannot be calculated for
some reason, this function does nothing.

&lt;!-- Virtual: put_vector_at --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="vector"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlVector</doc>
            <type name="Vector" c:type="CpmlVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="cpml_primitive_reset" version="1.0">
        <doc xml:space="preserve">Resets @primitive so it refers to the first primitive of the
source segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_point"
              c:identifier="cpml_primitive_set_point"
              version="1.0">
        <doc xml:space="preserve">Sets the specified @n_point of @primitive to @pair. The @n_point
index starts from 0: if @n_point is 0, the start point (the origin)
is changed, 1 for the second point and so on. If @n_point is
negative, it is considered as a negative index from the end, so
that -1 is the end point, -2 the point before the end point and
so on.

#CPML_CLOSE is managed in a special way: if @n_point
is -1 or 1 and @primitive is a close-path, this function cycles
the source #CpmlSegment and returns the first point. This is
needed because requesting the end point (or the second point)
of a close path is a valid operation and must returns the origin
of the segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if the point to be set is existent, 0 otherwise.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="n_point" transfer-ownership="none">
            <doc xml:space="preserve">the index of the point to retrieve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the source #CpmlPair</doc>
            <type name="Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_cairo"
              c:identifier="cpml_primitive_to_cairo"
              version="1.0">
        <doc xml:space="preserve">Renders a single @primitive to the @cr cairo context.
As a special case, if the primitive is a #CPML_CLOSE, an
equivalent line is rendered, because a close path left alone
is not renderable.

Also a #CPML_ARC primitive is treated specially, as it is not
natively supported by cairo and has its own rendering API.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </instance-parameter>
          <parameter name="cr"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the destination cairo context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="copy" c:identifier="cpml_primitive_copy" version="1.0">
        <doc xml:space="preserve">Copies @src in @primitive. This is a shallow copy: the internal fields
of @primitive refer to the same memory as the original @src primitive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="primitive"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPrimitive</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source #CpmlPrimitive</doc>
            <type name="Primitive" c:type="const CpmlPrimitive*"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_segment"
                c:identifier="cpml_primitive_from_segment"
                version="1.0">
        <doc xml:space="preserve">Initializes @primitive to the first primitive of @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="primitive"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPrimitive struct</doc>
            <type name="Primitive" c:type="CpmlPrimitive*"/>
          </parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the source segment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="PrimitiveType"
                 version="1.0"
                 glib:type-name="CpmlPrimitiveType"
                 glib:get-type="cpml_primitive_type_get_type"
                 c:type="CpmlPrimitiveType">
      <doc xml:space="preserve">This is a type compatible with #cairo_path_data_type_t type. It is
basically the same enum but it embodies an important difference:
it can be used to specify the special #CPML_ARC primitive. Having
two different types is a good way to make clear when a function
expect or not embedded #CPML_ARC primitives.

Arcs are used extensively in technical drawing: some operations are
trivials with arcs and a nightmare with cubic Bézier curves. Actually,
at least up to version 1.10.2, the cairo library does not support arc
primitives natively and there is no plan they will be ever supported.

The CPML library supports arc natively, converting them to curves
when the #CpmlSegment is returned to the cairo context, for instance
when using cpml_segment_to_cairo().</doc>
      <member name="move" value="0" c:identifier="CPML_MOVE" glib:nick="move">
        <doc xml:space="preserve">equivalent to %CAIRO_PATH_MOVE_TO</doc>
      </member>
      <member name="line" value="1" c:identifier="CPML_LINE" glib:nick="line">
        <doc xml:space="preserve">equivalent to %CAIRO_PATH_LINE_TO</doc>
      </member>
      <member name="arc" value="19" c:identifier="CPML_ARC" glib:nick="arc">
        <doc xml:space="preserve">an arc representation at CPML level</doc>
      </member>
      <member name="curve"
              value="2"
              c:identifier="CPML_CURVE"
              glib:nick="curve">
        <doc xml:space="preserve">equivalent to %CAIRO_PATH_CURVE_TO</doc>
      </member>
      <member name="close"
              value="3"
              c:identifier="CPML_CLOSE"
              glib:nick="close">
        <doc xml:space="preserve">equivalent to %CAIRO_PATH_CLOSE_PATH</doc>
      </member>
      <function name="get_n_points"
                c:identifier="cpml_primitive_type_get_n_points"
                version="1.0">
        <doc xml:space="preserve">Gets the number of points required to identify the @type primitive.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of points or 0 on errors</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a primitive type</doc>
            <type name="PrimitiveType" c:type="CpmlPrimitiveType"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <record name="Segment"
            c:type="CpmlSegment"
            version="1.0"
            glib:type-name="CpmlSegment"
            glib:get-type="cpml_segment_get_type"
            c:symbol-prefix="segment">
      <doc xml:space="preserve">This is an unobtrusive struct to identify a segment inside a
cairo path. Unobtrusive means that the real coordinates are
still stored in @path: CpmlSegment only provides a way to
access them.</doc>
      <field name="path" writable="1">
        <doc xml:space="preserve">the source #cairo_path_t struct</doc>
        <type name="cairo.Path" c:type="cairo_path_t*"/>
      </field>
      <field name="data" introspectable="0" writable="1">
        <doc xml:space="preserve">the data points of the segment; the first primitive
           will always be a %CPML_MOVE</doc>
        <type c:type="cairo_path_data_t*"/>
      </field>
      <field name="num_data" writable="1">
        <doc xml:space="preserve">size of @data</doc>
        <type name="gint" c:type="int"/>
      </field>
      <method name="copy" c:identifier="cpml_segment_copy" version="1.0">
        <doc xml:space="preserve">Makes a shallow copy of @src into @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source segment to copy</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_data"
              c:identifier="cpml_segment_copy_data"
              version="1.0">
        <doc xml:space="preserve">Copies the memory referenced by the &lt;structfield&gt;data&lt;/structfield&gt; field
from @src to @segment. For a shallow copy, check out cpml_segment_copy().

This could seem a somewhat unusual operation because @segment should
be compatible with @src, i.e. it is expected that they have the same
&lt;structfield&gt;num_data&lt;/structfield&gt; value. Anyway it is convenient
in some situation, such as when restoring the original data from a
backup segment, e.g.:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
CpmlSegment *backup;

backup = cpml_segment_deep_dup(&amp;segment);
// Now &amp;segment points can be freely modified
...
// Let's restore &amp;segment original points
cpml_segment_copy_data(&amp;segment, backup);
g_free(backup);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if the data has been succesfully copied, 0 on errors.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment structure</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source segment to copy</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deep_dup"
              c:identifier="cpml_segment_deep_dup"
              version="1.0">
        <doc xml:space="preserve">Duplicates @segment. This function makes a deep duplication,
that is it duplicates also the underlying data that defines
the segment. The &lt;structfield&gt;path&lt;/structfield&gt; field
is set to &lt;constant&gt;NULL&lt;/constant&gt; as
&lt;structfield&gt;data&lt;/structfield&gt; is no more referring to the
original cairo path.

All the data is allocated in the same chunk of memory so freeing
the returned pointer releases all the occupied memory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a deep duplicate of @segment: must be freed with g_free() when no longer needed.</doc>
          <type name="Segment" c:type="CpmlSegment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment structure</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="cpml_segment_dump" version="1.0">
        <doc xml:space="preserve">Dumps the specified @segment to stdout. Useful for debugging purposes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="cpml_segment_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @segment. This function makes a shallow duplication,
that is the internal pointers of the resulting segment struct
refer to the same memory as the original @segment. Check out
cpml_segment_deep_dup() if it is required also the content
duplication.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a shallow duplicate of @segment: must be freed with g_free() when no longer needed.</doc>
          <type name="Segment" c:type="CpmlSegment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment structure</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="from_cairo"
              c:identifier="cpml_segment_from_cairo"
              version="1.0">
        <doc xml:space="preserve">Builds a CpmlSegment from a #cairo_path_t structure. This operation
involves stripping duplicate %CPML_MOVE primitives at the beginning
of @path and including all the primitives up to the end of the
contiguous line, that is before a %CPML_MOVE, when the original path
data finish or up to a %CPML_CLOSE. This is done unobtrusively by
setting the @segment fields appropriately, i.e. @path is not touched.

The first primitive must be a %CPML_MOVE, so no dependency on the
cairo context (to know the current position) is needed.

This function will fail if @path is empty or if its
&lt;structfield&gt;status&lt;/structfield&gt; member is not %CAIRO_STATUS_SUCCESS.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 if @segment has been succesfully computed, 0 on errors.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the source #cairo_path_t</doc>
            <type name="gpointer" c:type="cairo_path_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="cpml_segment_get_length"
              version="1.0">
        <doc xml:space="preserve">Gets the whole length of @segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested length</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="cpml_segment_next" version="1.0">
        <doc xml:space="preserve">Modifies @segment to point to the next segment of the source cairo path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">1 on success, 0 if no next segment found or errors.</doc>
          <type name="gboolean" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="cpml_segment_offset" version="1.0">
        <doc xml:space="preserve">Offsets a segment of the specified amount, that is builds a "parallel"
segment at the @offset distance from the original one and returns the
result by replacing the original @segment.

&lt;important&gt;
&lt;title&gt;TODO&lt;/title&gt;
&lt;itemizedlist&gt;
&lt;listitem&gt;Closed path are not yet managed: an elegant solution is not
          so obvious: use &lt;function&gt;cpml_close_offset&lt;/function&gt; when
          will be available.&lt;/listitem&gt;
&lt;listitem&gt;Degenerated primitives, such as lines of length 0, are not
          managed properly.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/important&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the offset distance</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_extents"
              c:identifier="cpml_segment_put_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the whole extents of @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">where to store the extents</doc>
            <type name="Extents" c:type="CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_intersections"
              c:identifier="cpml_segment_put_intersections"
              version="1.0">
        <doc xml:space="preserve">Computes the intersections between @segment and @segment2 and
returns the found points in @dest. If the intersections are more
than @n_dest, only the first @n_dest pairs are stored in @dest.

To get the job done, the primitives of @segment are sequentially
scanned for intersections with any primitive in @segment2. This
means @segment has a higher precedence over @segment2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of intersections found</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the first #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
          <parameter name="segment2" transfer-ownership="none">
            <doc xml:space="preserve">the second #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </parameter>
          <parameter name="n_dest" transfer-ownership="none">
            <doc xml:space="preserve">maximum number of intersections to return</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the destination vector of #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_pair_at"
              c:identifier="cpml_segment_put_pair_at"
              version="1.0">
        <doc xml:space="preserve">Gets the coordinates of the point lying on @segment at position
@pos. @pos is an homogeneous factor where 0 is the start point,
1 the end point, 0.5 the mid point and so on.
The relation &lt;constant&gt;0 &lt; @pos &lt; 1&lt;/constant&gt; should be satisfied,
although some cases accept value outside this range.

&lt;important&gt;
&lt;title&gt;TODO&lt;/title&gt;
&lt;itemizedlist&gt;
&lt;listitem&gt;The actual implementation returns only the start and end points,
          that is only when @pos is 0 or 1.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/important&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlPair</doc>
            <type name="Pair" c:type="CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_vector_at"
              c:identifier="cpml_segment_put_vector_at"
              version="1.0">
        <doc xml:space="preserve">Gets the steepness of the point lying on @segment at position
@pos. @pos is an homogeneous factor where 0 is the start point,
1 the end point, 0.5 the mid point and so on.
The relation &lt;constant&gt;0 &lt; @pos &lt; 1&lt;/constant&gt; should be satisfied,
although some cases accept value outside this range.

&lt;important&gt;
&lt;title&gt;TODO&lt;/title&gt;
&lt;itemizedlist&gt;
&lt;listitem&gt;The actual implementation returns only the start and end
          steepness, that is only when @pos is 0 or 1.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/important&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="vector" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CpmlVector</doc>
            <type name="Vector" c:type="CpmlVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="cpml_segment_reset" version="1.0">
        <doc xml:space="preserve">Modifies @segment to point to the first segment of the source cairo path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reverse" c:identifier="cpml_segment_reverse" version="1.0">
        <doc xml:space="preserve">Reverses @segment in-place. The resulting rendering will be the same,
but with the primitives generated in reverse order.

It is assumed that @segment has already been sanitized, e.g. when it
is returned by some CPML API or it is a cairo path already conforming
to the segment rules described in cpml_segment_from_cairo().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_cairo"
              c:identifier="cpml_segment_to_cairo"
              version="1.0">
        <doc xml:space="preserve">Appends the path of @segment to @cr. The segment is "flattened",
that is %CPML_ARC primitives are approximated by one or more
%CPML_CURVE using cpml_arc_to_cairo(). Check its documentation
for further details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="const CpmlSegment*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">the destination cairo context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform"
              c:identifier="cpml_segment_transform"
              version="1.0">
        <doc xml:space="preserve">Applies @matrix on all the points of @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">a #CpmlSegment</doc>
            <type name="Segment" c:type="CpmlSegment*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the matrix to be applied</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function name="angle" c:identifier="cpml_angle" version="1.0">
      <doc xml:space="preserve">Normalizes @angle, that is returns the equivalent radians value
between the range &lt;constant&gt;M_PI&lt;/constant&gt; (inclusive)
and &lt;constant&gt;-M_PI&lt;/constant&gt; (exclusive).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an equivalent value in radians</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">an angle in radians</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="arc_info" c:identifier="cpml_arc_info" version="1.0">
      <doc xml:space="preserve">Given an @arc, this function calculates and returns its basic data.
Any pointer can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the requested
info is not returned. This function can fail (when the three points lay on
a straight line, for example) in which case 0 is returned and no data can
be considered valid.

The radius @r can be 0 when the three points are coincidents: a
circle with radius 0 is considered a valid path.

When the start and end angle are returned, together with their
values these angles implicitely gives another important information:
the arc direction.

If @start &amp;lt; @end the arc must be rendered with increasing angle
value (clockwise direction using the ordinary cairo coordinate
system) while if @start &gt; @end the arc must be rendered in reverse
order (that is counterclockwise in the cairo world). This is the
reason the angle values are returned in the range &lt;constant&gt;-M_PI
&amp;lt; &lt;varname&gt;value&lt;/varname&gt; &amp;lt; 3 M_PI&lt;/constant&gt; inclusive instead of
the usual &lt;constant&gt;-M_PI &amp;lt; &lt;varname&gt;value&lt;/varname&gt; &amp;lt; M_PI&lt;/constant&gt;.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">1 if the function worked succesfully, 0 on errors.</doc>
        <type name="gboolean" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive arc data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="center"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">where to store the center coordinates</doc>
          <type name="Pair" c:type="CpmlPair*"/>
        </parameter>
        <parameter name="r"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">where to store the radius</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="start"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">where to store the starting angle</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="end"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">where to store the ending angle</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arc_to_cairo"
              c:identifier="cpml_arc_to_cairo"
              version="1.0">
      <doc xml:space="preserve">Renders @arc to the @cr cairo context. As cairo does not support
arcs natively, it is approximated using one or more Bézier curves.

The number of curves used is dependent from the angle of the arc.
Anyway, this function uses internally the hardcoded M_PI_2 value
as threshold value. This means the maximum arc approximated by a
single curve will be a quarter of a circle and, consequently, a
whole circle will be approximated by 4 Bézier curves.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive arc data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="cr"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">the destination cairo context</doc>
          <type name="cairo.Context" c:type="cairo_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arc_to_curves"
              c:identifier="cpml_arc_to_curves"
              version="1.0">
      <doc xml:space="preserve">Converts @arc to a serie of @n_curves Bézier curves and puts them
inside @segment. Obviously, @segment must have enough space to
contain at least @n_curves curves.

This function works in a similar way as cpml_arc_to_cairo() but
has two important differences: it does not need a cairo context
and the number of curves to be generated is explicitely defined.
The latter difference allows a more specific error control from
the application: in the file src/cairo-arc.c, found in the cairo
tarball (at least in cairo-1.9.1), there is a table showing the
magnitude of error of this curve approximation algorithm.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive arc data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="segment"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlSegment</doc>
          <type name="Segment" c:type="CpmlSegment*"/>
        </parameter>
        <parameter name="n_curves" transfer-ownership="none">
          <doc xml:space="preserve">number of Bézier to use</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="curve_offset_algorithm"
              c:identifier="cpml_curve_offset_algorithm"
              version="1.0">
      <doc xml:space="preserve">Selects the algorithm to use for offsetting Bézier curves and
returns the old algorithm.

You can use #CPML_CURVE_OFFSET_ALGORITHM_NONE (that does not
change the current algorithm) if you are only interested in
knowing which is the current algorithm used.

&lt;important&gt;&lt;para&gt;
This function is &lt;emphasis&gt;not thread-safe&lt;/emphasis&gt;. If you
are changing the algorithm in a thread environment you must
ensure by yourself no other threads are calling #CpmlCurve
methods in the meantime.
&lt;/para&gt;&lt;/important&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the previous algorithm used.</doc>
        <type name="CurveOffsetAlgorithm" c:type="CpmlCurveOffsetAlgorithm"/>
      </return-value>
      <parameters>
        <parameter name="new_algorithm" transfer-ownership="none">
          <doc xml:space="preserve">the new algorithm to use</doc>
          <type name="CurveOffsetAlgorithm" c:type="CpmlCurveOffsetAlgorithm"/>
        </parameter>
      </parameters>
    </function>
    <function name="curve_put_offset_at_time"
              c:identifier="cpml_curve_put_offset_at_time"
              version="1.0">
      <doc xml:space="preserve">Given the @curve Bézier cubic, find the coordinates at time @t
(where 0 is the start and 1 is the end), offset that point at
@offset distance and stores the result in @pair.

The point to offset and the vector along which that point must
be offseted are found calling cpml_curve_put_pair_at_time() and
cpml_curve_put_vector_at_time() respectively.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="curve" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive curve data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="t" transfer-ownership="none">
          <doc xml:space="preserve">the "time" value</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">the offset distance</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="pair"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination pair</doc>
          <type name="Pair" c:type="CpmlPair*"/>
        </parameter>
      </parameters>
    </function>
    <function name="curve_put_pair_at_time"
              c:identifier="cpml_curve_put_pair_at_time"
              version="1.0">
      <doc xml:space="preserve">Given the @curve Bézier cubic, finds the coordinates at time @t
(where 0 is the start and 1 is the end) and stores the result
in @pair. Keep in mind @t is not homogeneous, so 0.5 does not
necessarily means the mid point.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="curve" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive curve data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="t" transfer-ownership="none">
          <doc xml:space="preserve">the "time" value</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="pair" transfer-ownership="none">
          <doc xml:space="preserve">the destination pair</doc>
          <type name="Pair" c:type="CpmlPair*"/>
        </parameter>
      </parameters>
    </function>
    <function name="curve_put_vector_at_time"
              c:identifier="cpml_curve_put_vector_at_time"
              version="1.0">
      <doc xml:space="preserve">Given the @curve Bézier cubic, finds the slope at time @t
(where 0 is the start and 1 is the end) and stores the result
in @vector. Keep in mind @t is not homogeneous, so 0.5
does not necessarily means the mid point.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="curve" transfer-ownership="none">
          <doc xml:space="preserve">the #CpmlPrimitive curve data</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
        <parameter name="t" transfer-ownership="none">
          <doc xml:space="preserve">the "time" value</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">the destination vector</doc>
          <type name="Vector" c:type="CpmlVector*"/>
        </parameter>
      </parameters>
    </function>
    <function name="extents_copy"
              c:identifier="cpml_extents_copy"
              moved-to="Extents.copy"
              version="1.0">
      <doc xml:space="preserve">Copies @src in @extents.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="extents"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlExtents</doc>
          <type name="Extents" c:type="CpmlExtents*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">the source #CpmlExtents</doc>
          <type name="Extents" c:type="const CpmlExtents*"/>
        </parameter>
      </parameters>
    </function>
    <function name="extents_from_cairo_text"
              c:identifier="cpml_extents_from_cairo_text"
              moved-to="Extents.from_cairo_text"
              version="1.0">
      <doc xml:space="preserve">Converts @cairo_extents in a #CpmlExtents format and stores the
result in @extents.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="extents"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlExtents</doc>
          <type name="Extents" c:type="CpmlExtents*"/>
        </parameter>
        <parameter name="cairo_extents" transfer-ownership="none">
          <doc xml:space="preserve">the source #cairo_text_extents_t</doc>
          <type name="gpointer" c:type="cairo_text_extents_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="primitive_copy"
              c:identifier="cpml_primitive_copy"
              moved-to="Primitive.copy"
              version="1.0">
      <doc xml:space="preserve">Copies @src in @primitive. This is a shallow copy: the internal fields
of @primitive refer to the same memory as the original @src primitive.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="primitive"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlPrimitive</doc>
          <type name="Primitive" c:type="CpmlPrimitive*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">the source #CpmlPrimitive</doc>
          <type name="Primitive" c:type="const CpmlPrimitive*"/>
        </parameter>
      </parameters>
    </function>
    <function name="primitive_from_segment"
              c:identifier="cpml_primitive_from_segment"
              moved-to="Primitive.from_segment"
              version="1.0">
      <doc xml:space="preserve">Initializes @primitive to the first primitive of @segment.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="primitive"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlPrimitive struct</doc>
          <type name="Primitive" c:type="CpmlPrimitive*"/>
        </parameter>
        <parameter name="segment" transfer-ownership="none">
          <doc xml:space="preserve">the source segment</doc>
          <type name="Segment" c:type="CpmlSegment*"/>
        </parameter>
      </parameters>
    </function>
    <function name="primitive_type_get_n_points"
              c:identifier="cpml_primitive_type_get_n_points"
              moved-to="PrimitiveType.get_n_points"
              version="1.0">
      <doc xml:space="preserve">Gets the number of points required to identify the @type primitive.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of points or 0 on errors</doc>
        <type name="gulong" c:type="size_t"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a primitive type</doc>
          <type name="PrimitiveType" c:type="CpmlPrimitiveType"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_angle"
              c:identifier="cpml_vector_angle"
              version="1.0">
      <doc xml:space="preserve">Gets the angle of @vector, in radians. If @vector is (0, 0),
0 is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the angle in radians, a value between -M_PI and M_PI</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">the source #CpmlVector</doc>
          <type name="Vector" c:type="const CpmlVector*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_from_angle"
              c:identifier="cpml_vector_from_angle"
              version="1.0">
      <doc xml:space="preserve">Calculates the coordinates of the point far 1 from the origin
in the @angle direction. The result is stored in @vector.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlVector</doc>
          <type name="Vector" c:type="CpmlVector*"/>
        </parameter>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">angle of direction, in radians</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_normal"
              c:identifier="cpml_vector_normal"
              version="1.0">
      <doc xml:space="preserve">Stores in @vector a vector normal to the original @vector.
The length is retained.

The algorithm is really quick because no trigonometry is involved.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">the subject #CpmlVector</doc>
          <type name="Vector" c:type="CpmlVector*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_set_length"
              c:identifier="cpml_vector_set_length"
              version="1.0">
      <doc xml:space="preserve">Imposes the specified @length to @vector. If the old length is 0
(and so the direction is not known), nothing happens. If @length
is 0, @vector is set to &lt;constant&gt;(0, 0)&lt;/constant&gt;.

The @length parameter can be negative, in which case the vector
is inverted.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">a #CpmlVector</doc>
          <type name="Vector" c:type="CpmlVector*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the new length</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector_transform"
              c:identifier="cpml_vector_transform"
              version="1.0">
      <doc xml:space="preserve">Shortcut to apply a specific transformation matrix to @vector.
It works in a similar way of cpml_pair_transform() but uses
cairo_matrix_transform_distance() instead of
cairo_matrix_transform_point().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve">the destination #CpmlPair struct</doc>
          <type name="Vector" c:type="CpmlVector*"/>
        </parameter>
        <parameter name="matrix"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the transformation matrix</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
