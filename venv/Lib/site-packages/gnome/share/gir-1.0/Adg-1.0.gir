<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Cpml" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gtk" version="3.0"/>
  <include name="PangoCairo" version="1.0"/>
  <include name="cairo" version="1.0"/>
  <c:include name="adg.h"/>
  <namespace name="Adg"
             version="1.0"
             shared-library="libadg-1-3.dll"
             c:identifier-prefixes="Adg"
             c:symbol-prefixes="adg">
    <class name="ADim"
           c:symbol-prefix="adim"
           c:type="AdgADim"
           version="1.0"
           parent="Dim"
           glib:type-name="AdgADim"
           glib:get-type="adg_adim_get_type"
           glib:type-struct="ADimClass">
      <doc xml:space="preserve">All fields are privates and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_adim_new" version="1.0">
        <doc xml:space="preserve">Creates a new - undefined - angular dimension. You must, at least,
define the first line by setting #AdgADim:org1 (start point) and
#AdgDim:ref1 (end point), the second line by setting #AdgADim:org2
(start point) and #AdgDim:ref2 (end point) and the position of
the quote in #AdgDim:pos.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created angular dimension entity</doc>
          <type name="ADim" c:type="AdgADim*"/>
        </return-value>
      </constructor>
      <constructor name="new_full"
                   c:identifier="adg_adim_new_full"
                   version="1.0">
        <doc xml:space="preserve">Creates a new angular dimension, specifing all the needed
properties in one shot using #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created angular dimension entity</doc>
          <type name="ADim" c:type="AdgADim*"/>
        </return-value>
        <parameters>
          <parameter name="ref1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">first reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="ref2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">second reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="org1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">first origin point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="org2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">second origin point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the position point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_explicit"
                   c:identifier="adg_adim_new_full_explicit"
                   version="1.0">
        <doc xml:space="preserve">Wrappes adg_adim_new_full() with explicit values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created linear dimension entity</doc>
          <type name="ADim" c:type="AdgADim*"/>
        </return-value>
        <parameters>
          <parameter name="ref1_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of end point of the first line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref1_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of end point of the first line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref2_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of end point of the second line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref2_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of end point of the second line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="org1_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of start point of the first line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="org1_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of start point of the first line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="org2_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of start point of the second line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="org2_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of start point of the second line</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the position reference</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the position reference</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_from_model"
                   c:identifier="adg_adim_new_full_from_model"
                   version="1.0">
        <doc xml:space="preserve">Creates a new angular dimension, specifing all the needed properties
in one shot and using named pairs from @model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created angular dimension entity</doc>
          <type name="ADim" c:type="AdgADim*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the model from which the named pairs are taken</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="ref1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the end point of the first line</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ref2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the end point of the second line</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="org1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the origin of the first line</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="org2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the origin of the second line</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the position reference</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_org1" c:identifier="adg_adim_get_org1" version="1.0">
        <doc xml:space="preserve">Gets the #AdgADim:org1 point. The returned point is internally owned
and must not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first reference point</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_org2" c:identifier="adg_adim_get_org2" version="1.0">
        <doc xml:space="preserve">Gets the #AdgADim:org2 point. The returned point is internally owned
and must not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the second reference point</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_extension1"
              c:identifier="adg_adim_has_extension1"
              version="1.0">
        <doc xml:space="preserve">Checks if @adim should render the first extension line.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on first extension line presents, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim entity</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_extension2"
              c:identifier="adg_adim_has_extension2"
              version="1.0">
        <doc xml:space="preserve">Checks if @adim should render the second extension line.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on first extension line presents, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim entity</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_org1" c:identifier="adg_adim_set_org1" version="1.0">
        <doc xml:space="preserve">Sets the #AdgADim:org1 property to @org1. The old point
is silently discarded, unreferencing its model if that
point was bound to a named pair (hence, possibly destroying
the model if this was the last reference).

@org1 can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case
the point is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="org1" transfer-ownership="none">
            <doc xml:space="preserve">the new point to use as first reference</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org1_explicit"
              c:identifier="adg_adim_set_org1_explicit"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgADim:org1 property to the (@x, @y) explicit
coordinates. The old point is silently discarded,
unreferencing its model if that point was bound to a named
pair (hence, possibly destroying the model if this was the
last reference).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org1_from_model"
              c:identifier="adg_adim_set_org1_from_model"
              version="1.0">
        <doc xml:space="preserve">Binds #AdgADim:org1 to the @org1 named pair of @model. If @model
is &lt;constant&gt;NULL&lt;/constant&gt;, the point will be unset. In any
case, the old point is silently discarded, unreferencing its
model if that point was bound to a named pair (hence, possibly
destroying the model if this was the last reference).

The assignment is lazy so @org1 could be not be present in @model.
Anyway, at the first access to this point an error will be raised
if the named pair is still missing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the source #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="org1" transfer-ownership="none">
            <doc xml:space="preserve">a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org1_from_pair"
              c:identifier="adg_adim_set_org1_from_pair"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set the #AdgADim:org1 property using a
pair instead of explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="org1" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates pair of the first reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org2" c:identifier="adg_adim_set_org2" version="1.0">
        <doc xml:space="preserve">Sets the #AdgADim:org2 property to @org2. The old point
is silently discarded, unreferencing its model if that
point was bound to a named pair (hence, possibly destroying
the model if this was the last reference).

@org2 can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case
the point is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="org2" transfer-ownership="none">
            <doc xml:space="preserve">the new point to use as first reference</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org2_explicit"
              c:identifier="adg_adim_set_org2_explicit"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgADim:org2 property to the (@x, @y) explicit
coordinates. The old point is silently discarded,
unreferencing its model if that point was bound to a named
pair (hence, possibly destroying the model if this was the
last reference).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org2_from_model"
              c:identifier="adg_adim_set_org2_from_model"
              version="1.0">
        <doc xml:space="preserve">Binds #AdgADim:org2 to the @org2 named pair of @model. If @model
is &lt;constant&gt;NULL&lt;/constant&gt;, the point will be unset. In any
case, the old point is silently discarded, unreferencing its
model if that point was bound to a named pair (hence, possibly
destroying the model if this was the last reference).

The assignment is lazy so @org2 could be not be present in @model.
Anyway, at the first access to this point an error will be raised
if the named pair is still missing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the source #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="org2" transfer-ownership="none">
            <doc xml:space="preserve">a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_org2_from_pair"
              c:identifier="adg_adim_set_org2_from_pair"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set the #AdgADim:org2 property using a
pair instead of explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="org2" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates pair of the first reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_extension1"
              c:identifier="adg_adim_switch_extension1"
              version="1.0">
        <doc xml:space="preserve">Shows (if @new_state is &lt;constant&gt;TRUE&lt;/constant&gt;) or hides
(if @new_state is &lt;constant&gt;FALSE&lt;/constant&gt;) the first
extension line of @adim.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim entity</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_extension2"
              c:identifier="adg_adim_switch_extension2"
              version="1.0">
        <doc xml:space="preserve">Shows (if @new_state is &lt;constant&gt;TRUE&lt;/constant&gt;) or hides
(if @new_state is &lt;constant&gt;FALSE&lt;/constant&gt;) the second
extension line of @adim.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgADim entity</doc>
            <type name="ADim" c:type="AdgADim*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new new_state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="has-extension1" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="has-extension2" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="org1" writable="1" transfer-ownership="none">
        <type name="Point"/>
      </property>
      <property name="org2" writable="1" transfer-ownership="none">
        <type name="Point"/>
      </property>
      <property name="value"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Dim" c:type="AdgDim"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="ADimClass"
            c:type="AdgADimClass"
            glib:is-gtype-struct-for="ADim">
      <field name="parent_class" readable="0" private="1">
        <type name="DimClass" c:type="AdgDimClass"/>
      </field>
    </record>
    <class name="Alignment"
           c:symbol-prefix="alignment"
           c:type="AdgAlignment"
           version="1.0"
           parent="Container"
           glib:type-name="AdgAlignment"
           glib:get-type="adg_alignment_get_type"
           glib:type-struct="AlignmentClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_alignment_new" version="1.0">
        <doc xml:space="preserve">Creates a new alignment container with the specified factor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created alignment or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Alignment" c:type="AdgAlignment*"/>
        </return-value>
        <parameters>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the alignment factor</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_explicit"
                   c:identifier="adg_alignment_new_explicit"
                   version="1.0">
        <doc xml:space="preserve">Convenient function that creates a new alignment accepting explicit
factor values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created alignment</doc>
          <type name="Alignment" c:type="AdgAlignment*"/>
        </return-value>
        <parameters>
          <parameter name="x_factor" transfer-ownership="none">
            <doc xml:space="preserve">x component of the factor</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y_factor" transfer-ownership="none">
            <doc xml:space="preserve">y component of the factor</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_factor"
              c:identifier="adg_alignment_get_factor"
              version="1.0">
        <doc xml:space="preserve">Gets the value of the #AdgAlignment:factor property. The returned
pair is owned by @alignment and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the factor pair</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="alignment" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgAlignment container</doc>
            <type name="Alignment" c:type="AdgAlignment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_factor"
              c:identifier="adg_alignment_set_factor"
              version="1.0">
        <doc xml:space="preserve">Sets a the #AdgAlignment:factor property to @factor on @alignment.
The factor is applied to the @alignment extents to compute the
displacement of the content, providing a way to for instance center
the content either vertically or horizontally. A pair factor
of &lt;constant&gt;(0.5, 0)&lt;/constant&gt; means the content will be centered
horizontally in reference to the normal flow without @alignment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="alignment" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgAlignment container</doc>
            <type name="Alignment" c:type="AdgAlignment*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the new factor</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_factor_explicit"
              c:identifier="adg_alignment_set_factor_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient wrapper around adg_alignment_set_factor() that accepts
explicit factors instead of an #CpmlPair value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="alignment" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgAlignment container</doc>
            <type name="Alignment" c:type="AdgAlignment*"/>
          </instance-parameter>
          <parameter name="x_factor" transfer-ownership="none">
            <doc xml:space="preserve">x component of the factor</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y_factor" transfer-ownership="none">
            <doc xml:space="preserve">y component of the factor</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="factor" writable="1" transfer-ownership="none">
        <type name="Cpml.Pair"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Container" c:type="AdgContainer"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="AlignmentClass"
            c:type="AdgAlignmentClass"
            glib:is-gtype-struct-for="Alignment">
      <field name="parent_class" readable="0" private="1">
        <type name="ContainerClass" c:type="AdgContainerClass"/>
      </field>
    </record>
    <class name="Arrow"
           c:symbol-prefix="arrow"
           c:type="AdgArrow"
           version="1.0"
           parent="Marker"
           glib:type-name="AdgArrow"
           glib:get-type="adg_arrow_get_type"
           glib:type-struct="ArrowClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_arrow_new" version="1.0">
        <doc xml:space="preserve">Creates a new undefined arrow entity. The position must be defined
by setting the #AdgMarker:trail and #AdgMarker:pos properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created arrow entity</doc>
          <type name="Arrow" c:type="AdgArrow*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_trail"
                   c:identifier="adg_arrow_new_with_trail"
                   version="1.0">
        <doc xml:space="preserve">Creates a new arrow on the first segment on @trail at position
@pos, where @pos is a ratio of the @trail length (being 0 the
start point, 1 the end point, 0.5 the middle point and so on).
By default, an arrow as #AdgEntity:local-mix set to #ADG_MIX_PARENT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created arrow entity</doc>
          <type name="Arrow" c:type="AdgArrow*"/>
        </return-value>
        <parameters>
          <parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTrail where the arrow should be added</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position ratio on @trail</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_angle"
              c:identifier="adg_arrow_get_angle"
              version="1.0">
        <doc xml:space="preserve">Gets the current angle of @arrow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the arrow angle, in radians</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="arrow" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgArrow</doc>
            <type name="Arrow" c:type="AdgArrow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_angle"
              c:identifier="adg_arrow_set_angle"
              version="1.0">
        <doc xml:space="preserve">Sets a new angle: @angle will be the new opening angle of @arrow.
Changing the arrow angle will invalidate @arrow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="arrow" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgArrow</doc>
            <type name="Arrow" c:type="AdgArrow*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the new angle</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="angle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Marker" c:type="AdgMarker"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="ArrowClass"
            c:type="AdgArrowClass"
            glib:is-gtype-struct-for="Arrow">
      <field name="parent_class" readable="0" private="1">
        <type name="MarkerClass" c:type="AdgMarkerClass"/>
      </field>
    </record>
    <record name="Canvas" c:type="AdgCanvas" disguised="1" version="1.0">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
    </record>
    <class name="ColorStyle"
           c:symbol-prefix="color_style"
           c:type="AdgColorStyle"
           version="1.0"
           parent="Style"
           glib:type-name="AdgColorStyle"
           glib:get-type="adg_color_style_get_type"
           glib:type-struct="ColorStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_color_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new color initialized to opaque black.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new color style</doc>
          <type name="ColorStyle" c:type="AdgColorStyle*"/>
        </return-value>
      </constructor>
      <method name="get_alpha"
              c:identifier="adg_color_style_get_alpha"
              version="1.0">
        <doc xml:space="preserve">Gets the alpha channel value, where 0 means completely transparent
and 1 is fully opaque.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested alpha value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue"
              c:identifier="adg_color_style_get_blue"
              version="1.0">
        <doc xml:space="preserve">Gets the current value of the blue channel, where 0 means no blue and
1 is full blue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested blue value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green"
              c:identifier="adg_color_style_get_green"
              version="1.0">
        <doc xml:space="preserve">Gets the current value of the green channel, where 0 means no green and
1 is full green.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested green value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red"
              c:identifier="adg_color_style_get_red"
              version="1.0">
        <doc xml:space="preserve">Gets the current value of the red channel, where 0 means no red and
1 is full red.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested red value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="put_rgb"
              c:identifier="adg_color_style_put_rgb"
              version="1.0">
        <doc xml:space="preserve">Gets the values of the red, green and blue channels of @color_style.
Any of the pointer can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case
the value is not returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">where to store the red channel value</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">where to store the green channel value</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">where to store the blue channel value</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha"
              c:identifier="adg_color_style_set_alpha"
              version="1.0">
        <doc xml:space="preserve">Sets a new color alpha value, where 0 means completely transparent
and 1 is fully opaque.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">the new alpha</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue"
              c:identifier="adg_color_style_set_blue"
              version="1.0">
        <doc xml:space="preserve">Sets a new value for the blue channel, where 0 means no blue and
1 is full blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green"
              c:identifier="adg_color_style_set_green"
              version="1.0">
        <doc xml:space="preserve">Sets a new value for the green channel, where 0 means no green and
1 is full green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red"
              c:identifier="adg_color_style_set_red"
              version="1.0">
        <doc xml:space="preserve">Sets a new value for the red channel, where 0 means no red and
1 is full red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rgb"
              c:identifier="adg_color_style_set_rgb"
              version="1.0">
        <doc xml:space="preserve">Sets the RGB channels at once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgColorStyle</doc>
            <type name="ColorStyle" c:type="AdgColorStyle*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">the red channel value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">the green channel value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">the blue channel value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="alpha" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="blue" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="green" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="red" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="ColorStyleClass"
            c:type="AdgColorStyleClass"
            glib:is-gtype-struct-for="ColorStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
    </record>
    <class name="Container"
           c:symbol-prefix="container"
           c:type="AdgContainer"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgContainer"
           glib:get-type="adg_container_get_type"
           glib:type-struct="ContainerClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_container_new" version="1.0">
        <doc xml:space="preserve">Creates a new container entity.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created container entity</doc>
          <type name="Container" c:type="AdgContainer*"/>
        </return-value>
      </constructor>
      <virtual-method name="add" invoker="add" version="1.0">
        <doc xml:space="preserve">Emits a #AdgContainer::add signal on @container passing @entity
as argument. @entity must be added to only one container at a time,
you can't place the same entity inside two different containers.

Once @entity has been added, the floating reference will be removed
and @container will own a reference to @entity. This means the only
proper way to destroy @entity is to call adg_container_remove().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="children" invoker="children" version="1.0">
        <doc xml:space="preserve">Gets the children list of @container. This list must be manually
freed with g_slist_free() when no longer user.

The returned list is ordered from the most recently added child
to the oldest one.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a newly allocated #GSList of #AdgEntity or &lt;constant&gt;NULL&lt;/constant&gt; on no children or errors</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Entity"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove" invoker="remove" version="1.0">
        <doc xml:space="preserve">Emits a #AdgContainer::remove signal on @container passing
@entity as argument. @entity must be inside @container.

Note that @container will own a reference to @entity and it
may be the last reference held: this means removing an entity
from its container can destroy it.

If you want to use @entity again, you need to add a reference
to it, using g_object_ref(), before removing it from @container.
The following typical example shows you how to properly move
&lt;varname&gt;entity&lt;/varname&gt; from &lt;varname&gt;container1&lt;/varname&gt;
to &lt;varname&gt;container2&lt;/varname&gt;:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
g_object_ref(entity);
adg_container_remove(container1, entity);
adg_container_add(container2, entity)
g_object_unref(entity);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="adg_container_add" version="1.0">
        <doc xml:space="preserve">Emits a #AdgContainer::add signal on @container passing @entity
as argument. @entity must be added to only one container at a time,
you can't place the same entity inside two different containers.

Once @entity has been added, the floating reference will be removed
and @container will own a reference to @entity. This means the only
proper way to destroy @entity is to call adg_container_remove().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="children"
              c:identifier="adg_container_children"
              version="1.0">
        <doc xml:space="preserve">Gets the children list of @container. This list must be manually
freed with g_slist_free() when no longer user.

The returned list is ordered from the most recently added child
to the oldest one.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a newly allocated #GSList of #AdgEntity or &lt;constant&gt;NULL&lt;/constant&gt; on no children or errors</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Entity"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach"
              c:identifier="adg_container_foreach"
              version="1.0">
        <doc xml:space="preserve">Invokes @callback on each child of @container.
The callback should be declared as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
void callback(AdgEntity *entity, gpointer user_data);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">callback user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="propagate"
              c:identifier="adg_container_propagate"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Emits the specified signal to all the children of @container
using g_signal_emit_valist() calls.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="signal_id" transfer-ownership="none">
            <doc xml:space="preserve">the signal id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="detail" transfer-ownership="none">
            <doc xml:space="preserve">the detail</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">parameters to be passed to the signal, followed by a pointer
      to the allocated memory where to store the return type: if
      the signal is %G_TYPE_NONE (void return type), this trailing
      pointer should be omitted</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="propagate_by_name"
              c:identifier="adg_container_propagate_by_name"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Emits the specified signal to all the children of @container
using g_signal_emit_valist() calls.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">parameters to be passed to the signal, followed by a pointer
      to the allocated memory where to store the return type: if
      the signal is %G_TYPE_NONE (void return type), this trailing
      pointer should be omitted</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="propagate_valist"
              c:identifier="adg_container_propagate_valist"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Emits the specified signal to all the children of @container
using g_signal_emit_valist() calls.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="signal_id" transfer-ownership="none">
            <doc xml:space="preserve">the signal id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="detail" transfer-ownership="none">
            <doc xml:space="preserve">the detail</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">parameters to be passed to the signal, followed by a
           pointer to the allocated memory where to store the
           return type: if the signal is %G_TYPE_NONE (void return
           type), this trailing pointer should be omitted</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="adg_container_remove" version="1.0">
        <doc xml:space="preserve">Emits a #AdgContainer::remove signal on @container passing
@entity as argument. @entity must be inside @container.

Note that @container will own a reference to @entity and it
may be the last reference held: this means removing an entity
from its container can destroy it.

If you want to use @entity again, you need to add a reference
to it, using g_object_ref(), before removing it from @container.
The following typical example shows you how to properly move
&lt;varname&gt;entity&lt;/varname&gt; from &lt;varname&gt;container1&lt;/varname&gt;
to &lt;varname&gt;container2&lt;/varname&gt;:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
g_object_ref(entity);
adg_container_remove(container1, entity);
adg_container_add(container2, entity)
g_object_unref(entity);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="container" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgContainer</doc>
            <type name="Container" c:type="AdgContainer*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <property name="child"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="Entity"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="add" when="first" version="1.0">
        <doc xml:space="preserve">Adds @entity to @container. @entity must not be inside another
container or the operation will fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgEntity to add</doc>
            <type name="Entity"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove" when="first" version="1.0">
        <doc xml:space="preserve">Removes @entity from @container.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgEntity to remove</doc>
            <type name="Entity"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ContainerClass"
            c:type="AdgContainerClass"
            glib:is-gtype-struct-for="Container"
            version="1.0">
      <doc xml:space="preserve">#AdgContainer effectively stores a #GSList of children into its
private data and keeps a reference to every child it owns.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
      <field name="children">
        <callback name="children">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">a newly allocated #GSList of #AdgEntity or &lt;constant&gt;NULL&lt;/constant&gt; on no children or errors</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Entity"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="container" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgContainer</doc>
              <type name="Container" c:type="AdgContainer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add">
        <callback name="add">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="container" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgContainer</doc>
              <type name="Container" c:type="AdgContainer*"/>
            </parameter>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove">
        <callback name="remove">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="container" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgContainer</doc>
              <type name="Container" c:type="AdgContainer*"/>
            </parameter>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <constant name="DIR_RIGHT"
              value="0.000000"
              c:type="ADG_DIR_RIGHT"
              version="1.0">
      <doc xml:space="preserve">Symbolic constant for the right direction (in radians).</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <record name="Dash"
            c:type="AdgDash"
            version="1.0"
            glib:type-name="AdgDash"
            glib:get-type="adg_dash_get_type"
            c:symbol-prefix="dash">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_dash_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty dash pattern.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created dash pattern.</doc>
          <type name="Dash" c:type="AdgDash*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_dashes"
                   c:identifier="adg_dash_new_with_dashes"
                   version="1.0"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new dash pattern, presetting some dashes on it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created dash pattern.</doc>
          <type name="Dash" c:type="AdgDash*"/>
        </return-value>
        <parameters>
          <parameter name="num_dashes" transfer-ownership="none">
            <doc xml:space="preserve">the number of dashes to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">lengths (a list of double values) of each dash</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_dash"
              c:identifier="adg_dash_append_dash"
              version="1.0">
        <doc xml:space="preserve">Appends to the @dash pattern a new dash of the specified @length value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_dashes"
              c:identifier="adg_dash_append_dashes"
              shadowed-by="append_dashes_array"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Appends to the current @dash pattern @num_dashes number of dashes.
The length of each dash must be specified as gdouble in the arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
          <parameter name="num_dashes" transfer-ownership="none">
            <doc xml:space="preserve">number of dashes to append</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">a @num_dashes list of #gdouble</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="append_dashes_array"
              c:identifier="adg_dash_append_dashes_array"
              shadows="append_dashes"
              version="1.0">
        <doc xml:space="preserve">Array version of adg_dash_append_dashes().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
          <parameter name="num_dashes" transfer-ownership="none">
            <doc xml:space="preserve">number of dashes to append</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="dashes" transfer-ownership="none">
            <doc xml:space="preserve">array of @num_dashes gdoubles</doc>
            <array length="0" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="append_dashes_valist"
              c:identifier="adg_dash_append_dashes_valist"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Variadic version of adg_dash_append_dashes().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
          <parameter name="num_dashes" transfer-ownership="none">
            <doc xml:space="preserve">number of dashes to append</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">a va_list containing @num_dashes list of #gdouble</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_dashes"
              c:identifier="adg_dash_clear_dashes"
              version="1.0">
        <doc xml:space="preserve">Resets the dashes of @dash, effectively clearing the pattern.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="adg_dash_destroy" version="1.0">
        <doc xml:space="preserve">Destroys @dash, freeing every resource owned by it. After the destruction
@dash cannot be used anymore.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="adg_dash_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @src. The returned value must be freed with adg_dash_destroy()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the duplicate of @src.</doc>
          <type name="Dash" c:type="AdgDash*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="const AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dashes"
              c:identifier="adg_dash_get_dashes"
              version="1.0">
        <doc xml:space="preserve">Gets the array of gdoubles containing the length of each dash of the
pattern of @dash.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of lengths or &lt;constant&gt;NULL&lt;/constant&gt; on invalid @dash. The array is owned by @dash and must not be modified or freed.</doc>
          <type name="gdouble" c:type="const gdouble*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="const AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dashes"
              c:identifier="adg_dash_get_num_dashes"
              version="1.0">
        <doc xml:space="preserve">Gets the number of dashes stored inside this dash pattern.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of dashes or -1 if @dash is invalid.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="const AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset"
              c:identifier="adg_dash_get_offset"
              version="1.0">
        <doc xml:space="preserve">Gets the offset of the pattern in @dash.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset of @dash or 0 on invalid @dash.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="const AdgDash*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_offset"
              c:identifier="adg_dash_set_offset"
              version="1.0">
        <doc xml:space="preserve">Sets the pattern offset of @dash to @offset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDash instance</doc>
            <type name="Dash" c:type="AdgDash*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the new offset value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="DependencyFunc" c:type="AdgDependencyFunc" version="1.0">
      <doc xml:space="preserve">Callback used by adg_model_foreach_dependency().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="model" transfer-ownership="none">
          <doc xml:space="preserve">the #AdgModel</doc>
          <type name="Model" c:type="AdgModel*"/>
        </parameter>
        <parameter name="entity" transfer-ownership="none">
          <doc xml:space="preserve">the #AdgEntity dependent on @model</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">a general purpose pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Dim"
           c:symbol-prefix="dim"
           c:type="AdgDim"
           version="1.0"
           parent="Entity"
           abstract="1"
           glib:type-name="AdgDim"
           glib:get-type="adg_dim_get_type"
           glib:type-struct="DimClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="default_value">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_detached"
              c:identifier="adg_dim_get_detached"
              version="1.0">
        <doc xml:space="preserve">Gets the state of the #AdgDim:detached property: check the property
documentation for further details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current flag state.</doc>
          <type name="ThreeState" c:type="AdgThreeState"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dim_dress"
              c:identifier="adg_dim_get_dim_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the dimension dress to be used in rendering @dim.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current dimension dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_level" c:identifier="adg_dim_get_level" version="1.0">
        <doc xml:space="preserve">Gets the level of this dimension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the level value.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max" c:identifier="adg_dim_get_max" version="1.0">
        <doc xml:space="preserve">Gets the maximum value text or &lt;constant&gt;NULL&lt;/constant&gt;
on maximum value disabled.

The string is internally owned and must not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum value text.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min" c:identifier="adg_dim_get_min" version="1.0">
        <doc xml:space="preserve">Gets the minimum value text or &lt;constant&gt;NULL&lt;/constant&gt;
on minimum value disabled.

The string is internally owned and must not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mimimum value text.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outside"
              c:identifier="adg_dim_get_outside"
              version="1.0">
        <doc xml:space="preserve">Gets the state of the #AdgDim:outside property: check the property
documentation for further details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current flag state.</doc>
          <type name="ThreeState" c:type="AdgThreeState"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="adg_dim_get_pos" version="1.0">
        <doc xml:space="preserve">Gets the #AdgDim:pos point of @dim.

The returned point is internally owned and must not be freed
or modified. Anyway it is not const because a call to
adg_point_update() with the returned value must be able to
modify the internal cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position point.</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_quote" c:identifier="adg_dim_get_quote" version="1.0">
        <doc xml:space="preserve">Gets the quote entity, if any. This function is valid only after
the #AdgDim implementation of the arrange() virtual method has
been called.

The returned entity is owned by @dim and should not be
modified or freed.

&lt;note&gt;&lt;para&gt;
This function is only useful in new dimension implementations.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the quote entity.</doc>
          <type name="Alignment" c:type="AdgAlignment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ref1" c:identifier="adg_dim_get_ref1" version="1.0">
        <doc xml:space="preserve">Gets the #AdgDim:ref1 point of @dim.

The returned point is internally owned and must not be freed
or modified. Anyway it is not const because a call to
adg_point_update() with the returned value must be able to
modify the internal cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first reference point.</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ref2" c:identifier="adg_dim_get_ref2" version="1.0">
        <doc xml:space="preserve">Gets the #AdgDim:ref2 point of @dim.

The returned point is internally owned and must not be freed
or modified. Anyway it is not const because a call to
adg_point_update() with the returned value must be able to
modify the internal cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the second reference point.</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="adg_dim_get_value" version="1.0">
        <doc xml:space="preserve">Gets the value text. The string is internally owned and
must not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value text.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="quote_angle"
              c:identifier="adg_dim_quote_angle"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in new dimension implementations.
&lt;/para&gt;&lt;/note&gt;

Converts @angle accordling to the style of @dim. Any quote angle
should be validated by this method because every dimensioning
style has its own convention regardling the text rotation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the angle to use (always in radians).</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">an angle (in radians)</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_detached"
              c:identifier="adg_dim_set_detached"
              version="1.0">
        <doc xml:space="preserve">Sets a new state for the #AdgDim:detached flag: check the property
documentation for further details.

This is used only by dimensions where detaching has meaning.
In some cases, such as with #AdgRDim dimensions, this property is
not used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="detached" transfer-ownership="none">
            <doc xml:space="preserve">the new detached state</doc>
            <type name="ThreeState" c:type="AdgThreeState"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dim_dress"
              c:identifier="adg_dim_set_dim_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new dimension dress to @dim. The new dress must be
related to the original dress for this property: you cannot
set a dress used for line styles to a dress managing fonts.

The check is done by calling adg_dress_are_related() with
@dress and the previous dress as arguments. Check out its
documentation for details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_level" c:identifier="adg_dim_set_level" version="1.0">
        <doc xml:space="preserve">Sets a new level for this dimension. The level is used to
stack the quotes using a spacing value from dim_style
(specified in global space).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the new level</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_limits"
              c:identifier="adg_dim_set_limits"
              version="1.0">
        <doc xml:space="preserve">Shortcut to set both the limits at once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="min"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new minumum value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="max"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new maximum value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max" c:identifier="adg_dim_set_max" version="1.0">
        <doc xml:space="preserve">Sets the maximum value. Use &lt;constant&gt;NULL&lt;/constant&gt;
as @max to disable it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="max"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new maximum value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min" c:identifier="adg_dim_set_min" version="1.0">
        <doc xml:space="preserve">Sets the minimum value. Use &lt;constant&gt;NULL&lt;/constant&gt;
as @min to disable it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="min"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new minimum limit</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_outside"
              c:identifier="adg_dim_set_outside"
              version="1.0">
        <doc xml:space="preserve">Sets a new state for the #AdgDim:outside flag: check the property
documentation for further details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="outside" transfer-ownership="none">
            <doc xml:space="preserve">the new outside state</doc>
            <type name="ThreeState" c:type="AdgThreeState"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="adg_dim_set_pos" version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:pos property of @dim to @pos. The old point
is silently discarded, unreferencing its model if that
point was bound to a named pair (hence, possibly destroying
the model if it was the last reference).

@pos can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the
point is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the new point to use as position</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos_explicit"
              c:identifier="adg_dim_set_pos_explicit"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:pos property to the (@x, @y) explicit
coordinates. The old point is silently discarded,
unreferencing its model if that point was bound to a named
pair (hence, possibly destroying the model if this was the
last reference).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the position</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the position</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos_from_model"
              c:identifier="adg_dim_set_pos_from_model"
              version="1.0">
        <doc xml:space="preserve">Binds #AdgDim:pos to the @pos named pair of @model. If @model
is &lt;constant&gt;NULL&lt;/constant&gt;, the point will be unset. In any
case, the old point is silently discarded, unreferencing its
model if that point was bound to a named pair (hence,
possibly destroying the model if this was the last reference).

The assignment is lazy so @pos could be not be present in @model.
Anyway, at the first access to this point an error will be raised
if the named pair is still missing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the source #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos_from_pair"
              c:identifier="adg_dim_set_pos_from_pair"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set the #AdgDim:pos property using a
pair instead of explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates pair of the position point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref1" c:identifier="adg_dim_set_ref1" version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:ref1 property to @ref1. The old point
is silently discarded, unreferencing its model if that
point was bound to a named pair (hence, possibly destroying
the model if this was the last reference).

@ref1 can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the
point is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="ref1" transfer-ownership="none">
            <doc xml:space="preserve">the new point to use as first reference</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref1_explicit"
              c:identifier="adg_dim_set_ref1_explicit"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:ref1 property to the (@x, @y) explicit
coordinates. The old point is silently discarded,
unreferencing its model if that point was bound to a named
pair (hence, possibly destroying the model if this was the
last reference).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref1_from_model"
              c:identifier="adg_dim_set_ref1_from_model"
              version="1.0">
        <doc xml:space="preserve">Binds #AdgDim:ref1 to the @ref1 named pair of @model. If @model
is &lt;constant&gt;NULL&lt;/constant&gt;, the point will be unset. In any case,
the old point is silently discarded, unreferencing its model
if that point was bound to a named pair (hence, possibly destroying
the model if this was the last reference).

The assignment is lazy so @ref1 could be not be present in @model.
Anyway, at the first access to this point an error will be raised
if the named pair is still missing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the source #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="ref1" transfer-ownership="none">
            <doc xml:space="preserve">a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref1_from_pair"
              c:identifier="adg_dim_set_ref1_from_pair"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set the #AdgDim:ref1 property using a
pair instead of explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="ref1" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates pair of the first reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref2" c:identifier="adg_dim_set_ref2" version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:ref2 property to @ref2. The old point
is silently discarded, unreferencing its model if that
point was bound to a named pair (hence, possibly destroying
the model if it was the last reference).

@ref2 can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case
the point is destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="ref2" transfer-ownership="none">
            <doc xml:space="preserve">the new point to use as second reference</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref2_explicit"
              c:identifier="adg_dim_set_ref2_explicit"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgDim:ref2 property to the (@x, @y) explicit
coordinates. The old point is silently discarded,
unreferencing its model if that point was bound to a named
pair (hence, possibly destroying the model if this was the
last reference).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the second reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the second reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref2_from_model"
              c:identifier="adg_dim_set_ref2_from_model"
              version="1.0">
        <doc xml:space="preserve">Binds #AdgDim:ref2 to the @ref2 named pair of @model. If @model
is &lt;constant&gt;NULL&lt;/constant&gt;, the point will be unset. In any
case, the old point is silently discarded, unreferencing its
model if that point was bound to a named pair (hence, possibly
destroying the model if this was the last reference).

The assignment is lazy so @ref2 could be not be present in @model.
Anyway, at the first access to this point an error will be raised
if the named pair is still missing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the source #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="ref2" transfer-ownership="none">
            <doc xml:space="preserve">a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ref2_from_pair"
              c:identifier="adg_dim_set_ref2_from_pair"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set the #AdgDim:ref2 property using a
pair instead of explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="ref2" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates pair of the second reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="adg_dim_set_value" version="1.0">
        <doc xml:space="preserve">Explicitely sets the text to use as value. If @value
is &lt;constant&gt;NULL&lt;/constant&gt; or was never set, an automatic
text is calculated using the format specified in the current
#AdgDimStyle and getting its value by calling
the &lt;function&gt;default_value&lt;/function&gt; virtual method.

Inside the template string, the "&lt;&gt;" tag (or whatever specified
by the #AdgDimStyle:number-tag property) is substituted with the
string returned by &lt;function&gt;default_value&lt;/function&gt;.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDim</doc>
            <type name="Dim" c:type="AdgDim*"/>
          </instance-parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the value text</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="detached"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dim-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="level" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="max" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="min" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="outside"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="pos" writable="1" transfer-ownership="none">
        <type name="Point"/>
      </property>
      <property name="ref1" writable="1" transfer-ownership="none">
        <type name="Point"/>
      </property>
      <property name="ref2" writable="1" transfer-ownership="none">
        <type name="Point"/>
      </property>
      <property name="value"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="DimClass"
            c:type="AdgDimClass"
            glib:is-gtype-struct-for="Dim"
            version="1.0">
      <doc xml:space="preserve">The default implementation of @quote_angle flips the quote if it should be
rotated in the bottom right half of the circle, that is:

&lt;informalexample&gt;&lt;programlisting&gt;
if 1/3 PI &lt;= angle &lt;= -3/4  PI; then angle += PI.
&lt;/programlisting&gt;&lt;/informalexample&gt;

The virtual method @default_value instead *must* be implemented by any
derived class. The default implementation will trigger an error if called.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
      <field name="quote_angle">
        <callback name="quote_angle">
          <return-value transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </return-value>
          <parameters>
            <parameter name="angle" transfer-ownership="none">
              <type name="gdouble" c:type="gdouble"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="default_value">
        <callback name="default_value">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="dim" transfer-ownership="none">
              <type name="Dim" c:type="AdgDim*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="DimStyle"
           c:symbol-prefix="dim_style"
           c:type="AdgDimStyle"
           version="1.0"
           parent="Style"
           glib:type-name="AdgDimStyle"
           glib:get-type="adg_dim_style_get_type"
           glib:type-struct="DimStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_dim_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new empty dimension style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created dimension style.</doc>
          <type name="DimStyle" c:type="AdgDimStyle*"/>
        </return-value>
      </constructor>
      <method name="get_baseline_spacing"
              c:identifier="adg_dim_style_get_baseline_spacing"
              version="1.0">
        <doc xml:space="preserve">Gets the distance between two consecutive baselines
while stacking dimensions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested spacing.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_beyond"
              c:identifier="adg_dim_style_get_beyond"
              version="1.0">
        <doc xml:space="preserve">Gets how much (in global space) the baseline should extend beyond
the extension lines on dimension with outside markers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested beyond length.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_dress"
              c:identifier="adg_dim_style_get_color_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the @dim_style color dress to be used. This dress should be
intended as a fallback color as it could be overriden by more
specific dresses, such as a color explicitely specified on the
#AdgDimStyle:value-dress.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_from_offset"
              c:identifier="adg_dim_style_get_from_offset"
              version="1.0">
        <doc xml:space="preserve">Gets the distance (in global space) the extension lines must keep from the
sensed points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested distance.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limits_shift"
              c:identifier="adg_dim_style_get_limits_shift"
              version="1.0">
        <doc xml:space="preserve">Gets the smooth displacement for the limits. The returned pointer
refers to an internal allocated struct and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested shift.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limits_spacing"
              c:identifier="adg_dim_style_get_limits_spacing"
              version="1.0">
        <doc xml:space="preserve">Gets the distance (in global space) between the limits/tolerances.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested spacing.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_dress"
              c:identifier="adg_dim_style_get_line_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used for rendering the base and
the extension lines with @dim_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_dress"
              c:identifier="adg_dim_style_get_max_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the @dim_style dress to be used for the upper limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the upper limit dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_dress"
              c:identifier="adg_dim_style_get_min_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the @dim_style dress to be used for the lower limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the lower limit dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_format"
              c:identifier="adg_dim_style_get_number_format"
              version="1.0">
        <doc xml:space="preserve">Gets the number format (in printf style) of this quoting style. The
returned pointer refers to internally managed text that must not be
modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested format.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_tag"
              c:identifier="adg_dim_style_get_number_tag"
              version="1.0">
        <doc xml:space="preserve">Gets the number tag of @dim_style. This tag will be used while
generating the set values of the dimensions bound to this style:
check the #AdgDim:value documentation for further details.

The returned pointer refers to internally managed text that
must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested tag.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_quote_shift"
              c:identifier="adg_dim_style_get_quote_shift"
              version="1.0">
        <doc xml:space="preserve">Gets the smooth displacement of the quote. The returned pointer refers
to an internal allocated struct and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested shift.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_to_offset"
              c:identifier="adg_dim_style_get_to_offset"
              version="1.0">
        <doc xml:space="preserve">Gets how much (in global space) the extension lines must extend after
crossing the baseline.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested distance.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value_dress"
              c:identifier="adg_dim_style_get_value_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the font dress to be used for the basic value of dimensions
with @dim_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="marker1_new"
              c:identifier="adg_dim_style_marker1_new"
              version="1.0">
        <doc xml:space="preserve">Creates a new marker entity by cloning the #AdgDimStyle:marker1
object. The returned entity should be unreferenced with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created marker or &lt;constant&gt;NULL&lt;/constant&gt; if the #AdgDimStyle:marker1 property is not set or on errors.</doc>
          <type name="Marker" c:type="AdgMarker*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="marker2_new"
              c:identifier="adg_dim_style_marker2_new"
              version="1.0">
        <doc xml:space="preserve">Creates a new marker entity by cloning the #AdgDimStyle:marker2
object. The returned entity should be unreferenced with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created marker or &lt;constant&gt;NULL&lt;/constant&gt; if the #AdgDimStyle:marker2 property is not set or on errors.</doc>
          <type name="Marker" c:type="AdgMarker*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_baseline_spacing"
              c:identifier="adg_dim_style_set_baseline_spacing"
              version="1.0">
        <doc xml:space="preserve">Sets a new value in the #AdgDimStyle:baseline-spacing value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="spacing" transfer-ownership="none">
            <doc xml:space="preserve">the new spacing</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_beyond"
              c:identifier="adg_dim_style_set_beyond"
              version="1.0">
        <doc xml:space="preserve">Sets a new value in the #AdgDimStyle:beyond property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="beyond" transfer-ownership="none">
            <doc xml:space="preserve">the new length</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_dress"
              c:identifier="adg_dim_style_set_color_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new color dress on @dim_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new color dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_offset"
              c:identifier="adg_dim_style_set_from_offset"
              version="1.0">
        <doc xml:space="preserve">Sets a new value in the #AdgDimStyle:from-offset property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the new offset</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_limits_shift"
              c:identifier="adg_dim_style_set_limits_shift"
              version="1.0">
        <doc xml:space="preserve">Sets a new #AdgDimStyle:limits-shift value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="shift" transfer-ownership="none">
            <doc xml:space="preserve">the new displacement</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_limits_spacing"
              c:identifier="adg_dim_style_set_limits_spacing"
              version="1.0">
        <doc xml:space="preserve">Sets a new #AdgDimStyle:limits-spacing value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="spacing" transfer-ownership="none">
            <doc xml:space="preserve">the new spacing</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_dress"
              c:identifier="adg_dim_style_set_line_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress on @dim_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new line dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_marker1"
              c:identifier="adg_dim_style_set_marker1"
              version="1.0">
        <doc xml:space="preserve">Uses @marker as entity template to generate a new marker entity
when a call to adg_dim_style_marker1_new() is made. It is allowed
to pass &lt;constant&gt;NULL&lt;/constant&gt; as @marker, in which case the
template data of the first marker are unset.

This method duplicates internally the property values of @marker,
so any further change to @marker does not affect @dim_style anymore.
This also means @marker could be destroyed without problems after
this call because @dim_style uses only its property values and does
not add any references to @marker.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker derived entity</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_marker2"
              c:identifier="adg_dim_style_set_marker2"
              version="1.0">
        <doc xml:space="preserve">Uses @marker as entity template to generate a new marker entity
when a call to adg_dim_style_marker2_new() is made. It is allowed
to pass &lt;constant&gt;NULL&lt;/constant&gt; as @marker, in which case the
template data of the second marker are unset.

This method duplicates internally the property values of @marker,
so any further change to @marker does not affect @dim_style anymore.
This also means @marker could be destroyed without problems after
this call because @dim_style uses only its property values and does
not add any references to @marker.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker derived entity</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_dress"
              c:identifier="adg_dim_style_set_max_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new dress on @dim_style for the upper limit value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new upper limit dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_dress"
              c:identifier="adg_dim_style_set_min_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new dress on @dim_style for the lower limit value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new lower limit dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_number_format"
              c:identifier="adg_dim_style_set_number_format"
              version="1.0">
        <doc xml:space="preserve">Sets a new value in the #AdgDimStyle:number-format property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the new format to adopt</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_number_tag"
              c:identifier="adg_dim_style_set_number_tag"
              version="1.0">
        <doc xml:space="preserve">Sets a new tag in the #AdgDimStyle:number-tag property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">the new tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_quote_shift"
              c:identifier="adg_dim_style_set_quote_shift"
              version="1.0">
        <doc xml:space="preserve">Sets a new #AdgDimStyle:quote-shift value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="shift" transfer-ownership="none">
            <doc xml:space="preserve">the new displacement</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_to_offset"
              c:identifier="adg_dim_style_set_to_offset"
              version="1.0">
        <doc xml:space="preserve">Sets a new value in the #AdgDimStyle:to-offset property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">the new offset</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value_dress"
              c:identifier="adg_dim_style_set_value_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new dress on @dim_style for the basic value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dim_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgDimStyle object</doc>
            <type name="DimStyle" c:type="AdgDimStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new basic value font style</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <property name="baseline-spacing" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="beyond" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="color-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="from-offset" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="limits-shift" writable="1" transfer-ownership="none">
        <type name="Cpml.Pair"/>
      </property>
      <property name="limits-spacing" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="line-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="marker1"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="Marker"/>
      </property>
      <property name="marker2"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="Marker"/>
      </property>
      <property name="max-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="min-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="number-format" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="number-tag" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="quote-shift" writable="1" transfer-ownership="none">
        <type name="Cpml.Pair"/>
      </property>
      <property name="to-offset" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="value-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="DimStyleClass"
            c:type="AdgDimStyleClass"
            glib:is-gtype-struct-for="DimStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
    </record>
    <enumeration name="Dress" version="1.0" c:type="AdgDress">
      <doc xml:space="preserve">An index representing a virtual #AdgStyle. The ADG comes equipped
with some built-in dress.</doc>
      <member name="undefined" value="0" c:identifier="ADG_DRESS_UNDEFINED">
        <doc xml:space="preserve">undefined dress, used for notifying invalid
                                  dresses.</doc>
      </member>
      <member name="color" value="1" c:identifier="ADG_DRESS_COLOR">
        <doc xml:space="preserve">default built-in color. This is a
                                  pass-through dress, that is it does not
                                  change the cairo context when it is
                                  applied. This dress will be resolved to an
                                  #AdgColorStyle instance.</doc>
      </member>
      <member name="color_background"
              value="2"
              c:identifier="ADG_DRESS_COLOR_BACKGROUND">
        <doc xml:space="preserve">default built-in color to be used as the
                                  #AdgCanvas background. This dress will be
                                  resolved to an #AdgColorStyle instance.</doc>
      </member>
      <member name="color_stroke"
              value="3"
              c:identifier="ADG_DRESS_COLOR_STROKE">
        <doc xml:space="preserve">default built-in color for #AdgStroke
                                  entities. This dress will be resolved to
                                  an #AdgColorStyle instance.</doc>
      </member>
      <member name="color_dimension"
              value="4"
              c:identifier="ADG_DRESS_COLOR_DIMENSION">
        <doc xml:space="preserve">built-in color used by default in
                                  #AdgDimStyle. This dress will be resolved
                                  to an #AdgColorStyle instance.</doc>
      </member>
      <member name="color_annotation"
              value="5"
              c:identifier="ADG_DRESS_COLOR_ANNOTATION">
        <doc xml:space="preserve">built-in color used for rendering
                                  helper entities such as #AdgToyText,
                                  #AdgTable and #AdgTitleBlock. This dress
                                  will be resolved to an #AdgColorStyle
                                  instance.</doc>
      </member>
      <member name="color_fill" value="6" c:identifier="ADG_DRESS_COLOR_FILL">
        <doc xml:space="preserve">built-in color used by default by
                                  #AdgFillStyle based styles. This dress
                                  will be resolved to an #AdgColorStyle
                                  instance.</doc>
      </member>
      <member name="color_axis" value="7" c:identifier="ADG_DRESS_COLOR_AXIS">
        <doc xml:space="preserve">default built-in color for stroking
                                  #ADG_DRESS_LINE_AXIS lines. This dress
                                  will be resolved to an #AdgColorStyle
                                  instance.</doc>
      </member>
      <member name="color_hidden"
              value="8"
              c:identifier="ADG_DRESS_COLOR_HIDDEN">
        <doc xml:space="preserve">default built-in color for stroking
                                  #ADG_DRESS_LINE_HIDDEN lines. This dress
                                  will be resolved to an #AdgColorStyle
                                  instance.</doc>
      </member>
      <member name="line" value="9" c:identifier="ADG_DRESS_LINE">
        <doc xml:space="preserve">default built-in line. This is a
                                  pass-through dress, that is it does not
                                  change the cairo context when it is
                                  applied. This dress will be resolved to
                                  an #AdgLineStyle instance.</doc>
      </member>
      <member name="line_stroke"
              value="10"
              c:identifier="ADG_DRESS_LINE_STROKE">
        <doc xml:space="preserve">built-in line type to be used by default
                                  for rendering #AdgStroke entities.
                                  This dress will be resolved to an
                                  #AdgLineStyle instance.</doc>
      </member>
      <member name="line_dimension"
              value="11"
              c:identifier="ADG_DRESS_LINE_DIMENSION">
        <doc xml:space="preserve">built-in line type used by default for
                                  rendering base and extension lines of
                                  dimensions. This dress will be resolved
                                  to an #AdgLineStyle instance.</doc>
      </member>
      <member name="line_fill" value="12" c:identifier="ADG_DRESS_LINE_FILL">
        <doc xml:space="preserve">built-in line type used by #AdgFillStyle.
                                  This dress will be resolved to an
                                  #AdgLineStyle instance.</doc>
      </member>
      <member name="line_grid" value="13" c:identifier="ADG_DRESS_LINE_GRID">
        <doc xml:space="preserve">built-in line type used for rendering
                                  the grid of #AdgTable entities, that is
                                  the frame of the cells. This dress will
                                  be resolved to an #AdgLineStyle instance.</doc>
      </member>
      <member name="line_frame" value="14" c:identifier="ADG_DRESS_LINE_FRAME">
        <doc xml:space="preserve">built-in line type used for rendering the
                                  frame of #AdgTable entities, that is the
                                  frame around the whole table. This dress
                                  will be resolved to an #AdgLineStyle
                                  instance.</doc>
      </member>
      <member name="line_axis" value="15" c:identifier="ADG_DRESS_LINE_AXIS">
        <doc xml:space="preserve">built-in line type used for rendering axis
                                  and centerlines. This dress will be
                                  resolved to an #AdgLineStyle instance.</doc>
      </member>
      <member name="line_hidden"
              value="16"
              c:identifier="ADG_DRESS_LINE_HIDDEN">
        <doc xml:space="preserve">built-in line type used for rendering
                                  hidden lines and edges. This dress will be
                                  resolved to an #AdgLineStyle instance.</doc>
      </member>
      <member name="font" value="17" c:identifier="ADG_DRESS_FONT">
        <doc xml:space="preserve">default built-in font. This dress will be
                                  resolved to an #AdgFontStyle instance.</doc>
      </member>
      <member name="font_text" value="18" c:identifier="ADG_DRESS_FONT_TEXT">
        <doc xml:space="preserve">built-in font used by default for
                                  rendering common text such as #AdgToyText
                                   or the value of #AdgTable entities. This
                                   dress will be resolved to an #AdgFontStyle
                                   instance.</doc>
      </member>
      <member name="font_annotation"
              value="19"
              c:identifier="ADG_DRESS_FONT_ANNOTATION">
        <doc xml:space="preserve">built-in font used for rendering auxiliary
                                  text, such as the titles on #AdgTable
                                  entities. This dress will be resolved to
                                  an #AdgFontStyle instance.</doc>
      </member>
      <member name="font_quote_text"
              value="20"
              c:identifier="ADG_DRESS_FONT_QUOTE_TEXT">
        <doc xml:space="preserve">built-in font used for rendering regular
                                  text on dimension entities, such as the
                                  nominal value and the notes of a quote.
                                  This dress will be resolved to an
                                  #AdgFontStyle instance.</doc>
      </member>
      <member name="font_quote_annotation"
              value="21"
              c:identifier="ADG_DRESS_FONT_QUOTE_ANNOTATION">
        <doc xml:space="preserve">built-in font used for rendering auxiliary
                                  text on dimension entities, such as the
                                  min and max limits of a quote. This dress
                                  will be resolved to an #AdgFontStyle
                                  instance.</doc>
      </member>
      <member name="dimension" value="22" c:identifier="ADG_DRESS_DIMENSION">
        <doc xml:space="preserve">default built-in for dimensions. This
                                  dress will be resolved to an #AdgDimStyle
                                  instance.</doc>
      </member>
      <member name="fill" value="23" c:identifier="ADG_DRESS_FILL">
        <doc xml:space="preserve">default built-in for filling. This is a
                                  pass-through dress, that is it does not
                                  change the cairo context when it is
                                  applied. This dress will be resolved to an
                                  #AdgFillStyle derived instance.</doc>
      </member>
      <member name="fill_hatch" value="24" c:identifier="ADG_DRESS_FILL_HATCH">
        <doc xml:space="preserve">built-in dress used by default by
                                  #AdgHatch instances. This dress will be
                                  resolved to an #AdgFillStyle derived
                                  instance.</doc>
      </member>
      <member name="table" value="25" c:identifier="ADG_DRESS_TABLE">
        <doc xml:space="preserve">default built-in for tables. This dress
                                  will be resolved to an #AdgTableStyle
                                  derived instance.</doc>
      </member>
    </enumeration>
    <class name="Edges"
           c:symbol-prefix="edges"
           c:type="AdgEdges"
           version="1.0"
           parent="Trail"
           glib:type-name="AdgEdges"
           glib:get-type="adg_edges_get_type"
           glib:type-struct="EdgesClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_edges_new" version="1.0">
        <doc xml:space="preserve">Creates a new undefined model to keep track of the edges of
another model. You should at least set the referred #AdgTrail
with adg_edges_set_source().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created edges model</doc>
          <type name="Edges" c:type="AdgEdges*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_source"
                   c:identifier="adg_edges_new_with_source"
                   version="1.0">
        <doc xml:space="preserve">Creates a new edges model explicitely specifying the source trail.
The returned object will own a weak reference on @source.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created edges model</doc>
          <type name="Edges" c:type="AdgEdges*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the new source #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_axis_angle"
              c:identifier="adg_edges_get_axis_angle"
              version="1.0">
        <doc xml:space="preserve">Gets the angle of the supposed axis of @edges. Refer to
adg_edges_set_axis_angle() for details of what this parameter
is used for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value (in radians) of the axis angle</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_critical_angle"
              c:identifier="adg_edges_get_critical_angle"
              version="1.0">
        <doc xml:space="preserve">Gets the current critical angle of @edges. Refer to
adg_edges_set_critical_angle() for details of what this parameter
is used for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value (in radians) of the critical angle</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source"
              c:identifier="adg_edges_get_source"
              version="1.0">
        <doc xml:space="preserve">Gets the source #AdgTrail of this @edges model.
The returned object is owned by @edges and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested #AdgTrail or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Trail" c:type="AdgTrail*"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_axis_angle"
              c:identifier="adg_edges_set_axis_angle"
              version="1.0">
        <doc xml:space="preserve">Sets the axis angle of @edges to @angle, basically setting
the #AdgEdges:axis-angle property. All the resulting edge
lines will be normal to this axis.

It is implied the axis will pass through the (0,0) point,
so the underlying trail should be constructed accordingly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the new angle (in radians)</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_critical_angle"
              c:identifier="adg_edges_set_critical_angle"
              version="1.0">
        <doc xml:space="preserve">Sets the critical angle of @edges to @angle, basically setting
the #AdgEdges:critical-angle property.

The critical angle defines what corner should generate an edge and
what not. Typical values are close to 0, being 0 the lowest angle
where every corner generates an edge.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the new angle (in radians)</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source"
              c:identifier="adg_edges_set_source"
              version="1.0">
        <doc xml:space="preserve">Sets @source as the source trail for @edges.
After the call, @edges will own a weak reference on @source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="edges" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEdges</doc>
            <type name="Edges" c:type="AdgEdges*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the new source #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </method>
      <property name="axis-angle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="critical-angle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="source"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Trail"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Trail" c:type="AdgTrail"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="EdgesClass"
            c:type="AdgEdgesClass"
            glib:is-gtype-struct-for="Edges">
      <field name="parent_class" readable="0" private="1">
        <type name="TrailClass" c:type="AdgTrailClass"/>
      </field>
    </record>
    <class name="Entity"
           c:symbol-prefix="entity"
           c:type="AdgEntity"
           version="1.0"
           parent="GObject.InitiallyUnowned"
           abstract="1"
           glib:type-name="AdgEntity"
           glib:get-type="adg_entity_get_type"
           glib:type-struct="EntityClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="arrange" invoker="arrange" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::arrange signal on @entity and all its children,
if any. The arrange call is implicitely called by the
#AdgEntity::render signal but not by adg_entity_get_extents().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="destroy" invoker="destroy" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::destroy signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="global_changed"
                      invoker="global_changed"
                      version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::global-changed signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate" invoker="invalidate" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::invalidate signal on @entity and on all of
its children, if any, clearing the eventual cache stored by the
#AdgEntity::arrange signal and setting the entity state similary
to the just initialized entity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_changed"
                      invoker="local_changed"
                      version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::local-changed signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parent_set">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="old_parent" transfer-ownership="none">
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render" invoker="render" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::render signal on @entity and on all of its
children, if any, causing the rendering to the @cr cairo context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_t drawing context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="apply_dress"
              c:identifier="adg_entity_apply_dress"
              version="1.0">
        <doc xml:space="preserve">Convenient function to apply a @dress style (as returned by
adg_entity_style()) to the @cr cairo context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the dress style to apply</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_t drawing context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="arrange" c:identifier="adg_entity_arrange" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::arrange signal on @entity and all its children,
if any. The arrange call is implicitely called by the
#AdgEntity::render signal but not by adg_entity_get_extents().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="adg_entity_destroy" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::destroy signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_canvas"
              c:identifier="adg_entity_get_canvas"
              version="1.0">
        <doc xml:space="preserve">Walks on the @entity hierarchy and gets the first parent of @entity,
that is the first #AdgCanvas instance. The returned object is
owned by @entity and should not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested canvas or &lt;constant&gt;NULL&lt;/constant&gt; on errors or if there is no #AdgCanvas in the @entity hierarchy.</doc>
          <type name="Canvas" c:type="AdgCanvas*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="adg_entity_get_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the bounding box of @entity. The returned struct is
owned by @entity and should not modified or freed.

This struct specifies the surface portion (in global space
of @entity) occupied by the entity without taking into
account rendering properties such as line thickness or caps.

The #AdgEntity::arrange signal should be emitted before
this call (either explicitely trought adg_entity_arrange()
or implicitely with adg_entity_render()) in order to get
an up to date boundary box.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bounding box of @entity or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_global_map"
              c:identifier="adg_entity_get_global_map"
              version="1.0">
        <doc xml:space="preserve">Gets the transformation to be used to compute the global matrix
of @entity.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested map or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_global_matrix"
              c:identifier="adg_entity_get_global_matrix"
              version="1.0">
        <doc xml:space="preserve">Gets the current global matrix of @entity. The returned value
is owned by @entity and should not be changed or freed.

The global matrix is computed in the arrange() phase by
combining all the global maps of the @entity hierarchy using
the %ADG_MIX_ANCESTORS method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the global matrix or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_map"
              c:identifier="adg_entity_get_local_map"
              version="1.0">
        <doc xml:space="preserve">Gets the transformation to be used to compute the local matrix
of @entity and store it in @map.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested map or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_matrix"
              c:identifier="adg_entity_get_local_matrix"
              version="1.0">
        <doc xml:space="preserve">Gets the current local matrix of @entity. The returned value
is owned by @entity and should not be changed or freed.

The local matrix is computed in the arrange() phase by
combining all the local maps of the @entity hierarchy using
the method specified by the #AdgEntity:local-mix property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the local matrix or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_mix"
              c:identifier="adg_entity_get_local_mix"
              version="1.0">
        <doc xml:space="preserve">Gets the local mix method of @entity. Check out the
adg_entity_set_local_mix() documentation to know what the
local mix method is used for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the local mix method of @entity or %ADG_MIX_UNDEFINED on errors</doc>
          <type name="Mix" c:type="AdgMix"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="adg_entity_get_parent"
              version="1.0">
        <doc xml:space="preserve">Gets the parent of @entity. The returned object is owned
by @entity and should not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent entity or &lt;constant&gt;NULL&lt;/constant&gt; on errors or if @entity is a toplevel.</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_style"
              c:identifier="adg_entity_get_style"
              version="1.0">
        <doc xml:space="preserve">Gets the overriden @dress style from @entity. This is a kind
of accessor function: for rendering purpose use adg_entity_style()
instead. The returned object is owned by @entity and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested style or &lt;constant&gt;NULL&lt;/constant&gt; if the @dress style is not overriden.</doc>
          <type name="Style" c:type="AdgStyle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the dress of the style to get</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="global_changed"
              c:identifier="adg_entity_global_changed"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::global-changed signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate"
              c:identifier="adg_entity_invalidate"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::invalidate signal on @entity and on all of
its children, if any, clearing the eventual cache stored by the
#AdgEntity::arrange signal and setting the entity state similary
to the just initialized entity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="local_changed"
              c:identifier="adg_entity_local_changed"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::local-changed signal on @entity and on all of
its children, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="point" c:identifier="adg_entity_point" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

A convenient method to set an #AdgPoint owned by @entity.
@old_point is the old value while @new_point is the new value.
It can be used for changing a private #AdgPoint struct, such as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
data-&gt;point = adg_entity_point(entity, data-&gt;point, new_point);
&lt;/programlisting&gt;&lt;/informalexample&gt;

This function takes care of the dependencies between @entity and
the eventual models bound to the old and new points.

@old_point can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case a
clone of @new_point will be returned. Also @new_point can
be &lt;constant&gt;NULL&lt;/constant&gt;, in which case @old_point
is destroyed and &lt;constant&gt;NULL&lt;/constant&gt; will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new properly defined point</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgPoint to define</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </parameter>
          <parameter name="new_point" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgPoint value</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="adg_entity_render" version="1.0">
        <doc xml:space="preserve">Emits the #AdgEntity::render signal on @entity and on all of its
children, if any, causing the rendering to the @cr cairo context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_t drawing context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_extents"
              c:identifier="adg_entity_set_extents"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Sets a new bounding box for @entity. @extents can
be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the extents are unset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the new extents</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_global_map"
              c:identifier="adg_entity_set_global_map"
              version="1.0">
        <doc xml:space="preserve">Sets the new global transformation of @entity to @map:
the old map is discarded. If @map is &lt;constant&gt;NULL&lt;/constant&gt;,
the global map is left unchanged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the new map</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_map"
              c:identifier="adg_entity_set_local_map"
              version="1.0">
        <doc xml:space="preserve">Sets the new local transformation of @entity to @map:
the old map is discarded. If @map is &lt;constant&gt;NULL&lt;/constant&gt;,
the local map is left unchanged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the new map</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_mix"
              c:identifier="adg_entity_set_local_mix"
              version="1.0">
        <doc xml:space="preserve">Sets a new local mix method on @entity. The
#AdgEntity:local-mix property defines how the local
matrix must be computed: check out the #AdgMix
documentation to know what are the availables methods
and how they affect the local matrix computation.

Setting a different local mix method emits an
#AdgEntity::local-changed signal on @entity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="local_mix" transfer-ownership="none">
            <doc xml:space="preserve">new mix method</doc>
            <type name="Mix" c:type="AdgMix"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent"
              c:identifier="adg_entity_set_parent"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Sets a new parent on @entity. Changing the @parent of an entity
emits the #AdgEntity::parent-set signal on it.

There is no reference management at this level: they should be
handled at a higher level, e.g. by #AdgContainer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the parent entity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_style"
              c:identifier="adg_entity_set_style"
              version="1.0">
        <doc xml:space="preserve">Overrides the style of @dress for @entity and its children.
If @style is &lt;constant&gt;NULL&lt;/constant&gt;, any previous
override is removed.

The new style must still be compatible with @dress: check out
the adg_dress_style_is_compatible() documentation to know
what a compatible style means.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">a dress style</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
          <parameter name="style" transfer-ownership="none">
            <doc xml:space="preserve">the new style to use</doc>
            <type name="Style" c:type="AdgStyle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="style" c:identifier="adg_entity_style" version="1.0">
        <doc xml:space="preserve">Gets the style to be used for @entity. @dress specifies which
"family" of style to get.

The following sequence of checks is performed to get the proper
style, stopping at the first succesfull result:

&lt;orderedlist&gt;
&lt;listitem&gt;check if the style is directly overriden by this entity,
          as returned by adg_entity_get_style();&lt;/listitem&gt;
&lt;listitem&gt;check if @entity has a parent, in which case returns the
          adg_entity_style() of the parent;&lt;/listitem&gt;
&lt;listitem&gt;returns the main style with adg_dress_get_fallback().&lt;/listitem&gt;
&lt;/orderedlist&gt;

The returned object is owned by @entity and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested style or &lt;constant&gt;NULL&lt;/constant&gt; for transparent dresses or errors.</doc>
          <type name="Style" c:type="AdgStyle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the dress of the style to get</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_global_map"
              c:identifier="adg_entity_transform_global_map"
              version="1.0">
        <doc xml:space="preserve">Convenient function to change the global map of @entity by
applying @tranformation using the @mode operator. This is
logically equivalent to the following:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
cairo_matrix_t map;
adg_matrix_copy(&amp;map, adg_entity_get_global_map(entity));
adg_matrix_transform(&amp;map, transformation, mode);
adg_entity_set_global_map(entity, &amp;map);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="transformation" transfer-ownership="none">
            <doc xml:space="preserve">the transformation to apply</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">how @transformation should be applied</doc>
            <type name="TransformMode" c:type="AdgTransformMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_local_map"
              c:identifier="adg_entity_transform_local_map"
              version="1.0">
        <doc xml:space="preserve">Convenient function to change the local map of @entity by
applying @tranformation using the @mode operator. This is
logically equivalent to the following:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
cairo_matrix_t map;
adg_matrix_copy(&amp;map, adg_entity_get_local_map(entity));
adg_matrix_transform(&amp;map, transformation, mode);
adg_entity_set_local_map(entity, &amp;map);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity object</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </instance-parameter>
          <parameter name="transformation" transfer-ownership="none">
            <doc xml:space="preserve">the transformation to apply</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">how @transformation should be applied</doc>
            <type name="TransformMode" c:type="AdgTransformMode"/>
          </parameter>
        </parameters>
      </method>
      <property name="global-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="local-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="local-mix"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="parent" writable="1" transfer-ownership="none">
        <type name="Entity"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.InitiallyUnowned" c:type="GInitiallyUnowned"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="arrange" when="last" version="1.0">
        <doc xml:space="preserve">Arranges the layout of @entity, updating the cache if necessary,
and computes the extents of @entity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="destroy" when="first" version="1.0">
        <doc xml:space="preserve">Emitted to explicitely destroy @entity. It unreferences
@entity so that will be destroyed, unless the caller owns
an additional references added with g_object_ref().

In the usual case, this is equivalent of calling
g_object_unref() on @entity but, for composite entities or
containers, the destroy signal is propagated to the children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="global-changed" when="first" version="1.0">
        <doc xml:space="preserve">Emitted when the global map of @entity or any of its parent
has changed. The default handler will compute the new global
matrix, updating the internal cache.

This signal has lazy emission, i.e. it is emitted only when
the global matrix is requested, typically in the arrange phase.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="invalidate" when="last" version="1.0">
        <doc xml:space="preserve">Invalidates the whole @entity, that is resets all the cache
(if present) built during the #AdgEntity::arrange signal.
The resulting state is a clean entity, similar to what you
have just before the first rendering.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="local-changed" when="first" version="1.0">
        <doc xml:space="preserve">Emitted when the local map of @entity or any of its parent
has changed. The default handler will compute the new local
matrix, updating the internal cache.

This signal has lazy emission, i.e. it is emitted only when
the local matrix is requested, typically in the arrange phase.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="parent-set" when="first" version="1.0">
        <doc xml:space="preserve">Emitted after the parent entity has changed. The new parent
can be inspected using adg_entity_get_parent().

It is allowed for both old and new parent to
be &lt;constant&gt;NULL&lt;/constant&gt;.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_parent" transfer-ownership="none">
            <doc xml:space="preserve">the old parent</doc>
            <type name="Entity"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="render" when="last" version="1.0">
        <doc xml:space="preserve">Causes the rendering of @entity on @cr. A render signal will
automatically emit #AdgEntity::arrange just before the real
rendering on the cairo context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_t drawing context</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="EntityClass"
            c:type="AdgEntityClass"
            glib:is-gtype-struct-for="Entity"
            version="1.0">
      <doc xml:space="preserve">Any entity (if not abstract) must implement at least the @render method.
The other signal handlers can be overriden to provide custom behaviors
and usually must chain up the original handler.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.InitiallyUnownedClass"
              c:type="GInitiallyUnownedClass"/>
      </field>
      <field name="destroy">
        <callback name="destroy">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parent_set">
        <callback name="parent_set">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
            <parameter name="old_parent" transfer-ownership="none">
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="global_changed">
        <callback name="global_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_changed">
        <callback name="local_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="arrange">
        <callback name="arrange">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render">
        <callback name="render">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
            <parameter name="cr" transfer-ownership="none">
              <doc xml:space="preserve">a #cairo_t drawing context</doc>
              <type name="cairo.Context" c:type="cairo_t*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FillStyle"
           c:symbol-prefix="fill_style"
           c:type="AdgFillStyle"
           version="1.0"
           parent="Style"
           abstract="1"
           glib:type-name="AdgFillStyle"
           glib:get-type="adg_fill_style_get_type"
           glib:type-struct="FillStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="set_extents" invoker="set_extents" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in new fill style implementations.
&lt;/para&gt;&lt;/note&gt;

Forcibly sets new extents on @fill_style. Any fill style class
that want to make some kind of customization can override the
&lt;function&gt;set_extents&lt;/function&gt; virtual method to intercept
any extents change.

Sets new extents on @fill_style. These extents are usually set
by the arrange() method of the entity using this filling style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fill_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFillStyle</doc>
            <type name="FillStyle" c:type="AdgFillStyle*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the new extents</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_extents"
              c:identifier="adg_fill_style_get_extents"
              version="1.0">
        <doc xml:space="preserve">Stores a copy of the extents of @fill_style in @extents.
This struct specifies the maximum portion (in global space)
this fill style should be applied: it will clamped by the
entities as needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of @fill_style or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fill_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFillStyle</doc>
            <type name="FillStyle" c:type="AdgFillStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pattern"
              c:identifier="adg_fill_style_get_pattern"
              version="1.0">
        <doc xml:space="preserve">Gets the current pattern binded to @fill_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current pattern</doc>
          <type name="cairo.Pattern" c:type="cairo_pattern_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fill_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFillStyle</doc>
            <type name="FillStyle" c:type="AdgFillStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_extents"
              c:identifier="adg_fill_style_set_extents"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in new fill style implementations.
&lt;/para&gt;&lt;/note&gt;

Forcibly sets new extents on @fill_style. Any fill style class
that want to make some kind of customization can override the
&lt;function&gt;set_extents&lt;/function&gt; virtual method to intercept
any extents change.

Sets new extents on @fill_style. These extents are usually set
by the arrange() method of the entity using this filling style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fill_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFillStyle</doc>
            <type name="FillStyle" c:type="AdgFillStyle*"/>
          </instance-parameter>
          <parameter name="extents" transfer-ownership="none">
            <doc xml:space="preserve">the new extents</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pattern"
              c:identifier="adg_fill_style_set_pattern"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in new fill implementations.
&lt;/para&gt;&lt;/note&gt;

Sets a new pattern on @fill_style. A new reference is added to
@pattern with cairo_pattern_reference() and the old pattern
(if any) is unreferenced with cairo_pattern_destroy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fill_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFillStyle</doc>
            <type name="FillStyle" c:type="AdgFillStyle*"/>
          </instance-parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">the new pattern</doc>
            <type name="cairo.Pattern" c:type="cairo_pattern_t*"/>
          </parameter>
        </parameters>
      </method>
      <property name="pattern" writable="1" transfer-ownership="none">
        <type name="cairo.Pattern"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="FillStyleClass"
            c:type="AdgFillStyleClass"
            glib:is-gtype-struct-for="FillStyle"
            version="1.0">
      <doc xml:space="preserve">The default &lt;function&gt;set_extents&lt;/function&gt; implementation simply sets
the extents owned by the fill style instance to the one provided, so the
last call has precedence. Any derived class can override it to customize
this behavior, for example to keep the greatest boundary box instead of
the last one.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
      <field name="set_extents">
        <callback name="set_extents">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="fill_style" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgFillStyle</doc>
              <type name="FillStyle" c:type="AdgFillStyle*"/>
            </parameter>
            <parameter name="extents" transfer-ownership="none">
              <doc xml:space="preserve">the new extents</doc>
              <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FontStyle"
           c:symbol-prefix="font_style"
           c:type="AdgFontStyle"
           version="1.0"
           parent="Style"
           glib:type-name="AdgFontStyle"
           glib:get-type="adg_font_style_get_type"
           glib:type-struct="FontStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_font_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new font style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created font style</doc>
          <type name="FontStyle" c:type="AdgFontStyle*"/>
        </return-value>
      </constructor>
      <method name="get_antialias"
              c:identifier="adg_font_style_get_antialias"
              version="1.0">
        <doc xml:space="preserve">Gets the antialias mode used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested antialias mode.</doc>
          <type name="gint" c:type="cairo_antialias_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_dress"
              c:identifier="adg_font_style_get_color_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the color dress used by @font_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current color dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family"
              c:identifier="adg_font_style_get_family"
              version="1.0">
        <doc xml:space="preserve">Gets the family of @font_style. The returned pointer refers to
internally managed text that must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested family.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hint_metrics"
              c:identifier="adg_font_style_get_hint_metrics"
              version="1.0">
        <doc xml:space="preserve">Gets the state on whether to hint font metrics.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested hint metrics state.</doc>
          <type name="gint" c:type="cairo_hint_metrics_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hint_style"
              c:identifier="adg_font_style_get_hint_style"
              version="1.0">
        <doc xml:space="preserve">Gets the hint style mode used, that is how to fit outlines
to the pixel grid in order to improve the appearance of the result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested hint style mode.</doc>
          <type name="gint" c:type="cairo_hint_style_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scaled_font"
              c:identifier="adg_font_style_get_scaled_font"
              version="1.0">
        <doc xml:space="preserve">Gets the scaled font of @font_style. The returned font is
owned by @font_style and must not be destroyed by the caller.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scaled font.</doc>
          <type name="cairo.ScaledFont" c:type="cairo_scaled_font_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="ctm" transfer-ownership="none">
            <doc xml:space="preserve">the current transformation matrix</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size"
              c:identifier="adg_font_style_get_size"
              version="1.0">
        <doc xml:space="preserve">Gets the size (in global space) of @font_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size variant.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slant"
              c:identifier="adg_font_style_get_slant"
              version="1.0">
        <doc xml:space="preserve">Gets the slant variant of @font_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the slant variant.</doc>
          <type name="gint" c:type="cairo_font_slant_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subpixel_order"
              c:identifier="adg_font_style_get_subpixel_order"
              version="1.0">
        <doc xml:space="preserve">Gets the subpixel order mode used, that is the order of color elements
within each pixel on the display device when rendering with an
antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested subpixel order mode.</doc>
          <type name="gint" c:type="cairo_subpixel_order_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_weight"
              c:identifier="adg_font_style_get_weight"
              version="1.0">
        <doc xml:space="preserve">Gets the weight variant of @font_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the weight variant.</doc>
          <type name="gint" c:type="cairo_font_weight_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_options"
              c:identifier="adg_font_style_new_options"
              version="1.0">
        <doc xml:space="preserve">Creates a new set of #cairo_font_options_t filled with the values
picked from @font_style. The returned value must be freed with
cairo_font_options_destroy().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated list of cairo font options.</doc>
          <type name="cairo.FontOptions" c:type="cairo_font_options_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_antialias"
              c:identifier="adg_font_style_set_antialias"
              version="1.0">
        <doc xml:space="preserve">Sets a new antialias mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="antialias" transfer-ownership="none">
            <doc xml:space="preserve">the new antialias mode</doc>
            <type name="gint" c:type="cairo_antialias_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_dress"
              c:identifier="adg_font_style_set_color_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new color dress on @font_style. The new dress
should be related to the original dress: you cannot
set a dress used for font styles to a dress managing
fonts.

The validation of the new dress is done by calling
adg_dress_are_related() with @dress and the previous
dress as arguments: check out its documentation for
details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new color dress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_family"
              c:identifier="adg_font_style_set_family"
              version="1.0">
        <doc xml:space="preserve">Sets a new family.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:space="preserve">the new family</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint_metrics"
              c:identifier="adg_font_style_set_hint_metrics"
              version="1.0">
        <doc xml:space="preserve">Sets a new hint metrics state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="hint_metrics" transfer-ownership="none">
            <doc xml:space="preserve">the new hint metrics state</doc>
            <type name="gint" c:type="cairo_hint_metrics_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hint_style"
              c:identifier="adg_font_style_set_hint_style"
              version="1.0">
        <doc xml:space="preserve">Sets a new hint style mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="hint_style" transfer-ownership="none">
            <doc xml:space="preserve">the new hint style mode</doc>
            <type name="gint" c:type="cairo_hint_style_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size"
              c:identifier="adg_font_style_set_size"
              version="1.0">
        <doc xml:space="preserve">Sets a new size (in global space) on @font_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the new size</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slant"
              c:identifier="adg_font_style_set_slant"
              version="1.0">
        <doc xml:space="preserve">Sets a new slant variant on @font_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="slant" transfer-ownership="none">
            <doc xml:space="preserve">the new slant</doc>
            <type name="gint" c:type="cairo_font_slant_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subpixel_order"
              c:identifier="adg_font_style_set_subpixel_order"
              version="1.0">
        <doc xml:space="preserve">Sets a new subpixel order mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="subpixel_order" transfer-ownership="none">
            <doc xml:space="preserve">the new subpixel order mode</doc>
            <type name="gint" c:type="cairo_subpixel_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_weight"
              c:identifier="adg_font_style_set_weight"
              version="1.0">
        <doc xml:space="preserve">Sets a new weight variant on @font_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="font_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgFontStyle object</doc>
            <type name="FontStyle" c:type="AdgFontStyle*"/>
          </instance-parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:space="preserve">the new weight</doc>
            <type name="gint" c:type="cairo_font_weight_t"/>
          </parameter>
        </parameters>
      </method>
      <property name="antialias" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="color-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="family" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="hint-metrics" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="hint-style" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="size" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="slant" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="subpixel-order" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="weight" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="FontStyleClass"
            c:type="AdgFontStyleClass"
            glib:is-gtype-struct-for="FontStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
    </record>
    <constant name="GTK_MODIFIERS"
              value="0"
              c:type="ADG_GTK_MODIFIERS"
              version="1.0">
      <doc xml:space="preserve">A GDK mask of the key/mouse modifiers accepted by the GTK+ widgets
of the ADG library. This means the state of the specified modifiers
is always checked: for example %GDK_CONTROL_MASK and %GDK_SHIFT_MASK
are included, hence keeping &lt;keycap&gt;CTRL&lt;/keycap&gt;
and &lt;keycap&gt;SHIFT&lt;/keycap&gt; pressed is different from keeping
only &lt;keycap&gt;SHIFT&lt;/keycap&gt; pressed. %GDK_LOCK_MASK instead is not
considered, so having it enabled or disabled does not make any
difference while monitoring the status &lt;keycap&gt;SHIFT&lt;/keycap&gt;
or &lt;keycap&gt;CTRL&lt;/keycap&gt;.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="GtkArea"
           c:symbol-prefix="gtk_area"
           c:type="AdgGtkArea"
           version="1.0"
           parent="Gtk.DrawingArea"
           glib:type-name="AdgGtkArea"
           glib:get-type="adg_gtk_area_get_type"
           glib:type-struct="GtkAreaClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Gtk.Buildable"/>
      <constructor name="new" c:identifier="adg_gtk_area_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty #AdgGtkArea. The widget is useful only after
an #AdgCanvas has been added either using the #AdgGtkArea:canvas
property or with adg_gtk_area_set_canvas().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created widget</doc>
          <type name="Gtk.Widget" c:type="GtkWidget*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_canvas"
                   c:identifier="adg_gtk_area_new_with_canvas"
                   version="1.0">
        <doc xml:space="preserve">Creates a new #AdgGtkArea and sets the #AdgGtkArea:canvas property
to @canvas.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created widget</doc>
          <type name="Gtk.Widget" c:type="GtkWidget*"/>
        </return-value>
        <parameters>
          <parameter name="canvas" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgCanvas shown by this widget</doc>
            <type name="Canvas" c:type="AdgCanvas*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="canvas_changed"
                      invoker="canvas_changed"
                      version="1.0">
        <doc xml:space="preserve">Emits the #AdgGtkArea::canvas-changed signal on @area.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="old_canvas" transfer-ownership="none">
            <doc xml:space="preserve">the old canvas bound to @area</doc>
            <type name="Canvas" c:type="AdgCanvas*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="extents_changed"
                      invoker="extents_changed"
                      version="1.0">
        <doc xml:space="preserve">Emits the #AdgGtkArea::extents-changed signal on @area.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="old_extents" transfer-ownership="none">
            <doc xml:space="preserve">the old extents of @area</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="canvas_changed"
              c:identifier="adg_gtk_area_canvas_changed"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgGtkArea::canvas-changed signal on @area.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="old_canvas" transfer-ownership="none">
            <doc xml:space="preserve">the old canvas bound to @area</doc>
            <type name="Canvas" c:type="AdgCanvas*"/>
          </parameter>
        </parameters>
      </method>
      <method name="extents_changed"
              c:identifier="adg_gtk_area_extents_changed"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgGtkArea::extents-changed signal on @area.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="old_extents" transfer-ownership="none">
            <doc xml:space="preserve">the old extents of @area</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_canvas"
              c:identifier="adg_gtk_area_get_canvas"
              version="1.0">
        <doc xml:space="preserve">Gets the canvas associated to @area. The returned canvas
is owned by @area and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested #AdgCanvas object or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Canvas" c:type="AdgCanvas*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="adg_gtk_area_get_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the extents of the canvas bound to @area. The returned
struct is owned by @area and should not modified or freed.

The extents of an #AdgGtkArea instance are the extents of
its canvas (as returned by adg_entity_get_extents()) with
the margins added to it and the #AdgGtkArea:render-map
transformation applied.

If @area does not have any canvas associated to it or the
canvas is invalid or empty, an undefined #CpmlExtents
struct will be returned.

The canvas will be updated, meaning adg_entity_arrange()
is called before the extents computation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of the @area canvas or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_factor"
              c:identifier="adg_gtk_area_get_factor"
              version="1.0">
        <doc xml:space="preserve">Gets the zoom factor associated to @area. The zoom factor is
directly used to zoom in (that is, the default zoom factor of
1.05 will zoom of 5% every iteration) and it is reversed while
zooming out (that is, the default factor will be 1/1.05).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested zoom factor or 0 on error</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_render_map"
              c:identifier="adg_gtk_area_get_render_map"
              version="1.0">
        <doc xml:space="preserve">Gets the render map.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested map or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea object</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_zoom"
              c:identifier="adg_gtk_area_get_zoom"
              version="1.0">
        <doc xml:space="preserve">Gets the last zoom coefficient applied on the canvas of @area.
If the #AdgGtkArea:autozoom property is &lt;constant&gt;FALSE&lt;/constant&gt;,
the value returned should be always 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current zoom coefficient.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_autozoom"
              c:identifier="adg_gtk_area_has_autozoom"
              version="1.0">
        <doc xml:space="preserve">Gets the current state of the #AdgGtkArea:autozoom property on
the @area object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current autozoom state</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="adg_gtk_area_reset">
        <doc xml:space="preserve">Forcibly resets the zoom ratio and position of the canvas bound
to @area. This means the canvas will be scaled and centered on
the current available space.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_canvas"
              c:identifier="adg_gtk_area_set_canvas"
              version="1.0">
        <doc xml:space="preserve">Sets a new canvas on @area. The old canvas, if presents, is
unreferenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="canvas" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgCanvas</doc>
            <type name="Canvas" c:type="AdgCanvas*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_factor"
              c:identifier="adg_gtk_area_set_factor"
              version="1.0">
        <doc xml:space="preserve">Sets a new zoom factor to @area. If the factor is less than
1, it will be clamped to 1.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the new zoom factor</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_render_map"
              c:identifier="adg_gtk_area_set_render_map"
              version="1.0">
        <doc xml:space="preserve">Sets the new render transformation of @area to @map: the
old map is discarded. If @map is &lt;constant&gt;NULL&lt;/constant&gt;,
the render map is left unchanged.

&lt;note&gt;&lt;para&gt;
The render map is an implementation detail and this function
is expected to be used only by #AdgGtkArea derived objects.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea object</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the new map</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_autozoom"
              c:identifier="adg_gtk_area_switch_autozoom"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgGtkArea:autozoom property of @area to @state. When the
autozoom feature is enabled, @area reacts to any size allocation
by adjusting its zoom coefficient in global space. This means the
drawing will fill the available space (keeping its aspect ratio)
when resizing the window.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new autozoom state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_render_map"
              c:identifier="adg_gtk_area_transform_render_map"
              version="1.0">
        <doc xml:space="preserve">Convenient function to change the render map of @area by
applying @tranformation using the @mode operator. This is
logically equivalent to the following:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
cairo_matrix_t map;
adg_matrix_copy(&amp;map, adg_gtk_area_get_render_map(area));
adg_matrix_transform(&amp;map, transformation, mode);
adg_gtk_area_set_render_map(area, &amp;map);
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;note&gt;&lt;para&gt;
The render map is an implementation detail and this function
is expected to be used only by #AdgGtkArea derived objects.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="area" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkArea object</doc>
            <type name="GtkArea" c:type="AdgGtkArea*"/>
          </instance-parameter>
          <parameter name="transformation" transfer-ownership="none">
            <doc xml:space="preserve">the transformation to apply</doc>
            <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">how @transformation should be applied</doc>
            <type name="TransformMode" c:type="AdgTransformMode"/>
          </parameter>
        </parameters>
      </method>
      <property name="autozoom" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="canvas"
                introspectable="0"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="factor" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="render-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Gtk.DrawingArea" c:type="GtkDrawingArea"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="canvas-changed"
                   when="last"
                   no-recurse="1"
                   version="1.0">
        <doc xml:space="preserve">Emitted after the canvas bound to @area has been changed. The old
canvas accessible from @old_canvas while the new canvas can be got
with the usual API, e.g. adg_gtk_area_get_canvas().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_canvas" transfer-ownership="none">
            <doc xml:space="preserve">the old #AdgCanvas object</doc>
            <type name="Canvas"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="extents-changed"
                   when="last"
                   no-recurse="1"
                   version="1.0">
        <doc xml:space="preserve">Emitted when the extents of @area have been changed.
The old extents are always compared to the new ones,
so when the extents are recalculated but the result
is the same the signal is not emitted.

The extents of #AdgGtkArea are subject to the render
map, so changing the #AdgGtkArea:render-map property
will emit this signal too.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_extents" transfer-ownership="none">
            <doc xml:space="preserve">the old #CpmlExtents struct</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="GtkAreaClass"
            c:type="AdgGtkAreaClass"
            glib:is-gtype-struct-for="GtkArea"
            version="1.0">
      <doc xml:space="preserve">The default @canvas_changed resets the internal initialization flag, so at
the first call to the &lt;function&gt;size_allocate&lt;/function&gt; method the zoom
factor is set to 1.

The default @extents_changed signal does not do anything: it is intended as
a hook for derived class for refreshing GUI elements (such as scrollbars)
whenever the boundary box changes.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="Gtk.DrawingAreaClass" c:type="GtkDrawingAreaClass"/>
      </field>
      <field name="canvas_changed">
        <callback name="canvas_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="area" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgGtkArea</doc>
              <type name="GtkArea" c:type="AdgGtkArea*"/>
            </parameter>
            <parameter name="old_canvas" transfer-ownership="none">
              <doc xml:space="preserve">the old canvas bound to @area</doc>
              <type name="Canvas" c:type="AdgCanvas*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="extents_changed">
        <callback name="extents_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="area" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgGtkArea</doc>
              <type name="GtkArea" c:type="AdgGtkArea*"/>
            </parameter>
            <parameter name="old_extents" transfer-ownership="none">
              <doc xml:space="preserve">the old extents of @area</doc>
              <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="GtkLayout"
           c:symbol-prefix="gtk_layout"
           c:type="AdgGtkLayout"
           version="1.0"
           parent="GtkArea"
           glib:type-name="AdgGtkLayout"
           glib:get-type="adg_gtk_layout_get_type"
           glib:type-struct="GtkLayoutClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <implements name="Atk.ImplementorIface"/>
      <implements name="Gtk.Buildable"/>
      <implements name="Gtk.Scrollable"/>
      <constructor name="new" c:identifier="adg_gtk_layout_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty #AdgGtkLayout. The widget is useful only after
an #AdgCanvas has been added either using the #AdgGtkArea:canvas
property or with adg_gtk_area_set_canvas().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created widget.</doc>
          <type name="Gtk.Widget" c:type="GtkWidget*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_canvas"
                   c:identifier="adg_gtk_layout_new_with_canvas"
                   version="1.0">
        <doc xml:space="preserve">Creates a new #AdgGtkLayout and sets the #AdgGtkArea:canvas
property to @canvas.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created widget.</doc>
          <type name="Gtk.Widget" c:type="GtkWidget*"/>
        </return-value>
        <parameters>
          <parameter name="canvas" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgCanvas shown by this widget</doc>
            <type name="Canvas" c:type="AdgCanvas*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_hadjustment"
              c:identifier="adg_gtk_layout_get_hadjustment"
              version="1.0">
        <doc xml:space="preserve">Retrieves the current horizontal adjustment of @layout.

The returned alignment is owned by @layout and should
not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the alignment of @layout.</doc>
          <type name="Gtk.Adjustment" c:type="GtkAdjustment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkLayout</doc>
            <type name="GtkLayout" c:type="AdgGtkLayout*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vadjustment"
              c:identifier="adg_gtk_layout_get_vadjustment"
              version="1.0">
        <doc xml:space="preserve">Retrieves the current vertical adjustment of @layout.

The returned alignment is owned by @layout and should
not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the alignment of @layout.</doc>
          <type name="Gtk.Adjustment" c:type="GtkAdjustment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkLayout</doc>
            <type name="GtkLayout" c:type="AdgGtkLayout*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_hadjustment"
              c:identifier="adg_gtk_layout_set_hadjustment"
              version="1.0">
        <doc xml:space="preserve">Sets the new horizontal adjustment for @layout to @hadjustment.
The old adjustment, if present, is unreferenced.

This is basically the same as manually setting the
#GtkScrollable:hadjustment property with g_object_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkLayout</doc>
            <type name="GtkLayout" c:type="AdgGtkLayout*"/>
          </instance-parameter>
          <parameter name="hadjustment" transfer-ownership="none">
            <doc xml:space="preserve">the new adjustment</doc>
            <type name="Gtk.Adjustment" c:type="GtkAdjustment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vadjustment"
              c:identifier="adg_gtk_layout_set_vadjustment"
              version="1.0">
        <doc xml:space="preserve">Sets the new vertical adjustment for @layout to @vadjustment.
The old adjustment, if present, is unreferenced.

This is basically the same as manually setting the
#GtkScrollable:vadjustment property with g_object_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgGtkLayout</doc>
            <type name="GtkLayout" c:type="AdgGtkLayout*"/>
          </instance-parameter>
          <parameter name="vadjustment" transfer-ownership="none">
            <doc xml:space="preserve">the new adjustment</doc>
            <type name="Gtk.Adjustment" c:type="GtkAdjustment*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GtkArea" c:type="AdgGtkArea"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="GtkLayoutClass"
            c:type="AdgGtkLayoutClass"
            glib:is-gtype-struct-for="GtkLayout">
      <field name="parent_class" readable="0" private="1">
        <type name="GtkAreaClass" c:type="AdgGtkAreaClass"/>
      </field>
    </record>
    <class name="Hatch"
           c:symbol-prefix="hatch"
           c:type="AdgHatch"
           version="1.0"
           parent="Stroke"
           glib:type-name="AdgHatch"
           glib:get-type="adg_hatch_get_type"
           glib:type-struct="HatchClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_hatch_new" version="1.0">
        <doc xml:space="preserve">Creates a new hatch entity. @trail can be &lt;constant&gt;NULL&lt;/constant&gt;,
in which case an empty hatch is created.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created hatch entity</doc>
          <type name="Hatch" c:type="AdgHatch*"/>
        </return-value>
        <parameters>
          <parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTrail to hatch</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_fill_dress"
              c:identifier="adg_hatch_get_fill_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in rendering @hatch.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="hatch" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgHatch</doc>
            <type name="Hatch" c:type="AdgHatch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_fill_dress"
              c:identifier="adg_hatch_set_fill_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering @hatch. The new dress
must be related to the original dress for this property:
you cannot set a dress used for line styles to a dress
managing fonts.

The check is done by calling adg_dress_are_related() with
@dress and the previous dress as arguments. Check out its
documentation for details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hatch" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgHatch</doc>
            <type name="Hatch" c:type="AdgHatch*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <property name="fill-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Stroke" c:type="AdgStroke"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="HatchClass"
            c:type="AdgHatchClass"
            glib:is-gtype-struct-for="Hatch">
      <field name="parent_class" readable="0" private="1">
        <type name="StrokeClass" c:type="AdgStrokeClass"/>
      </field>
    </record>
    <class name="LDim"
           c:symbol-prefix="ldim"
           c:type="AdgLDim"
           version="1.0"
           parent="Dim"
           glib:type-name="AdgLDim"
           glib:get-type="adg_ldim_get_type"
           glib:type-struct="LDimClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_ldim_new" version="1.0">
        <doc xml:space="preserve">Creates a new - undefined - linear dimension. You must, at least,
define the start of the dimension in #AdgDim:ref1, the end in
#AdgDim:ref2 and the position of the quote in #AdgDim:pos using
any valid #AdgDim method. The director of the dimension (that is,
if it is horizontal, vertical or oblique at a specific angle)
should be specified with adg_ldim_set_direction().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created linear dimension entity</doc>
          <type name="LDim" c:type="AdgLDim*"/>
        </return-value>
      </constructor>
      <constructor name="new_full"
                   c:identifier="adg_ldim_new_full"
                   version="1.0">
        <doc xml:space="preserve">Creates a new linear dimension, specifing all the needed properties in
one shot.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created linear dimension entity</doc>
          <type name="LDim" c:type="AdgLDim*"/>
        </return-value>
        <parameters>
          <parameter name="ref1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the first reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="ref2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second reference point</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the position reference</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">angle where to extend the dimension</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_explicit"
                   c:identifier="adg_ldim_new_full_explicit"
                   version="1.0">
        <doc xml:space="preserve">Wrappes adg_ldim_new_full() with explicit values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created linear dimension entity</doc>
          <type name="LDim" c:type="AdgLDim*"/>
        </return-value>
        <parameters>
          <parameter name="ref1_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref1_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the first reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref2_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the second reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="ref2_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the second reference point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the position reference</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the position reference</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">angle where to extend the dimension</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_from_model"
                   c:identifier="adg_ldim_new_full_from_model"
                   version="1.0">
        <doc xml:space="preserve">Creates a new linear dimension, specifing all the needed properties in
one shot and using named pairs from @model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created linear dimension entity</doc>
          <type name="LDim" c:type="AdgLDim*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the model from which the named pairs are taken</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="ref1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the first reference point</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ref2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second reference point</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the position reference</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">angle where to extend the dimension</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_direction"
              c:identifier="adg_ldim_get_direction"
              version="1.0">
        <doc xml:space="preserve">Gets the direction where @ldim will extend.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the direction angle in radians</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_extension1"
              c:identifier="adg_ldim_has_extension1"
              version="1.0">
        <doc xml:space="preserve">Checks if @ldim should render also the first extension line.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on first extension line presents, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_extension2"
              c:identifier="adg_ldim_has_extension2"
              version="1.0">
        <doc xml:space="preserve">Checks if @ldim should render also the second extension line.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on first extension line presents, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_direction"
              c:identifier="adg_ldim_set_direction"
              version="1.0">
        <doc xml:space="preserve">Sets the direction angle where to extend @ldim.
@direction is normalized by cpml_angle() before being used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">an angle value, in radians</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_extension1"
              c:identifier="adg_ldim_switch_extension1"
              version="1.0">
        <doc xml:space="preserve">Shows (if @new_state is &lt;constant&gt;TRUE&lt;/constant&gt;) or hide (if
@new_state is &lt;constant&gt;FALSE&lt;/constant&gt;) the first extension
line of @ldim.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_extension2"
              c:identifier="adg_ldim_switch_extension2"
              version="1.0">
        <doc xml:space="preserve">Shows (if @new_state is &lt;constant&gt;TRUE&lt;/constant&gt;) or hide (if
@new_state is &lt;constant&gt;FALSE&lt;/constant&gt;) the second extension
line of @ldim.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ldim" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLDim entity</doc>
            <type name="LDim" c:type="AdgLDim*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new new_state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="direction"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="has-extension1" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="has-extension2" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Dim" c:type="AdgDim"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="LDimClass"
            c:type="AdgLDimClass"
            glib:is-gtype-struct-for="LDim">
      <field name="parent_class" readable="0" private="1">
        <type name="DimClass" c:type="AdgDimClass"/>
      </field>
    </record>
    <class name="LineStyle"
           c:symbol-prefix="line_style"
           c:type="AdgLineStyle"
           version="1.0"
           parent="Style"
           glib:type-name="AdgLineStyle"
           glib:get-type="adg_line_style_get_type"
           glib:type-struct="LineStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_line_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new line style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new line style.</doc>
          <type name="LineStyle" c:type="AdgLineStyle*"/>
        </return-value>
      </constructor>
      <method name="get_antialias"
              c:identifier="adg_line_style_get_antialias"
              version="1.0">
        <doc xml:space="preserve">Gets the antialias mode used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested antialias mode.</doc>
          <type name="gint" c:type="cairo_antialias_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cap"
              c:identifier="adg_line_style_get_cap"
              version="1.0">
        <doc xml:space="preserve">Gets the line cap mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line cap mode.</doc>
          <type name="gint" c:type="cairo_line_cap_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_dress"
              c:identifier="adg_line_style_get_color_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the color dress used by @line_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current color dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dash"
              c:identifier="adg_line_style_get_dash"
              version="1.0">
        <doc xml:space="preserve">Gets the dash pattern currently active on @line_style.
A &lt;constant&gt;NULL&lt;/constant&gt; value is returned when no dash pattern is active.

The returned pattern is owned by @line_style: you are not allowed to modify
or free it. If something needs to be changed, work on a duplicate and reset
the new pattern, such as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
AdgDash *dash, *new_dash;

dash = adg_line_style_get_dash(line_style);
if (dash == NULL)
    new_dash = adg_dash_new();
else
    new_dash = adg_dash_dup(dash);

// ...modify new_dash as needed...

adg_line_style_set_dash(line_style, new_dash);
adg_dash_destroy(new_dash);
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;note&gt;&lt;para&gt;
Getting #AdgLineStyle:dash via the #GObject property mechanism returns
a duplicate instead, so you must free it when done.
&lt;/para&gt;&lt;/note&gt;

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
g_object_get(line_style, "dash", &amp;dash, NULL);
// Here dash is a duplicate: modifying it will not affect line_style
adg_dash_destroy(dash);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current dash pattern or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Dash" c:type="const AdgDash*"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_join"
              c:identifier="adg_line_style_get_join"
              version="1.0">
        <doc xml:space="preserve">Gets the line join mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line join mode.</doc>
          <type name="gint" c:type="cairo_line_join_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_miter_limit"
              c:identifier="adg_line_style_get_miter_limit"
              version="1.0">
        <doc xml:space="preserve">Gets the line miter limit value. The miter limit is used to determine
whether the lines should be joined with a bevel instead of a miter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested miter limit</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="adg_line_style_get_width"
              version="1.0">
        <doc xml:space="preserve">Gets the line thickness value (in global space).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested width.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_antialias"
              c:identifier="adg_line_style_set_antialias"
              version="1.0">
        <doc xml:space="preserve">Sets a new antialias mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="antialias" transfer-ownership="none">
            <doc xml:space="preserve">the new antialias mode</doc>
            <type name="gint" c:type="cairo_antialias_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cap"
              c:identifier="adg_line_style_set_cap"
              version="1.0">
        <doc xml:space="preserve">Sets a new line cap mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="cap" transfer-ownership="none">
            <doc xml:space="preserve">the new cap mode</doc>
            <type name="gint" c:type="cairo_line_cap_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_dress"
              c:identifier="adg_line_style_set_color_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new color dress on @line_style. The new dress
should be related to the original dress: you cannot
set a dress used for line styles to a dress managing
fonts.

The validation of the new dress is done by calling
adg_dress_are_related() with @dress and the previous
dress as arguments: check out its documentation for
details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new color dress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dash"
              c:identifier="adg_line_style_set_dash"
              version="1.0">
        <doc xml:space="preserve">Sets the dash pattern of @line_style to @dash: all future rendering with
this line style will use this pattern.

The @line_style will embed a copy of @dash: this means that, after this
call, @dash can be freed (with adg_dash_destroy()) if no more needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="dash" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDash pattern</doc>
            <type name="Dash" c:type="const AdgDash*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_join"
              c:identifier="adg_line_style_set_join"
              version="1.0">
        <doc xml:space="preserve">Sets a new line join mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="join" transfer-ownership="none">
            <doc xml:space="preserve">the new join mode</doc>
            <type name="gint" c:type="cairo_line_join_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_miter_limit"
              c:identifier="adg_line_style_set_miter_limit"
              version="1.0">
        <doc xml:space="preserve">Sets a new miter limit value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="miter_limit" transfer-ownership="none">
            <doc xml:space="preserve">the new miter limit</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_width"
              c:identifier="adg_line_style_set_width"
              version="1.0">
        <doc xml:space="preserve">Sets a new line thickness value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="line_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLineStyle object</doc>
            <type name="LineStyle" c:type="AdgLineStyle*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the new width</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="antialias" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="cap" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="color-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dash" writable="1" transfer-ownership="none">
        <type name="Dash"/>
      </property>
      <property name="join" writable="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="miter-limit" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="width" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="LineStyleClass"
            c:type="AdgLineStyleClass"
            glib:is-gtype-struct-for="LineStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
    </record>
    <class name="Logo"
           c:symbol-prefix="logo"
           c:type="AdgLogo"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgLogo"
           glib:get-type="adg_logo_get_type"
           glib:type-struct="LogoClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_logo_new" version="1.0">
        <doc xml:space="preserve">Creates a new logo entity.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created logo entity.</doc>
          <type name="Logo" c:type="AdgLogo*"/>
        </return-value>
      </constructor>
      <method name="get_frame_dress"
              c:identifier="adg_logo_get_frame_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in stroking the frame of @logo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_screen_dress"
              c:identifier="adg_logo_get_screen_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in stroking the screen shape of @logo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbol_dress"
              c:identifier="adg_logo_get_symbol_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in stroking the symbol of @logo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_frame_dress"
              c:identifier="adg_logo_set_frame_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering the frame of @logo.
The new dress must be a line dress: the check is done by
calling adg_dress_are_related() with @dress and the old
dress as arguments. Check out its documentation for
further details.

The default dress is a transparent line dress: the rendering
callback will stroke the frame using the default color with
a predefined thickness.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_screen_dress"
              c:identifier="adg_logo_set_screen_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering the screen of @logo.
The new dress must be a line dress: the check is done by
calling adg_dress_are_related() with @dress and the old
dress as arguments. Check out its documentation for
further details.

The default dress is a transparent line dress: the rendering
callback will stroke the screen using the default color with
a predefined thickness.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_symbol_dress"
              c:identifier="adg_logo_set_symbol_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering the symbol of @logo. The
new dress must be a line dress: the check is done by calling
adg_dress_are_related() with @dress and the old dress as
arguments. Check out its documentation for further details.

The default dress is a transparent line dress: the rendering
callback will stroke the symbol using the default color with
a predefined thickness.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgLogo</doc>
            <type name="Logo" c:type="AdgLogo*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <property name="frame-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="screen-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="symbol-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="LogoClass"
            c:type="AdgLogoClass"
            glib:is-gtype-struct-for="Logo">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
      <field name="data_class" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <constant name="MISSING_GBOXED_MATRIX"
              value="1"
              c:type="ADG_MISSING_GBOXED_MATRIX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MISSING_GBOXED_PATTERN"
              value="1"
              c:type="ADG_MISSING_GBOXED_PATTERN">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Marker"
           c:symbol-prefix="marker"
           c:type="AdgMarker"
           version="1.0"
           parent="Entity"
           abstract="1"
           glib:type-name="AdgMarker"
           glib:get-type="adg_marker_get_type"
           glib:type-struct="MarkerClass">
      <doc xml:space="preserve">All fields are privates and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="create_model" introspectable="0">
        <return-value>
          <type name="Model" c:type="AdgModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="backup_segment"
              c:identifier="adg_marker_backup_segment"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Duplicates the current subject segment for backup purpose: this
segment can be accessed by adg_marker_get_backup_segment().

A current segment should exist (i.e. both #AdgMarker:trail and
#AdgMarker:n-segment properties must be properly set) or this
method will fail without further processing.

When the subject segment is changed (either by changing
#AdgMarker:trail or #AdgMarker:n-segment) the original segment
is automatically restored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_backup_segment"
              c:identifier="adg_marker_get_backup_segment"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Gets the original segment where the marker has been applied.
Applying a marker could modify the underlying trail, usually
by trimming the original segment of a #AdgMarker:size dependent
length from the ends. The marker instance holds a copy of the
original segment, generated by adg_marker_backup_segment(),
to be used in recomputation, for example when the marker
changes its size.

When the subject segment is changed (either by changing
#AdgMarker:trail or #AdgMarker:n-segment) the original segment
is automatically restored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the original segment or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Segment" c:type="const CpmlSegment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_model"
              c:identifier="adg_marker_get_model"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Gets the current model of @marker. This is an accessor method:
if you need to get the model for rendering, use adg_marker_model()
instead. The returned object is owned by @marker and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the cached model or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Model" c:type="AdgModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_segment"
              c:identifier="adg_marker_get_n_segment"
              version="1.0">
        <doc xml:space="preserve">Returns the segment of the associated trail where this marker
will be applied, where 1 is the first segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an index greather than 0 on success or 0 on errors.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="adg_marker_get_pos" version="1.0">
        <doc xml:space="preserve">Gets the current position of @marker. The returned value is a ratio
position referred to the segment associated to @marker: 0 means the
start point and 1 means the end point of the segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the marker position.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_segment"
              c:identifier="adg_marker_get_segment"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Gets the segment where the marker will be applied. This segment
is eventually a modified version of the backup segment, after
having applied the marker.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the segment or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Segment" c:type="const CpmlSegment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="adg_marker_get_size" version="1.0">
        <doc xml:space="preserve">Gets the current size of @marker.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the marker size, in global space</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_trail"
              c:identifier="adg_marker_get_trail"
              version="1.0">
        <doc xml:space="preserve">Gets the trail where this marker should be applied.
The returned object is owned by @marker and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested trail or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Trail" c:type="AdgTrail*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="model" c:identifier="adg_marker_model" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Gets the model of @marker. If the model is not found, it is
automatically created by calling the &lt;function&gt;create_model&lt;/function&gt;
virtual method. The returned object is owned by @marker and
should not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current model or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Model" c:type="AdgModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_model"
              c:identifier="adg_marker_set_model"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in marker implementations.
&lt;/para&gt;&lt;/note&gt;

Sets a new model for @marker. The reference to the old model (if an
old model was present) is dropped while a new reference is added to
@model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">a new #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_n_segment"
              c:identifier="adg_marker_set_n_segment"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgMarker:n-segment property to @n_segment. The trail
is unchanged. If you want to set both properties at once (as
usually requested to refer to a specific segment),
adg_marker_set_segment() should be more convenient.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="n_segment" transfer-ownership="none">
            <doc xml:space="preserve">the new segment index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="adg_marker_set_pos" version="1.0">
        <doc xml:space="preserve">Sets a new position on @marker. Check out adg_marker_get_pos() for
details on what @pos represents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the new pos</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_segment"
              c:identifier="adg_marker_set_segment"
              version="1.0">
        <doc xml:space="preserve">Sets a new segment where the marker should be applied at once.
A dependency between @trail and @marker is added, so when @trail
changes @marker is invalidated.

A callback is added to #AdgModel::remove-dependency so manually
removing the dependency (such as when @trail is destroyed) will
unlink @marker from it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
          <parameter name="n_segment" transfer-ownership="none">
            <doc xml:space="preserve">a segment index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="adg_marker_set_size" version="1.0">
        <doc xml:space="preserve">Sets a new size on @marker. The @size is an implementation-dependent
property: it has meaning only when used by an #AdgMarker derived type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the new size</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_trail"
              c:identifier="adg_marker_set_trail"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgMarker:trail property to @trail. It is allowed to
pass &lt;constant&gt;NULL&lt;/constant&gt; to clear the current trail.

This method could fail unexpectedly if the segment index specified
by the #AdgMarker:n-segment property is not present inside the new
segment: if you want to set a new segment it is more convenient to
change both properties (#AdgMarker:trail and #AdgMarker:n-segment)
at once with adg_marker_set_segment().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="marker" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgMarker</doc>
            <type name="Marker" c:type="AdgMarker*"/>
          </instance-parameter>
          <parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">the new trail to use</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </method>
      <property name="model" writable="1" transfer-ownership="none">
        <type name="Model"/>
      </property>
      <property name="n-segment" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="pos"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="size" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="trail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Trail"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="MarkerClass"
            c:type="AdgMarkerClass"
            glib:is-gtype-struct-for="Marker"
            version="1.0">
      <doc xml:space="preserve">The @create_model method must be implemented by any #AdgMarker derived
classes. The derived classes are expected to apply a single model
(the one returned by this method) to every path endings by using
different transformations.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
      <field name="create_model" introspectable="0">
        <callback name="create_model" introspectable="0">
          <return-value>
            <type name="Model" c:type="AdgModel*"/>
          </return-value>
          <parameters>
            <parameter name="marker" transfer-ownership="none">
              <type name="Marker" c:type="AdgMarker*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="Mix" version="1.0" c:type="AdgMix">
      <doc xml:space="preserve">Specifies how the maps of an #AdgEntity instance and its ancestors
should be combined to get the matrix. The full logic is implemented
by the #AdgEntity::local-changed default handler to compute the
local matrix, while the global matrix is always computed using the
#ADG_MIX_ANCESTORS method.</doc>
      <member name="undefined" value="0" c:identifier="ADG_MIX_UNDEFINED">
        <doc xml:space="preserve">undefined method, mainly used to return an
                    error condition</doc>
      </member>
      <member name="disabled" value="1" c:identifier="ADG_MIX_DISABLED">
        <doc xml:space="preserve">the maps are completely ignored: the matrix is
                    always set to the identity matrix</doc>
      </member>
      <member name="none" value="2" c:identifier="ADG_MIX_NONE">
        <doc xml:space="preserve">the matrix is set to the entity map</doc>
      </member>
      <member name="ancestors" value="3" c:identifier="ADG_MIX_ANCESTORS">
        <doc xml:space="preserve">sequentially apply every map on the matrix using
                    %ADG_TRANSFORM_BEFORE #AdgTransformMode, starting
                    from the elder ancestor in the hierarchy
                    (probably an #AdgCanvas) up to the current entity</doc>
      </member>
      <member name="ancestors_normalized"
              value="4"
              c:identifier="ADG_MIX_ANCESTORS_NORMALIZED">
        <doc xml:space="preserve">perform the same operations as %ADG_MIX_ANCESTORS
                    but normalize the resulting matrix with
                    adg_matrix_normalize() before returning it</doc>
      </member>
      <member name="parent" value="5" c:identifier="ADG_MIX_PARENT">
        <doc xml:space="preserve">similar to %ADG_MIX_ANCESTORS but taking into account
                    only the parent and ignoring any other ancestors;
                    if the entity has no parent, it returns the
                    entity map as in %ADG_MIX_NONE</doc>
      </member>
      <member name="parent_normalized"
              value="6"
              c:identifier="ADG_MIX_PARENT_NORMALIZED">
        <doc xml:space="preserve">perform the same operations as %ADG_MIX_PARENT
                    but normalize the resulting matrix with
                    adg_matrix_normalize() before returning it</doc>
      </member>
    </enumeration>
    <class name="Model"
           c:symbol-prefix="model"
           c:type="AdgModel"
           version="1.0"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="AdgModel"
           glib:get-type="adg_model_get_type"
           glib:type-struct="ModelClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="add_dependency"
                      invoker="add_dependency"
                      version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::add-dependency signal on @model passing @entity
as argument. This will add a reference to @entity owned by @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed" invoker="changed" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits the #AdgModel::changed signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear" invoker="clear" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful new model implementations.
&lt;/para&gt;&lt;/note&gt;

Emits the #AdgModel::clear signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="named_pair">
        <return-value transfer-ownership="none">
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_dependency"
                      invoker="remove_dependency"
                      version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::remove-dependency signal on @model passing
@entity as argument. @entity must be inside @model.

Note that @model will own a reference to @entity and it
may be the last reference held: this means removing an entity
from the model can destroy it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset" invoker="reset" version="1.0">
        <doc xml:space="preserve">Emits the #AdgModel::reset signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_named_pair"
                      invoker="set_named_pair"
                      version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in model definitions, such as
inside an #AdgTrailCallback function or while constructing
an #AdgPath instance.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::set-named-pair signal on @model passing
@name and @pair as arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name to associate to the pair</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlPair</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_dependency"
              c:identifier="adg_model_add_dependency"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::add-dependency signal on @model passing @entity
as argument. This will add a reference to @entity owned by @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="changed" c:identifier="adg_model_changed" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits the #AdgModel::changed signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="adg_model_clear" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful new model implementations.
&lt;/para&gt;&lt;/note&gt;

Emits the #AdgModel::clear signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_dependency"
              c:identifier="adg_model_foreach_dependency"
              version="1.0">
        <doc xml:space="preserve">Invokes @callback on each entity linked to @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">the entity callback</doc>
            <type name="DependencyFunc" c:type="AdgDependencyFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">general purpose user data passed "as is" to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_named_pair"
              c:identifier="adg_model_foreach_named_pair"
              version="1.0">
        <doc xml:space="preserve">Invokes @callback for each named pair set on @model. This can
be used, for example, to retrieve all the named pairs of a @model
or to duplicate a transformed version of every named pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">the named pair callback</doc>
            <type name="NamedPairFunc" c:type="AdgNamedPairFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">general purpose user data passed "as is" to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dependencies"
              c:identifier="adg_model_get_dependencies"
              version="1.0">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of dependencies or &lt;constant&gt;NULL&lt;/constant&gt; on error.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="Entity"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel
.
Gets the list of entities dependending on @model. This list
is owned by @model and must not be modified or freed.</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_named_pair"
              c:identifier="adg_model_get_named_pair"
              version="1.0">
        <doc xml:space="preserve">Gets the @name named pair associated to @model. The returned
pair is owned by @model and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested #CpmlPair or &lt;constant&gt;NULL&lt;/constant&gt; if not found.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the pair to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dependency"
              c:identifier="adg_model_remove_dependency"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in entity implementations.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::remove-dependency signal on @model passing
@entity as argument. @entity must be inside @model.

Note that @model will own a reference to @entity and it
may be the last reference held: this means removing an entity
from the model can destroy it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="adg_model_reset" version="1.0">
        <doc xml:space="preserve">Emits the #AdgModel::reset signal on @model.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_named_pair"
              c:identifier="adg_model_set_named_pair"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in model definitions, such as
inside an #AdgTrailCallback function or while constructing
an #AdgPath instance.
&lt;/para&gt;&lt;/note&gt;

Emits a #AdgModel::set-named-pair signal on @model passing
@name and @pair as arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name to associate to the pair</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlPair</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_named_pair_explicit"
              c:identifier="adg_model_set_named_pair_explicit"
              version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This function is only useful in model definitions, such as
inside an #AdgTrailCallback function or while constructing
an #AdgPath instance.
&lt;/para&gt;&lt;/note&gt;

Convenient wrapper on adg_model_set_named_pair() that accepts
explicit coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name to associate to the pair</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="dependency"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <type name="Entity"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="add-dependency" when="first" version="1.0">
        <doc xml:space="preserve">Adds @entity to @model. After that @entity will depend on @model,
that is #AdgModel::changed on @model will invalidate @entity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgEntity that depends on @model</doc>
            <type name="Entity"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="changed" when="last" no-recurse="1" version="1.0">
        <doc xml:space="preserve">Notificates that the model has changed. By default, all the
dependent entities are invalidated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="clear" when="last" no-recurse="1" version="1.0">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This signal is only useful in model implementations.
&lt;/para&gt;&lt;/note&gt;

Removes any information from @model cached by the implementation
code. Useful to force a recomputation of the cache when something
in the model has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="remove-dependency" when="first" version="1.0">
        <doc xml:space="preserve">Removes the @entity from @model, that is @entity will not depend
on @model anymore.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgEntity that does not depend on @model anymore</doc>
            <type name="Entity"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reset" when="last" no-recurse="1" version="1.0">
        <doc xml:space="preserve">Resets the state of @model by destroying any named pair
associated to it. This step also involves the emission of the
#AdgModel::clear signal.

This signal is intended to be used while redefining the model.
A typical usage would be in these terms:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
adg_model_reset(model);
// Definition of model. This also requires the redefinition of
// the named pairs because the old ones have been destroyed.
...
adg_model_changed(model);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="set-named-pair" when="first" version="1.0">
        <doc xml:space="preserve">Adds, updates or deletes a named pair, accordling to the given
parameters.

If @pair is &lt;constant&gt;NULL&lt;/constant&gt;, the @name named pair is
searched and deleted. If it is not found, a warning is raised.

Otherwise, the @name named pair is searched: if it is found,
its data are updated with @pair. If it is not found, a new
named pair is created using @name and @pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an arbitrary name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">an #CpmlPair</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ModelClass"
            c:type="AdgModelClass"
            glib:is-gtype-struct-for="Model"
            version="1.0">
      <doc xml:space="preserve">The default @named_pair implementation looks up the #CpmlPair in an internal
#GHashTable that uses the pair name as key and the #CpmlPair struct as value.

The default @set_named_pair implementation can be used for either adding
(if the #CpmlPair is not &lt;constant&gt;NULL&lt;/constant&gt;) or removing (if #CpmlPair
is &lt;constant&gt;NULL&lt;/constant&gt;) an item from the named pairs hash table.

The default handler for @clear signals does not do anything.

The default @reset involves the clearing of the internal cache data
(done by emitting the #AdgModel::clear signal) and the destruction of the
internal named pair hash table.

The default @add_dependency and @remove_dependency implementations add and
remove items from an internal #GSList of #AdgEntity.

The default handler of the @changed signal calls adg_entity_invalidate()
on every dependency by using adg_model_foreach_dependency().</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="named_pair">
        <callback name="named_pair">
          <return-value transfer-ownership="none">
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_named_pair">
        <callback name="set_named_pair">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name to associate to the pair</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="pair" transfer-ownership="none">
              <doc xml:space="preserve">the #CpmlPair</doc>
              <type name="Cpml.Pair" c:type="const CpmlPair*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear">
        <callback name="clear">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_dependency">
        <callback name="add_dependency">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_dependency">
        <callback name="remove_dependency">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="model" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgModel</doc>
              <type name="Model" c:type="AdgModel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="NamedPairFunc" c:type="AdgNamedPairFunc" version="1.0">
      <doc xml:space="preserve">Callback used by adg_model_foreach_named_pair().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="model" transfer-ownership="none">
          <doc xml:space="preserve">the #AdgModel</doc>
          <type name="Model" c:type="AdgModel*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the named pair</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pair" transfer-ownership="none">
          <doc xml:space="preserve">an #CpmlPair</doc>
          <type name="Cpml.Pair" c:type="CpmlPair*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">a general purpose pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="PangoStyle"
           c:symbol-prefix="pango_style"
           c:type="AdgPangoStyle"
           version="1.0"
           parent="FontStyle"
           glib:type-name="AdgPangoStyle"
           glib:get-type="adg_pango_style_get_type"
           glib:type-struct="PangoStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_pango_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new pango style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created pango style</doc>
          <type name="PangoStyle" c:type="AdgPangoStyle*"/>
        </return-value>
      </constructor>
      <method name="get_description"
              c:identifier="adg_pango_style_get_description"
              version="1.0">
        <doc xml:space="preserve">Gets the #PangoFontDescription of @pango_style. The returned font is
owned by @pango_style and must not be destroyed by the caller.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the font description</doc>
          <type name="Pango.FontDescription" c:type="PangoFontDescription*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pango_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPangoStyle object</doc>
            <type name="PangoStyle" c:type="AdgPangoStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="FontStyle" c:type="AdgFontStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="PangoStyleClass"
            c:type="AdgPangoStyleClass"
            glib:is-gtype-struct-for="PangoStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="FontStyleClass" c:type="AdgFontStyleClass"/>
      </field>
    </record>
    <class name="ParamDress"
           c:symbol-prefix="param_dress"
           parent="GObject.ParamSpec"
           glib:type-name="AdgParamDress"
           glib:get-type="adg_param_dress_get_type"
           glib:fundamental="1">
    </class>
    <class name="Path"
           c:symbol-prefix="path"
           c:type="AdgPath"
           version="1.0"
           parent="Trail"
           glib:type-name="AdgPath"
           glib:get-type="adg_path_get_type"
           glib:type-struct="PathClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_path_new" version="1.0">
        <doc xml:space="preserve">Creates a new path model. The path should be constructed
programmatically by using the methods provided by #AdgPath.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created path model</doc>
          <type name="Path" c:type="AdgPath*"/>
        </return-value>
      </constructor>
      <method name="append"
              c:identifier="adg_path_append"
              shadowed-by="append_array"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Generic method to append a primitive to @path. The number of #CpmlPair
pointers to pass as @Varargs depends on @type: %CPML_CLOSE does not
require any pair, %CPML_MOVE and %CPML_LINE require one pair,
%CPML_ARC two pairs, %CPML_CURVE three pairs and so on.

All the needed pairs must be not &lt;constant&gt;NULL&lt;/constant&gt; pointers,
otherwise the function will fail. The pairs in excess, if any, are ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_data_type_t value</doc>
            <type name="Cpml.PrimitiveType" c:type="CpmlPrimitiveType"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">point data, specified as #CpmlPair pointers</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="append_array"
              c:identifier="adg_path_append_array"
              shadows="append"
              version="1.0">
        <doc xml:space="preserve">A bindingable version of adg_path_append() that uses a
&lt;constant&gt;NULL&lt;/constant&gt; terminated array of pairs instead of variable
argument list and friends.

Furthermore, because of the list is &lt;constant&gt;NULL&lt;/constant&gt; terminated,
an arbitrary number of pairs can be passed in @pairs. This allows to embed
in a primitive element more data pairs than requested, something impossible
to do with adg_path_append() and adg_path_append_valist().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_data_type_t value</doc>
            <type name="Cpml.PrimitiveType" c:type="CpmlPrimitiveType"/>
          </parameter>
          <parameter name="pairs" transfer-ownership="none">
            <doc xml:space="preserve">point data, specified as a &lt;constant&gt;NULL&lt;/constant&gt; terminated array of #CpmlPair pointers.</doc>
            <array c:type="CpmlPair**">
              <type name="Cpml.Pair"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="append_cairo_path"
              c:identifier="adg_path_append_cairo_path"
              version="1.0">
        <doc xml:space="preserve">Appends a whole #cairo_path_t to @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="cairo_path" transfer-ownership="none">
            <doc xml:space="preserve">the #cairo_path_t path to append</doc>
            <type name="gpointer" c:type="cairo_path_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_primitive"
              c:identifier="adg_path_append_primitive"
              version="1.0">
        <doc xml:space="preserve">Appends @primitive to @path. The primitive to add is considered the
continuation of the current path so the &lt;structfield&gt;org&lt;/structfield&gt;
component of @primitive is not used. Anyway the current point is
checked against it: they must be equal or the function will fail
without further processing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlPrimitive to append</doc>
            <type name="Cpml.Primitive" c:type="const CpmlPrimitive*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_segment"
              c:identifier="adg_path_append_segment"
              version="1.0">
        <doc xml:space="preserve">Appends @segment to @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlSegment to append</doc>
            <type name="Cpml.Segment" c:type="const CpmlSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_valist"
              c:identifier="adg_path_append_valist"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">va_list version of adg_path_append().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #cairo_data_type_t value</doc>
            <type name="Cpml.PrimitiveType" c:type="CpmlPrimitiveType"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">point data, specified as #CpmlPair pointers</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc" c:identifier="adg_path_arc" version="1.0">
        <doc xml:space="preserve">A more usual way to add an arc to @path. After this call, the current
point will be the computed end point of the arc. The arc will be
rendered in increasing angle, accordling to @start and @end. This means
if @start is less than @end, the arc will be rendered in clockwise
direction (accordling to the default cairo coordinate system) while if
@start is greather than @end, the arc will be rendered in couterclockwise
direction.

By explicitely setting the whole arc data, the start point could be
different from the current point. In this case, if @path has no
current point before the call a %CPML_MOVE to the start point of
the arc will be automatically prepended to the arc. If @path has a
current point, a %CPML_LINE to the start point of the arc will be
used instead of the "move to" primitive.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">coordinates of the center of the arc</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">the radius of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start angle, in radians</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end angle, in radians</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc_explicit"
              c:identifier="adg_path_arc_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_arc() using explicit
coordinates instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="xc" transfer-ownership="none">
            <doc xml:space="preserve">x position of the center of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="yc" transfer-ownership="none">
            <doc xml:space="preserve">y position of the center of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">the radius of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start angle, in radians</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end angle, in radians</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc_to" c:identifier="adg_path_arc_to" version="1.0">
        <doc xml:space="preserve">Adds an arc to the path from the current point to @pair, passing
throught @throught. After this call the current point will be @pair.

If @path has no current point before this call, this function will
trigger a warning without other effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="throught" transfer-ownership="none">
            <doc xml:space="preserve">an arbitrary point on the arc</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination coordinates</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc_to_explicit"
              c:identifier="adg_path_arc_to_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_arc_to() using explicit
coordinates instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of an intermediate point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of an intermediate point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the end of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the end of the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="chamfer" c:identifier="adg_path_chamfer" version="1.0">
        <doc xml:space="preserve">A binary action that generates a chamfer between two primitives.
The first primitive involved is the current primitive, the second will
be the next primitive appended to @path after this call. The second
primitive is required: if the chamfer operation is not properly
terminated (by not providing the second primitive), any API accessing
the path in reading mode will raise a warning.

An exception is a chamfer after a %CPML_CLOSE primitive. In this case,
the second primitive is not required: the current close path is used
as first operand while the first primitive of the current segment is
used as second operand.

The chamfer operation requires two lengths: @delta1 specifies the
"quantity" to trim on the first primitive while @delta2 is the same
applied on the second primitive. The term "quantity" means the length
of the portion to cut out from the original primitive (that is the
primitive as would be without the chamfer).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="delta1" transfer-ownership="none">
            <doc xml:space="preserve">the distance from the intersection point of the current primitive</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="delta2" transfer-ownership="none">
            <doc xml:space="preserve">the distance from the intersection point of the next primitive</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="adg_path_close" version="1.0">
        <doc xml:space="preserve">Adds a line segment to the path from the current point to the
beginning of the current segment, (the most recent point passed
to an adg_path_move_to()), and closes this segment.
After this call the current point will be unset.

The behavior of adg_path_close() is distinct from simply calling
adg_path_line_to() with the coordinates of the segment starting
point. When a closed segment is stroked, there are no caps on the
ends. Instead, there is a line join connecting the final and
initial primitive of the segment.

If @path has no current point before this call, this function will
trigger a warning without other effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="curve_to" c:identifier="adg_path_curve_to" version="1.0">
        <doc xml:space="preserve">Adds a cubic Bézier curve to the path from the current point to
position @pair, using @control1 and @control2 as control points.
After this call the current point will be @pair.

If @path has no current point before this call, this function will
trigger a warning without other effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="control1" transfer-ownership="none">
            <doc xml:space="preserve">the first control point of the curve</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="control2" transfer-ownership="none">
            <doc xml:space="preserve">the second control point of the curve</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination coordinates</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="curve_to_explicit"
              c:identifier="adg_path_curve_to_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_curve_to() using explicit
coordinates instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the first control point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the first control point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the second control point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the second control point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x3" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the end of the curve</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y3" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the end of the curve</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="fillet" c:identifier="adg_path_fillet" version="1.0">
        <doc xml:space="preserve">A binary action that joins to primitives with an arc.
The first primitive involved is the current primitive, the second will
be the next primitive appended to @path after this call. The second
primitive is required: if the fillet operation is not properly
terminated (by not providing the second primitive), any API accessing
the path in reading mode will raise a warning.

An exception is a fillet after a %CPML_CLOSE primitive. In this case,
the second primitive is not required: the current close path is used
as first operand while the first primitive of the current segment is
used as second operand.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the radius of the fillet</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_point"
              c:identifier="adg_path_get_current_point"
              version="1.0">
        <doc xml:space="preserve">Gets the current point of @path, which is conceptually the
final point reached by the path so far.

If there is no defined current point, &lt;constant&gt;NULL&lt;/constant&gt; is returned.
It is possible to check this in advance with
adg_path_has_current_point().

Most #AdgPath methods alter the current point and most of them
expect a current point to be defined otherwise will fail triggering
a warning. Check the description of every method for specific details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current point or &lt;constant&gt;NULL&lt;/constant&gt; on no current point set or errors.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_current_point"
              c:identifier="adg_path_has_current_point"
              version="1.0">
        <doc xml:space="preserve">Returns whether a current point is defined on @path.
See adg_path_get_current_point() for details on the current point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a current point is defined</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="last_primitive"
              c:identifier="adg_path_last_primitive"
              version="1.0">
        <doc xml:space="preserve">Gets the last primitive appended to @path. The #CPML_MOVE type is
not considered a full-fledged primitive, i.e. adg_path_move_to()
or similar does not change the last primitive.

The returned struct is owned by @path and should not be freed or
modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the last appended primitive or &lt;constant&gt;NULL&lt;/constant&gt; on no last primitive or on errors.</doc>
          <type name="Cpml.Primitive" c:type="const CpmlPrimitive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="line_to" c:identifier="adg_path_line_to" version="1.0">
        <doc xml:space="preserve">Adds a line to @path from the current point to @pair. After this
call the current point will be @pair.

If @path has no current point before this call, this function will
trigger a warning without other effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination coordinates</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="line_to_explicit"
              c:identifier="adg_path_line_to_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_line_to() using explicit
coordinates instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the new x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the new y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_to" c:identifier="adg_path_move_to" version="1.0">
        <doc xml:space="preserve">Begins a new segment. After this call the current point will be @pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the destination coordinates</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_to_explicit"
              c:identifier="adg_path_move_to_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_move_to() using explicit
coordinates instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the new x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the new y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="over_primitive"
              c:identifier="adg_path_over_primitive"
              version="1.0">
        <doc xml:space="preserve">Gets the primitive before the last one appended to @path. The
"over" term comes from forth, where the &lt;emphasis&gt;OVER&lt;/emphasis&gt;
operator works on the stack in the same way as
adg_path_over_primitive() works on @path. The #CPML_MOVE type is
not considered a full-fledged primitive, i.e. adg_path_move_to()
or similar does not change the over primitive.

The returned struct is owned by @path and should not be freed or
modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the primitive before the last appended one or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Primitive" c:type="const CpmlPrimitive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reflect" c:identifier="adg_path_reflect" version="1.0">
        <doc xml:space="preserve">Reflects the first segment or @path around the axis passing
throught (0, 0) and with a @vector slope. The internal segment
is duplicated and the proper transformation (computed from
@vector) to mirror the segment is applied on all its points.
The result is then reversed with cpml_segment_reverse() and
appended to the original path with adg_path_append_segment().

For convenience, if @vector is &lt;constant&gt;NULL&lt;/constant&gt; the
path is reversed around the x axis &lt;constant&gt;(y = 0)&lt;/constant&gt;.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="vector"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the slope of the axis</doc>
            <type name="Cpml.Vector" c:type="const CpmlVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reflect_explicit"
              c:identifier="adg_path_reflect_explicit"
              version="1.0">
        <doc xml:space="preserve">Convenient function to call adg_path_reflect() using explicit
vector components instead of #CpmlVector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPath</doc>
            <type name="Path" c:type="AdgPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the vector x component</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the vector y component</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Trail" c:type="AdgTrail"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="PathClass"
            c:type="AdgPathClass"
            glib:is-gtype-struct-for="Path">
      <field name="parent_class" readable="0" private="1">
        <type name="TrailClass" c:type="AdgTrailClass"/>
      </field>
    </record>
    <record name="Point"
            c:type="AdgPoint"
            version="1.0"
            glib:type-name="AdgPoint"
            glib:get-type="adg_point_get_type"
            c:symbol-prefix="point">
      <doc xml:space="preserve">This is an opaque struct: all its fields are privates.</doc>
      <constructor name="new" c:identifier="adg_point_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty #AdgPoint. The returned pointer
should be freed with adg_point_destroy() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #AdgPoint</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="adg_point_copy" version="1.0">
        <doc xml:space="preserve">Copies @src into @point. If the old content of @point was linked
to the named pair of a model, the reference to that model is
dropped. Similary, if @src is a named pair, a new reference to
the new model is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the source point to copy</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="adg_point_destroy" version="1.0">
        <doc xml:space="preserve">Destroys the @point instance, unreferencing the internal model if
@point is linked to a named pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="adg_point_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @src. This operation also adds a new reference
to the internal model if @src is linked to a named pair.

The returned value should be freed with adg_point_destroy()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the duplicated #AdgPoint struct or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Point" c:type="AdgPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="adg_point_equal" version="1.0">
        <doc xml:space="preserve">Compares @point1 and @point2 and returns &lt;constant&gt;TRUE&lt;/constant&gt;
if the points are equals. The comparison is made by checking also
the named pairs they are bound to. If you want to compare only
their coordinates, use cpml_pair_equal() directly on the
#AdgPoint structs:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
if (adg_point_update(point1) &amp;&amp;
    adg_point_update(point2) &amp;&amp;
    cpml_pair_equal((CpmlPair *) point1, (CpmlPair *) point2))
{
    ...
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;constant&gt;NULL&lt;/constant&gt; points are handled gracefully.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @point1 is equal to @point2, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="point1" transfer-ownership="none">
            <doc xml:space="preserve">the first point to compare</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </instance-parameter>
          <parameter name="point2" transfer-ownership="none">
            <doc xml:space="preserve">the second point to compare</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_model"
              c:identifier="adg_point_get_model"
              version="1.0">
        <doc xml:space="preserve">Gets the source model of the named pair bound to @point, or
returns &lt;constant&gt;NULL&lt;/constant&gt; if @point is an explicit
pair. The returned value is owned by @point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #AdgModel or &lt;constant&gt;NULL&lt;/constant&gt;.</doc>
          <type name="Model" c:type="AdgModel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="adg_point_get_name" version="1.0">
        <doc xml:space="preserve">Gets the name of the named pair bound to @point, or
returns &lt;constant&gt;NULL&lt;/constant&gt; if @point is an explicit
pair. The returned value is owned by @point and should not
be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the named pair or &lt;constant&gt;NULL&lt;/constant&gt;.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="const AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pair" c:identifier="adg_point_get_pair" version="1.0">
        <doc xml:space="preserve">#AdgPoint is an evolution of the pair concept but internally the
relevant data is still stored in an #CpmlPair struct. This function
returns a copy of the internally owned pair.

&lt;note&gt;&lt;para&gt;
The #CpmlPair is the first field of an #AdgPoint struct so casting
is allowed between them and, in fact, it is often more convenient
than calling this function. Just remember to update the internal
pair by using adg_point_update() before.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the pair of @point or &lt;constant&gt;NULL&lt;/constant&gt; if the named pair does not exist.</doc>
          <type name="Cpml.Pair" c:type="CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate"
              c:identifier="adg_point_invalidate"
              version="1.0">
        <doc xml:space="preserve">Invalidates @point, forcing a refresh of its internal #CpmlPair if
the point is linked to a named pair. If @point is explicitely set,
this function has no effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_pair" c:identifier="adg_point_set_pair" version="1.0">
        <doc xml:space="preserve">Sets an explicit pair in @point by using the given @pair. If
@point was linked to a named pair in a model, this link is
dropped before setting the pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
          <parameter name="pair" transfer-ownership="none">
            <doc xml:space="preserve">the #CpmlPair to use</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pair_explicit"
              c:identifier="adg_point_set_pair_explicit"
              version="1.0">
        <doc xml:space="preserve">Works in the same way of adg_point_set_pair() but accept direct numbers
instead of an #CpmlPair structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the x coordinate of the point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the y coordinate of the point</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pair_from_model"
              c:identifier="adg_point_set_pair_from_model"
              version="1.0">
        <doc xml:space="preserve">Links the @name named pair of @model to @point, so any subsequent
call to adg_point_get_pair() will return the named pair value.
A new reference is added to @model while the previous model (if any)
is unreferenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgModel</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the id of a named pair in @model</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset" c:identifier="adg_point_unset" version="1.0">
        <doc xml:space="preserve">Unsets @point by resetting the internal &lt;varname&gt;up_to_date&lt;/varname&gt;
flag and (eventually) unlinking it from the named pair it is bound
to. After this call the content of @point is undefined, so a
subsequent call to adg_point_get_pair() will
return &lt;constant&gt;NULL&lt;/constant&gt; raising a warning.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="adg_point_update" version="1.0">
        <doc xml:space="preserve">Updates the internal #CpmlPair of @point. The internal
implementation is protected against multiple calls so it
can be called more times without harms.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @point has been updated or &lt;constant&gt;FALSE&lt;/constant&gt; on errors, i.e. when it is bound to a non-existent named pair.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an #AdgPoint</doc>
            <type name="Point" c:type="AdgPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="Projection"
           c:symbol-prefix="projection"
           c:type="AdgProjection"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgProjection"
           glib:get-type="adg_projection_get_type"
           glib:type-struct="ProjectionClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_projection_new" version="1.0">
        <doc xml:space="preserve">Creates a new projection entity representing the selected @scheme.
If @scheme is invalid, a projection symbol without a scheme is
returned, that is #AdgProjection:scheme is set to
#ADG_PROJECTION_SCHEME_UNDEFINED, and a warning is raised.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created projection entity.</doc>
          <type name="Projection" c:type="AdgProjection*"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">the scheme represented by this projection</doc>
            <type name="ProjectionScheme" c:type="AdgProjectionScheme"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_axis_dress"
              c:identifier="adg_projection_get_axis_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in stroking the axis of @projection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme"
              c:identifier="adg_projection_get_scheme"
              version="1.0">
        <doc xml:space="preserve">Gets the scheme represented by @projection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scheme of @projection</doc>
          <type name="ProjectionScheme" c:type="AdgProjectionScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbol_dress"
              c:identifier="adg_projection_get_symbol_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in stroking the symbol of @projection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_axis_dress"
              c:identifier="adg_projection_set_axis_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering the axis of @projection.
The new dress must be a line dress: the check is done by
calling adg_dress_are_related() with @dress and the old
dress as arguments. Check out its documentation for
further details.

The default dress is a transparent line dress: the rendering
callback will stroke the axis using the default line style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scheme"
              c:identifier="adg_projection_set_scheme"
              version="1.0">
        <doc xml:space="preserve">Sets a new scheme on @projection. If @scheme is different
from the old one, @projection is invalidated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">the new projection scheme</doc>
            <type name="ProjectionScheme" c:type="AdgProjectionScheme"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_symbol_dress"
              c:identifier="adg_projection_set_symbol_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering the symbol of @projection. The
new dress must be a line dress: the check is done by calling
adg_dress_are_related() with @dress and the old dress as
arguments. Check out its documentation for further details.

The default dress is a transparent line dress: the rendering
callback will stroke the symbol using the default color with
a predefined thickness.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgProjection</doc>
            <type name="Projection" c:type="AdgProjection*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <property name="axis-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="scheme"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="symbol-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="ProjectionClass"
            c:type="AdgProjectionClass"
            glib:is-gtype-struct-for="Projection">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
      <field name="data_class" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <enumeration name="ProjectionScheme"
                 version="1.0"
                 c:type="AdgProjectionScheme">
      <doc xml:space="preserve">Specifies how the views are positioned relative to each other.</doc>
      <member name="undefined"
              value="0"
              c:identifier="ADG_PROJECTION_SCHEME_UNDEFINED">
        <doc xml:space="preserve">there is a single view or the views are
                                    not related with a consistent scheme</doc>
      </member>
      <member name="first_angle"
              value="1"
              c:identifier="ADG_PROJECTION_SCHEME_FIRST_ANGLE">
        <doc xml:space="preserve">the views are generated as if the object
                                    were sitting on the paper and, from the
                                    front view, it is rolled to the right to
                                    show the left side or rolled up to show
                                    its bottom</doc>
      </member>
      <member name="third_angle"
              value="2"
              c:identifier="ADG_PROJECTION_SCHEME_THIRD_ANGLE">
        <doc xml:space="preserve">the views are generated as if the object
                                    were a box to be unfolded</doc>
      </member>
    </enumeration>
    <class name="RDim"
           c:symbol-prefix="rdim"
           c:type="AdgRDim"
           version="1.0"
           parent="Dim"
           glib:type-name="AdgRDim"
           glib:get-type="adg_rdim_get_type"
           glib:type-struct="RDimClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_rdim_new" version="1.0">
        <doc xml:space="preserve">Creates a new uninitialized radial dimension. To be useful, you
need at least define the center of the arc to quote in #AdgDim:ref1,
a point on the arc in #AdgDim:ref2 and the position of the quote
in #AdgDim:pos using any valid #AdgDim method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a newly created quote</doc>
          <type name="RDim" c:type="AdgRDim*"/>
        </return-value>
      </constructor>
      <constructor name="new_full"
                   c:identifier="adg_rdim_new_full"
                   version="1.0">
        <doc xml:space="preserve">Creates a new quote by specifying explicitely all the needed
data to get a valid quote.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created quote.</doc>
          <type name="RDim" c:type="AdgRDim*"/>
        </return-value>
        <parameters>
          <parameter name="center"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">center of the arc to quote</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="radius"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">where the quote must be applied on the arc</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">position of the quote text</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_explicit"
                   c:identifier="adg_rdim_new_full_explicit"
                   version="1.0">
        <doc xml:space="preserve">Does the same job of adg_rdim_new_full() but using specific
coordinates instead of #CpmlPair structures.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created quote.</doc>
          <type name="RDim" c:type="AdgRDim*"/>
        </return-value>
        <parameters>
          <parameter name="center_x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the center of the arc to quote</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="center_y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the center of the arc to quote</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="radius_x" transfer-ownership="none">
            <doc xml:space="preserve">x coordiante where the quote must be applied on the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="radius_y" transfer-ownership="none">
            <doc xml:space="preserve">y coordiante where the quote must be applied on the arc</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the quote text</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="pos_y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the quote text</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_from_model"
                   c:identifier="adg_rdim_new_full_from_model"
                   version="1.0">
        <doc xml:space="preserve">Creates a new radial dimension, specifing all the needed properties in
one shot and using named pairs from @model.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created radial dimension entity</doc>
          <type name="RDim" c:type="AdgRDim*"/>
        </return-value>
        <parameters>
          <parameter name="model" transfer-ownership="none">
            <doc xml:space="preserve">the model from which the named pairs are taken</doc>
            <type name="Model" c:type="AdgModel*"/>
          </parameter>
          <parameter name="center"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the center point of the arc to quote</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="radius"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an arbitrary point on the arc</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the position reference</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="value"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Dim" c:type="AdgDim"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="RDimClass"
            c:type="AdgRDimClass"
            glib:is-gtype-struct-for="RDim">
      <field name="parent_class" readable="0" private="1">
        <type name="DimClass" c:type="AdgDimClass"/>
      </field>
    </record>
    <class name="RuledFill"
           c:symbol-prefix="ruled_fill"
           c:type="AdgRuledFill"
           version="1.0"
           parent="FillStyle"
           glib:type-name="AdgRuledFill"
           glib:get-type="adg_ruled_fill_get_type"
           glib:type-struct="RuledFillClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_ruled_fill_new" version="1.0">
        <doc xml:space="preserve">Constructs a new empty ruled fill style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created ruled fill style</doc>
          <type name="RuledFill" c:type="AdgRuledFill*"/>
        </return-value>
      </constructor>
      <method name="get_angle"
              c:identifier="adg_ruled_fill_get_angle"
              version="1.0">
        <doc xml:space="preserve">Gets the current angle of @ruled_fill.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the angle (in radians)</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_dress"
              c:identifier="adg_ruled_fill_get_line_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the @ruled_fill dress to be used for rendering the lines.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill object</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spacing"
              c:identifier="adg_ruled_fill_get_spacing"
              version="1.0">
        <doc xml:space="preserve">Gets the current spacing of @ruled_fill.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the spacing (in global space)</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_angle"
              c:identifier="adg_ruled_fill_set_angle"
              version="1.0">
        <doc xml:space="preserve">Sets a new angle on @ruled_fill.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the new angle</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_dress"
              c:identifier="adg_ruled_fill_set_line_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress on @ruled_fill.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill object</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new line dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_spacing"
              c:identifier="adg_ruled_fill_set_spacing"
              version="1.0">
        <doc xml:space="preserve">Sets a new spacing on @ruled_fill.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ruled_fill" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgRuledFill</doc>
            <type name="RuledFill" c:type="AdgRuledFill*"/>
          </instance-parameter>
          <parameter name="spacing" transfer-ownership="none">
            <doc xml:space="preserve">the new spacing</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="angle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="line-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="spacing" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="FillStyle" c:type="AdgFillStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="RuledFillClass"
            c:type="AdgRuledFillClass"
            glib:is-gtype-struct-for="RuledFill">
      <field name="parent_class" readable="0" private="1">
        <type name="FillStyleClass" c:type="AdgFillStyleClass"/>
      </field>
    </record>
    <class name="Stroke"
           c:symbol-prefix="stroke"
           c:type="AdgStroke"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgStroke"
           glib:get-type="adg_stroke_get_type"
           glib:type-struct="StrokeClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_stroke_new" version="1.0">
        <doc xml:space="preserve">Creates a new stroke entity based on the @trail model.
@trail can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case
an empty stroke is created.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created stroke entity</doc>
          <type name="Stroke" c:type="AdgStroke*"/>
        </return-value>
        <parameters>
          <parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTrail to stroke</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_line_dress"
              c:identifier="adg_stroke_get_line_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used in rendering @stroke.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStroke</doc>
            <type name="Stroke" c:type="AdgStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_trail"
              c:identifier="adg_stroke_get_trail"
              version="1.0">
        <doc xml:space="preserve">Gets the #AdgTrail bound to this @stroke entity.
The returned trail is owned by @stroke and should not
be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested #AdgTrail or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Trail" c:type="AdgTrail*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStroke</doc>
            <type name="Stroke" c:type="AdgStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_line_dress"
              c:identifier="adg_stroke_set_line_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress for rendering @stroke. The new dress
must be related to the original dress for this property:
you cannot set a dress used for line styles to a dress
managing fonts.

The check is done by calling adg_dress_are_related() with
@dress and the previous dress as arguments. Check out its
documentation for details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStroke</doc>
            <type name="Stroke" c:type="AdgStroke*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_trail"
              c:identifier="adg_stroke_set_trail"
              version="1.0">
        <doc xml:space="preserve">Sets @trail as the new trail to be stroked by @stroke.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStroke</doc>
            <type name="Stroke" c:type="AdgStroke*"/>
          </instance-parameter>
          <parameter name="trail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the new #AdgTrail to bind</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </parameter>
        </parameters>
      </method>
      <property name="line-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="trail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Trail"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="StrokeClass"
            c:type="AdgStrokeClass"
            glib:is-gtype-struct-for="Stroke">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
    </record>
    <class name="Style"
           c:symbol-prefix="style"
           c:type="AdgStyle"
           version="1.0"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="AdgStyle"
           glib:get-type="adg_style_get_type"
           glib:type-struct="StyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <virtual-method name="apply" invoker="apply" version="1.0">
        <doc xml:space="preserve">Emits the #AdgStyle::apply signal on @style, passing @entity and
@cr as parameters to the signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle derived style</doc>
            <type name="Style" c:type="AdgStyle*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the caller #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">the subject cairo context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="invalidate" invoker="invalidate" version="1.0">
        <doc xml:space="preserve">Emits the #AdgStyle::invalidate signal on @style. This signal
is always emitted while disposing @style, so be sure it
can be called more than once without harms.

&lt;note&gt;&lt;para&gt;
This function is only useful in new style implementations.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle derived style</doc>
            <type name="Style" c:type="AdgStyle*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="apply" c:identifier="adg_style_apply" version="1.0">
        <doc xml:space="preserve">Emits the #AdgStyle::apply signal on @style, passing @entity and
@cr as parameters to the signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle derived style</doc>
            <type name="Style" c:type="AdgStyle*"/>
          </instance-parameter>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the caller #AdgEntity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">the subject cairo context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate"
              c:identifier="adg_style_invalidate"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgStyle::invalidate signal on @style. This signal
is always emitted while disposing @style, so be sure it
can be called more than once without harms.

&lt;note&gt;&lt;para&gt;
This function is only useful in new style implementations.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgStyle derived style</doc>
            <type name="Style" c:type="AdgStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="apply" when="last" version="1.0">
        <doc xml:space="preserve">Applies @style to @cr so the next rendering operations will be
done accordling to this style directives. The @entity parameter
is used to resolve the internal dresses of @style, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entity" transfer-ownership="none">
            <doc xml:space="preserve">the caller #AdgEntity</doc>
            <type name="Entity"/>
          </parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">the #cairo_t context</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidate" when="last" version="1.0">
        <doc xml:space="preserve">Invalidates the @style, that is resets all the cache, if any,
retained by the internal implementation.

This signal is emitted while disposing @style, so be sure it
can be called more than once without harms. Furthermore it
will be emitted from property setter code of new implementations
to force the recomputation of the cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="StyleClass"
            c:type="AdgStyleClass"
            glib:is-gtype-struct-for="Style"
            version="1.0">
      <doc xml:space="preserve">The default @invalidate handler does not do anything.

The virtual method @apply *must* be implemented by any derived class.
The default implementation will trigger an error if called.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="style" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgStyle derived style</doc>
              <type name="Style" c:type="AdgStyle*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="apply">
        <callback name="apply">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="style" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgStyle derived style</doc>
              <type name="Style" c:type="AdgStyle*"/>
            </parameter>
            <parameter name="entity" transfer-ownership="none">
              <doc xml:space="preserve">the caller #AdgEntity</doc>
              <type name="Entity" c:type="AdgEntity*"/>
            </parameter>
            <parameter name="cr" transfer-ownership="none">
              <doc xml:space="preserve">the subject cairo context</doc>
              <type name="cairo.Context" c:type="cairo_t*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Table"
           c:symbol-prefix="table"
           c:type="AdgTable"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgTable"
           glib:get-type="adg_table_get_type"
           glib:type-struct="TableClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_table_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty table entity.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created table entity</doc>
          <type name="Table" c:type="AdgTable*"/>
        </return-value>
      </constructor>
      <method name="foreach" c:identifier="adg_table_foreach" version="1.0">
        <doc xml:space="preserve">Invokes @callback on each row of @table.
The callback should be declared as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
void callback(AdgTableRow *table_row, gpointer user_data);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">callback user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_cell"
              c:identifier="adg_table_foreach_cell"
              version="1.0">
        <doc xml:space="preserve">Invokes @callback on each cell of @table.
The callback should be declared as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
void callback(AdgTableCell *table_cell, gpointer user_data);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">callback user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cell" c:identifier="adg_table_get_cell" version="1.0">
        <doc xml:space="preserve">Gets the cell named @name inside @table. Only named cells
can be retrieved by this method.

The returned cell is owned by @table and must not be
modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested cell or &lt;constant&gt;NULL&lt;/constant&gt; if not found.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a cell</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_table_dress"
              c:identifier="adg_table_get_table_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the table dress to be used in rendering @table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current table dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_table_style"
              c:identifier="adg_table_get_table_style"
              version="1.0">
        <doc xml:space="preserve">Gets the #AdgTableStyle explicitely set on @table. This is a kind
of accessor function: for rendering purpose use adg_entity_style()
instead. The returned object is owned by @table and should not be
freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested style or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Style" c:type="AdgStyle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_frame"
              c:identifier="adg_table_has_frame"
              version="1.0">
        <doc xml:space="preserve">Returns the state of the #AdgTable:has-frame property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current state.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="adg_table_insert" version="1.0">
        <doc xml:space="preserve">Inserts @table_row inside the rows list of @table. If @before_row
is specified, @table_row is inserted before it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
          <parameter name="before_row"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #AdgTableRow or &lt;constant&gt;NULL&lt;/constant&gt;</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate_grid" c:identifier="adg_table_invalidate_grid">
        <doc xml:space="preserve">&lt;note&gt;&lt;para&gt;
This method is only useful in table children implementation.
&lt;/para&gt;&lt;/note&gt;

Clears the internal grid cache, effectively forcing its
regeneration next time the #AdgEntity::arrange signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="adg_table_remove" version="1.0">
        <doc xml:space="preserve">Removes @table_row from list of rows of @table.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cell" c:identifier="adg_table_set_cell" version="1.0">
        <doc xml:space="preserve">Binds @table_cell to @name, so it can be accessed by name later
with adg_table_get_cell(). Internally the binding is handled with
an hash table, so accessing the cell this way is O(1).

If @name is &lt;constant&gt;NULL&lt;/constant&gt;, any binding to @table_cell
will be removed. This is quite inefficient because the whole hash
table must be scanned.

If @table_cell is &lt;constant&gt;NULL&lt;/constant&gt;, the key with @name
in the hash table will be removed.

Both @name and @table_cell cannot be &lt;constant&gt;NULL&lt;/constant&gt; at the same time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the cell</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">the named cell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_table_dress"
              c:identifier="adg_table_set_table_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new table dress for rendering @table. The new dress
must be related to the original dress for this property:
you cannot set a dress used for line styles to a dress
managing fonts.

The check is done by calling adg_dress_are_related() with
@dress and the previous dress as arguments. Check out its
documentation for details on what is a related dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new #AdgDress to use</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_frame"
              c:identifier="adg_table_switch_frame"
              version="1.0">
        <doc xml:space="preserve">Sets the #AdgTable:has-frame property: &lt;constant&gt;TRUE&lt;/constant&gt;
will draw a frame around the whole table using the
#AdgTableStyle:frame-dress dress of the table style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the frame</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="has-frame" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="table-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="TableCell"
            c:type="AdgTableCell"
            version="1.0"
            glib:type-name="AdgTableCell"
            glib:get-type="adg_table_cell_get_type"
            c:symbol-prefix="table_cell">
      <doc xml:space="preserve">An opaque structure referring to the cell of an #AdgTableRow.
Any row can have an unlimited number of cells.</doc>
      <constructor name="new" c:identifier="adg_table_cell_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty cell without a frame and appends it at the
end of the cells yet present in @table_row. You can add content
to the cell by using adg_table_cell_set_title() and
adg_table_cell_set_value() or enable the frame with
adg_table_cell_switch_frame().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="adg_table_cell_new_full"
                   version="1.0">
        <doc xml:space="preserve">A convenient function to add a cell and specifies some common
used properties at once.

If @name is &lt;constant&gt;NULL&lt;/constant&gt;, the created cell will
not be a named cell. Check adg_table_set_cell() for further
details on what a named cell is supposed to be.

@title can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case no
title entity will be created.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the cell width</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the name to bound to this cell</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="title"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the title text</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="has_frame" transfer-ownership="none">
            <doc xml:space="preserve">whether to draw or not the frame</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_width"
                   c:identifier="adg_table_cell_new_with_width"
                   version="1.0">
        <doc xml:space="preserve">A convenient wrapper to adg_table_cell_new() that allows to
specify the @width of @table_row all at once.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the cell width</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="arrange"
              c:identifier="adg_table_cell_arrange"
              version="1.0">
        <doc xml:space="preserve">Rearranges the underlying #AdgTableCell owned by @table_cell using
the new extents provided in @layout. If the x or y size component
of @layout is negative, the value holded by the internal extents
struct is not overriden.

&lt;note&gt;&lt;para&gt;
table_cell-&gt;extents must be up to date if @layout-&gt;size.x or
@layout-&gt;size.y is negative in order to have a valid size.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of @table_cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">the new extents to use</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dispose"
              c:identifier="adg_table_cell_dispose"
              version="1.0">
        <doc xml:space="preserve">Disposes @table_cell.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell struct</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="adg_table_cell_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @src. The returned duplicate should be freed
with adg_table_cell_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate of @src.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableCell structure</doc>
            <type name="TableCell" c:type="const AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="adg_table_cell_free" version="1.0">
        <doc xml:space="preserve">Releases all the memory allocated by @table_cell, itself included.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableCell structure</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="adg_table_cell_get_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the extents of @table_cell. This function is useful only after the
arrange() phase as in the other situation the extents will likely
be not up to date.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of @table_cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_row"
              c:identifier="adg_table_cell_get_row"
              version="1.0">
        <doc xml:space="preserve">Gets the row container of @table_cell. The returned #AdgTableRow
is owned by @table_cell and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the container row.</doc>
          <type name="TableRow" c:type="AdgTableRow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_table"
              c:identifier="adg_table_cell_get_table"
              version="1.0">
        <doc xml:space="preserve">A convenient function that gets the table that contains
@table_cell. The returned #AdgTable is owned by @table_cell
and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the container table.</doc>
          <type name="Table" c:type="AdgTable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="adg_table_cell_get_width"
              version="1.0">
        <doc xml:space="preserve">Gets the width of @table_cell.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested width or 0 on errors.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_frame"
              c:identifier="adg_table_cell_has_frame"
              version="1.0">
        <doc xml:space="preserve">Gets the frame flag of @table_cell.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the frame flag.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_before"
              c:identifier="adg_table_cell_new_before"
              version="1.0">
        <doc xml:space="preserve">Creates a new cell and inserts it rigthly before the @table_cell cell.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created cell or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableCell" c:type="AdgTableCell*"/>
        </return-value>
        <parameters>
          <instance-parameter name="before_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_text_title"
              c:identifier="adg_table_cell_set_text_title"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set a the title of a cell using an #AdgToyText
entity with the font dress picked from #AdgTable:table-dress with
a call to adg_table_style_get_title_dress().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">a text string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_text_value"
              c:identifier="adg_table_cell_set_text_value"
              version="1.0">
        <doc xml:space="preserve">Convenient function to set a the value of a cell using an #AdgToyText
entity with a value font dress picked from #AdgTable:table-dress with
a call to adg_table_style_get_value_dress().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a text string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title"
              c:identifier="adg_table_cell_set_title"
              version="1.0">
        <doc xml:space="preserve">Sets @title as the new title entity of @table_cell. The top left
corner of the bounding box of @title will be cohincident to
the top left corner of the cell extents, taking into accounts
eventual padding spaces specified by the table style.

The old internal entity is unrefenrenced while the @title (if
not &lt;constant&gt;NULL&lt;/constant&gt;) is refenenced with
g_object_ref_sink().

@title can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the old
entity is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">the new title entity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value"
              c:identifier="adg_table_cell_set_value"
              version="1.0">
        <doc xml:space="preserve">Sets @value as the new value entity of @table_cell. The bottom middle
point of the bounding box of @value will be cohincident to the
bottom middle point of the cell extents, taking into accounts
eventual padding spaces specified by the table style.

The old internal entity is unrefenrenced while the @value (if
not &lt;constant&gt;NULL&lt;/constant&gt;) is referenced with
g_object_ref_sink().

@value can be &lt;constant&gt;NULL&lt;/constant&gt;, in which case the old entity is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value entity</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value_pos"
              c:identifier="adg_table_cell_set_value_pos"
              version="1.0">
        <doc xml:space="preserve">Sets a new custom position for the value entity of @table_cell. The
@from_factor specifies the source point (as a fraction of the
value extents) while the @to_factor is the destination point
(specified as a fraction of the cell extents) the source point
must be moved to.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="from_factor" transfer-ownership="none">
            <doc xml:space="preserve">the alignment factor on the value entity</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
          <parameter name="to_factor" transfer-ownership="none">
            <doc xml:space="preserve">the alignment factor on the cell</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value_pos_explicit"
              c:identifier="adg_table_cell_set_value_pos_explicit"
              version="1.0">
        <doc xml:space="preserve">A convenient wrapper around adg_table_cell_set_value_pos()
that uses explicit factors instead of #CpmlPair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="from_x" transfer-ownership="none">
            <doc xml:space="preserve">the x alignment factor on the entity</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="from_y" transfer-ownership="none">
            <doc xml:space="preserve">the y alignment factor on the entity</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="to_x" transfer-ownership="none">
            <doc xml:space="preserve">the x alignment factor on the cell</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="to_y" transfer-ownership="none">
            <doc xml:space="preserve">the y alignment factor on the cell</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_width"
              c:identifier="adg_table_cell_set_width"
              version="1.0">
        <doc xml:space="preserve">Sets a new width on @table_cell. The extents on the whole table
will be invalidated, so will be recomputed in the next
arrange() phase.

A positive @width value specifies the width of this cell in global
space: if the width of its content (that is, either the title or the
value entity) will be greater than @width, it will be rendered
outside the cell boundary box, luckely overwriting the adiacent
cells.

Using 0 as @width means the width of the cell will be automatically
adjusted to the maximum width of its content.

Negative width values are not allowed: this condition will raise
a warning without any further processing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the new width</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="size_request"
              c:identifier="adg_table_cell_size_request"
              version="1.0">
        <doc xml:space="preserve">Computes the minimum space needed to properly render @table_cell
and updates the size component of the internal #CpmlExtents struct,
returning it to the caller. The returned #CpmlPair is owned by
@table_cell and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minimum size required.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="row_extents" transfer-ownership="none">
            <doc xml:space="preserve">the extents of the container #AdgTableRow</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="switch_frame"
              c:identifier="adg_table_cell_switch_frame"
              version="1.0">
        <doc xml:space="preserve">Sets the frame flag of @table_cell: if @has_frame is
&lt;constant&gt;TRUE&lt;/constant&gt;, a frame around @table_cell
will be rendered using the #AdgTableStyle:frame-dress
dress of the table style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
          <parameter name="has_frame" transfer-ownership="none">
            <doc xml:space="preserve">whether to draw or not the frame</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="title" c:identifier="adg_table_cell_title" version="1.0">
        <doc xml:space="preserve">Gets the current title of @table_cell. The returned string is owned
by @table_cell and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the title entity or &lt;constant&gt;NULL&lt;/constant&gt; for undefined title.</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="value" c:identifier="adg_table_cell_value" version="1.0">
        <doc xml:space="preserve">Gets the current value of @table_cell. The returned string is owned
by @table_cell and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value entity or &lt;constant&gt;NULL&lt;/constant&gt; for undefined value.</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableCell</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="TableClass"
            c:type="AdgTableClass"
            glib:is-gtype-struct-for="Table">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
    </record>
    <record name="TableRow"
            c:type="AdgTableRow"
            version="1.0"
            glib:type-name="AdgTableRow"
            glib:get-type="adg_table_row_get_type"
            c:symbol-prefix="table_row">
      <doc xml:space="preserve">An opaque structure referring to a row of an #AdgTable. Any
table can have an unlimited number of rows.</doc>
      <constructor name="new" c:identifier="adg_table_row_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty row and appends it at the end of the rows
already present in @table. By default, the height of this new
row will be the fallback value provided by the table style:
you can override it by using adg_table_row_set_height().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created row or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableRow" c:type="AdgTableRow*"/>
        </return-value>
        <parameters>
          <parameter name="table" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTable</doc>
            <type name="Table" c:type="AdgTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="arrange"
              c:identifier="adg_table_row_arrange"
              version="1.0">
        <doc xml:space="preserve">Rearranges the underlying #AdgTableCell owned by @table_row using
the new extents provided in @layout. If the x or y size component
of @layout is negative, the value holded by the internal extents
struct is not overriden.

&lt;note&gt;&lt;para&gt;
table_row-&gt;extents must be up to date if @layout-&gt;size.x or
@layout-&gt;size.y is negative in order to have a valid size.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of @table_row or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
          <parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">the new extents to use</doc>
            <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="adg_table_row_dup" version="1.0">
        <doc xml:space="preserve">Duplicates @src. The returned duplicate should be freed
with adg_table_row_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate of @src.</doc>
          <type name="TableRow" c:type="AdgTableRow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableRow structure</doc>
            <type name="TableRow" c:type="const AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach"
              c:identifier="adg_table_row_foreach"
              version="1.0">
        <doc xml:space="preserve">Invokes @callback on each cell of @table_row.
The callback should be declared as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
void callback(AdgTableCell *table_cell, gpointer user_data);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">callback user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="adg_table_row_free" version="1.0">
        <doc xml:space="preserve">Releases all the memory allocated by @table_row, itself included.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableRow structure</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="adg_table_row_get_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the extents of @table_row. This function is useful only after
the arrange() phase as in the other situation the extents will
likely be not up to date.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the extents of @table_row or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="adg_table_row_get_height"
              version="1.0">
        <doc xml:space="preserve">Gets the height of @table_row.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested height or 0 on errors.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_table"
              c:identifier="adg_table_row_get_table"
              version="1.0">
        <doc xml:space="preserve">Returns the container table of @table_row. The returned table
is owned by @table_row and must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested table or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Table" c:type="AdgTable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="adg_table_row_insert" version="1.0">
        <doc xml:space="preserve">Inserts @table_cell inside @table_row. If @before_cell
is specified, @table_cell is inserted before it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
          <parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTableCell to insert</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </parameter>
          <parameter name="before_cell"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #AdgTableRow</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_before"
              c:identifier="adg_table_row_new_before"
              version="1.0">
        <doc xml:space="preserve">Creates a new empty row with default height and inserts it
just before @before_row.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created row or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="TableRow" c:type="AdgTableRow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="before_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="adg_table_row_remove" version="1.0">
        <doc xml:space="preserve">Removes @table_cell from list of cells of @table_row.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
          <parameter name="table_cell" transfer-ownership="none">
            <doc xml:space="preserve">the #AdgTableCell to remove</doc>
            <type name="TableCell" c:type="AdgTableCell*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_height"
              c:identifier="adg_table_row_set_height"
              version="1.0">
        <doc xml:space="preserve">Sets a new height on @table_row. The extents will be invalidated to
recompute the whole layout of the table. Specifying 0 in
@height will use the default height set in the table style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the new height</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="size_request"
              c:identifier="adg_table_row_size_request"
              version="1.0">
        <doc xml:space="preserve">Computes the minimum space needed to properly render @table_row
and updates the size component of the internal #CpmlExtents struct,
returning it to the caller. The returned #CpmlPair is owned by
@table_row and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minimum size required.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_row" transfer-ownership="none">
            <doc xml:space="preserve">a valid #AdgTableRow</doc>
            <type name="TableRow" c:type="AdgTableRow*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="TableStyle"
           c:symbol-prefix="table_style"
           c:type="AdgTableStyle"
           version="1.0"
           parent="Style"
           glib:type-name="AdgTableStyle"
           glib:get-type="adg_table_style_get_type"
           glib:type-struct="TableStyleClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_table_style_new" version="1.0">
        <doc xml:space="preserve">Constructs a new empty table style initialized with default params.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new table style.</doc>
          <type name="TableStyle" c:type="AdgTableStyle*"/>
        </return-value>
      </constructor>
      <method name="get_cell_padding"
              c:identifier="adg_table_style_get_cell_padding"
              version="1.0">
        <doc xml:space="preserve">Gets the padding values in x and y to be left clear inside the cells.
The returned pointer refers to an internal allocated struct and
must not be modified or freed.

The cell padding is a symmetric value, that is the padding on the
left will always be equal to the padding on the right and the top
will always be equal to the bottom.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the cell padding values or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cell_spacing"
              c:identifier="adg_table_style_get_cell_spacing"
              version="1.0">
        <doc xml:space="preserve">Gets the spacing values in x and y to be left between the cell
boundary boxes. The returned pointer refers to an internal
allocated struct and must not be modified or freed.

The cell spacing is a symmetric value, that is the spacing on the
left will always be equal to the spacing on the right and the top
will always be equal to the bottom.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the cell spacing values or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Pair" c:type="const CpmlPair*"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_dress"
              c:identifier="adg_table_style_get_color_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the @table_style color dress to be used. This dress should be
intended as a fallback color as it could be overriden by more
specific dresses, such as a color explicitely specified on the
#AdgTableStyle:value-dress.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_dress"
              c:identifier="adg_table_style_get_frame_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used for rendering the frames with
@table_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_grid_dress"
              c:identifier="adg_table_style_get_grid_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the line dress to be used for rendering the grids with
@table_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the line dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_row_height"
              c:identifier="adg_table_style_get_row_height"
              version="1.0">
        <doc xml:space="preserve">Gets the row height fallback value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the fallback row height or 0 on errors.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_title_dress"
              c:identifier="adg_table_style_get_title_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the font dress to be used for rendering cell titles
with @table_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value_dress"
              c:identifier="adg_table_style_get_value_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the font dress to be used for rendering cell values
with @table_style.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font dress.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_cell_padding"
              c:identifier="adg_table_style_set_cell_padding"
              version="1.0">
        <doc xml:space="preserve">Sets new #AdgTableStyle:cell-padding values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="padding" transfer-ownership="none">
            <doc xml:space="preserve">the new padding values</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cell_spacing"
              c:identifier="adg_table_style_set_cell_spacing"
              version="1.0">
        <doc xml:space="preserve">Sets new #AdgTableStyle:cell-spacing values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="spacing" transfer-ownership="none">
            <doc xml:space="preserve">the new spacing values</doc>
            <type name="Cpml.Pair" c:type="const CpmlPair*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_dress"
              c:identifier="adg_table_style_set_color_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new color dress on @table_style.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new color dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_dress"
              c:identifier="adg_table_style_set_frame_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress on @table_style for rendering the frames.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new line dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_grid_dress"
              c:identifier="adg_table_style_set_grid_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new line dress on @table_style for rendering the grids.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new line dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_row_height"
              c:identifier="adg_table_style_set_row_height"
              version="1.0">
        <doc xml:space="preserve">Sets a new #AdgTableStyle:row-height fallback. @height must
be a valid row height greather than 0 or a warning will be
raised and this function will fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the new row heigth fallback</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title_dress"
              c:identifier="adg_table_style_set_title_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new font dress on @table_style for rendering cell titles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new font dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value_dress"
              c:identifier="adg_table_style_set_value_dress"
              version="1.0">
        <doc xml:space="preserve">Sets a new font dress on @table_style for rendering cell values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="table_style" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTableStyle object</doc>
            <type name="TableStyle" c:type="AdgTableStyle*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new font dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <property name="cell-padding" writable="1" transfer-ownership="none">
        <type name="Cpml.Pair"/>
      </property>
      <property name="cell-spacing" writable="1" transfer-ownership="none">
        <type name="Cpml.Pair"/>
      </property>
      <property name="color-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="frame-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="grid-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="row-height" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="title-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="value-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Style" c:type="AdgStyle"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="TableStyleClass"
            c:type="AdgTableStyleClass"
            glib:is-gtype-struct-for="TableStyle">
      <field name="parent_class" readable="0" private="1">
        <type name="StyleClass" c:type="AdgStyleClass"/>
      </field>
    </record>
    <class name="Text"
           c:symbol-prefix="text"
           c:type="AdgText"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgText"
           glib:get-type="adg_text_get_type"
           glib:type-struct="TextClass">
      <doc xml:space="preserve">All fields are privates and should not be used directly.
Use its public methods instead.</doc>
      <implements name="Textual"/>
      <constructor name="new" c:identifier="adg_text_new" version="1.0">
        <doc xml:space="preserve">Creates a new text entity using @text as its content.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created text entity</doc>
          <type name="Text" c:type="AdgText*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the text</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="TextClass"
            c:type="AdgTextClass"
            glib:is-gtype-struct-for="Text">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
    </record>
    <interface name="Textual"
               c:symbol-prefix="textual"
               c:type="AdgTextual"
               version="1.0"
               glib:type-name="AdgTextual"
               glib:get-type="adg_textual_get_type"
               glib:type-struct="TextualIface">
      <doc xml:space="preserve">Dummy type of the #AdgTextualIface interface.</doc>
      <virtual-method name="dup_text" invoker="dup_text" version="1.0">
        <doc xml:space="preserve">Gets a duplicate of the current text bound to @textual.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the current text of @textual: free with g_free() when finished</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_font_dress"
                      invoker="get_font_dress"
                      version="1.0">
        <doc xml:space="preserve">Gets the current font dress of @textual, eventually resolved to
an #AdgFontStyle before the rendering.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current font dress of @textual.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_font_dress"
                      invoker="set_font_dress"
                      version="1.0">
        <doc xml:space="preserve">Sets the font dress of @textual to @dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_text" invoker="set_text" version="1.0">
        <doc xml:space="preserve">Sets a new text on @textual. If @text is the same as the old text
no actions are performed, otherwise the &lt;function&gt;set_text&lt;/function&gt;
virtual method is called and the #AdgTextual::text-changed signal
is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the new text to be set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="text_changed" invoker="text_changed" version="1.0">
        <doc xml:space="preserve">Emits the #AdgTextual::text-changed signal on @textual.

&lt;note&gt;&lt;para&gt;
This function is only useful when creating a new class that implements
the #AdgTextual interface.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="old_text" transfer-ownership="none">
            <doc xml:space="preserve">the old text bound to @textual</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="dup_text"
              c:identifier="adg_textual_dup_text"
              version="1.0">
        <doc xml:space="preserve">Gets a duplicate of the current text bound to @textual.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the current text of @textual: free with g_free() when finished</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font_dress"
              c:identifier="adg_textual_get_font_dress"
              version="1.0">
        <doc xml:space="preserve">Gets the current font dress of @textual, eventually resolved to
an #AdgFontStyle before the rendering.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current font dress of @textual.</doc>
          <type name="Dress" c:type="AdgDress"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_font_dress"
              c:identifier="adg_textual_set_font_dress"
              version="1.0">
        <doc xml:space="preserve">Sets the font dress of @textual to @dress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="dress" transfer-ownership="none">
            <doc xml:space="preserve">the new dress</doc>
            <type name="Dress" c:type="AdgDress"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_text"
              c:identifier="adg_textual_set_text"
              version="1.0">
        <doc xml:space="preserve">Sets a new text on @textual. If @text is the same as the old text
no actions are performed, otherwise the &lt;function&gt;set_text&lt;/function&gt;
virtual method is called and the #AdgTextual::text-changed signal
is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the new text to be set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="text_changed"
              c:identifier="adg_textual_text_changed"
              version="1.0">
        <doc xml:space="preserve">Emits the #AdgTextual::text-changed signal on @textual.

&lt;note&gt;&lt;para&gt;
This function is only useful when creating a new class that implements
the #AdgTextual interface.
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #AdgTextual</doc>
            <type name="Textual" c:type="AdgTextual*"/>
          </instance-parameter>
          <parameter name="old_text" transfer-ownership="none">
            <doc xml:space="preserve">the old text bound to @textual</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="font-dress"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="text" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="text-changed" when="last" version="1.0">
        <doc xml:space="preserve">Emitted whenever the text of @textual has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_text" transfer-ownership="none">
            <doc xml:space="preserve">the old text</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="TextualIface"
            c:type="AdgTextualIface"
            glib:is-gtype-struct-for="Textual"
            version="1.0">
      <doc xml:space="preserve">The virtual methods @set_text and @dup_text must be implemented
by all the types which implement this interface.</doc>
      <field name="base_iface" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="set_font_dress">
        <callback name="set_font_dress">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="textual" transfer-ownership="none">
              <doc xml:space="preserve">an object that implements #AdgTextual</doc>
              <type name="Textual" c:type="AdgTextual*"/>
            </parameter>
            <parameter name="dress" transfer-ownership="none">
              <doc xml:space="preserve">the new dress</doc>
              <type name="Dress" c:type="AdgDress"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_font_dress">
        <callback name="get_font_dress">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the current font dress of @textual.</doc>
            <type name="Dress" c:type="AdgDress"/>
          </return-value>
          <parameters>
            <parameter name="textual" transfer-ownership="none">
              <doc xml:space="preserve">an object that implements #AdgTextual</doc>
              <type name="Textual" c:type="AdgTextual*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_text">
        <callback name="set_text">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="textual" transfer-ownership="none">
              <doc xml:space="preserve">an object that implements #AdgTextual</doc>
              <type name="Textual" c:type="AdgTextual*"/>
            </parameter>
            <parameter name="text" transfer-ownership="none">
              <doc xml:space="preserve">the new text to be set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_text">
        <callback name="dup_text">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the current text of @textual: free with g_free() when finished</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="textual" transfer-ownership="none">
              <doc xml:space="preserve">an object that implements #AdgTextual</doc>
              <type name="Textual" c:type="AdgTextual*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="text_changed">
        <callback name="text_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="textual" transfer-ownership="none">
              <doc xml:space="preserve">an object that implements #AdgTextual</doc>
              <type name="Textual" c:type="AdgTextual*"/>
            </parameter>
            <parameter name="old_text" transfer-ownership="none">
              <doc xml:space="preserve">the old text bound to @textual</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ThreeState" version="1.0" c:type="AdgThreeState">
      <doc xml:space="preserve">A generic three state flags to be used whenever needed. Could be
user when a boolean is requested but also an indefinite / default
state should be caught.</doc>
      <member name="off" value="0" c:identifier="ADG_THREE_STATE_OFF">
        <doc xml:space="preserve">disabled, switched off, disactive</doc>
      </member>
      <member name="on" value="1" c:identifier="ADG_THREE_STATE_ON">
        <doc xml:space="preserve">enabled, switched on, active</doc>
      </member>
      <member name="unknown" value="2" c:identifier="ADG_THREE_STATE_UNKNOWN">
        <doc xml:space="preserve">unknown / indefinite / automatic state</doc>
      </member>
    </enumeration>
    <class name="TitleBlock"
           c:symbol-prefix="title_block"
           c:type="AdgTitleBlock"
           version="1.0"
           parent="Table"
           glib:type-name="AdgTitleBlock"
           glib:get-type="adg_title_block_get_type"
           glib:type-struct="TitleBlockClass">
      <doc xml:space="preserve">All fields are privates and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_title_block_new" version="1.0">
        <doc xml:space="preserve">Creates a new empty title block entity.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created title block entity.</doc>
          <type name="TitleBlock" c:type="AdgTitleBlock*"/>
        </return-value>
      </constructor>
      <method name="get_author"
              c:identifier="adg_title_block_get_author"
              version="1.0">
        <doc xml:space="preserve">Gets the author's name of the drawing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the author or &lt;constant&gt;NULL&lt;/constant&gt; on no author or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_date"
              c:identifier="adg_title_block_get_date"
              version="1.0">
        <doc xml:space="preserve">Gets the date of the rendering set on @title_block.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the date or &lt;constant&gt;NULL&lt;/constant&gt; on no date or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drawing"
              c:identifier="adg_title_block_get_drawing"
              version="1.0">
        <doc xml:space="preserve">Gets the drawing name, commonly used to specify the file name.
The returned string is owned by @title_block and should not
be modifed or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the drawing name or &lt;constant&gt;NULL&lt;/constant&gt; on no name or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scale"
              c:identifier="adg_title_block_get_scale"
              version="1.0">
        <doc xml:space="preserve">Gets the scale descriptive name of the drawing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scale text or &lt;constant&gt;NULL&lt;/constant&gt; on no scale or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size"
              c:identifier="adg_title_block_get_size"
              version="1.0">
        <doc xml:space="preserve">Gets the media size (a descriptive name) where this drawing will
be printed. Usually contains something like &lt;constant&gt;"A4"&lt;/constant&gt;
or &lt;constant&gt;"Letter"&lt;/constant&gt;.
The returned string is owned by @title_block and should not
be modifed or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size or &lt;constant&gt;NULL&lt;/constant&gt; on no size or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_title"
              c:identifier="adg_title_block_get_title"
              version="1.0">
        <doc xml:space="preserve">Gets the descriptive title associated to this title block.
The returned string is owned by @title_block and should not
be modifed or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the title or &lt;constant&gt;NULL&lt;/constant&gt; on no title or errors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="logo" c:identifier="adg_title_block_logo" version="1.0">
        <doc xml:space="preserve">Gets the logo bound to this title block.
The returned object is owned by @title_block and should not
be unreferenced although can be freely modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the logo or &lt;constant&gt;NULL&lt;/constant&gt; on no logo or errors.</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="projection"
              c:identifier="adg_title_block_projection"
              version="1.0">
        <doc xml:space="preserve">Gets the projection bound to this title block.
The returned object is owned by @title_block and should not
be unreferenced although can be freely modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the projection or &lt;constant&gt;NULL&lt;/constant&gt; on no projection or errors.</doc>
          <type name="Entity" c:type="AdgEntity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_author"
              c:identifier="adg_title_block_set_author"
              version="1.0">
        <doc xml:space="preserve">Sets a new author on the title block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="author" transfer-ownership="none">
            <doc xml:space="preserve">the new author</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_date"
              c:identifier="adg_title_block_set_date"
              version="1.0">
        <doc xml:space="preserve">Sets a new date on the title block. By default the date is
set to &lt;constant&gt;NULL&lt;/constant&gt; and it will be implicitely
rendered using the*preferred representation for the current
local of the actual date. This is roughly equivalent to:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
strftime(buffer, sizeof(buffer), "%x", now);
adg_title_block_set_date(title_block, buffer);
&lt;/programlisting&gt;&lt;/informalexample&gt;

To not render any value, use an empty string as @date.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">the new date</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drawing"
              c:identifier="adg_title_block_set_drawing"
              version="1.0">
        <doc xml:space="preserve">Sets a new drawing name on the title block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="drawing" transfer-ownership="none">
            <doc xml:space="preserve">the new drawing name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_logo"
              c:identifier="adg_title_block_set_logo"
              version="1.0">
        <doc xml:space="preserve">Sets a new logo on the title block. This function will add
a reference to @logo, removing the eventual reference held
to the old logo, hence possibly destroying the old endity.

The space reserved for the logo is 56x56, so try to keep the
new logo near this size or scale it accordingly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="logo" transfer-ownership="none">
            <doc xml:space="preserve">the new logo</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_projection"
              c:identifier="adg_title_block_set_projection"
              version="1.0">
        <doc xml:space="preserve">Sets a new projection symbol on the title block. This function
will add a reference to @projection, removing the eventual
reference held to the old symbol, hence possibly destroying
the old endity.

The space reserved for the projection is 56x56, so try to keep the
new projection near this size or scale it accordingly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">the new projection</doc>
            <type name="Entity" c:type="AdgEntity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scale"
              c:identifier="adg_title_block_set_scale"
              version="1.0">
        <doc xml:space="preserve">Sets a new scale on the title block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">the new scale</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size"
              c:identifier="adg_title_block_set_size"
              version="1.0">
        <doc xml:space="preserve">Sets a new size on the title block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the new size</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title"
              c:identifier="adg_title_block_set_title"
              version="1.0">
        <doc xml:space="preserve">Sets a new title on the title block.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="title_block" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTitleBlock entity</doc>
            <type name="TitleBlock" c:type="AdgTitleBlock*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">the new title</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="author" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="date" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="drawing" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="logo" writable="1" transfer-ownership="none">
        <type name="Entity"/>
      </property>
      <property name="projection" writable="1" transfer-ownership="none">
        <type name="Entity"/>
      </property>
      <property name="scale" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="size" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="title" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Table" c:type="AdgTable"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="TitleBlockClass"
            c:type="AdgTitleBlockClass"
            glib:is-gtype-struct-for="TitleBlock">
      <field name="parent_class" readable="0" private="1">
        <type name="TableClass" c:type="AdgTableClass"/>
      </field>
    </record>
    <class name="ToyText"
           c:symbol-prefix="toy_text"
           c:type="AdgToyText"
           version="1.0"
           parent="Entity"
           glib:type-name="AdgToyText"
           glib:get-type="adg_toy_text_get_type"
           glib:type-struct="ToyTextClass">
      <doc xml:space="preserve">All fields are privates and should not be used directly.
Use its public methods instead.</doc>
      <implements name="Textual"/>
      <constructor name="new" c:identifier="adg_toy_text_new" version="1.0">
        <doc xml:space="preserve">Creates a new toy text entity using @text as its content.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly created toy text entity</doc>
          <type name="ToyText" c:type="AdgToyText*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the text</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="Entity" c:type="AdgEntity"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="ToyTextClass"
            c:type="AdgToyTextClass"
            glib:is-gtype-struct-for="ToyText">
      <field name="parent_class" readable="0" private="1">
        <type name="EntityClass" c:type="AdgEntityClass"/>
      </field>
    </record>
    <class name="Trail"
           c:symbol-prefix="trail"
           c:type="AdgTrail"
           version="1.0"
           parent="Model"
           glib:type-name="AdgTrail"
           glib:get-type="adg_trail_get_type"
           glib:type-struct="TrailClass">
      <doc xml:space="preserve">All fields are private and should not be used directly.
Use its public methods instead.</doc>
      <constructor name="new" c:identifier="adg_trail_new" version="1.0">
        <doc xml:space="preserve">Creates a new trail model. The #cairo_path_t must be constructed by
the @callback function: #AdgTrail will not cache anything, so you
should implement any caching mechanism in the callback, if needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new trail model.</doc>
          <type name="Trail" c:type="AdgTrail*"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve">the #cairo_path_t constructor function</doc>
            <type name="TrailCallback" c:type="AdgTrailCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">generic pointer to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_cairo_path"
                      invoker="get_cairo_path"
                      version="1.0">
        <doc xml:space="preserve">Gets a pointer to the cairo path of @trail. The returned path is
owned by @trail and must be considered read-only.

This function gets the #cairo_path_t of @trail by calling
adg_trail_cairo_path() and converts its #CPML_ARC primitives,
not recognized by cairo, into approximated Bézier curves
primitives (#CPML_CURVE). The conversion is cached, so any further
request is O(1). This cache is cleared only by the
adg_model_clear() method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the internal cairo path or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Path" c:type="cairo_path_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="cairo_path"
              c:identifier="adg_trail_cairo_path"
              version="1.0">
        <doc xml:space="preserve">Gets the cairo path structure defined by @trail. The returned
value is managed by the #AdgTrail implementation, that is this
function directly calls the &lt;function&gt;get_cairo_path&lt;/function&gt;
virtual method that any trail instance must have.

Whenever used internally by the ADG project, the returned path
is (by convention) owned by @trail and so it should not be freed.
Anyway, callers are allowed to modify it as long as its size is
retained and its data contains a valid path: this is needed to
let the #AdgMarker infrastructure work properly (the markers
should be able to modify the trail where they are applied).

Any further call to this method will probably make the pointer
previously returned useless because the #cairo_path_t could be
relocated and the old #cairo_path_t will likely contain rubbish.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the #cairo_path_t or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Path" c:type="cairo_path_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="adg_trail_dump" version="1.0">
        <doc xml:space="preserve">Dumps the data content of @trail to stdout in a human readable format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cairo_path"
              c:identifier="adg_trail_get_cairo_path"
              version="1.0">
        <doc xml:space="preserve">Gets a pointer to the cairo path of @trail. The returned path is
owned by @trail and must be considered read-only.

This function gets the #cairo_path_t of @trail by calling
adg_trail_cairo_path() and converts its #CPML_ARC primitives,
not recognized by cairo, into approximated Bézier curves
primitives (#CPML_CURVE). The conversion is cached, so any further
request is O(1). This cache is cleared only by the
adg_model_clear() method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the internal cairo path or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="cairo.Path" c:type="const cairo_path_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extents"
              c:identifier="adg_trail_get_extents"
              version="1.0">
        <doc xml:space="preserve">Gets the extents of @trail. The returned pointer is owned by
@trail and should not be freed nor modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested extents or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
          <type name="Cpml.Extents" c:type="const CpmlExtents*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_angle"
              c:identifier="adg_trail_get_max_angle"
              version="1.0">
        <doc xml:space="preserve">Gets the #AdgTrail:max-angle property value of @trail.
Refer to adg_trail_set_max_angle() for details of what
this parameter is used for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value (in radians) of the max angle</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="put_segment"
              c:identifier="adg_trail_put_segment"
              version="1.0">
        <doc xml:space="preserve">Convenient function to get a segment from @trail. The segment is
got from the cairo path: check out adg_trail_cairo_path() for
further information.

When the segment is not found, either because @n_segment is out
of range or because there is still no path bound to @trail, this
function will return &lt;constant&gt;FALSE&lt;/constant&gt; leaving @segment
untouched. If the segment is found and @segment is
not &lt;constant&gt;NULL&lt;/constant&gt;, the resulting segment is copied in @segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on success or &lt;constant&gt;FALSE&lt;/constant&gt; on errors.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
          <parameter name="n_segment" transfer-ownership="none">
            <doc xml:space="preserve">the segment to retrieve, where 1 is the first segment</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="segment"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the destination #CpmlSegment</doc>
            <type name="Cpml.Segment" c:type="CpmlSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_angle"
              c:identifier="adg_trail_set_max_angle"
              version="1.0">
        <doc xml:space="preserve">Sets the max angle of @trail to @angle, basically setting
the #AdgTrail:max-angle property.

This property is used to specify the maximum ciruclar arc
that will be approximated by a single Bézier curve in the
adg_trail_get_cairo_path() method. Basically this can be
used to fine tune the fitting algorithm: lower values mean
an arc will be approximated with more curves, lowering the
error but incrementing time and memory needed. The default
value of %G_PI_2 is usually good in most cases.

Check the cairo-arc.c source file (part of the cairo project)
for mathematical details. A copy can probably be consulted
online at the cairo repository on freedesktop. Here is a link
to the 1.10.2 version:

http://cgit.freedesktop.org/cairo/tree/src/cairo-arc.c?id=1.10.2</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trail" transfer-ownership="none">
            <doc xml:space="preserve">an #AdgTrail</doc>
            <type name="Trail" c:type="AdgTrail*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the new angle (in radians)</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="max-angle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Model" c:type="AdgModel"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <callback name="TrailCallback" c:type="AdgTrailCallback" version="1.0">
      <doc xml:space="preserve">This is the callback used to generate the #cairo_path_t and it is
called directly by adg_trail_cairo_path(). The caller owns
the returned path, that is the finalization of the returned
#cairo_path_t should be made by the caller when appropriate.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #cairo_path_t of this trail model</doc>
        <type name="cairo.Path" c:type="cairo_path_t*"/>
      </return-value>
      <parameters>
        <parameter name="trail" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgTrail</doc>
          <type name="Trail" c:type="AdgTrail*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">the general purpose pointer set by adg_trail_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TrailClass"
            c:type="AdgTrailClass"
            glib:is-gtype-struct-for="Trail"
            version="1.0">
      <doc xml:space="preserve">The default @get_cairo_path calls the #AdgTrailCallback callback passed
to adg_trail_new() during construction. No caching is performed in
between.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ModelClass" c:type="AdgModelClass"/>
      </field>
      <field name="get_cairo_path">
        <callback name="get_cairo_path">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the internal cairo path or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
            <type name="cairo.Path" c:type="cairo_path_t*"/>
          </return-value>
          <parameters>
            <parameter name="trail" transfer-ownership="none">
              <doc xml:space="preserve">an #AdgTrail</doc>
              <type name="Trail" c:type="AdgTrail*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="TransformMode" version="1.0" c:type="AdgTransformMode">
      <doc xml:space="preserve">Specifies the mode a generic transformation should be applied on
a matrix. Although used in different places, the function performing
the dirty work is always adg_matrix_transform().</doc>
      <member name="none" value="0" c:identifier="ADG_TRANSFORM_NONE">
        <doc xml:space="preserve">do not apply any transformation: the
                                  matrix is returned unchanged</doc>
      </member>
      <member name="before" value="1" c:identifier="ADG_TRANSFORM_BEFORE">
        <doc xml:space="preserve">apply the transformation before the
                                  matrix: the result is equivalent to
                                  cairo_matrix_multiply(matrix, transformation, matrix)</doc>
      </member>
      <member name="after" value="2" c:identifier="ADG_TRANSFORM_AFTER">
        <doc xml:space="preserve">apply the transformation after the
                                  matrix: the result is equivalent to
                                  cairo_matrix_multiply(matrix, matrix, transformation)</doc>
      </member>
      <member name="before_normalized"
              value="3"
              c:identifier="ADG_TRANSFORM_BEFORE_NORMALIZED">
        <doc xml:space="preserve">same as %ADG_TRANSFORM_BEFORE but
                                  normalizing the transformation with
                                  adg_matrix_normalize() before applying it</doc>
      </member>
      <member name="after_normalized"
              value="4"
              c:identifier="ADG_TRANSFORM_AFTER_NORMALIZED">
        <doc xml:space="preserve">same as %ADG_TRANSFORM_AFTER but
                                  normalizing the transformation with
                                  adg_matrix_normalize() before applying it</doc>
      </member>
    </enumeration>
    <constant name="UTF8_DEGREE"
              value="°"
              c:type="ADG_UTF8_DEGREE"
              version="1.0">
      <doc xml:space="preserve">String constant that embeds a UTF-8 encoded degree symbol (U+00B0).
It is used to suffix by the default implementation of #AdgADim to
suffix the set value, but can be also used manually:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
adg_dim_set_value(dim, "&lt;&gt;" ADG_UTF8_DEGREE);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="UTF8_DIAMETER"
              value="ø"
              c:type="ADG_UTF8_DIAMETER"
              version="1.0">
      <doc xml:space="preserve">String constant that embeds a UTF-8 encoded diameter (U+2300).
It can be used to prefix diameter quotes, such as:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
adg_dim_set_value(dim, ADG_UTF8_DIAMETER "&lt;&gt;");
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function name="dress_are_related"
              c:identifier="adg_dress_are_related"
              version="1.0">
      <doc xml:space="preserve">Checks whether @dress1 and @dress2 are related, that is
if they have the same ancestor type as returned by
adg_dress_get_ancestor_type().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if the dresses are related, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dress1" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
        <parameter name="dress2" transfer-ownership="none">
          <doc xml:space="preserve">another #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_from_name"
              c:identifier="adg_dress_from_name"
              version="1.0">
      <doc xml:space="preserve">Gets the dress bound to a @name string. No warnings are raised
if the dress is not found.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #AdgDress value or #ADG_DRESS_UNDEFINED if not found.</doc>
        <type name="Dress" c:type="AdgDress"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of a dress</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_get_ancestor_type"
              c:identifier="adg_dress_get_ancestor_type"
              version="1.0">
      <doc xml:space="preserve">Gets the base type that should be present in every #AdgStyle
acceptable by @dress.  No warnings are raised if @dress
is not found.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ancestor type or 0 on errors.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_get_fallback"
              c:identifier="adg_dress_get_fallback"
              version="1.0">
      <doc xml:space="preserve">Gets the fallback style associated to @dress. No warnings
are raised if the dress is not found. The returned style
is owned by dress and should not be freed or modified.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the requested #AdgStyle derived instance or &lt;constant&gt;NULL&lt;/constant&gt; if not set.</doc>
        <type name="Style" c:type="AdgStyle*"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_get_name"
              c:identifier="adg_dress_get_name"
              version="1.0">
      <doc xml:space="preserve">Gets the name associated to @dress. No warnings are raised if
@dress is not found.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the requested name or &lt;constant&gt;NULL&lt;/constant&gt; if not found.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_set" c:identifier="adg_dress_set" version="1.0">
      <doc xml:space="preserve">Copies @src in @dress. This operation can be successful only if
@dress is #ADG_DRESS_UNDEFINED or if it contains a dress related
to @src, i.e. adg_dress_are_related() returns &lt;constant&gt;TRUE&lt;/constant&gt;.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on copy done, &lt;constant&gt;FALSE&lt;/constant&gt; on copy failed or not needed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">the source dress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_set_fallback"
              c:identifier="adg_dress_set_fallback"
              version="1.0">
      <doc xml:space="preserve">Associates a new @fallback style to @dress. If the dress is
not valid, a warning message is raised and the function fails.

@fallback is checked for compatibily with @dress. Any dress holds
an ancestor type: if this type is not found in the @fallback
hierarchy, a warning message is raised and the function fails.

After a succesfull call, the reference to the previous fallback
(if any) is dropped while a new reference to @fallback is added.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
        <parameter name="fallback" transfer-ownership="full">
          <doc xml:space="preserve">the new fallback style</doc>
          <type name="Style" c:type="AdgStyle*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dress_style_is_compatible"
              c:identifier="adg_dress_style_is_compatible"
              version="1.0">
      <doc xml:space="preserve">Checks whether @style is compatible with @dress, that is if
@style has the ancestor style type (as returned by
adg_dress_get_ancestor_type()) in its hierarchy.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @dress can accept @style, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">an #AdgDress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
        <parameter name="style" transfer-ownership="none">
          <doc xml:space="preserve">the #AdgStyle to check</doc>
          <type name="Style" c:type="AdgStyle*"/>
        </parameter>
      </parameters>
    </function>
    <function name="find_file"
              c:identifier="adg_find_file"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve">Searches @file in the provided paths and returns the full
path to the first existing match. The check is performed
using g_file_test() with the G_FILE_TEST_EXISTS test.

The result should be freed with g_free() when no longer needed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the path or &lt;constant&gt;NULL&lt;/constant&gt; if not found or on errors.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">the file to search</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a NULL terminated list of paths where to look for
       file existence.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="gtk_toggle_button_sensitivize"
              c:identifier="adg_gtk_toggle_button_sensitivize"
              version="1.0">
      <doc xml:space="preserve">Assigns the value of the #GtkToggleButton:active property of
@toggle_button to the #GtkWidget:sensitive property of @widget.
Useful to set or reset the sensitiveness of @widget depending
of the state of a check button, for example:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
g_signal_connect(toggle_button, "toggled",
                 G_CALLBACK(adg_gtk_toggle_button_sensitivize), widget1);
g_signal_connect(toggle_button, "toggled",
                 G_CALLBACK(adg_gtk_toggle_button_sensitivize), widget2);
g_signal_connect(toggle_button, "toggled",
                 G_CALLBACK(adg_gtk_toggle_button_sensitivize), widget3);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="toggle_button" transfer-ownership="none">
          <doc xml:space="preserve">a #GtkToggleButton</doc>
          <type name="Gtk.ToggleButton" c:type="GtkToggleButton*"/>
        </parameter>
        <parameter name="widget" transfer-ownership="none">
          <doc xml:space="preserve">the #GtkWidget</doc>
          <type name="Gtk.Widget" c:type="GtkWidget*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gtk_use_default_icons"
              c:identifier="adg_gtk_use_default_icons">
      <doc xml:space="preserve">Sets the default icon list of every #GtkWindow to a hand-coded
list of ADG icons. Check gtk gtk_window_set_default_icon_list()
for further details.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dir" transfer-ownership="none">
          <doc xml:space="preserve">the directory where the icons should be installed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gtk_window_hide_here"
              c:identifier="adg_gtk_window_hide_here"
              version="1.0">
      <doc xml:space="preserve">A convenient function that hides @window and tries to store the
current position. Any subsequent call to gtk_widget_show() will
hopefully reopen the window at the same position.

It can be used instead of gtk_widget_hide() or by connecting it
to a #GtkDialog::response signal, for instance:

&lt;informalexample&gt;&lt;programlisting language="C"&gt;
g_signal_connect(dialog, "response",
                 G_CALLBACK(adg_gtk_window_hide_here), NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="window" transfer-ownership="none">
          <doc xml:space="preserve">a #GtkWindow</doc>
          <type name="Gtk.Window" c:type="GtkWindow*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_boolean_value"
              c:identifier="adg_is_boolean_value"
              version="1.0">
      <doc xml:space="preserve">Checks if @value is a valid #gboolean value, that is if it is
&lt;constant&gt;TRUE&lt;/constant&gt; or &lt;constant&gt;FALSE&lt;/constant&gt;.
No other values are accepted.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @value is a valid #gboolean, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the gboolean value to check</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_enum_value"
              c:identifier="adg_is_enum_value"
              version="1.0">
      <doc xml:space="preserve">Checks if @value is a valid @enum_type value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @value is a valid @enum_type, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the enum value to check</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="enum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GEnum based type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_string_empty"
              c:identifier="adg_is_string_empty"
              version="1.0">
      <doc xml:space="preserve">Checks if @str is an empty string, that is if is
&lt;constant&gt;NULL&lt;/constant&gt; or if its first character
is &lt;constant&gt;'\0'&lt;/constant&gt;.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @str is an empty string, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the subject string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_copy" c:identifier="adg_matrix_copy" version="1.0">
      <doc xml:space="preserve">Copies @src to @matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">the destination #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="cairo_matrix_t*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">the source #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_dump" c:identifier="adg_matrix_dump" version="1.0">
      <doc xml:space="preserve">Dumps the specified @matrix to stdout. Useful for debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">an #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_dup" c:identifier="adg_matrix_dup" version="1.0">
      <doc xml:space="preserve">Duplicates @matrix.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a duplicate of @matrix that must be freed with g_free() when no longer needed.</doc>
        <type name="cairo.Matrix" c:type="cairo_matrix_t*"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">the souce #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_equal"
              c:identifier="adg_matrix_equal"
              version="1.0">
      <doc xml:space="preserve">Compares @matrix1 and @matrix2 and returns &lt;constant&gt;TRUE&lt;/constant&gt;
if the matrices are equal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; if @matrix1 is equal to @matrix2, &lt;constant&gt;FALSE&lt;/constant&gt; otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="matrix1" transfer-ownership="none">
          <doc xml:space="preserve">the first operand</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
        <parameter name="matrix2" transfer-ownership="none">
          <doc xml:space="preserve">the second operand</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_identity"
              c:identifier="adg_matrix_identity"
              version="1.0">
      <doc xml:space="preserve">A convenient constant providing an identity matrix.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to the identity matrix</doc>
        <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
      </return-value>
    </function>
    <function name="matrix_normalize"
              c:identifier="adg_matrix_normalize"
              version="1.0">
      <doc xml:space="preserve">Gets rid of the scaling component of a matrix.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt;constant&gt;TRUE&lt;/constant&gt; on success, &lt;constant&gt;FALSE&lt;/constant&gt; on errors.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">the source/destination #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="cairo_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_null" c:identifier="adg_matrix_null" version="1.0">
      <doc xml:space="preserve">A convenient constant providing an null matrix, that is a matrix
where all components are 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to the null matrix</doc>
        <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
      </return-value>
    </function>
    <function name="matrix_transform"
              c:identifier="adg_matrix_transform"
              version="1.0">
      <doc xml:space="preserve">Modifies @matrix applying @transformation in the way specified by
@mode.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">the source/destination #cairo_matrix_t</doc>
          <type name="cairo.Matrix" c:type="cairo_matrix_t*"/>
        </parameter>
        <parameter name="transformation" transfer-ownership="none">
          <doc xml:space="preserve">the transformation to apply</doc>
          <type name="cairo.Matrix" c:type="const cairo_matrix_t*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">how @transformation should be applied</doc>
          <type name="TransformMode" c:type="AdgTransformMode"/>
        </parameter>
      </parameters>
    </function>
    <function name="nop" c:identifier="adg_nop">
      <doc xml:space="preserve">A function that does nothing. It can be used as
&lt;constant&gt;/dev/null&lt;/constant&gt; when callback are required, e.g. with
g_log_set_default_handler().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="param_spec_dress"
              c:identifier="adg_param_spec_dress"
              version="1.0">
      <doc xml:space="preserve">Creates a param spec to hold a dress value. This is similar to
g_param_spec_enum() but rejects a new dress value if it is not
related with the old one. The setting is performed via
adg_dress_set(), so check its documentation for details.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated #GParamSpec.</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nickname of the param</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">brief desciption</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dress" transfer-ownership="none">
          <doc xml:space="preserve">the #AdgDress dress</doc>
          <type name="Dress" c:type="AdgDress"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GParamFlags</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="scale_factor" c:identifier="adg_scale_factor">
      <doc xml:space="preserve">Converts a scale in the form x:y (where x and y are respectively
two positive integers representing the numerator and denominator
of a fraction) into its approximate double representation. Any
garbage following x or y will be silently ignored, meaning that
x+garbage:y+garbage is equivalent to x:y. Furthermore, the postfix
:y can be omitted, in which case (double) x will be returned.

x and y are converted by using atoi(), so refer to your C library
documentation for details on the algorithm used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the (possibly approximated) double conversion of @scale or 0 on errors.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="scale" transfer-ownership="none">
          <doc xml:space="preserve">a string identifying the scale</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="string_replace"
              c:identifier="adg_string_replace"
              version="1.0">
      <doc xml:space="preserve">Replaces @from with @to inside @str and returns the result as a
newly allocated string.

@str and @from must be non-null valid C strings while @to can be
&lt;constant&gt;NULL&lt;/constant&gt;, in which case an empty string
(&lt;constant&gt;""&lt;/constant&gt;) will be implied.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string to be freed with g_free() or &lt;constant&gt;NULL&lt;/constant&gt; on errors.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the original string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">the substring to replace</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">the replacement string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="switch_extents"
              c:identifier="adg_switch_extents"
              version="1.0">
      <doc xml:space="preserve">Strokes (if @state is &lt;constant&gt;TRUE&lt;/constant&gt;) a rectangle
around every entity to show their extents. Useful for
debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve">new extents state</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_from_filename"
              c:identifier="adg_type_from_filename"
              introspectable="0">
      <doc xml:space="preserve">Gets the surface type from @file. The algorithm simply looks to the
file name extension and tries to guess the correct surface type. If the
guess fails, e.g. the extension does not exist or it is not usual, the
function returns &lt;constant&gt;CAIRO_SURFACE_TYPE_XLIB&lt;/constant&gt;. This is
the value conventionally used to signal unrecognized file names.</doc>
      <return-value>
        <doc xml:space="preserve">the surface type of @file or &lt;constant&gt;CAIRO_SURFACE_TYPE_XLIB&lt;/constant&gt;.</doc>
        <type c:type="cairo_surface_type_t"/>
      </return-value>
      <parameters>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">the full path to the file</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
