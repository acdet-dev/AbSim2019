<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="InfGnutls" version="3.0"/>
  <include name="InfGsasl" version="1.0"/>
  <include name="libxml2" version="2.0"/>
  <package name="libinfinity-0.7"/>
  <namespace name="Infinity"
             version="0.7"
             shared-library="libinfinity-0.7-0.dll"
             c:identifier-prefixes="Inf"
             c:symbol-prefixes="inf">
    <alias name="AclAccountId" c:type="InfAclAccountId">
      <doc xml:space="preserve">This type represents a unique identifier for a user account.</doc>
      <type name="GLib.Quark" c:type="GQuark"/>
    </alias>
    <alias name="NativeSocket" c:type="InfNativeSocket">
      <doc xml:space="preserve">Native socket type on the target platform. This typedef is a simple #int
on Unix and a #SOCKET on Windows.</doc>
      <type name="guint" c:type="guint"/>
    </alias>
    <record name="AclAccount"
            c:type="InfAclAccount"
            glib:type-name="InfAclAccount"
            glib:get-type="inf_acl_account_get_type"
            c:symbol-prefix="acl_account">
      <doc xml:space="preserve">This boxed type specifies basic user account information.</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">A unique ID for this account.</doc>
        <type name="AclAccountId" c:type="InfAclAccountId"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">A human readable account name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new" c:identifier="inf_acl_account_new">
        <doc xml:space="preserve">Creates a new #InfAclAccount.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclAccount object.</doc>
          <type name="AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The unique ID of the new account.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The human-readable name of the new account.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="inf_acl_account_copy">
        <doc xml:space="preserve">Creates a copy of @account.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclAccount. Free with
inf_acl_account_free() when no longer needed.</doc>
          <type name="AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccount to copy.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_acl_account_free">
        <doc xml:space="preserve">Releases all resources allocated by @account.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccount.</doc>
            <type name="AclAccount" c:type="InfAclAccount*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_xml" c:identifier="inf_acl_account_to_xml">
        <doc xml:space="preserve">Serializes the properties of @account into the XML node @xml. The function
inf_acl_account_from_xml() does the reverse operation and deserializes the
account object from the XML.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML node to write the account attributes to.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <function name="array_free" c:identifier="inf_acl_account_array_free">
        <doc xml:space="preserve">Releases all resources allocated by an array of #InfAclAccount&lt;!-- --&gt;s.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="accounts" transfer-ownership="none">
            <doc xml:space="preserve">An array of #InfAclAccount objects.</doc>
            <array length="1" zero-terminated="0" c:type="InfAclAccount*">
              <type name="AclAccount" c:type="InfAclAccount"/>
            </array>
          </parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <doc xml:space="preserve">The number of elements in the array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_xml"
                c:identifier="inf_acl_account_from_xml"
                throws="1">
        <doc xml:space="preserve">Attempts to deserialize an #InfAclAccount that was written to an XML node
by the function inf_acl_account_to_xml(). If an error occurs, such as
mandatory fields being missing, the function returns %NULL and @error is
set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclAccount on success, or %NULL on
failure. Free with inf_acl_account_free() when no longer needed.</doc>
          <type name="AclAccount" c:type="InfAclAccount*"/>
        </return-value>
        <parameters>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">An XML node.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_from_string"
                c:identifier="inf_acl_account_id_from_string">
        <doc xml:space="preserve">Converts the given string into a unique account identifier which can be
used with the rest of the ACL API.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The account ID which is equivalent to the given
string.</doc>
          <type name="AclAccountId" c:type="InfAclAccountId"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">A string representation of an account ID.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_to_string"
                c:identifier="inf_acl_account_id_to_string">
        <doc xml:space="preserve">Translates the given account ID to a unique string identifier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string representation of the given account ID, or %NULL if
the account does not exist. The return value must not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccountId.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="AclMask"
            c:type="InfAclMask"
            glib:type-name="InfAclMask"
            glib:get-type="inf_acl_mask_get_type"
            c:symbol-prefix="acl_mask">
      <doc xml:space="preserve">This structure represents a mask of #InfAclSetting&lt;!-- --&gt;s, where each
setting can be either turned on or off.</doc>
      <field name="mask" writable="1">
        <doc xml:space="preserve">A 256 bit wide bitfield of #InfAclSetting&lt;!-- --&gt;s.</doc>
        <array zero-terminated="0" c:type="guint64" fixed-size="4">
          <type name="guint64" c:type="guint64"/>
        </array>
      </field>
      <method name="and" c:identifier="inf_acl_mask_and">
        <doc xml:space="preserve">Computes the bitwise AND of @lhs and @rhs and writes the result to @out.
@out is allowed to be equivalent to @lhs and/or @rhs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The output mask.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="lhs" transfer-ownership="none">
            <doc xml:space="preserve">First mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
          <parameter name="rhs" transfer-ownership="none">
            <doc xml:space="preserve">Second mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Output mask.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="and1" c:identifier="inf_acl_mask_and1">
        <doc xml:space="preserve">Disables the bit corresponding to setting in @mask, leaving all other bits
alone.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The mask itself.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclMask.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">The setting to unset.</doc>
            <type name="AclSetting" c:type="InfAclSetting"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="inf_acl_mask_clear">
        <doc xml:space="preserve">Resets a mask so that all fields are zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclMask to reset.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_acl_mask_copy">
        <doc xml:space="preserve">Creates a dynamically allocated copy of @mask. This function should not
usually be used since masks can simply created on the stack and copied
by value. This function is mainly meant for the boxed type definition and
for language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclMask. Free with inf_acl_mask_free()
when no longer needed.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclMask to copy.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="empty" c:identifier="inf_acl_mask_empty">
        <doc xml:space="preserve">Checks whether the given mask is empty, i.e. all fields are set to zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mask has all fields zero, or %FALSE otherwies.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclMask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="inf_acl_mask_equal">
        <doc xml:space="preserve">Checks whether the two masks are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @lhs and @rhs are equal or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="lhs" transfer-ownership="none">
            <doc xml:space="preserve">The first mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
          <parameter name="rhs" transfer-ownership="none">
            <doc xml:space="preserve">The second mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_acl_mask_free">
        <doc xml:space="preserve">Releases a #InfAclMask that was created with inf_acl_mask_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclMask to free.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has" c:identifier="inf_acl_mask_has">
        <doc xml:space="preserve">Returns %TRUE if the given mask has the bit which corresponds to @setting
set, or %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the bit corresponding to @setting is set in @mask.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclMask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">The setting to check.</doc>
            <type name="AclSetting" c:type="InfAclSetting"/>
          </parameter>
        </parameters>
      </method>
      <method name="neg" c:identifier="inf_acl_mask_neg">
        <doc xml:space="preserve">Negates the given mask bitwise and writes the result to @out. The output
mask is allowed to be equivalent to @mask itself.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The output mask.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The mask to negate.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">The output mask.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="or" c:identifier="inf_acl_mask_or">
        <doc xml:space="preserve">Computes the bitwise OR of @lhs and @rhs and writes the result to @out.
@out is allowed to be equivalent to @lhs and/or @rhs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The output mask.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="lhs" transfer-ownership="none">
            <doc xml:space="preserve">First mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </instance-parameter>
          <parameter name="rhs" transfer-ownership="none">
            <doc xml:space="preserve">Second mask.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Output mask.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="or1" c:identifier="inf_acl_mask_or1">
        <doc xml:space="preserve">Enables the bit corresponding to setting in @mask, leaving all other bits
alone.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The mask itself.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclMask.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">The setting to add.</doc>
            <type name="AclSetting" c:type="InfAclSetting"/>
          </parameter>
        </parameters>
      </method>
      <method name="set1" c:identifier="inf_acl_mask_set1">
        <doc xml:space="preserve">Initializes @mask such that all permissions are off except the one
corresponding to @setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The mask itself.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclMask to initialize.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">The permission to set.</doc>
            <type name="AclSetting" c:type="const InfAclSetting"/>
          </parameter>
        </parameters>
      </method>
      <method name="setv" c:identifier="inf_acl_mask_setv">
        <doc xml:space="preserve">Initializes @mask such that all permissions are off except the ones
specified in the @settings array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The mask itself.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclMask to initialize.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </instance-parameter>
          <parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">An array of
#InfAclSetting&lt;!-- --&gt;s to set.</doc>
            <array length="1" zero-terminated="0" c:type="InfAclSetting*">
              <type name="AclSetting" c:type="InfAclSetting"/>
            </array>
          </parameter>
          <parameter name="n_settings" transfer-ownership="none">
            <doc xml:space="preserve">The number of settings.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="AclSetting"
                 glib:type-name="InfAclSetting"
                 glib:get-type="inf_acl_setting_get_type"
                 c:type="InfAclSetting">
      <doc xml:space="preserve">Defines the actual permissions that can be granted or revoked for different
users.</doc>
      <member name="can_add_subdirectory"
              value="0"
              c:identifier="INF_ACL_CAN_ADD_SUBDIRECTORY"
              glib:nick="can-add-subdirectory">
        <doc xml:space="preserve">The user is allowed to create a new
subdirectory node.</doc>
      </member>
      <member name="can_add_document"
              value="1"
              c:identifier="INF_ACL_CAN_ADD_DOCUMENT"
              glib:nick="can-add-document">
        <doc xml:space="preserve">The user is allowed to create a new leaf node.</doc>
      </member>
      <member name="can_sync_in"
              value="2"
              c:identifier="INF_ACL_CAN_SYNC_IN"
              glib:nick="can-sync-in">
        <doc xml:space="preserve">The user is allowed to create documents with
non-empty content.</doc>
      </member>
      <member name="can_remove_node"
              value="3"
              c:identifier="INF_ACL_CAN_REMOVE_NODE"
              glib:nick="can-remove-node">
        <doc xml:space="preserve">The user is allowed to remove a child node.</doc>
      </member>
      <member name="can_explore_node"
              value="4"
              c:identifier="INF_ACL_CAN_EXPLORE_NODE"
              glib:nick="can-explore-node">
        <doc xml:space="preserve">The user is allowed to explore a subdirectory
node in the directory tree.</doc>
      </member>
      <member name="can_subscribe_chat"
              value="5"
              c:identifier="INF_ACL_CAN_SUBSCRIBE_CHAT"
              glib:nick="can-subscribe-chat">
        <doc xml:space="preserve">The user can subscribe to the global
server-wide chat.</doc>
      </member>
      <member name="can_subscribe_session"
              value="6"
              c:identifier="INF_ACL_CAN_SUBSCRIBE_SESSION"
              glib:nick="can-subscribe-session">
        <doc xml:space="preserve">The user is allowed to subscribe to a
session in the directory tree.</doc>
      </member>
      <member name="can_join_user"
              value="7"
              c:identifier="INF_ACL_CAN_JOIN_USER"
              glib:nick="can-join-user">
        <doc xml:space="preserve">The user is allowed to join a user into the
session which corresponds to the node.</doc>
      </member>
      <member name="can_query_account_list"
              value="8"
              c:identifier="INF_ACL_CAN_QUERY_ACCOUNT_LIST"
              glib:nick="can-query-account-list">
        <doc xml:space="preserve">The user is allowed to query the full list
of ACL accounts.</doc>
      </member>
      <member name="can_create_account"
              value="9"
              c:identifier="INF_ACL_CAN_CREATE_ACCOUNT"
              glib:nick="can-create-account">
        <doc xml:space="preserve">The user can create a new account on the
server.</doc>
      </member>
      <member name="can_override_account"
              value="10"
              c:identifier="INF_ACL_CAN_OVERRIDE_ACCOUNT"
              glib:nick="can-override-account">
        <doc xml:space="preserve">The user can create an account under a name
that exists already, overriding the login credentials.</doc>
      </member>
      <member name="can_remove_account"
              value="11"
              c:identifier="INF_ACL_CAN_REMOVE_ACCOUNT"
              glib:nick="can-remove-account">
        <doc xml:space="preserve">The user can remove user accounts.</doc>
      </member>
      <member name="can_query_acl"
              value="12"
              c:identifier="INF_ACL_CAN_QUERY_ACL"
              glib:nick="can-query-acl">
        <doc xml:space="preserve">The user is allowed to query the full ACL for
this node.</doc>
      </member>
      <member name="can_set_acl"
              value="13"
              c:identifier="INF_ACL_CAN_SET_ACL"
              glib:nick="can-set-acl">
        <doc xml:space="preserve">The user is allowed to change the ACL of this node,
or create new nodes with a non-default ACL.</doc>
      </member>
    </enumeration>
    <record name="AclSheet"
            c:type="InfAclSheet"
            glib:type-name="InfAclSheet"
            glib:get-type="inf_acl_sheet_get_type"
            c:symbol-prefix="acl_sheet">
      <doc xml:space="preserve">A set of permissions to be applied for a particular account and a
particular node in the infinote directory.</doc>
      <field name="account" writable="1">
        <doc xml:space="preserve">The account for which to apply the permissions in this sheet.</doc>
        <type name="AclAccountId" c:type="InfAclAccountId"/>
      </field>
      <field name="mask" writable="1">
        <doc xml:space="preserve">Mask which specifies which of the permissions in the @perms
field take effect. Fields which are masked-out are left at their default
value and inherited from the parent node.</doc>
        <type name="AclMask" c:type="InfAclMask"/>
      </field>
      <field name="perms" writable="1">
        <doc xml:space="preserve">Mask which specifies whether or not the user is allowed to
perform the various operations defined by #InfAclSetting.</doc>
        <type name="AclMask" c:type="InfAclMask"/>
      </field>
      <constructor name="new" c:identifier="inf_acl_sheet_new">
        <doc xml:space="preserve">Creates a dynamically allocated #InfAclSheet. This is usually not
needed because you can copy the structs by value, but it is useful
for properties and bindings. The new sheet will hold permissions for the
given account. The permissions will initially be all masked out.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclSheet. Free with
inf_acl_sheet_free() when no longer in use.</doc>
          <type name="AclSheet" c:type="InfAclSheet*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccountId representing a unique account id.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="inf_acl_sheet_copy">
        <doc xml:space="preserve">Makes a dynamically allocated copy of @sheet. This should not be used by
applications because you can copy the structs by value, but it is useful
for properties and bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-allocated copy of @sheet. Free with
inf_acl_sheet_free() when no longer in use.</doc>
          <type name="AclSheet" c:type="InfAclSheet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheet.</doc>
            <type name="AclSheet" c:type="const InfAclSheet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_acl_sheet_free">
        <doc xml:space="preserve">Frees a #InfAclSheet allocated by inf_acl_sheet_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheet.</doc>
            <type name="AclSheet" c:type="InfAclSheet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="perms_from_xml"
                c:identifier="inf_acl_sheet_perms_from_xml"
                throws="1">
        <doc xml:space="preserve">This function extracts the permission mask and the permission flags from
the XML node @xml. The counterpart to this function is
inf_acl_sheet_perms_to_xml(). If an error occurs the function returns
%FALSE and @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation was successful, or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML node to read from.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="mask"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Output parameter to write the permission mask to.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
          <parameter name="perms"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Output parameter to write the permissions to.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </function>
      <function name="perms_to_xml" c:identifier="inf_acl_sheet_perms_to_xml">
        <doc xml:space="preserve">This function writes the given permission mask and permission flags to the
XML node @xml. They can be converted back using the
inf_acl_sheet_perms_from_xml() function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">Permission mask to write.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
          <parameter name="perms" transfer-ownership="none">
            <doc xml:space="preserve">Individiual permissions to write.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">error: Location to store error information, if any.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="AclSheetSet"
            c:type="InfAclSheetSet"
            glib:type-name="InfAclSheetSet"
            glib:get-type="inf_acl_sheet_set_get_type"
            c:symbol-prefix="acl_sheet_set">
      <doc xml:space="preserve">A set of #InfAclSheet&lt;!-- --&gt;s, one for each user.</doc>
      <field name="own_sheets" readable="0" private="1">
        <type name="AclSheet" c:type="InfAclSheet*"/>
      </field>
      <field name="sheets" writable="1">
        <doc xml:space="preserve">An array of #InfAclSheet objects.</doc>
        <type name="AclSheet" c:type="const InfAclSheet*"/>
      </field>
      <field name="n_sheets" writable="1">
        <doc xml:space="preserve">The number of elements in the @sheets array.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="inf_acl_sheet_set_new">
        <doc xml:space="preserve">Creates a new #InfAclSheetSet. Add sheets with
inf_acl_sheet_set_add_sheet().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclSheetSet. Free with
inf_acl_sheet_set_free().</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
      </constructor>
      <constructor name="new_external"
                   c:identifier="inf_acl_sheet_set_new_external">
        <doc xml:space="preserve">Creates a new #InfAclSheetSet refererencing the given ACL sheets. The
created sheet set is only holding a reference to the given array, so it
must stay alive as long as the sheet set is alive.

No new sheets can be added to the returned sheet set with
inf_acl_sheet_set_add_sheet(), or removed with
inf_acl_sheet_set_remove_sheet().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclSheetSet. Free with
inf_acl_sheet_set_free() when no longer needed.</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <parameter name="sheets" transfer-ownership="none">
            <doc xml:space="preserve">An array of #InfAclSheet&lt;!-- --&gt;s</doc>
            <array length="1" zero-terminated="0" c:type="InfAclSheet*">
              <type name="AclSheet" c:type="InfAclSheet"/>
            </array>
          </parameter>
          <parameter name="n_sheets" transfer-ownership="none">
            <doc xml:space="preserve">Number of elements in @sheets.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_sheet" c:identifier="inf_acl_sheet_set_add_sheet">
        <doc xml:space="preserve">Adds a new default sheet for @account to @sheet_set. The function returns
a pointer to the new sheet. The pointer stays valid as long as no other
sheet is added to the set. If there is already a sheet for @account in the
set, then the existing sheet is returned instead.

This function can only be used if the sheet set has not been created with
the inf_acl_sheet_set_new_external() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclSheet for the new account.</doc>
          <type name="AclSheet" c:type="InfAclSheet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccountId representing a unique account ID.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_acl_sheet_set_copy">
        <doc xml:space="preserve">Creates a copy of @sheet_set. If @sheet_set was created with
inf_acl_sheet_set_new_external(), the copied sheet set will also only hold
a reference to the external sheets, and the same restrictions apply.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclSheetSet. Free with
inf_acl_sheet_set_free() when no longer needed.</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find_const_sheet"
              c:identifier="inf_acl_sheet_set_find_const_sheet">
        <doc xml:space="preserve">Returns the #InfAclSheet for @account. If there is no such sheet in
@sheet_set, the function returns %NULL.

The difference between this function and
inf_acl_sheet_set_find_sheet() is that this function returns a sheet
that cannot be modified, but it can also be used on a sheet set created
with the inf_acl_sheet_set_new_external() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclSheet for @account, or %NULL.</doc>
          <type name="AclSheet" c:type="const InfAclSheet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccountId representing the unique account ID of the
account whose ACL sheet is to be found.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_sheet" c:identifier="inf_acl_sheet_set_find_sheet">
        <doc xml:space="preserve">Returns the #InfAclSheet for @account. If there is no such sheet in
@sheet_set, the function returns %NULL.

This function can only be used if the sheet set has not been created with
the inf_acl_sheet_set_new_external() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclSheet for @account, or %NULL.</doc>
          <type name="AclSheet" c:type="InfAclSheet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclAccountId representing the unique account ID of the
account whose ACL sheet is to be found.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_acl_sheet_set_free">
        <doc xml:space="preserve">Releases all resources allocated for @sheet_set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_clear_sheets"
              c:identifier="inf_acl_sheet_set_get_clear_sheets">
        <doc xml:space="preserve">Returns a new sheet set with all sheets that are present in @sheet_set,
but with all permissions masked. When this set is merged with the original
set, all permissions will be reset to default for all accounts. Before
the merge, the returned sheet set can be modified. This allows to replace
the current permissions with new ones atomically.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAclSheetSet. Free with
inf_acl_sheet_set_free() when no longer needed.</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge_sheets"
              c:identifier="inf_acl_sheet_set_merge_sheets">
        <doc xml:space="preserve">Replaces all sheets that are present in @other in @sheet_set with the ones
from @other. Note that an empty sheet in @other (with all permissions
masked out) causes the corresponding sheet in @sheet_set to be removed.

If @sheet_set is %NULL it is treated like an empty sheet set, i.e. the
merged sheet set is a copy of @other. In that case a new sheet set is
created and returned, unless @other is empty. If the merged sheet set
ends up empty, it is freed and the function returns %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The merged sheet set, or %NULL
when the merged sheet set would be empty.</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set"
                              transfer-ownership="full"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #InfAclSheetSet, or %NULL.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">The sheet set to merge.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_sheet"
              c:identifier="inf_acl_sheet_set_remove_sheet">
        <doc xml:space="preserve">Removes a sheet from @sheet_set. @sheet must be one of the sheets inside
@sheet_set. The sheet is removed by replacing it with the last sheet in
the set, so the order of sheets is not preserved.

This function can only be used if the sheet set has not been created with
the inf_acl_sheet_set_new_external() function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="sheet" transfer-ownership="none">
            <doc xml:space="preserve">The sheet to remove.</doc>
            <type name="AclSheet" c:type="InfAclSheet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="inf_acl_sheet_set_sink">
        <doc xml:space="preserve">If a sheet set was created with inf_acl_sheet_set_new_external(), this
function lifts the restrictions that come with it by making an internal
copy of the ACL sheets.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet.</doc>
            <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_xml" c:identifier="inf_acl_sheet_set_to_xml">
        <doc xml:space="preserve">Serializes the sheet set given by @sheet_set into an XML node. The sheet
set can be deserialized again with inf_acl_sheet_set_from_xml().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAclSheetSet to serialize.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML node to serialize @sheet_set into.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <function name="from_xml"
                c:identifier="inf_acl_sheet_set_from_xml"
                throws="1">
        <doc xml:space="preserve">Reads a sheet set from @xml that has been written with
inf_acl_sheet_set_to_xml(). If an error occurs the function returns
%NULL and @error is set. If there is no ACL stored in @xml, the function
returns %NULL without setting @error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfAclSheetSet, or %NULL. Free with
inf_acl_sheet_set_free() when no longer needed.</doc>
          <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML node from which to read the sheet set.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="AdoptedAlgorithm"
           c:symbol-prefix="adopted_algorithm"
           c:type="InfAdoptedAlgorithm"
           parent="GObject.Object"
           glib:type-name="InfAdoptedAlgorithm"
           glib:get-type="inf_adopted_algorithm_get_type"
           glib:type-struct="AdoptedAlgorithmClass">
      <doc xml:space="preserve">#InfAdoptedAlgorithm is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_algorithm_new">
        <doc xml:space="preserve">Creates a #InfAdoptedAlgorithm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedAlgorithm.</doc>
          <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
        </return-value>
        <parameters>
          <parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">The table of participating users.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer to apply operations to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="inf_adopted_algorithm_new_full">
        <doc xml:space="preserve">Note that it is possible that request logs need to grow a bit larger than
@max_total_log_size in high-latency situations or when a user does not send
status updates frequently. However, when all requests have been
processed by all users, the sum of all requests in the logs is guaranteed
to be lower or equal to this value.

Set to %G_MAXUINT to disable limitation. In theory, this would allow
everyone to undo every operation up to the first one ever made. In practise,
this issues a huge amount of data that needs to be synchronized on user
join and is too expensive to compute anyway.

The default value is 2048.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedAlgorithm.</doc>
          <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
        </return-value>
        <parameters>
          <parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">The table of participating users.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer to apply operations to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
          <parameter name="max_total_log_size" transfer-ownership="none">
            <doc xml:space="preserve">The maxmimum number of operations to keep in all
user's request logs.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="begin_execute_request">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_redo_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="can_redo" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_undo_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="can_undo" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="end_execute_request">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="translated_request" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_redo" c:identifier="inf_adopted_algorithm_can_redo">
        <doc xml:space="preserve">Returns whether @user can issue a redo request in the current state. Note
that if @user is non-local, then the result of this function does not
depend on the current state but on the state that we know @user is
guaranteed to have reached. This is because @user might still issue a
Redo request even if the max-total-log-size is already exceeded if @user
does not know yet that it is exceeded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if Redo is possible, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_undo" c:identifier="inf_adopted_algorithm_can_undo">
        <doc xml:space="preserve">Returns whether @user can issue an undo request in the current state. Note
that if @user is non-local, then the result of this function does not
depend on the current state but on the state that we know @user is
guaranteed to have reached. This is because @user might still issue an
Undo request even if the max-total-log-size is already exceeded if @user
does not know yet that it is exceeded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if Undo is possible, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cleanup" c:identifier="inf_adopted_algorithm_cleanup">
        <doc xml:space="preserve">Removes requests in all users request logs which are no longer needed. This
includes requests which cannot be undone or redone anymore due to the
constraints of the #InfAdoptedAlgorithm:max-total-log-size property, and
requests that every participant is guaranteed to have processed already.

This function can be called after every executed request to keep memory use
to a minimum, or it can be called in regular intervals, or it can also be
omitted if the request history should be preserved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="execute_request"
              c:identifier="inf_adopted_algorithm_execute_request"
              throws="1">
        <doc xml:space="preserve">This function transforms the given request such that it can be applied to
the current document state and then applies it the buffer and adds it to
the request log of the algorithm, so that it is used for future
transformations of other requests.

If @apply is %FALSE then the request is not applied to the buffer. In this
case, it is assumed that the buffer is already modified, and that the
request is made as a result from the buffer modification. This also means
that the request must be applicable to the current document state, without
requiring transformation.

In addition, the function emits the
#InfAdoptedAlgorithm::begin-execute-request and
#InfAdoptedAlgorithm::end-execute-request signals, and makes
inf_adopted_algorithm_get_execute_request() return @request during that
period.

This allows other code to hook in before and after request processing. This
does not cause any loss of generality because this function is not
re-entrant anyway: it cannot work when used concurrently by multiple
threads nor in a recursive manner, because only when one request has been
added to the log the next request can be translated, since it might need
the previous request for the translation path and it needs to be translated
to a state where the effect of the previous request is included so that it
can consistently applied to the buffer.

There are also runtime errors that can occur if @request execution fails.
In this case the function returns %FALSE and @error is set. Possible
reasons for this include @request being an %INF_ADOPTED_REQUEST_UNDO or
%INF_ADOPTED_REQUEST_REDO request without there being an operation to
undo or redo, or if the translated operation cannot be applied to the
buffer. This usually means that the input @request was invalid. However,
this is not considered a programmer error because typically requests are
received from untrusted input sources such as network connections.
Note that there cannot be any runtime errors if @apply is set to %FALSE.
In that case it is safe to call the function with %NULL error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request to execute.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="apply" transfer-ownership="none">
            <doc xml:space="preserve">Whether to apply the request to the buffer.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_request"
              c:identifier="inf_adopted_algorithm_generate_request">
        <doc xml:space="preserve">Creates a new request that can be applied to the current document state.
The request is made by the given user. If operation is of type
%INF_ADOPTED_REQUEST_DO, then @operation specifies the operation to be
performed. Otherwise, @operation must be %NULL.

To apply the effect of the request to the document, run
inf_adopted_algorithm_execute_request(). Note that even if the effect
is already applied to the document, the function must still be called
with the @apply parameter set to %FALSE, so that the algorithm knows that
the request has been applied.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedRequest. Free with
g_object_unref() when no longer needed.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of request to create.</doc>
            <type name="AdoptedRequestType" c:type="InfAdoptedRequestType"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The user for which to create the request.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The operation to perform, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current"
              c:identifier="inf_adopted_algorithm_get_current">
        <doc xml:space="preserve">Returns the current vector time of @algorithm.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAdoptedStateVector owned by @algorithm.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_execute_request"
              c:identifier="inf_adopted_algorithm_get_execute_request">
        <doc xml:space="preserve">Returns whether the algorithm is currently transforming a request to the
current state and appling its state to the buffer. If it is the function
is returning the request that was received and is currently being
executed, other wise the function returns %NULL. Note that the request
execution is not re-entrant, i.e. two requests cannot be executed
concurrently at the same time, or recursively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The request that @algorithm is
currently processing, or %NULL. The return value must not be freed by
the caller.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="translate_request"
              c:identifier="inf_adopted_algorithm_translate_request">
        <doc xml:space="preserve">Translates @request so that it can be applied to the document at state @to.
@request will not be modified but a new, translated request is returned
instead.

There are several preconditions for this function to be called. @to must
be a reachable point in the state space. Also, requests can only be
translated in forward direction, so @request's vector time must be
causally before (see inf_adopted_state_vector_causally_before()) @to.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new or cached #InfAdoptedRequest. Free with
g_object_unref() when no longer needed.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedAlgorithm.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">The state vector to translate @request to.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <property name="buffer"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Buffer"/>
      </property>
      <property name="buffer-modified-state" transfer-ownership="none">
        <type name="AdoptedStateVector"/>
      </property>
      <property name="current-state" transfer-ownership="none">
        <type name="AdoptedStateVector"/>
      </property>
      <property name="max-total-log-size"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="user-table"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="UserTable"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="begin-execute-request" when="last">
        <doc xml:space="preserve">This signal is emitted every time the algorithm executes a request, i.e.
transforms it such that it can be applied to the current state, resolves
undo/redo operations and applies the resulting operation to the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser executing the request.</doc>
            <type name="AdoptedUser"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedRequest being executed.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="can-redo-changed" when="last">
        <doc xml:space="preserve">This signal is emitted every time the can-redo state of a local user
in @algorithm's user table changed. The can-redo state defines whether
@user can generate a redo request
(via inf_adopted_algorithm_generate_request()) in the current situation, see
also inf_adopted_algorithm_can_redo().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser whose can-redo state has changed.</doc>
            <type name="AdoptedUser"/>
          </parameter>
          <parameter name="can_undo" transfer-ownership="none">
            <doc xml:space="preserve">Whether @user can issue a redo request in the current
state or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="can-undo-changed" when="last">
        <doc xml:space="preserve">This signal is emitted every time the can-undo state of a local user
in @algorithm's user table changed. The can-undo state defines whether
@user can generate an undo request
(via inf_adopted_algorithm_generate_request()) in the current situation, see
also inf_adopted_algorithm_can_undo().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser whose can-undo state has changed.</doc>
            <type name="AdoptedUser"/>
          </parameter>
          <parameter name="can_undo" transfer-ownership="none">
            <doc xml:space="preserve">Whether @user can issue an undo request in the current
state or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="end-execute-request" when="last">
        <doc xml:space="preserve">This signal is emitted after a request has been executed. The @request
parameter is not necessarily the same as the one in the corresponding
emission of #InfAdoptedAlgorithm::begin-execute-request, however its
effect on the buffer is the same. The difference is that the request in
this signal might be reversible while the request in the
#InfAdoptedAlgorithm::begin-execute-request emission might not be
reversible. The algorithm can make some requests reversible during
their execution.

The @translated request is the result of the transformation, i.e. it is
always a %INF_ADOPTED_REQUEST_DO type request and its state vector
corresponds to the current state. It has already been applied on the
buffer by the algorithm. If @request is of type %INF_ADOPTED_REQUEST_UNDO
or %INF_ADOPTED_REQUEST_REDO then @translated represents the operation
that actually was performed on the buffer to undo or redo the effect of
a previous request.

It can happen that an error occurs during execution. Usually this is due
to invalid input, such as a request that cannot be transformed to the
current state, a %INF_ADOPTED_REQUEST_UNDO request which has no
corresponding %INF_ADOPTED_REQUEST_DO or %INF_ADOPTED_REQUEST_REDO
request, or a request that ends up in an invalid operation (e.g.
inserting text behind the end of the document). If such an error occurs
then @request is the same as the one in the
%InfAdoptedAlgorithm::begin-execute-request emission, @translated may or
may not be %NULL and @error contains information on the error occured.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser executing the request.</doc>
            <type name="AdoptedUser"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedRequest that was executed.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
          <parameter name="translated" transfer-ownership="none">
            <doc xml:space="preserve">The result of the request transformation, or %NULL.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">The error that occurred during execution, or %NULL.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AdoptedAlgorithmClass"
            c:type="InfAdoptedAlgorithmClass"
            glib:is-gtype-struct-for="AdoptedAlgorithm">
      <doc xml:space="preserve">Signals for the #InfAdoptedAlgorithm class.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="can_undo_changed">
        <callback name="can_undo_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="algorithm" transfer-ownership="none">
              <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="can_undo" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_redo_changed">
        <callback name="can_redo_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="algorithm" transfer-ownership="none">
              <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="can_redo" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="begin_execute_request">
        <callback name="begin_execute_request">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="algorithm" transfer-ownership="none">
              <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_execute_request">
        <callback name="end_execute_request">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="algorithm" transfer-ownership="none">
              <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
            <parameter name="translated_request" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="AdoptedAlgorithmError"
                 c:type="InfAdoptedAlgorithmError">
      <doc xml:space="preserve">Error codes for #InfAdoptedAlgorithm. These can occur when invalid requests
are passed to inf_adopted_algorithm_execute_request().</doc>
      <member name="no_undo"
              value="0"
              c:identifier="INF_ADOPTED_ALGORITHM_ERROR_NO_UNDO">
        <doc xml:space="preserve">An undo request was about to be
executed but there is no operation to undo.</doc>
      </member>
      <member name="no_redo"
              value="1"
              c:identifier="INF_ADOPTED_ALGORITHM_ERROR_NO_REDO">
        <doc xml:space="preserve">A redo request was about to be
executed but there is no operation to redo.</doc>
      </member>
      <member name="failed"
              value="2"
              c:identifier="INF_ADOPTED_ALGORITHM_ERROR_FAILED">
        <doc xml:space="preserve">No further specified error code.</doc>
      </member>
    </enumeration>
    <enumeration name="AdoptedConcurrencyId"
                 glib:type-name="InfAdoptedConcurrencyId"
                 glib:get-type="inf_adopted_concurrency_id_get_type"
                 c:type="InfAdoptedConcurrencyId">
      <doc xml:space="preserve">A concurrency ID is used to determine which operation to transform in case
two similar operations are transformed against each other.</doc>
      <member name="self"
              value="1"
              c:identifier="INF_ADOPTED_CONCURRENCY_SELF"
              glib:nick="self">
        <doc xml:space="preserve">Transform the operation itself.</doc>
      </member>
      <member name="none"
              value="0"
              c:identifier="INF_ADOPTED_CONCURRENCY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">Unspecified which operation to transform.</doc>
      </member>
      <member name="other"
              value="-1"
              c:identifier="INF_ADOPTED_CONCURRENCY_OTHER"
              glib:nick="other">
        <doc xml:space="preserve">Transform the other operation.</doc>
      </member>
    </enumeration>
    <class name="AdoptedNoOperation"
           c:symbol-prefix="adopted_no_operation"
           c:type="InfAdoptedNoOperation"
           parent="GObject.Object"
           glib:type-name="InfAdoptedNoOperation"
           glib:get-type="inf_adopted_no_operation_get_type"
           glib:type-struct="AdoptedNoOperationClass">
      <doc xml:space="preserve">#InfAdoptedNoOperation is an opaque data type. You should only access it
via the public API functions.</doc>
      <implements name="AdoptedOperation"/>
      <constructor name="new" c:identifier="inf_adopted_no_operation_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedNoOperation. A no operation is an operation
that does nothing, but might be the result of a transformation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedNoOperation.</doc>
          <type name="AdoptedNoOperation" c:type="InfAdoptedNoOperation*"/>
        </return-value>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AdoptedNoOperationClass"
            c:type="InfAdoptedNoOperationClass"
            glib:is-gtype-struct-for="AdoptedNoOperation">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="AdoptedOperation"
               c:symbol-prefix="adopted_operation"
               c:type="InfAdoptedOperation"
               glib:type-name="InfAdoptedOperation"
               glib:get-type="inf_adopted_operation_get_type"
               glib:type-struct="AdoptedOperationInterface">
      <doc xml:space="preserve">#InfAdoptedOperation is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="apply" invoker="apply" throws="1">
        <doc xml:space="preserve">Applies @operation to @buffer. The operation is considered to be applied by
user @by. If the operation cannot be applied then @error is set and the
function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="apply_transformed"
                      invoker="apply_transformed"
                      throws="1">
        <doc xml:space="preserve">Applies @transformed to @buffer. The operation is considered to be applied
by user @by. The operation @transformed must have originated from
@operation by transformation with inf_adopted_operation_transform().

If @operation is reversible or does not affect the buffer (see
#InfAdoptedOperationFlags), this function is equivalent to
&lt;code&gt;inf_adopted_operation_apply(transformed, by, buffer)&lt;/code&gt;, with
the exception of the return value. In that case the return value will be
@operation itself, with a reference added.

However, if @operation is not reversible and affects the buffer, the
function attempts to construct an operation which is identical to
@operation, but reversible, and returns it. The function can use
information from the transformed operation and the buffer to construct
the reversible operation. If a reversible operation cannot be constructed,
the function returns an additional reference on @operation, and still
applies the transformed operation
to the buffer.

For example, an operation that deletes text in a text editor would be
transmitting only the position and the length of the text to delete over
the network. From that information alone, the operation cannot be made
reversible. However, when the operation is applied to the buffer, the
actual text that is being removed can be restored by looking it up in
the buffer, making the operation reversible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfAdoptedOperation, or %NULL on error.
Free with g_object_unref() when no longer needed.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="transformed" transfer-ownership="none">
            <doc xml:space="preserve">A transformed version of @operation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser applying the operation.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy" invoker="copy">
        <doc xml:space="preserve">Returns a copy of @operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to copy.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_flags" invoker="get_flags">
        <doc xml:space="preserve">Returns the flags for @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#InfAdoptedOperationFlags for @operation.</doc>
          <type name="AdoptedOperationFlags"
                c:type="InfAdoptedOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="need_concurrency_id" invoker="need_concurrency_id">
        <doc xml:space="preserve">This function returns whether transforming @operation against @against
is not defined unambiguously. In that case, transformation requires a
so-called concurrency ID which determines which of the two operations
is transformed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether transformation of @operation against @against requires a
concurrency ID to be defined.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The operation to transform against.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="revert" invoker="revert">
        <doc xml:space="preserve">Returns a new #InfAdoptedOperation that undoes the effect of @operation. If
@operation and then its reverse operation are applied to a buffer (in that
order), the buffer remains unchanged.

@operation must be reversible for this function to be called (i.e.
inf_adopted_operation_is_reversible() must return TRUE).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The reverse operation of @operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform" invoker="transform">
        <doc xml:space="preserve">Performs an inclusion transformation of @operation against @against,
meaning that the effect of @against is included in @operation.

If inf_adopted_operation_need_concurrency_id() returns %TRUE for @operation
and @against, then @operation_lcs and @against_lcs must not be %NULL. In
this case they must be the same operations as @operation and @against at
the earlierst state to which both of them can be transformed. This
information can then be used to resolve any conflicts in the transformation
of @operation against @against.

The @concurrency_id parameter is used if
inf_adopted_operation_need_concurrency_id() returns %TRUE and no conflict
resolution can be deduced from @operation_lcs and @against_lcs. In this
case @concurrency_id defines a unique way to transform the two operations.
Usually, this is derived from the user IDs of the users who issued the two
conflicting operations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The transformed
#InfAdoptedOperation, or %NULL if the transformation failed.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The operation to transform against.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="operation_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The operation at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="against_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The @against operation at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="concurrency_id" transfer-ownership="none">
            <doc xml:space="preserve">The concurrency ID for the transformation.</doc>
            <type name="AdoptedConcurrencyId"
                  c:type="InfAdoptedConcurrencyId"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="apply"
              c:identifier="inf_adopted_operation_apply"
              throws="1">
        <doc xml:space="preserve">Applies @operation to @buffer. The operation is considered to be applied by
user @by. If the operation cannot be applied then @error is set and the
function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="apply_transformed"
              c:identifier="inf_adopted_operation_apply_transformed"
              throws="1">
        <doc xml:space="preserve">Applies @transformed to @buffer. The operation is considered to be applied
by user @by. The operation @transformed must have originated from
@operation by transformation with inf_adopted_operation_transform().

If @operation is reversible or does not affect the buffer (see
#InfAdoptedOperationFlags), this function is equivalent to
&lt;code&gt;inf_adopted_operation_apply(transformed, by, buffer)&lt;/code&gt;, with
the exception of the return value. In that case the return value will be
@operation itself, with a reference added.

However, if @operation is not reversible and affects the buffer, the
function attempts to construct an operation which is identical to
@operation, but reversible, and returns it. The function can use
information from the transformed operation and the buffer to construct
the reversible operation. If a reversible operation cannot be constructed,
the function returns an additional reference on @operation, and still
applies the transformed operation
to the buffer.

For example, an operation that deletes text in a text editor would be
transmitting only the position and the length of the text to delete over
the network. From that information alone, the operation cannot be made
reversible. However, when the operation is applied to the buffer, the
actual text that is being removed can be restored by looking it up in
the buffer, making the operation reversible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfAdoptedOperation, or %NULL on error.
Free with g_object_unref() when no longer needed.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="transformed" transfer-ownership="none">
            <doc xml:space="preserve">A transformed version of @operation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedUser applying the operation.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_adopted_operation_copy">
        <doc xml:space="preserve">Returns a copy of @operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to copy.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="inf_adopted_operation_get_flags">
        <doc xml:space="preserve">Returns the flags for @operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#InfAdoptedOperationFlags for @operation.</doc>
          <type name="AdoptedOperationFlags"
                c:type="InfAdoptedOperationFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_reversible"
              c:identifier="inf_adopted_operation_is_reversible">
        <doc xml:space="preserve">Returns whether @operation is reversible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @operation is reversible.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="need_concurrency_id"
              c:identifier="inf_adopted_operation_need_concurrency_id">
        <doc xml:space="preserve">This function returns whether transforming @operation against @against
is not defined unambiguously. In that case, transformation requires a
so-called concurrency ID which determines which of the two operations
is transformed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether transformation of @operation against @against requires a
concurrency ID to be defined.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The operation to transform against.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="revert" c:identifier="inf_adopted_operation_revert">
        <doc xml:space="preserve">Returns a new #InfAdoptedOperation that undoes the effect of @operation. If
@operation and then its reverse operation are applied to a buffer (in that
order), the buffer remains unchanged.

@operation must be reversible for this function to be called (i.e.
inf_adopted_operation_is_reversible() must return TRUE).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The reverse operation of @operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="inf_adopted_operation_transform">
        <doc xml:space="preserve">Performs an inclusion transformation of @operation against @against,
meaning that the effect of @against is included in @operation.

If inf_adopted_operation_need_concurrency_id() returns %TRUE for @operation
and @against, then @operation_lcs and @against_lcs must not be %NULL. In
this case they must be the same operations as @operation and @against at
the earlierst state to which both of them can be transformed. This
information can then be used to resolve any conflicts in the transformation
of @operation against @against.

The @concurrency_id parameter is used if
inf_adopted_operation_need_concurrency_id() returns %TRUE and no conflict
resolution can be deduced from @operation_lcs and @against_lcs. In this
case @concurrency_id defines a unique way to transform the two operations.
Usually, this is derived from the user IDs of the users who issued the two
conflicting operations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The transformed
#InfAdoptedOperation, or %NULL if the transformation failed.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The operation to transform against.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="operation_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The operation at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="against_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The @against operation at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="concurrency_id" transfer-ownership="none">
            <doc xml:space="preserve">The concurrency ID for the transformation.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <bitfield name="AdoptedOperationFlags"
              glib:type-name="InfAdoptedOperationFlags"
              glib:get-type="inf_adopted_operation_flags_get_type"
              c:type="InfAdoptedOperationFlags">
      <doc xml:space="preserve">Various flags for #InfAdoptedOperation.</doc>
      <member name="affects_buffer"
              value="1"
              c:identifier="INF_ADOPTED_OPERATION_AFFECTS_BUFFER"
              glib:nick="affects_buffer">
        <doc xml:space="preserve">The operation changes the content of
the buffer.</doc>
      </member>
      <member name="reversible"
              value="2"
              c:identifier="INF_ADOPTED_OPERATION_REVERSIBLE"
              glib:nick="reversible">
        <doc xml:space="preserve">The operation is reversible, which means
that inf_adopted_operation_revert() can be called to generate an operation
that undoes the effect of the operation.</doc>
      </member>
    </bitfield>
    <record name="AdoptedOperationInterface"
            c:type="InfAdoptedOperationInterface"
            glib:is-gtype-struct-for="AdoptedOperation">
      <doc xml:space="preserve">The virtual methods that need to be implemented by an operation to be used
with #InfAdoptedAlgorithm.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="need_concurrency_id">
        <callback name="need_concurrency_id">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether transformation of @operation against @against requires a
concurrency ID to be defined.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="against" transfer-ownership="none">
              <doc xml:space="preserve">The operation to transform against.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform">
        <callback name="transform">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The transformed
#InfAdoptedOperation, or %NULL if the transformation failed.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAdoptedOperation to transform.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="against" transfer-ownership="none">
              <doc xml:space="preserve">The operation to transform against.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="operation_lcs" transfer-ownership="none">
              <doc xml:space="preserve">The operation at a previous state, or %NULL.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="against_lcs" transfer-ownership="none">
              <doc xml:space="preserve">The @against operation at a previous state, or %NULL.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="concurrency_id" transfer-ownership="none">
              <doc xml:space="preserve">The concurrency ID for the transformation.</doc>
              <type name="AdoptedConcurrencyId"
                    c:type="InfAdoptedConcurrencyId"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy">
        <callback name="copy">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A copy of @operation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAdoptedOperation to copy.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">#InfAdoptedOperationFlags for @operation.</doc>
            <type name="AdoptedOperationFlags"
                  c:type="InfAdoptedOperationFlags"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="apply">
        <callback name="apply" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="by" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedUser.</doc>
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
              <type name="Buffer" c:type="InfBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="apply_transformed">
        <callback name="apply_transformed" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A #InfAdoptedOperation, or %NULL on error.
Free with g_object_unref() when no longer needed.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="transformed" transfer-ownership="none">
              <doc xml:space="preserve">A transformed version of @operation.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
            <parameter name="by" transfer-ownership="none">
              <doc xml:space="preserve">The #InfAdoptedUser applying the operation.</doc>
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">The #InfBuffer to apply the operation to.</doc>
              <type name="Buffer" c:type="InfBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="revert">
        <callback name="revert">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The reverse operation of @operation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedOperation.</doc>
              <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="AdoptedRequest"
           c:symbol-prefix="adopted_request"
           c:type="InfAdoptedRequest"
           parent="GObject.Object"
           glib:type-name="InfAdoptedRequest"
           glib:get-type="inf_adopted_request_get_type"
           glib:type-struct="AdoptedRequestClass">
      <doc xml:space="preserve">#InfAdoptedRequest is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new_do" c:identifier="inf_adopted_request_new_do">
        <doc xml:space="preserve">Creates a new #InfAdoptedRequest with type %INF_ADOPTED_REQUEST_DO.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new DO request.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <parameter name="vector" transfer-ownership="none">
            <doc xml:space="preserve">The vector time at which the request was made.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="user_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the user that made the request.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">The operation the user performed.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="received" transfer-ownership="none">
            <doc xml:space="preserve">Time the request was received, in microseconds since the epoch.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_redo" c:identifier="inf_adopted_request_new_redo">
        <doc xml:space="preserve">Creates a new #InfAdoptedRequest with type %INF_ADOPTED_REQUEST_REDO. The
operation performed is implicitely defined by reverting the operation of
the associated UNDO request, but must still be computed by
#InfAdoptedAlgorithm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new REDO request.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <parameter name="vector" transfer-ownership="none">
            <doc xml:space="preserve">The vector time at which the request was made.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="user_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the user that made the request.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="received" transfer-ownership="none">
            <doc xml:space="preserve">Time the request was received, in microseconds since the epoch.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_undo" c:identifier="inf_adopted_request_new_undo">
        <doc xml:space="preserve">Creates a new #InfAdoptedRequest with type %INF_ADOPTED_REQUEST_UNDO.
The operation performed is implicitely defined by reverting the operation
of the associated DO or REDO request, but must still be computed by
#InfAdoptedAlgorithm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new UNDO request.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <parameter name="vector" transfer-ownership="none">
            <doc xml:space="preserve">The vector time at which the request was made.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="user_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the user that made the request.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="received" transfer-ownership="none">
            <doc xml:space="preserve">Time the request was received, in microseconds since the epoch.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="affects_buffer"
              c:identifier="inf_adopted_request_affects_buffer">
        <doc xml:space="preserve">Returns whether this request, when applied, changes the content of the
buffer. If this is a %INF_ADOPTED_REQUEST_UNDO or %INF_ADOPTED_REQUEST_REDO
request, than it always affects the buffer, because only requests that
affect the buffer can be undone or redone. If it is a
%INF_ADOPTED_REQUEST_DO request, than it returns whether its operation
has the %INF_ADOPTED_OPERATION_AFFECTS_BUFFER flag set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @request affects the session's buffer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_adopted_request_copy">
        <doc xml:space="preserve">Creates a copy of @request with an initial reference count of 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedRequest.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedRequest to copy.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fold" c:identifier="inf_adopted_request_fold">
        <doc xml:space="preserve">Folds @request as described in "Reducing the Problems of Group Undo" by
Matthias Ressel and Rul Gunzenh&amp;auml;user
(http://portal.acm.org/citation.cfm?doid=320297.320312).

Note that @by is the total amount of requests between the original and
the fold request, and thus equivalent to 2j in the paper's definition.

@into must not be the same user as the one that issued @request.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The folded request as a new #InfAdoptedRequest.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
          <parameter name="into" transfer-ownership="none">
            <doc xml:space="preserve">The direction into which to fold.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">The number of operations between the original and the fold request.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_execute_time"
              c:identifier="inf_adopted_request_get_execute_time">
        <doc xml:space="preserve">Returns the time when the request was executed by an #InfAdoptedAlgorithm,
see inf_adopted_algorithm_execute_request(). The time is
given in microseconds since January 1, 1970. If the request was not yet
executed, the function returns 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The time when the function was executed, or 0.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_index" c:identifier="inf_adopted_request_get_index">
        <doc xml:space="preserve">Returns the vector time component of the request's own users. This
corresponds to the request index by that user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The vector time component of the request's own user.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_operation"
              c:identifier="inf_adopted_request_get_operation">
        <doc xml:space="preserve">Returns the operation carried by the request. This can only be called if
the request's type is %INF_ADOPTED_REQUEST_DO.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The request's operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_receive_time"
              c:identifier="inf_adopted_request_get_receive_time">
        <doc xml:space="preserve">Returns the time when the request was received, or, if it's a local
request, generated. The time is given in microseconds since January 1,
1970.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Time when the request was received.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_type"
              c:identifier="inf_adopted_request_get_request_type">
        <doc xml:space="preserve">Returns the request type of @request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The type of @request.</doc>
          <type name="AdoptedRequestType" c:type="InfAdoptedRequestType"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_id"
              c:identifier="inf_adopted_request_get_user_id">
        <doc xml:space="preserve">Returns the user ID of the user that issued @request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The request's user ID.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vector" c:identifier="inf_adopted_request_get_vector">
        <doc xml:space="preserve">Returns the vector time the request was made i.e. its operation can be
applied to the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The state vector of @request. The returned value
should not be freed, it is owned by the #InfAdoptedRequest.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mirror" c:identifier="inf_adopted_request_mirror">
        <doc xml:space="preserve">Mirrors @request as described in "Reducing the Problems of Group Undo" by
Matthias Ressel and Rul Gunzenh&amp;auml;user
(http://portal.acm.org/citation.cfm?doid=320297.320312).

Note that @by is the total amount of requests between the original and
mirrored request, and thus equivalent to 2j-1 in the paper's definition.

@request must be of type %INF_ADOPTED_REQUEST_DO and its operation must
be reversible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The mirrored request as a new #InfAdoptedRequest.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">The number of requests between the original and the mirrored
operation.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="need_concurrency_id"
              c:identifier="inf_adopted_request_need_concurrency_id">
        <doc xml:space="preserve">Returns whether transforming @request against @against requires a
concurrency ID. If this function returns %TRUE, you must provide the
@request_lcs and @against_lcs parameters when calling
inf_adopted_request_transform().

Both request need to be of type %INF_ADOPTED_REQUEST_DO, and their state
vectors must be the same.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether transformation of @request against @against requires a
concurrency ID.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform against.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_execute_time"
              c:identifier="inf_adopted_request_set_execute_time">
        <doc xml:space="preserve">Sets the time when @request was executed. Usually this is called by
#InfAdoptedAlgorithm when it executes a request, i.e. translates it to the
current state of the document.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">A time in microseconds since January 1, 1970.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="inf_adopted_request_transform">
        <doc xml:space="preserve">Transforms the operation of @request against the operation of @against.
Both requests must be of type %INF_ADOPTED_REQUEST_DO, and their state
vectors must be the same.

If the function inf_adopted_request_need_concurrency_id() returns %TRUE,
@request_lcs and @against_lcs must not be %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedRequest, the result of the
transformation.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </instance-parameter>
          <parameter name="against" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform against.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="request_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform in a previous state, or %NULL.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="against_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The request to transform against in a previous state, or
%NULL.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <property name="executed" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="operation"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedOperation"/>
      </property>
      <property name="received"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedRequestType"/>
      </property>
      <property name="user-id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="vector"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedStateVector"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="AdoptedRequestClass"
            c:type="InfAdoptedRequestClass"
            glib:is-gtype-struct-for="AdoptedRequest">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="AdoptedRequestLog"
           c:symbol-prefix="adopted_request_log"
           c:type="InfAdoptedRequestLog"
           parent="GObject.Object"
           glib:type-name="InfAdoptedRequestLog"
           glib:get-type="inf_adopted_request_log_get_type"
           glib:type-struct="AdoptedRequestLogClass">
      <doc xml:space="preserve">#InfAdoptedRequestLog is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_request_log_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedRequestLog for the user with the given ID.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedRequestLog.</doc>
          <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
        </return-value>
        <parameters>
          <parameter name="user_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the #InfAdoptedUser to create a request log for. The
request log only contains requests of that particular user.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="add_request" invoker="add_request">
        <doc xml:space="preserve">Inserts @request into @log. The component represented by the log's user
of the request's state vector must match the end index of @log if @log
is not empty. Also, the user that issued @request must be the same user as
the one this request log belongs to.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_cached_request"
              c:identifier="inf_adopted_request_log_add_cached_request">
        <doc xml:space="preserve">#InfAdoptedRequestLog has a cache for translated requests built in. This
can be used to store requests that have been translated to another point
in the state space, and to efficiently look them up later. The advantage
of having this functionality within #InfAdoptedRequestLog is that when
requests are removed from the log the cache is automatically updated
accordingly.

The data structure of the cache is optimized for quick lookup of entries
by the state vector and cleaning up entries in an efficient manner also
when the cache has grown very big.

The request cache is mainly used by #InfAdoptedAlgorithm to efficiently
handle big transformations.

This function adds a request to the cache of the request log.
@request must be a translated version of a request existing in @log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedRequest to add to the cache.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_request"
              c:identifier="inf_adopted_request_log_add_request">
        <doc xml:space="preserve">Inserts @request into @log. The component represented by the log's user
of the request's state vector must match the end index of @log if @log
is not empty. Also, the user that issued @request must be the same user as
the one this request log belongs to.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_begin"
              c:identifier="inf_adopted_request_log_get_begin">
        <doc xml:space="preserve">Returns the first index (i.e. the index of the oldest request) in the log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The first index in the log.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_end" c:identifier="inf_adopted_request_log_get_end">
        <doc xml:space="preserve">Returns the index a newly inserted request would have (i.e. one past the
index of the newest request in the log). This ensures that
inf_adopted_request_log_get_end() - inf_adopted_request_log_get_begin()
reveals the number of requests in the log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The index of the next request in the log.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request"
              c:identifier="inf_adopted_request_log_get_request">
        <doc xml:space="preserve">Returns the request with the given index. Such a request must exist in
@log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAdoptedRequest. The request is owned by
the request log, you do not need to free it.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The index of a request contained in @log.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_id"
              c:identifier="inf_adopted_request_log_get_user_id">
        <doc xml:space="preserve">Returns the ID of the user whose requests @log contains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The log's user ID.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="inf_adopted_request_log_is_empty">
        <doc xml:space="preserve">Returns whether @log is empty. A log is empty if it does not contain any
requsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @log is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_cached_request"
              c:identifier="inf_adopted_request_log_lookup_cached_request">
        <doc xml:space="preserve">Looks up the request at @vec from the cache of the request log. If the
queried request does not exist in the cache, the function returns %NULL.

See inf_adopted_request_log_add_cached_request() for an explanation of
the request cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The cached #InfAdoptedRequest
according to @vec, or %NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">The state vector at which to look up the request.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lower_related"
              c:identifier="inf_adopted_request_log_lower_related">
        <doc xml:space="preserve">Returns the oldest request in @log that is related to @n&lt;!-- --&gt;th request
in log. Requests are considered related when they are enclosed by a
do/undo, an undo/redo or a redo/undo pair.

Note that the sets of related requests within a request log are
disjoint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The oldest request in @log being related to the
@n&lt;!-- --&gt;th request.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">Index of a request in @log.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_associated"
              c:identifier="inf_adopted_request_log_next_associated">
        <doc xml:space="preserve">If @request is of type %INF_ADOPTED_REQUEST_DO or
%INF_ADOPTED_REQUEST_REDO, this returns UNDO request that undoes this
request, if any. If @request is a %INF_ADOPTED_REQUEST UNDO request, this
returns a request that redoes @request, if any.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The next associated request of
@request, or %NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest contained in @log.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_redo"
              c:identifier="inf_adopted_request_log_next_redo">
        <doc xml:space="preserve">Returns the request that would be redone if a redo request was added to
the request log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The next request to be redone, or
%NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_undo"
              c:identifier="inf_adopted_request_log_next_undo">
        <doc xml:space="preserve">Returns the request that would be undone if a undo request was added to
the request log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The next request to be undone, or
%NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="original_request"
              c:identifier="inf_adopted_request_log_original_request">
        <doc xml:space="preserve">Returns the most previous associated request for @request, that is,
the %INF_ADOPTED_REQUEST_DO request that @request undoes or redoes,
respectively. If @request itself is a %INF_ADOPTED_REQUEST_DO request,
@request itself is returned.

@request must either be contained in @log or the vector time component
of its own user must be equivalent to inf_adopted_request_log_get_end(),
in which case @request is treated as it if was the newest request in @log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The original request of @request.
This function never returns %NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_associated"
              c:identifier="inf_adopted_request_log_prev_associated">
        <doc xml:space="preserve">If @request is of type %INF_ADOPTED_REQUEST_REDO or, this returns the UNDO
request that is redone by @request, if @request is a
%INF_ADOPTED_REQUEST_UNDO request, this returns the request that is undone
by @request.

@request must either be contained in @log or the vector time component
of its own user must be equivalent to inf_adopted_request_log_get_end(),
in which case @request is treated as it if was the newest request in @log.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The previous associated request of
@request, or %NULL.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_requests"
              c:identifier="inf_adopted_request_log_remove_requests">
        <doc xml:space="preserve">Removes all requests with index lower than @up_to. This function only works
if the request before @up_to is an "upper related" request.
See inf_adopted_request_log_upper_related(). This condition guarantees
that remaining requests do not refer to removed ones.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="up_to" transfer-ownership="none">
            <doc xml:space="preserve">The index of the first request not to remove.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_begin"
              c:identifier="inf_adopted_request_log_set_begin">
        <doc xml:space="preserve">This function sets the index of the first log that will be added to @log.
For a new request log, this is set to 0. If you intend to insert a request
sequence into @log that does not start with 0, then you can call this
function with the desired start index, so that
inf_adopted_request_log_get_begin() and inf_adopted_request_log_get_end()
return the correct value.

If you don't need inf_adopted_request_log_get_begin() or
inf_adopted_request_log_get_end() before adding the first request to the
log, then you don't need to call this function, since
inf_adopted_request_log_add_request() will do it implicitely based on the
request's vector time component for the request log's user.

This function can only be called if the request log is empty, see
inf_adopted_request_log_is_empty().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The index of the first request to be added to the log.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="upper_related"
              c:identifier="inf_adopted_request_log_upper_related">
        <doc xml:space="preserve">Returns the newest request in @log that is related to @n&lt;!-- --&gt;th request
in log. Requests are considered related when they are enclosed by a
do/undo, an undo/redo or a redo/undo pair.

Note that the sets of related requests within a request log are
disjoint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The newest request in @log being related to the
@n&lt;!-- --&gt;th request.</doc>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="log" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
            <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">Index of a request in @log.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="begin"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="end" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="next-redo" transfer-ownership="none">
        <type name="AdoptedRequest"/>
      </property>
      <property name="next-undo" transfer-ownership="none">
        <type name="AdoptedRequest"/>
      </property>
      <property name="user-id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="add-request" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a new request is added to the request log
via inf_adopted_request_log_add_request().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The new request being added.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AdoptedRequestLogClass"
            c:type="InfAdoptedRequestLogClass"
            glib:is-gtype-struct-for="AdoptedRequestLog">
      <doc xml:space="preserve">This structure contains the default signal handlers for
#InfAdoptedRequestLog.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_request">
        <callback name="add_request">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="log" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedRequestLog.</doc>
              <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAdoptedRequest.</doc>
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="AdoptedRequestType"
                 glib:type-name="InfAdoptedRequestType"
                 glib:get-type="inf_adopted_request_type_get_type"
                 c:type="InfAdoptedRequestType">
      <doc xml:space="preserve">Possible types for an #InfAdoptedRequest.</doc>
      <member name="do"
              value="0"
              c:identifier="INF_ADOPTED_REQUEST_DO"
              glib:nick="do">
        <doc xml:space="preserve">A request that performs an operation.</doc>
      </member>
      <member name="undo"
              value="1"
              c:identifier="INF_ADOPTED_REQUEST_UNDO"
              glib:nick="undo">
        <doc xml:space="preserve">A request that undoes a previously applied
request.</doc>
      </member>
      <member name="redo"
              value="2"
              c:identifier="INF_ADOPTED_REQUEST_REDO"
              glib:nick="redo">
        <doc xml:space="preserve">A request that redoes a previously undone
request.</doc>
      </member>
    </enumeration>
    <class name="AdoptedSession"
           c:symbol-prefix="adopted_session"
           c:type="InfAdoptedSession"
           parent="Session"
           glib:type-name="InfAdoptedSession"
           glib:get-type="inf_adopted_session_get_type"
           glib:type-struct="AdoptedSessionClass">
      <doc xml:space="preserve">#InfAdoptedSession is an opaque data type. You should only access it via
the public API functions.</doc>
      <implements name="CommunicationObject"/>
      <virtual-method name="check_request">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_to_xml">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="diff_vec" transfer-ownership="none">
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="for_sync" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="xml_to_request" introspectable="0" throws="1">
        <return-value>
          <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="diff_vec" transfer-ownership="none">
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="for_sync" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="broadcast_request"
              c:identifier="inf_adopted_session_broadcast_request">
        <doc xml:space="preserve">Sends a request to all subscribed connections. The request should originate
from a call to inf_adopted_algorithm_generate_request(), with
@session's #InfAdoptedAlgorithm.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedRequest obtained from @session's algorithm.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_algorithm"
              c:identifier="inf_adopted_session_get_algorithm">
        <doc xml:space="preserve">Returns the #InfAdoptedAlgorithm object of @session. Returns %NULL if
@session has status %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING
because there the algorithm object is not yet created before successful
synchronization.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAdoptedAlgorithm, or %NULL.</doc>
          <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_io" c:identifier="inf_adopted_session_get_io">
        <doc xml:space="preserve">Returns the #InfIo object of @session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIo.</doc>
          <type name="Io" c:type="InfIo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read_request_info"
              c:identifier="inf_adopted_session_read_request_info"
              throws="1">
        <doc xml:space="preserve">This function reads common information such as the state vector the request
was made and the user that made the request from XML. It is most likely to
be used by implementations of the xml_to_request virtual function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data could be read successfully, %FALSE if the XML
request does not contain valid request data, in which case @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML to read the data from.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="diff_vec" transfer-ownership="none">
            <doc xml:space="preserve">The reference vector of the time vector of the request, or %NULL.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="user"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Location to store the user of
the request, or %NULL.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser**"/>
          </parameter>
          <parameter name="time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Location to store the state the
request was made, or %NULL.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector**"/>
          </parameter>
          <parameter name="operation"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Location to store the
operation of the request, or %NULL.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="redo" c:identifier="inf_adopted_session_redo">
        <doc xml:space="preserve">This is a shortcut for creating @n redo requests and broadcasting them.
If @n &gt; 1 then this is also more efficient.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The number of redo requests to issue.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="undo" c:identifier="inf_adopted_session_undo">
        <doc xml:space="preserve">This is a shortcut for creating @n undo requests and broadcasting them.
If @n &gt; 1 then this is also more efficient.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The number of undo requests to issue.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_request_info"
              c:identifier="inf_adopted_session_write_request_info">
        <doc xml:space="preserve">This function writes common data from @request, such as the user that
issued the request and the state in which the request was made into @xml.
If @diff_vec is given, then the state is written as a diff to this vector,
see inf_adopted_state_vector_to_string_diff(). Deserializing this data
again (via inf_adopted_session_read_request_info()) requires the same
@diff_vec then.

This function is most likely to be used by implementations of the
request_to_xml virtual function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedRequest whose info to write.</doc>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="diff_vec" transfer-ownership="none">
            <doc xml:space="preserve">A reference state vector, or %NULL.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML node to write the data into.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">An XML node representing the operation of the request, or
%NULL.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <property name="algorithm" transfer-ownership="none">
        <type name="AdoptedAlgorithm"/>
      </property>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Io"/>
      </property>
      <property name="max-total-log-size"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Session" c:type="InfSession"/>
      </field>
      <glib:signal name="check-request" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the session received a request from a
non-local user. It is used to decide whether the request should be
processed or not. Note that generally not processing a request results is
loss of synchronization, since other hosts might process the request.
Only if the same condition can be applied on all sites a request should
be rejected. Another possibility is to reject a request at a central host
before it gets distributed to all other clients. If there is one signal
handler returning %TRUE the request is rejected, i.e. only if all signal
handlers return %FALSE it is accepted.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request to be processed.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The user who issued the request.</doc>
            <type name="AdoptedUser"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AdoptedSessionClass"
            c:type="InfAdoptedSessionClass"
            glib:is-gtype-struct-for="AdoptedSession">
      <doc xml:space="preserve">Virtual functions and default signal handlers for #InfAdoptedSession.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="SessionClass" c:type="InfSessionClass"/>
      </field>
      <field name="xml_to_request" introspectable="0">
        <callback name="xml_to_request" introspectable="0" throws="1">
          <return-value>
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
            <parameter name="diff_vec" transfer-ownership="none">
              <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
            </parameter>
            <parameter name="for_sync" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_to_xml">
        <callback name="request_to_xml">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
            <parameter name="diff_vec" transfer-ownership="none">
              <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
            </parameter>
            <parameter name="for_sync" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_request">
        <callback name="check_request">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="AdoptedSessionError" c:type="InfAdoptedSessionError">
      <doc xml:space="preserve">Error codes for #InfAdoptedSession. These only occur when invalid requests
are received from the network.</doc>
      <member name="no_such_user"
              value="0"
              c:identifier="INF_ADOPTED_SESSION_ERROR_NO_SUCH_USER">
        <doc xml:space="preserve">The "user" field in a request
message does not contain a valid user ID.</doc>
      </member>
      <member name="missing_operation"
              value="1"
              c:identifier="INF_ADOPTED_SESSION_ERROR_MISSING_OPERATION">
        <doc xml:space="preserve">A request message does not
contain an operation.</doc>
      </member>
      <member name="invalid_request"
              value="2"
              c:identifier="INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST">
        <doc xml:space="preserve">A request in a synchronized
request log is invalid. Invalid means that it is not the request that
was issued after the previous request in the log, or that it is an Undo
or Redo request without a request to Undo or Redo, respectively.</doc>
      </member>
      <member name="missing_state_vector"
              value="3"
              c:identifier="INF_ADOPTED_SESSION_ERROR_MISSING_STATE_VECTOR">
        <doc xml:space="preserve">A synchronized user does
not contain that the state that user currently is in.</doc>
      </member>
      <member name="failed"
              value="4"
              c:identifier="INF_ADOPTED_SESSION_ERROR_FAILED">
        <doc xml:space="preserve">No further specified error code.</doc>
      </member>
    </enumeration>
    <class name="AdoptedSessionRecord"
           c:symbol-prefix="adopted_session_record"
           c:type="InfAdoptedSessionRecord"
           parent="GObject.Object"
           glib:type-name="InfAdoptedSessionRecord"
           glib:get-type="inf_adopted_session_record_get_type"
           glib:type-struct="AdoptedSessionRecordClass">
      <doc xml:space="preserve">#InfAdoptedSessionRecord is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_session_record_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedSessionRecord, recording @session. To start
recording, call inf_adopted_session_record_start_recording().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedSessionRecord.</doc>
          <type name="AdoptedSessionRecord" c:type="InfAdoptedSessionRecord*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSession.</doc>
            <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="is_recording"
              c:identifier="inf_adopted_session_record_is_recording">
        <doc xml:space="preserve">Returns whether @record is currently recording a session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @record currently records the session.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionRecord.</doc>
            <type name="AdoptedSessionRecord"
                  c:type="InfAdoptedSessionRecord*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start_recording"
              c:identifier="inf_adopted_session_record_start_recording"
              throws="1">
        <doc xml:space="preserve">Starts to record the session. Make sure the session is not already closed
before calling this function. If an error occurs, such as if @filename
could not be opened, then the function returns %FALSE and @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the session is started to be recorded, %FALSE on
error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionRecord.</doc>
            <type name="AdoptedSessionRecord"
                  c:type="InfAdoptedSessionRecord*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">The file in which to store the record.</doc>
            <type name="filename" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_recording"
              c:identifier="inf_adopted_session_record_stop_recording"
              throws="1">
        <doc xml:space="preserve">Stops the recording of the current session, which must have been started
previously via inf_adopted_session_record_start_recording(). If an error
occurs, then the function returns %FALSE and @error is set. Note that even
if an error occurs, then the recording is stopped as well. However, the
file might not have been completely written to disk, so you should still
show any errors during this function to the user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the recording has been stored successfully, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionRecord.</doc>
            <type name="AdoptedSessionRecord"
                  c:type="InfAdoptedSessionRecord*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="filename" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="session"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedSession"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AdoptedSessionRecordClass"
            c:type="InfAdoptedSessionRecordClass"
            glib:is-gtype-struct-for="AdoptedSessionRecord">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="AdoptedSessionReplay"
           c:symbol-prefix="adopted_session_replay"
           c:type="InfAdoptedSessionReplay"
           parent="GObject.Object"
           glib:type-name="InfAdoptedSessionReplay"
           glib:get-type="inf_adopted_session_replay_get_type"
           glib:type-struct="AdoptedSessionReplayClass">
      <doc xml:space="preserve">#InfAdoptedSessionReplay is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_session_replay_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedSessionReplay. Use
inf_adopted_session_replay_set_record() to start the recording, and
inf_adopted_session_replay_play_next() or
inf_adopted_session_replay_play_to_end() to play it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedSessionReplay. Free with
g_object_unref() when no longer in use.</doc>
          <type name="AdoptedSessionReplay" c:type="InfAdoptedSessionReplay*"/>
        </return-value>
      </constructor>
      <method name="get_session"
              c:identifier="inf_adopted_session_replay_get_session">
        <doc xml:space="preserve">Returns the played back session, or %NULL if
inf_adopted_session_replay_set_record() was not yet called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAdoptedSessionReplay, or %NULL.</doc>
          <type name="AdoptedSession" c:type="InfAdoptedSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="replay" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionReplay.</doc>
            <type name="AdoptedSessionReplay"
                  c:type="InfAdoptedSessionReplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="play_next"
              c:identifier="inf_adopted_session_replay_play_next"
              throws="1">
        <doc xml:space="preserve">Reads the next request from the record and passes it to the session. Note
that this might do nothing if that request is not yet causally ready,
meaning that it depends on another request that has not yet been played. In
that case it will be executed as soon as it is ready, that is after some
future inf_adopted_session_replay_play_next() call. Therefore, it is also
possible that this function executes more than one request.

If an error occurs, then this function returns %FALSE and @error is set.
If the end of the recording is reached, then it also returns %FALSE, but
@error is left untouched. If the next request has been read, then it
returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a request was read, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="replay" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionReplay.</doc>
            <type name="AdoptedSessionReplay"
                  c:type="InfAdoptedSessionReplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="play_to_end"
              c:identifier="inf_adopted_session_replay_play_to_end"
              throws="1">
        <doc xml:space="preserve">Plays all requests that are contained in the recording, so that the
replay's session has the same state as the recorded session when the
recording was stopped.

Note that, depending on the size of the record, this function may take
some time to finish.

If an error occurs during replay, then the function returns %FALSE and
@error is set. Otherwise it returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if an error occurs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="replay" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionReplay.</doc>
            <type name="AdoptedSessionReplay"
                  c:type="InfAdoptedSessionReplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_record"
              c:identifier="inf_adopted_session_replay_set_record"
              introspectable="0"
              throws="1">
        <doc xml:space="preserve">Set the record file for @replay to play. It should have been created with
#InfAdoptedSessionRecord. @plugin should match the type of the recorded
session. If an error occurs, the function returns %FALSE and @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE if the record file could not be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="replay" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSessionReplay.</doc>
            <type name="AdoptedSessionReplay"
                  c:type="InfAdoptedSessionReplay*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">Path to the record file to play.</doc>
            <type name="filename" c:type="gchar*"/>
          </parameter>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">A #InfcNotePlugin for the note type of the recorded session.</doc>
            <type c:type="const InfcNotePlugin*"/>
          </parameter>
        </parameters>
      </method>
      <property name="filename" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="session" transfer-ownership="none">
        <type name="AdoptedSession"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AdoptedSessionReplayClass"
            c:type="InfAdoptedSessionReplayClass"
            glib:is-gtype-struct-for="AdoptedSessionReplay">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="AdoptedSessionReplayError"
                 c:type="InfAdoptedSessionReplayError">
      <doc xml:space="preserve">Error codes for the &lt;literal&gt;INF_ADOPTED_SESSION_REPLAY_ERROR&lt;/literal&gt;
error domain. These can occur while loading or replaying a session
with #InfAdoptedSessionReplay.</doc>
      <member name="bad_file"
              value="0"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_BAD_FILE">
        <doc xml:space="preserve">The record file could not be
opened for reading.</doc>
      </member>
      <member name="bad_xml"
              value="1"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_BAD_XML">
        <doc xml:space="preserve">The record file contains
invalid XML.</doc>
      </member>
      <member name="bad_document"
              value="2"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_BAD_DOCUMENT">
        <doc xml:space="preserve">The record file is not a
session recording.</doc>
      </member>
      <member name="bad_session_type"
              value="3"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_BAD_SESSION_TYPE">
        <doc xml:space="preserve">The record file is a
session recording for a different type of session than the one provided.</doc>
      </member>
      <member name="bad_format"
              value="4"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_BAD_FORMAT">
        <doc xml:space="preserve">The record file is invalid.</doc>
      </member>
      <member name="unexpected_eof"
              value="5"
              c:identifier="INF_ADOPTED_SESSION_REPLAY_ERROR_UNEXPECTED_EOF">
        <doc xml:space="preserve">More data was expected
to be read from the record file, but the end of file was reached.</doc>
      </member>
    </enumeration>
    <class name="AdoptedSplitOperation"
           c:symbol-prefix="adopted_split_operation"
           c:type="InfAdoptedSplitOperation"
           parent="GObject.Object"
           glib:type-name="InfAdoptedSplitOperation"
           glib:get-type="inf_adopted_split_operation_get_type"
           glib:type-struct="AdoptedSplitOperationClass">
      <doc xml:space="preserve">#InfAdoptedSplitOperation is an opaque data type. You should only access it
via the public API functions.</doc>
      <implements name="AdoptedOperation"/>
      <constructor name="new" c:identifier="inf_adopted_split_operation_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedSplitOperation. A split operation is simply a
wrapper around two operations (which may in turn be split operations).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedSplitOperation.</doc>
          <type name="AdoptedSplitOperation"
                c:type="InfAdoptedSplitOperation*"/>
        </return-value>
        <parameters>
          <parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">one of the #InfAdoptedOperation&lt;!-- --&gt;s to be wrapped</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">the other #InfAdoptedOperation to be wrapped</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="transform_other"
              c:identifier="inf_adopted_split_operation_transform_other">
        <doc xml:space="preserve">Transforms @other against @op.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The transformed operation.</doc>
          <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSplitOperation.</doc>
            <type name="AdoptedSplitOperation"
                  c:type="InfAdoptedSplitOperation*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">An arbitrary #InfAdoptedOperation.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="op_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The operation @op at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="other_lcs" transfer-ownership="none">
            <doc xml:space="preserve">The operation @other at a previous state, or %NULL.</doc>
            <type name="AdoptedOperation" c:type="InfAdoptedOperation*"/>
          </parameter>
          <parameter name="concurrency_id" transfer-ownership="none">
            <doc xml:space="preserve">The concurrency id for the transformation of
@other against @op.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsplit"
              c:identifier="inf_adopted_split_operation_unsplit">
        <doc xml:space="preserve">Returns a list of the operations contained by the split operation. If the
splitted operation are in turn split operations, they will also be
unsplitted. The returned list is guarenteed to not contain a
#InfAdoptedSplitOperation.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">A
list of operations. Free with g_slist_free() when done.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="AdoptedOperation"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedSplitOperation.</doc>
            <type name="AdoptedSplitOperation"
                  c:type="InfAdoptedSplitOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="first"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedOperation"/>
      </property>
      <property name="second"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedOperation"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AdoptedSplitOperationClass"
            c:type="InfAdoptedSplitOperationClass"
            glib:is-gtype-struct-for="AdoptedSplitOperation">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AdoptedStateVector"
            c:type="InfAdoptedStateVector"
            glib:type-name="InfAdoptedStateVector"
            glib:get-type="inf_adopted_state_vector_get_type"
            c:symbol-prefix="adopted_state_vector">
      <doc xml:space="preserve">#InfAdoptedStateVector is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_state_vector_new">
        <doc xml:space="preserve">Returns a new state vector with all components set to zero.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedStateVector.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="inf_adopted_state_vector_add">
        <doc xml:space="preserve">Adds @value to the current value of @component. @value may be negative in
which case the current value is actually decreased. Make sure to not drop
below zero this way.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The component to change.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value by which to change the component.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="causally_before"
              c:identifier="inf_adopted_state_vector_causally_before">
        <doc xml:space="preserve">Checks whether an event that occured at time @second is causally
dependant on an event that occured at time @first, that is all
components of @first are less or equal to the corresponding component in
@second.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @second depends on @first.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="causally_before_inc"
              c:identifier="inf_adopted_state_vector_causally_before_inc">
        <doc xml:space="preserve">This function does the equivalent of

|[
inf_adopted_state_vector_add(first, inc_component, 1);
gboolean result = inf_adopted_state_vector_causally_before(first, second);
inf_adopted_state_vector_add(first, inc_component, -1);
return result;
]|

But it is more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @second depends on @first with the
@inc_component&lt;!-- --&gt;th component increased by one.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
          <parameter name="inc_component" transfer-ownership="none">
            <doc xml:space="preserve">The component to increment before comparing.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="inf_adopted_state_vector_compare">
        <doc xml:space="preserve">Performs a comparison suited for strict-weak ordering so that state vectors
can be sorted. This function returns -1 if @first compares before @second,
0 if they compare equal and 1 if @first compares after @second.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_adopted_state_vector_copy">
        <doc xml:space="preserve">Returns a copy of @vec.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @vec.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedStateVector to copy</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="inf_adopted_state_vector_foreach">
        <doc xml:space="preserve">Calls @func for each component in @vec. Note that there may be users for
which @func will not be called if their timestamp is 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">The function to call.</doc>
            <type name="AdoptedStateVectorForeachFunc"
                  c:type="InfAdoptedStateVectorForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_adopted_state_vector_free">
        <doc xml:space="preserve">Frees a state vector allocated by inf_adopted_state_vector_new() or
inf_adopted_state_vector_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="inf_adopted_state_vector_get">
        <doc xml:space="preserve">Returns the timestamp for the given component. Implicitely, all IDs
that the vector does not contain are assigned the timestamp 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The @component'th entry in the vector.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The component whose timestamp to look for.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="inf_adopted_state_vector_set">
        <doc xml:space="preserve">Sets the given component of @vec to @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The component to change.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to set the component to.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string"
              c:identifier="inf_adopted_state_vector_to_string">
        <doc xml:space="preserve">Returns a string representation of @vec.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-allocated string to be freed by the
caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string_diff"
              c:identifier="inf_adopted_state_vector_to_string_diff">
        <doc xml:space="preserve">Returns the string representation of a diff between @orig and @vec. This
is possibly smaller than the representation created by
inf_adopted_state_vector_to_string(), but the same @orig vector is needed
to recreate @vec from the string representation. Additionally,
inf_adopted_state_vector_causally_before(@orig, @vec) must hold.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string to be freed by the
caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="orig" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="vdiff" c:identifier="inf_adopted_state_vector_vdiff">
        <doc xml:space="preserve">This function returns the sum of the differences between each component
of @first and @second. This function can only be called if
inf_adopted_state_vector_causally_before() returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The sum of the differences between each component of @first and
@second.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">Another #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <function name="error_quark"
                c:identifier="inf_adopted_state_vector_error_quark">
        <doc xml:space="preserve">The domain for #InfAdoptedStateVectorError errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GQuark for that domain.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="from_string"
                c:identifier="inf_adopted_state_vector_from_string"
                throws="1">
        <doc xml:space="preserve">Recreates the #InfAdoptedStateVector from its string representation. If
an error occurs, the function returns %NULL and @error is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedStateVector, or %NULL.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">A string representation of a #InfAdoptedStateVector.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_string_diff"
                c:identifier="inf_adopted_state_vector_from_string_diff"
                throws="1">
        <doc xml:space="preserve">Recreates a vector from its string representation diff and the original
vector. If an error returns, the function returns %NULL and @error is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The created state vector, or %NULL on error.
Free with inf_adopted_state_vector_free() when no longer needed.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">A string representation of a diff between state vectors.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="orig" transfer-ownership="none">
            <doc xml:space="preserve">The state vector used to create @str in
inf_adopted_state_vector_to_string_diff().</doc>
            <type name="AdoptedStateVector"
                  c:type="const InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="AdoptedStateVectorError"
                 c:type="InfAdoptedStateVectorError"
                 glib:error-domain="INF_ADOPTED_STATE_VECTOR_ERROR">
      <doc xml:space="preserve">Error codes for #InfAdoptedStateVector.</doc>
      <member name="bad_format"
              value="0"
              c:identifier="INF_ADOPTED_STATE_VECTOR_BAD_FORMAT">
        <doc xml:space="preserve">A string representation of an
#InfAdoptedStateVector as required by
inf_adopted_state_vector_from_string() or
inf_adopted_state_vector_from_string_diff() is invalid.</doc>
      </member>
      <member name="failed"
              value="1"
              c:identifier="INF_ADOPTED_STATE_VECTOR_FAILED">
        <doc xml:space="preserve">No further specified error code.</doc>
      </member>
    </enumeration>
    <callback name="AdoptedStateVectorForeachFunc"
              c:type="InfAdoptedStateVectorForeachFunc">
      <doc xml:space="preserve">This function is called for every component in the state vector during
the invocation of inf_adopted_state_vector_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve">The ID of the entry.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value of the entry.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">The user data passed to inf_adopted_state_vector_foreach().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AdoptedUndoGrouping"
           c:symbol-prefix="adopted_undo_grouping"
           c:type="InfAdoptedUndoGrouping"
           parent="GObject.Object"
           glib:type-name="InfAdoptedUndoGrouping"
           glib:get-type="inf_adopted_undo_grouping_get_type"
           glib:type-struct="AdoptedUndoGroupingClass">
      <doc xml:space="preserve">#InfAdoptedUndoGrouping is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_adopted_undo_grouping_new">
        <doc xml:space="preserve">Creates a new #InfAdoptedUndoGrouping. To start grouping requests, set a
user whose requests to group via inf_adopted_undo_grouping_set_algorithm().
Before doing so you might want to connect to
#InfAdoptedUndoGrouping::group-requests, so the user's initial requests can
be grouped correctly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAdoptedUndoGrouping, to be freed
via g_object_unref().</doc>
          <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
        </return-value>
      </constructor>
      <virtual-method name="group_requests">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
          <parameter name="first" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
          <parameter name="second" transfer-ownership="none">
            <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="end_group"
              c:identifier="inf_adopted_undo_grouping_end_group">
        <doc xml:space="preserve">When inf_adopted_undo_grouping_start_group() was called before, then this
function restores the normal behaviour of grouping requests.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
          <parameter name="allow_group_with_next" transfer-ownership="none">
            <doc xml:space="preserve">Whether subsequent requests are allow to be part of
this group if #InfAdoptedUndoGrouping::group-requests allows.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_algorithm"
              c:identifier="inf_adopted_undo_grouping_get_algorithm">
        <doc xml:space="preserve">Returns the #InfAdoptedAlgorithm for @grouping.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@grouping's algorithm.</doc>
          <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_redo_size"
              c:identifier="inf_adopted_undo_grouping_get_redo_size">
        <doc xml:space="preserve">Returns the number of requests to redo so that a whole group is being
redone. This takes into account that possibly not the whole group cannot
be undone due to the #InfAdoptedAlgorithm:max-total-log-size constraint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of requests in the current redo group.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_undo_size"
              c:identifier="inf_adopted_undo_grouping_get_undo_size">
        <doc xml:space="preserve">Returns the number of requests to undo so that a whole group is being
undone. This takes into account that possibly not the whole group cannot
be undone due to the #InfAdoptedAlgorithm:max-total-log-size constraint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of requests in the current undo group.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_algorithm"
              c:identifier="inf_adopted_undo_grouping_set_algorithm">
        <doc xml:space="preserve">Sets the algorithm and user to group requests for. This function will group
all requests in user's request log, and also each new request that is
added to it's log. Requests that cannot be undone anymore (because
they are too old), will be correctly taken care off.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
          <parameter name="algorithm" transfer-ownership="none">
            <doc xml:space="preserve">The #InfAdoptedAlgorithm for the document to group requests,
or %NULL.</doc>
            <type name="AdoptedAlgorithm" c:type="InfAdoptedAlgorithm*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The user for which to group requests, or %NULL. Ignored if
@algorithm is %NULL.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_group"
              c:identifier="inf_adopted_undo_grouping_start_group">
        <doc xml:space="preserve">Makes all requests issued after this call belong into the same group,
i.e. they will be undone at once. This can make sense for example when the
user copy+pastes something into the document which causes multiple requests
to be generated. A call to inf_adopted_undo_grouping_end_group() restores
the normal behavior.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="grouping" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUndoGrouping.</doc>
            <type name="AdoptedUndoGrouping" c:type="InfAdoptedUndoGrouping*"/>
          </instance-parameter>
          <parameter name="allow_group_with_prev" transfer-ownership="none">
            <doc xml:space="preserve">Whether the new group can be part of the previous
group if #InfAdoptedUndoGrouping::group-requests allows.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="algorithm" writable="1" transfer-ownership="none">
        <type name="AdoptedAlgorithm"/>
      </property>
      <property name="user" writable="1" transfer-ownership="none">
        <type name="AdoptedUser"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="group-requests" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the #InfAdoptedUndoGrouping needs to
decide whether to put two requests into the same undo group or not.
A signal handler should return %TRUE if they belong into the same group
or %FALSE otherwise. Note however that the two requests may not
immediately follow each other because other users may have issued
requests inbetween. Check the vector times of the requests to find out,
using inf_adopted_request_get_vector().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first" transfer-ownership="none">
            <doc xml:space="preserve">The previous request.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
          <parameter name="second" transfer-ownership="none">
            <doc xml:space="preserve">The current request.</doc>
            <type name="AdoptedRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AdoptedUndoGroupingClass"
            c:type="InfAdoptedUndoGroupingClass"
            glib:is-gtype-struct-for="AdoptedUndoGrouping">
      <doc xml:space="preserve">This structure contains default signal handlers for #InfAdoptedUndoGrouping.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="group_requests">
        <callback name="group_requests">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="grouping" transfer-ownership="none">
              <type name="AdoptedUndoGrouping"
                    c:type="InfAdoptedUndoGrouping*"/>
            </parameter>
            <parameter name="first" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
            <parameter name="second" transfer-ownership="none">
              <type name="AdoptedRequest" c:type="InfAdoptedRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="AdoptedUser"
           c:symbol-prefix="adopted_user"
           c:type="InfAdoptedUser"
           parent="User"
           glib:type-name="InfAdoptedUser"
           glib:get-type="inf_adopted_user_get_type"
           glib:type-struct="AdoptedUserClass">
      <doc xml:space="preserve">#InfAdoptedUser is an opaque data type. You should only access it
via the public API functions.</doc>
      <method name="get_component"
              c:identifier="inf_adopted_user_get_component">
        <doc xml:space="preserve">Returns the amount of requests @user is guaranteed to have processed from
the user with ID @id.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of requests @user has processed from @id.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The component to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_request_log"
              c:identifier="inf_adopted_user_get_request_log">
        <doc xml:space="preserve">Returns the request log of @user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">User's #InfAdoptedRequestLog.</doc>
          <type name="AdoptedRequestLog" c:type="InfAdoptedRequestLog*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vector" c:identifier="inf_adopted_user_get_vector">
        <doc xml:space="preserve">Returns the current vector time of @user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current vector time of @user.</doc>
          <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_vector" c:identifier="inf_adopted_user_set_vector">
        <doc xml:space="preserve">Updates the state vector of @user. This function takes ownership of @vec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedUser.</doc>
            <type name="AdoptedUser" c:type="InfAdoptedUser*"/>
          </instance-parameter>
          <parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAdoptedStateVector.</doc>
            <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
          </parameter>
        </parameters>
      </method>
      <property name="request-log"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="AdoptedRequestLog"/>
      </property>
      <property name="vector" writable="1" transfer-ownership="none">
        <type name="AdoptedStateVector"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="User" c:type="InfUser"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="AdoptedUserClass"
            c:type="InfAdoptedUserClass"
            glib:is-gtype-struct-for="AdoptedUser">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="UserClass" c:type="InfUserClass"/>
      </field>
    </record>
    <record name="AsyncOperation"
            c:type="InfAsyncOperation"
            disguised="1"
            foreign="1">
      <doc xml:space="preserve">#InfAsyncOperation is an opaque data type and should only be accessed via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_async_operation_new">
        <doc xml:space="preserve">This function creates a new #InfAsyncOperation. The function given by
@run_func will be run asynchronously in a worker thread. Once the function
finishes, its result is passed back to the main thread defined by @io, and
@done_func is called with the computed result in the main thread.

To actually start the asynchronous operation, call
inf_async_operation_start(). This allows to save the returned value into
a structure before starting the operation, avoiding a potential race
condition if the asynchronous function finishes quickly.

The asynchronous operation can be canceled by calling
inf_async_operation_free() on the returned #InfAsyncOperation object.
If the operation is not cancelled and after @done_func has been called,
the operation is freed automatically and must not be freed by the caller.
The caller must also keep a reference to @io while the operation is
running. Before dropping your reference to @io, make sure to free the
asynchronous operation. When the last reference to @io is dropped, the
operation is freed automatically, since it cannot pass back its result to
the main thread anymore.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfAsyncOperation. Free with
inf_async_operation_free() to cancel the operation.</doc>
          <type name="AsyncOperation" c:type="InfAsyncOperation*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">The #InfIo object used to pass back the result of the operation.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="run_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A function to run asynchronously in a worker
thread, computing the result of the operation.</doc>
            <type name="AsyncOperationRunFunc"
                  c:type="InfAsyncOperationRunFunc"/>
          </parameter>
          <parameter name="done_func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">A function to be called in the thread of @io
once the result is available.</doc>
            <type name="AsyncOperationDoneFunc"
                  c:type="InfAsyncOperationDoneFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional user data to pass to both functions.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free" c:identifier="inf_async_operation_free">
        <doc xml:space="preserve">Frees the given asynchronous operation and cancels it if it is currently
running. This should only be called to cancel a running operation, or to
free an operation that has not been started. In all other cases, the
operation is freed automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAsyncOperation.</doc>
            <type name="AsyncOperation" c:type="InfAsyncOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="inf_async_operation_start" throws="1">
        <doc xml:space="preserve">Starts the operation given in @op. The operation must have been created
before with inf_async_operation_new(). If the operation cannot be started,
@error is set and %FALSE is returned. In that case, the operation must not
be used anymore since it will be automatically freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE if the operation could not be started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="op" transfer-ownership="full">
            <doc xml:space="preserve">A #InfAsyncOperation.</doc>
            <type name="AsyncOperation" c:type="InfAsyncOperation*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="AsyncOperationDoneFunc" c:type="InfAsyncOperationDoneFunc">
      <doc xml:space="preserve">This function is called in the main thread once the asynchronous operation
has finished.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="run_data" transfer-ownership="none">
          <doc xml:space="preserve">The result of the asynchronous operation.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">Data passed in inf_async_operation_new().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="AsyncOperationRunFunc" c:type="InfAsyncOperationRunFunc">
      <doc xml:space="preserve">This function performs the asynchronous task and is executed in a separate
thread. The pointer written into @run_data is passed back to the main
thread after the function has finished executing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="run_data" transfer-ownership="none">
          <doc xml:space="preserve">Location where to write the result of the asynchronous
operation.</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="run_notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">Function to be used to free @run_data, or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">Data passed in inf_async_operation_new().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="AuthenticationDetailError"
                 c:type="InfAuthenticationDetailError"
                 glib:error-domain="INF_AUTHENTICATION_DETAIL_ERROR">
      <doc xml:space="preserve">These errors can give an additional hint why the SASL
authentication failed.</doc>
      <member name="authentication_failed"
              value="0"
              c:identifier="INF_AUTHENTICATION_DETAIL_ERROR_AUTHENTICATION_FAILED">
        <doc xml:space="preserve">User did not provide
valid credentials.</doc>
      </member>
      <member name="user_not_authorized"
              value="1"
              c:identifier="INF_AUTHENTICATION_DETAIL_ERROR_USER_NOT_AUTHORIZED">
        <doc xml:space="preserve">User is not permitted
to connect to this server.</doc>
      </member>
      <member name="try_again"
              value="2"
              c:identifier="INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN">
        <doc xml:space="preserve">Authentication was temporarily
interrupted on the server side.</doc>
      </member>
      <member name="server_error"
              value="3"
              c:identifier="INF_AUTHENTICATION_DETAIL_ERROR_SERVER_ERROR">
        <doc xml:space="preserve">An error occured while
checking user permissions.</doc>
      </member>
    </enumeration>
    <interface name="Browser"
               c:symbol-prefix="browser"
               c:type="InfBrowser"
               glib:type-name="InfBrowser"
               glib:get-type="inf_browser_get_type"
               glib:type-struct="BrowserInterface">
      <doc xml:space="preserve">#InfBrowser is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="acl_account_added" invoker="acl_account_added">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-account-added signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to add the account, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acl_account_removed" invoker="acl_account_removed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-account-removed signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The removed #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to remove the account, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acl_changed" invoker="acl_changed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-changed signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which the ACL has changed.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet containing the changed ACL sheets.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to change the ACL, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acl_local_account_changed"
                      invoker="acl_local_account_changed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-local-account-changed signal
on @browser. It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new local #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that triggered the account change, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_note" invoker="add_note">
        <doc xml:space="preserve">Adds a new leaf node to the browser. The new node is of type @type. If
session is non-%NULL it will be used as the initial content of the new
node, otherwise the new node will start empty. In the case of non-%NULL
@session the session must be in status %INF_SESSION_RUNNING.

The returned request finishes as soon as the creation of the node is
acknowledged. It is however not guaranteed that the content of the note has
been synchronized yet. In the case of a client connected to an infinote
server the content is usually not transmitted when the request finishes.
If an error in the process of transmission happens then the node will be
removed again.

On the client side, the progress of synchronization to the server after the
request has finished can be monitored with the
InfSession::synchronization-failed,
InfSession::synchronization-complete and
InfSession::synchronization-progress signals. Note that a single session
might be synchronized to multiple servers at the same time, you will have
to check the connection parameter in the signal hander to find out to
which server the session is synchronized.

You can safely unref session after having called this function. If the
request or the synchronization fails, the session will be discarded in
that case. When the returned request finishes, you can use
infc_browser_iter_get_sync_in() to get the session again.

If @initial_subscribe is set, then, when the returned request finishes,
you might call inf_browser_get_session() on the resulting
#InfBrowserIter. However, that function is not guaranteed to return
non-%NULL in this case since the node might have been created, but the
subscription could have failed.

The initial ACL for the new node is given by @acl. If this parameter
is %NULL, then the default ACL is used, which inherits all permissions
from the parent node. In order to apply non-%NULL ACL to the new node,
the %INF_ACL_CAN_SET_ACL permission must be granted to the local entity for
the node @iter points to.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="acl"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="session"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfSession with a session of type @type, or
%NULL.</doc>
            <type name="Session" c:type="InfSession*"/>
          </parameter>
          <parameter name="initial_subscribe" transfer-ownership="none">
            <doc xml:space="preserve">Whether to subscribe to the newly created session.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="7">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_subdirectory" invoker="add_subdirectory">
        <doc xml:space="preserve">Adds a new subdirectory node to the browser.

The initial ACL for the new node is given by @acl. If this parameter
is %NULL, then the default ACL is used, which inherits all permissions
from the parent node. In order to apply non-%NULL ACL to the new node,
the %INF_ACL_CAN_SET_ACL permission must be granted to the local entity for
the node @iter points to.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="acl"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="begin_request" invoker="begin_request">
        <doc xml:space="preserve">This function emits the #InfBrowser::begin_request signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #infBrowserIter pointing to the node for which a request was made,
or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which was made.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_acl_account" invoker="create_acl_account">
        <doc xml:space="preserve">Requests creation of a new account. If the request succeeds, @crq will be
used by the server to create a certificate which is sent back to the
client and is associated to the newly created account.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="crq" transfer-ownership="none">
            <doc xml:space="preserve">A certificate request.</doc>
            <type name="InfGnutls.X509Crq" c:type="gnutls_x509_crq_t"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="error" invoker="error">
        <doc xml:space="preserve">This function emits the #InfBrowser::error signal on @browser. It is meant
to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError explaining what went wronig.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="explore" invoker="explore">
        <doc xml:space="preserve">Requests the node @iter points to to be explored. Initally, subdirectory
nodes are not explored, that is not known what content there is. Nodes can
be explored to learn about the children nodes they contain. Since exploring
is a potentially lengthy process involing networking or I/O with slow
devices this function returns a @InfExploreRequest which can be used to
monitor the progress of the operation and get notified when the exploration
finishes. During exploration #InfBrowser::node-added signals are already
emitted appropriately for every child explored inside @iter.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest, or %NULL if @iter
points to a non-subdirectory node.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_acl" invoker="get_acl">
        <doc xml:space="preserve">Retrieves the ACL for the node @iter points to. This function can also
be called if the ACL has not been queried before using
inf_browser_query_acl(). In that case, the returned sheet set will only
contain sheets for the default user and the local user. The function
can return %NULL which is equivalent to an empty sheet set, i.e. no ACL.

When the full ACL has been successfully queried with
inf_browser_query_acl(), the full ACL is returned by this function. The
function inf_browser_has_acl() can be used to check whether this function
will return the full ACL or only the sheets for the default and local
users.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclSheetSet containing the requested ACL, or %NULL. The
returned value is owned by the #InfBrowser and should not be freed.</doc>
          <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to retrieve ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_acl_default_account"
                      invoker="get_acl_default_account">
        <doc xml:space="preserve">Returns the default #InfAclAccount representing unauthenticated users, and
which is used to look up permissions if no permissions are explicitly
specified in the ACL of a particular node for a particular account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclAccount. The returned value is owned by
the browser and must not be freed.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_acl_local_account"
                      invoker="get_acl_local_account">
        <doc xml:space="preserve">Returns the #InfAclAccount representing the local host. This can be used to
check whether the local account is allowed to perform certain operations in
the browser. The function can also return %NULL, in which case all
operations are allowed, because the browser represents a local infinote
directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclAccount, or %NULL. The
returned value is owned by the browser and must not be freed.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_child" invoker="get_child">
        <doc xml:space="preserve">Sets @iter to point to the first child of the subdirectory node it
currently points to. If the subdirectory does not contain any children or
if @iter does not point to a subdirectory the function returns %FALSE.
This does not necessarily mean that there do not exist any children but it
can also be that they have not yet been explored. Nodes can be explored
with inf_browser_explore() and it can be checked whether a given node has
been explored with inf_browser_get_explored().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_explored" invoker="get_explored">
        <doc xml:space="preserve">Returns whether the node @iter points to has already been explored or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the node @iter points to has been explored
or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_next" invoker="get_next">
        <doc xml:space="preserve">Sets @iter to point to its next sibling node. If @iter points already to the
last node then @iter is left untouched and the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_node_name" invoker="get_node_name">
        <doc xml:space="preserve">Returns the name of the node @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string containing the node's name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_node_type" invoker="get_node_type">
        <doc xml:space="preserve">Returns the type of the node @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The node type as a string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parent" invoker="get_parent">
        <doc xml:space="preserve">Sets @iter to point to its parent node. If @iter is already the root node
then @iter is left untouched and the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_prev" invoker="get_prev">
        <doc xml:space="preserve">Sets @iter to point to its previous sibling node. If @iter points to the
first node already then @iter is left untouched and the function returns
%FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_root" invoker="get_root">
        <doc xml:space="preserve">Sets @iter to point to the root node of @browser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was set or %FALSE if there is no root node, i.e.
the browser is not open.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_session" invoker="get_session">
        <doc xml:space="preserve">Returns the session which has the content of the node @iter points to. The
session needs to be subscribed to, see inf_browser_subscribe(). If the
session is not subscribed or the subscription request has not yet finished
the function returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A @InfSessionProxy which contains
the session. The proxy object can be used to join a user into the session.</doc>
          <type name="SessionProxy" c:type="InfSessionProxy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_acl" invoker="has_acl">
        <doc xml:space="preserve">This function returns whether the ACL sheet for the given account is
available or not. If the function returns %FALSE then
inf_browser_query_acl() can be called in order to retrieve the full ACL.
If @account is 0, the function checks whether the full ACL is available,
i.e. the ACL sheets for all accounts. Usually the ACL sheets for the
default account and the local account are always available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when the ACL sheet for @account is available or %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to check full ACL
availability.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The account to check ACL availability for, or 0.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_subdirectory" invoker="is_subdirectory">
        <doc xml:space="preserve">Returns whether the node @iter points to is a subdirectory node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the node @iter points to is a subdirectory node or
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_from_request" invoker="iter_from_request">
        <doc xml:space="preserve">Sets @iter to the node for which @request was made. If that node does not
exist anymore or if @request has already finished the function returns
%FALSE and @iter is left untouched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which has not yet finished and which was
issued by @browser.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_pending_requests"
                      invoker="list_pending_requests">
        <doc xml:space="preserve">Returns a list of all pending requests for the node @iter points to which
match type @request_type. A pending request is a request which has been
created but has not yet finished. @request_type can be %NULL in which case
all requests for the given node are returned. If it is non-%NULL only
requests which match the given type are included in the list of returned
requests.

If @iter is %NULL then the function returns all pending global requests.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">A list of
#InfRequest&lt;!-- --&gt;s. Free with g_slist_free() when no longer needed.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Request"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser,
or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The type of request to return pending requests
for, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_acl_account_by_name"
                      invoker="lookup_acl_account_by_name">
        <doc xml:space="preserve">Looks up the account(s) with the given name. While in principal, there can
be many accounts with the same name, in practise user names are often
unique.

The request result contains an array of #InfAclAccount objects, all with
the same name. If there is only one entry with ID set to 0, there are no
accounts with the given name.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to be
notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the user account to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_acl_accounts" invoker="lookup_acl_accounts">
        <doc xml:space="preserve">Looks up the accounts with the given IDs. If the account list has been
queried with inf_browser_query_acl_account_list() before, then it is
likely that this function returns instantly, otherwise an asynchronous
operation might be started.

The request result contains an array of #InfAclAccount objects for the
given account IDs, which contain the account names as well. If one account
ID does not belong to an actual account, the #InfAclAccount.name field will
be %NULL.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:space="preserve">An array of account IDs to look up.</doc>
            <array length="1" zero-terminated="0" c:type="InfAclAccountId*">
              <type name="AclAccountId" c:type="InfAclAccountId"/>
            </array>
          </parameter>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:space="preserve">The number of elements in the array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="node_added" invoker="node_added">
        <doc xml:space="preserve">This function emits the #InfBrowser::node-added signal on @browser. It is
meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the newly added node.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to add or explore the node,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="node_removed" invoker="node_removed">
        <doc xml:space="preserve">This function emits the #InfBrowser::node-removed signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to be removed.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to delete the node, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_acl" invoker="query_acl">
        <doc xml:space="preserve">Queries the ACLs for all users of the node @iter points to. When the
request has finished, inf_browser_get_acl() can be used to retrieve the
ACLs.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to query the ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_acl_account_list"
                      invoker="query_acl_account_list">
        <doc xml:space="preserve">Queries the list of accounts in @browser. When this call has finished,
a list of accounts is available, and also a flag whether the browser
supports notification of accounts. If it does, then the
#InfBrowser::acl-account-added and #InfBrowser::acl-account-removed signals
are emitted when the account list changes, and the next time this function
is called, it might be available to serve the account list from the cache
without blocking.

It can also be that the browser does not support listing of accounts at
all. In this case, the request will fail with an error code of
%INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_acl_account" invoker="remove_acl_account">
        <doc xml:space="preserve">Requests deletion of the given account.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account to remove.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_node" invoker="remove_node">
        <doc xml:space="preserve">Requests to remove the node @iter points to. It may point to a
subdirectory node in which case all its children are removed recursively
as well.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_acl" invoker="set_acl">
        <doc xml:space="preserve">Changes the ACLs for the node @iter points to. Existing sheets that are not
in @sheet_set are left untouched. This operation is only allowed when the
ACL for the node @iter points to has been retrieved already with
inf_browser_query_acl(). Use inf_browser_has_acl() to check whether this
function can be called or whether the ACL needs to be queried first.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which to change ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">An #InfAclSheetSet with the sheets to update.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="subscribe" invoker="subscribe">
        <doc xml:space="preserve">Attempts to subscribe to the node @iter points to, i.e. obtain a
#InfSession representing its content. This also allows to change the
content of the node.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="subscribe_session" invoker="subscribe_session">
        <doc xml:space="preserve">This function emits the #InfBrowser::subscribe-session signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session a
subscription was made, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A session proxy for the newly subscribed session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to initiate the subscription,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unsubscribe_session" invoker="unsubscribe_session">
        <doc xml:space="preserve">This function emits the #InfBrowser::unsubscribe-session signal on
@browser. It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session the
subscription was removed, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A session proxy for the unsubscribed session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest due to which the session was unsubscribed,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="acl_account_added"
              c:identifier="inf_browser_acl_account_added">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-account-added signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to add the account, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="acl_account_removed"
              c:identifier="inf_browser_acl_account_removed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-account-removed signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The removed #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to remove the account, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="acl_changed" c:identifier="inf_browser_acl_changed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-changed signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which the ACL has changed.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet containing the changed ACL sheets.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to change the ACL, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="acl_local_account_changed"
              c:identifier="inf_browser_acl_local_account_changed">
        <doc xml:space="preserve">This function emits the #InfBrowser::acl-local-account-changed signal
on @browser. It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new local #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that triggered the account change, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_note" c:identifier="inf_browser_add_note">
        <doc xml:space="preserve">Adds a new leaf node to the browser. The new node is of type @type. If
session is non-%NULL it will be used as the initial content of the new
node, otherwise the new node will start empty. In the case of non-%NULL
@session the session must be in status %INF_SESSION_RUNNING.

The returned request finishes as soon as the creation of the node is
acknowledged. It is however not guaranteed that the content of the note has
been synchronized yet. In the case of a client connected to an infinote
server the content is usually not transmitted when the request finishes.
If an error in the process of transmission happens then the node will be
removed again.

On the client side, the progress of synchronization to the server after the
request has finished can be monitored with the
InfSession::synchronization-failed,
InfSession::synchronization-complete and
InfSession::synchronization-progress signals. Note that a single session
might be synchronized to multiple servers at the same time, you will have
to check the connection parameter in the signal hander to find out to
which server the session is synchronized.

You can safely unref session after having called this function. If the
request or the synchronization fails, the session will be discarded in
that case. When the returned request finishes, you can use
infc_browser_iter_get_sync_in() to get the session again.

If @initial_subscribe is set, then, when the returned request finishes,
you might call inf_browser_get_session() on the resulting
#InfBrowserIter. However, that function is not guaranteed to return
non-%NULL in this case since the node might have been created, but the
subscription could have failed.

The initial ACL for the new node is given by @acl. If this parameter
is %NULL, then the default ACL is used, which inherits all permissions
from the parent node. In order to apply non-%NULL ACL to the new node,
the %INF_ACL_CAN_SET_ACL permission must be granted to the local entity for
the node @iter points to.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="acl"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="session"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfSession with a session of type @type, or
%NULL.</doc>
            <type name="Session" c:type="InfSession*"/>
          </parameter>
          <parameter name="initial_subscribe" transfer-ownership="none">
            <doc xml:space="preserve">Whether to subscribe to the newly created session.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_subdirectory"
              c:identifier="inf_browser_add_subdirectory">
        <doc xml:space="preserve">Adds a new subdirectory node to the browser.

The initial ACL for the new node is given by @acl. If this parameter
is %NULL, then the default ACL is used, which inherits all permissions
from the parent node. In order to apply non-%NULL ACL to the new node,
the %INF_ACL_CAN_SET_ACL permission must be granted to the local entity for
the node @iter points to.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the node to add.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="acl"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="begin_request" c:identifier="inf_browser_begin_request">
        <doc xml:space="preserve">This function emits the #InfBrowser::begin_request signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #infBrowserIter pointing to the node for which a request was made,
or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which was made.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_acl" c:identifier="inf_browser_check_acl">
        <doc xml:space="preserve">Checks whether the given account has permissions to perform the operations
specified by @mask on the node @iter points to. The @mask parameter
should have all permissions enabled that are to be checked. The function
will then write those permissions that are actually granted to the
mask specified by the @out_mask parameter.

The function returns %TRUE if all permissions asked for are granted, i.e.
when *@out_mask equals *@mask after the function call. The @out_mask
parameter is allowed to be %NULL which is useful if only the return value
is of interest.

In order for this function to work, the ACL sheet for @account has to be
available for the node @iter points to and all of its parent nodes. If
@account is not the default or the local account, these need to be queried
before using inf_browser_query_acl().

If account is 0, it is assumed that local access to the directory is
available and the function always returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if all checked permissions are granted, or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node in a browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account whose permission to check, or %NULL.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="check_mask" transfer-ownership="none">
            <doc xml:space="preserve">A bitmask of #InfAclSetting&lt;!-- --&gt;s with permissions to
check.</doc>
            <type name="AclMask" c:type="const InfAclMask*"/>
          </parameter>
          <parameter name="out_mask"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">Output parameter with the granted permissions, or %NULL.</doc>
            <type name="AclMask" c:type="InfAclMask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_acl_account"
              c:identifier="inf_browser_create_acl_account">
        <doc xml:space="preserve">Requests creation of a new account. If the request succeeds, @crq will be
used by the server to create a certificate which is sent back to the
client and is associated to the newly created account.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="crq" transfer-ownership="none">
            <doc xml:space="preserve">A certificate request.</doc>
            <type name="InfGnutls.X509Crq" c:type="gnutls_x509_crq_t"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="error" c:identifier="inf_browser_error">
        <doc xml:space="preserve">This function emits the #InfBrowser::error signal on @browser. It is meant
to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError explaining what went wronig.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="explore" c:identifier="inf_browser_explore">
        <doc xml:space="preserve">Requests the node @iter points to to be explored. Initally, subdirectory
nodes are not explored, that is not known what content there is. Nodes can
be explored to learn about the children nodes they contain. Since exploring
is a potentially lengthy process involing networking or I/O with slow
devices this function returns a @InfExploreRequest which can be used to
monitor the progress of the operation and get notified when the exploration
finishes. During exploration #InfBrowser::node-added signals are already
emitted appropriately for every child explored inside @iter.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest, or %NULL if @iter
points to a non-subdirectory node.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_acl" c:identifier="inf_browser_get_acl">
        <doc xml:space="preserve">Retrieves the ACL for the node @iter points to. This function can also
be called if the ACL has not been queried before using
inf_browser_query_acl(). In that case, the returned sheet set will only
contain sheets for the default user and the local user. The function
can return %NULL which is equivalent to an empty sheet set, i.e. no ACL.

When the full ACL has been successfully queried with
inf_browser_query_acl(), the full ACL is returned by this function. The
function inf_browser_has_acl() can be used to check whether this function
will return the full ACL or only the sheets for the default and local
users.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclSheetSet containing the requested ACL, or %NULL. The
returned value is owned by the #InfBrowser and should not be freed.</doc>
          <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to retrieve ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_acl_default_account"
              c:identifier="inf_browser_get_acl_default_account">
        <doc xml:space="preserve">Returns the default #InfAclAccount representing unauthenticated users, and
which is used to look up permissions if no permissions are explicitly
specified in the ACL of a particular node for a particular account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclAccount. The returned value is owned by
the browser and must not be freed.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_acl_local_account"
              c:identifier="inf_browser_get_acl_local_account">
        <doc xml:space="preserve">Returns the #InfAclAccount representing the local host. This can be used to
check whether the local account is allowed to perform certain operations in
the browser. The function can also return %NULL, in which case all
operations are allowed, because the browser represents a local infinote
directory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclAccount, or %NULL. The
returned value is owned by the browser and must not be freed.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="inf_browser_get_child">
        <doc xml:space="preserve">Sets @iter to point to the first child of the subdirectory node it
currently points to. If the subdirectory does not contain any children or
if @iter does not point to a subdirectory the function returns %FALSE.
This does not necessarily mean that there do not exist any children but it
can also be that they have not yet been explored. Nodes can be explored
with inf_browser_explore() and it can be checked whether a given node has
been explored with inf_browser_get_explored().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_explored" c:identifier="inf_browser_get_explored">
        <doc xml:space="preserve">Returns whether the node @iter points to has already been explored or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the node @iter points to has been explored
or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_next" c:identifier="inf_browser_get_next">
        <doc xml:space="preserve">Sets @iter to point to its next sibling node. If @iter points already to the
last node then @iter is left untouched and the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_node_name" c:identifier="inf_browser_get_node_name">
        <doc xml:space="preserve">Returns the name of the node @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string containing the node's name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_node_type" c:identifier="inf_browser_get_node_type">
        <doc xml:space="preserve">Returns the type of the node @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The node type as a string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="inf_browser_get_parent">
        <doc xml:space="preserve">Sets @iter to point to its parent node. If @iter is already the root node
then @iter is left untouched and the function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="inf_browser_get_path">
        <doc xml:space="preserve">Returns the full path to the node @iter points to. A path always starts
with a '/' and then has the name of the node and all its parents separated
by '/', much like a filesystem path on Unix.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The path as a string. Free with g_free() when no
longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pending_request"
              c:identifier="inf_browser_get_pending_request">
        <doc xml:space="preserve">Returns a pending request for the node @iter points to which matches type
@request_type. If there is no such request the function returns %NULL.
This function is a shortcut for calling
inf_browser_list_pending_requests() and retrieving the first item from
the list.

If @iter is %NULL the function returns a global request.

For many request types, such as "subscribe-session", "subscribe-chat",
"explore-node", "query-user-list" or "query-acl" there can only be one
request at a time, and therefore this function is more convenient to use
than inf_browser_list_pending_requests().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser,
or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The type of request.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_prev" c:identifier="inf_browser_get_prev">
        <doc xml:space="preserve">Sets @iter to point to its previous sibling node. If @iter points to the
first node already then @iter is left untouched and the function returns
%FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="inf_browser_get_root">
        <doc xml:space="preserve">Sets @iter to point to the root node of @browser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was set or %FALSE if there is no root node, i.e.
the browser is not open.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session" c:identifier="inf_browser_get_session">
        <doc xml:space="preserve">Returns the session which has the content of the node @iter points to. The
session needs to be subscribed to, see inf_browser_subscribe(). If the
session is not subscribed or the subscription request has not yet finished
the function returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A @InfSessionProxy which contains
the session. The proxy object can be used to join a user into the session.</doc>
          <type name="SessionProxy" c:type="InfSessionProxy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_acl" c:identifier="inf_browser_has_acl">
        <doc xml:space="preserve">This function returns whether the ACL sheet for the given account is
available or not. If the function returns %FALSE then
inf_browser_query_acl() can be called in order to retrieve the full ACL.
If @account is 0, the function checks whether the full ACL is available,
i.e. the ACL sheets for all accounts. Usually the ACL sheets for the
default account and the local account are always available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when the ACL sheet for @account is available or %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to check full ACL
availability.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The account to check ACL availability for, or 0.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ancestor" c:identifier="inf_browser_is_ancestor">
        <doc xml:space="preserve">Returns whether @ancestor is an ancestor of @iter, i.e. either the two
iterators point to the same node or @ancestor is a parent, grand-parent,
grand-grand-parent, etc. of the node @iter points to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @ancestor is an ancestor of @iter.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="ancestor" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the ancestor node.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to be checked.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_subdirectory"
              c:identifier="inf_browser_is_subdirectory">
        <doc xml:space="preserve">Returns whether the node @iter points to is a subdirectory node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the node @iter points to is a subdirectory node or
%FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_from_request"
              c:identifier="inf_browser_iter_from_request">
        <doc xml:space="preserve">Sets @iter to the node for which @request was made. If that node does not
exist anymore or if @request has already finished the function returns
%FALSE and @iter is left untouched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which has not yet finished and which was
issued by @browser.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_pending_requests"
              c:identifier="inf_browser_list_pending_requests">
        <doc xml:space="preserve">Returns a list of all pending requests for the node @iter points to which
match type @request_type. A pending request is a request which has been
created but has not yet finished. @request_type can be %NULL in which case
all requests for the given node are returned. If it is non-%NULL only
requests which match the given type are included in the list of returned
requests.

If @iter is %NULL then the function returns all pending global requests.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">A list of
#InfRequest&lt;!-- --&gt;s. Free with g_slist_free() when no longer needed.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Request"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser,
or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The type of request to return pending requests
for, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_acl_account_by_name"
              c:identifier="inf_browser_lookup_acl_account_by_name">
        <doc xml:space="preserve">Looks up the account(s) with the given name. While in principal, there can
be many accounts with the same name, in practise user names are often
unique.

The request result contains an array of #InfAclAccount objects, all with
the same name. If there is only one entry with ID set to 0, there are no
accounts with the given name.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to be
notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the user account to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_acl_accounts"
              c:identifier="inf_browser_lookup_acl_accounts">
        <doc xml:space="preserve">Looks up the accounts with the given IDs. If the account list has been
queried with inf_browser_query_acl_account_list() before, then it is
likely that this function returns instantly, otherwise an asynchronous
operation might be started.

The request result contains an array of #InfAclAccount objects for the
given account IDs, which contain the account names as well. If one account
ID does not belong to an actual account, the #InfAclAccount.name field will
be %NULL.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:space="preserve">An array of account IDs to look up.</doc>
            <array length="1" zero-terminated="0" c:type="InfAclAccountId*">
              <type name="AclAccountId" c:type="InfAclAccountId"/>
            </array>
          </parameter>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:space="preserve">The number of elements in the array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="node_added" c:identifier="inf_browser_node_added">
        <doc xml:space="preserve">This function emits the #InfBrowser::node-added signal on @browser. It is
meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the newly added node.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to add or explore the node,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="node_removed" c:identifier="inf_browser_node_removed">
        <doc xml:space="preserve">This function emits the #InfBrowser::node-removed signal on @browser. It
is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to be removed.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to delete the node, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_acl" c:identifier="inf_browser_query_acl">
        <doc xml:space="preserve">Queries the ACLs for all users of the node @iter points to. When the
request has finished, inf_browser_get_acl() can be used to retrieve the
ACLs.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to a node for which to query the ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_acl_account_list"
              c:identifier="inf_browser_query_acl_account_list">
        <doc xml:space="preserve">Queries the list of accounts in @browser. When this call has finished,
a list of accounts is available, and also a flag whether the browser
supports notification of accounts. If it does, then the
#InfBrowser::acl-account-added and #InfBrowser::acl-account-removed signals
are emitted when the account list changes, and the next time this function
is called, it might be available to serve the account list from the cache
without blocking.

It can also be that the browser does not support listing of accounts at
all. In this case, the request will fail with an error code of
%INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_acl_account"
              c:identifier="inf_browser_remove_acl_account">
        <doc xml:space="preserve">Requests deletion of the given account.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned, where
@func has been installed for the #InfRequest::finished signal, so that it
is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the account to remove.</doc>
            <type name="AclAccountId" c:type="InfAclAccountId"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_node" c:identifier="inf_browser_remove_node">
        <doc xml:space="preserve">Requests to remove the node @iter points to. It may point to a
subdirectory node in which case all its children are removed recursively
as well.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_acl" c:identifier="inf_browser_set_acl">
        <doc xml:space="preserve">Changes the ACLs for the node @iter points to. Existing sheets that are not
in @sheet_set are left untouched. This operation is only allowed when the
ACL for the node @iter points to has been retrieved already with
inf_browser_query_acl(). Use inf_browser_has_acl() to check whether this
function can be called or whether the ACL needs to be queried first.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which to change ACLs.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">An #InfAclSheetSet with the sheets to update.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe" c:identifier="inf_browser_subscribe">
        <doc xml:space="preserve">Attempts to subscribe to the node @iter points to, i.e. obtain a
#InfSession representing its content. This also allows to change the
content of the node.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe_session"
              c:identifier="inf_browser_subscribe_session">
        <doc xml:space="preserve">This function emits the #InfBrowser::subscribe-session signal on @browser.
It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session a
subscription was made, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A session proxy for the newly subscribed session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest that was used to initiate the subscription,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_session"
              c:identifier="inf_browser_unsubscribe_session">
        <doc xml:space="preserve">This function emits the #InfBrowser::unsubscribe-session signal on
@browser. It is meant to be used by interface implementations only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session the
subscription was removed, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A session proxy for the unsubscribed session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The #InfRequest due to which the session was unsubscribed,
or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </parameter>
        </parameters>
      </method>
      <property name="status" transfer-ownership="none">
        <type name="BrowserStatus"/>
      </property>
      <glib:signal name="acl-account-added" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a new account is added to the browser,
and the browser supports account list notification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new #InfAclAccount.</doc>
            <type name="AclAccount"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which lead to the newly added account, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="acl-account-removed" when="last">
        <doc xml:space="preserve">This signal is emitted whenever an account is removed from the browser,
and the browser supports account list notification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The removed #InfAclAccount.</doc>
            <type name="AclAccount"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which lead to the removal of the account,
or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="acl-changed" when="last">
        <doc xml:space="preserve">This signal is emitted whenever an ACL for the node @iter points to
are changed. This signal is emitted whenever the ACL change for the
local user, the default user, or for a node that all ACLs have been
queried with inf_browser_query_acl().

The @sheet_set parameter contains only the ACL sheets that have
changed. In order to get the new full sheet set, call
inf_browser_get_acl().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which the ACL has changed.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet containing the changed ACL sheets.</doc>
            <type name="AclSheetSet"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which lead to the ACL being changed, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="acl-local-account-changed" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the account into which the local host
is logged into changes. This can happen for example on a delayed login,
or when the current account is deleted from the server in which case
the host is demoted to the default account.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The new local #InfAclAccount.</doc>
            <type name="AclAccount"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request which triggered the account change, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="begin-request" when="last" detailed="1">
        <doc xml:space="preserve">This signal is emitted whenever a request is made with the browser.
The signal is detailed with the request type, so that it is possible to
connect to e.g. "begin-request::add-subdirectory" to only get notified
about subdirectory creation requests.

If @iter is %NULL the request is a global request and not attached to a
particular node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node for which a request is made, or
%NULL.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request being made.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted whenever there was an asynchronous error with
the browser itself which was not the result of a particular user
request. The error may or may not be fatal. If it is fatal the browser
will also be closed which can be checked with the status property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError describing what went wrong.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="node-added" when="last">
        <doc xml:space="preserve">This signal is emitted when a node is added to the browser.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the newly added node.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request that lead to the node being added, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="node-removed" when="last">
        <doc xml:space="preserve">This signal is emitted just before a node is being removed from the
browser. The iterator is still valid and can be used to access the
node which will be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node being removed.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request that lead to the node being removed, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="subscribe-session" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the browser is subscribed to a session.
This can happen as a result of a inf_browser_subscribe() or
inf_browser_add_note() call, but it is also possible that a
subscription is initiated without user interaction.

If @iter is %NULL the session was a global session and not attached to
a particular node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which a subscription.
was made, or %NULL.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">The subscribed session.</doc>
            <type name="SessionProxy"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request that lead to the subscription, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="unsubscribe-session" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a session is detached from a browser
node. This can happen when a subscribed session is closed, or, in
the case of a server, if the session is idle for a long time it is
stored on disk and removed from memory.

Note that this signal does not mean that the corresponding
session can no longer be used. It only means that it is no longer
associated to a browser node, for example also when the browser node
is deleted. The session might still be intact, though, and can continue
even when it is detached from the browser.

In order to find out whether the local host was unsubscribed from a
session and the connection to the other session participants has been
lost, the #InfSession:subscription-group property should be monitored,
and if that property changes and
inf_session_get_subscription_group() returns %NULL afterwards,
it means the session is no longer connected.

If @iter is %NULL the session was a global session and not attached to
a particular node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node from which a subscription.
was removed, or %NULL.</doc>
            <type name="BrowserIter"/>
          </parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">The session to which the subscription was removed.</doc>
            <type name="SessionProxy"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">The request that lead to the unsubscription, or %NULL.</doc>
            <type name="Request"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="BrowserInterface"
            c:type="InfBrowserInterface"
            glib:is-gtype-struct-for="Browser">
      <doc xml:space="preserve">Signals and virtual functions for the #InfBrowser interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <doc xml:space="preserve">A #GError explaining what went wronig.</doc>
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="node_added">
        <callback name="node_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to the newly added node.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to add or explore the node,
or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="node_removed">
        <callback name="node_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to the node to be removed.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to delete the node, or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="subscribe_session">
        <callback name="subscribe_session">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session a
subscription was made, or %NULL.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">A session proxy for the newly subscribed session.</doc>
              <type name="SessionProxy" c:type="InfSessionProxy*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to initiate the subscription,
or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unsubscribe_session">
        <callback name="unsubscribe_session">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to the node to whose session the
subscription was removed, or %NULL.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">A session proxy for the unsubscribed session.</doc>
              <type name="SessionProxy" c:type="InfSessionProxy*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest due to which the session was unsubscribed,
or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="begin_request">
        <callback name="begin_request">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #infBrowserIter pointing to the node for which a request was made,
or %NULL.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The request which was made.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acl_account_added">
        <callback name="acl_account_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The new #InfAclAccount.</doc>
              <type name="AclAccount" c:type="const InfAclAccount*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to add the account, or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acl_account_removed">
        <callback name="acl_account_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The removed #InfAclAccount.</doc>
              <type name="AclAccount" c:type="const InfAclAccount*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to remove the account, or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acl_local_account_changed">
        <callback name="acl_local_account_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The new local #InfAclAccount.</doc>
              <type name="AclAccount" c:type="const InfAclAccount*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that triggered the account change, or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acl_changed">
        <callback name="acl_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iterator pointing to the node for which the ACL has changed.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="sheet_set" transfer-ownership="none">
              <doc xml:space="preserve">A #InfAclSheetSet containing the changed ACL sheets.</doc>
              <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">The #InfRequest that was used to change the ACL, or %NULL.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_root">
        <callback name="get_root">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was set or %FALSE if there is no root node, i.e.
the browser is not open.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       direction="out"
                       caller-allocates="1"
                       transfer-ownership="none">
              <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_next">
        <callback name="get_next">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_prev">
        <callback name="get_prev">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parent">
        <callback name="get_parent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_child">
        <callback name="get_child">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="explore">
        <callback name="explore">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest, or %NULL if @iter
points to a non-subdirectory node.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside
@browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_explored">
        <callback name="get_explored">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the node @iter points to has been explored
or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_subdirectory">
        <callback name="is_subdirectory">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the node @iter points to is a subdirectory node or
%FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_note">
        <callback name="add_note">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the node to add.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">The type of the node to add.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="acl"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
              <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
            </parameter>
            <parameter name="session"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfSession with a session of type @type, or
%NULL.</doc>
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="initial_subscribe" transfer-ownership="none">
              <doc xml:space="preserve">Whether to subscribe to the newly created session.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="8">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="8">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_subdirectory">
        <callback name="add_subdirectory">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a subdirectory node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the node to add.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="acl"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfAclSheetSet representing the initial ACL for
this node, or %NULL.</doc>
              <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_node">
        <callback name="remove_node">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_node_name">
        <callback name="get_node_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A string containing the node's name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_node_type">
        <callback name="get_node_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The node type as a string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="subscribe">
        <callback name="subscribe">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
get notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_session">
        <callback name="get_session">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A @InfSessionProxy which contains
the session. The proxy object can be used to join a user into the session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a leaf node inside @browser.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_pending_requests">
        <callback name="list_pending_requests">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">A list of
#InfRequest&lt;!-- --&gt;s. Free with g_slist_free() when no longer needed.</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Request"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">A #InfBrowserIter pointing to a node inside @browser,
or %NULL.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="request_type"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">The type of request to return pending requests
for, or %NULL.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_from_request">
        <callback name="iter_from_request">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @iter was moved or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">A #InfRequest which has not yet finished and which was
issued by @browser.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
            <parameter name="iter"
                       direction="out"
                       caller-allocates="1"
                       transfer-ownership="none">
              <doc xml:space="preserve">An uninitialized #InfBrowserIter.</doc>
              <type name="BrowserIter" c:type="InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_acl_default_account">
        <callback name="get_acl_default_account">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccount. The returned value is owned by
the browser and must not be freed.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_acl_local_account">
        <callback name="get_acl_local_account">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclAccount, or %NULL. The
returned value is owned by the browser and must not be freed.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_acl_account_list">
        <callback name="query_acl_account_list">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="2">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_acl_accounts">
        <callback name="lookup_acl_accounts">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest that can be used to
be notified when the request finishes, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="ids" transfer-ownership="none">
              <doc xml:space="preserve">An array of account IDs to look up.</doc>
              <array length="2" zero-terminated="0" c:type="InfAclAccountId*">
                <type name="AclAccountId" c:type="InfAclAccountId"/>
              </array>
            </parameter>
            <parameter name="n_ids" transfer-ownership="none">
              <doc xml:space="preserve">The number of elements in the array.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_acl_account_by_name">
        <callback name="lookup_acl_account_by_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest that can be used to be
notified when the request finishes, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the user account to look up.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_acl_account">
        <callback name="create_acl_account">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="crq" transfer-ownership="none">
              <doc xml:space="preserve">A certificate request.</doc>
              <type name="InfGnutls.X509Crq" c:type="gnutls_x509_crq_t"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_acl_account">
        <callback name="remove_acl_account">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest that can be used to
get notified when the request finishes or fails.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The ID of the account to remove.</doc>
              <type name="AclAccountId" c:type="InfAclAccountId"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_acl">
        <callback name="query_acl">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iterator pointing to a node for which to query the ACLs.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_acl">
        <callback name="has_acl">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE when the ACL sheet for @account is available or %FALSE
otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iterator pointing to a node for which to check full ACL
availability.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:space="preserve">The account to check ACL availability for, or 0.</doc>
              <type name="AclAccountId" c:type="InfAclAccountId"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_acl">
        <callback name="get_acl">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfAclSheetSet containing the requested ACL, or %NULL. The
returned value is owned by the #InfBrowser and should not be freed.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iterator pointing to a node for which to retrieve ACLs.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_acl">
        <callback name="set_acl">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest which can be used to
be notified when the request finishes.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="browser" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBrowser.</doc>
              <type name="Browser" c:type="InfBrowser*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve">An iterator pointing to the node for which to change ACLs.</doc>
              <type name="BrowserIter" c:type="const InfBrowserIter*"/>
            </parameter>
            <parameter name="sheet_set" transfer-ownership="none">
              <doc xml:space="preserve">An #InfAclSheetSet with the sheets to update.</doc>
              <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">The function to be called when the request finishes,
or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">Additional data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="BrowserIter"
            c:type="InfBrowserIter"
            glib:type-name="InfBrowserIter"
            glib:get-type="inf_browser_iter_get_type"
            c:symbol-prefix="browser_iter">
      <doc xml:space="preserve">The #InfBrowserIter structure is opaque, however it is guaranteed that
it can be copied by value and does not hold any dynamic data that would
need to be freed explicitly.</doc>
      <field name="node_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="node" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy" c:identifier="inf_browser_iter_copy">
        <doc xml:space="preserve">Makes a dynamically allocated copy of @iter. This should not be used by
applications because you can copy the structs by value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-allocated copy of @iter.</doc>
          <type name="BrowserIter" c:type="InfBrowserIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_browser_iter_free">
        <doc xml:space="preserve">Frees a #InfBrowserIter allocated by inf_browser_iter_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowserIter.</doc>
            <type name="BrowserIter" c:type="InfBrowserIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="BrowserStatus"
                 glib:type-name="InfBrowserStatus"
                 glib:get-type="inf_browser_status_get_type"
                 c:type="InfBrowserStatus">
      <doc xml:space="preserve">This enumeration contains possible status values for
#InfBrowser. Several operations, such as exploring a node or subscribing
to a session can only be performed when the browser is open (for example,
connected to a remote infinote server).</doc>
      <member name="closed"
              value="0"
              c:identifier="INF_BROWSER_CLOSED"
              glib:nick="closed">
        <doc xml:space="preserve">The browser is closed and cannot be used currently.</doc>
      </member>
      <member name="opening"
              value="1"
              c:identifier="INF_BROWSER_OPENING"
              glib:nick="opening">
        <doc xml:space="preserve">The browser is currently being opened but cannot be
used yet.</doc>
      </member>
      <member name="open"
              value="2"
              c:identifier="INF_BROWSER_OPEN"
              glib:nick="open">
        <doc xml:space="preserve">The browser is open and can be used to browse the
directory.</doc>
      </member>
    </enumeration>
    <interface name="Buffer"
               c:symbol-prefix="buffer"
               c:type="InfBuffer"
               glib:type-name="InfBuffer"
               glib:get-type="inf_buffer_get_type"
               glib:type-struct="BufferInterface">
      <doc xml:space="preserve">#InfBuffer is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="get_modified" invoker="get_modified">
        <doc xml:space="preserve">Indicates whether the buffer has been modified since the last call to
inf_buffer_set_modified() set the modification flag to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the buffer has been modified.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBuffer.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_modified" invoker="set_modified">
        <doc xml:space="preserve">Sets the modification flag of @buffer to @modified. You should normally set
the flag to %FALSE every time the document is saved onto disk. The buffer
itself will set it to %TRUE when it has been changed.

To get notified when the modification flag changes, connect to
GObject::notify for the InfBuffer:modified property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBuffer.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </instance-parameter>
          <parameter name="modified" transfer-ownership="none">
            <doc xml:space="preserve">Whether the buffer is considered modified or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_modified" c:identifier="inf_buffer_get_modified">
        <doc xml:space="preserve">Indicates whether the buffer has been modified since the last call to
inf_buffer_set_modified() set the modification flag to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the buffer has been modified.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBuffer.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_modified" c:identifier="inf_buffer_set_modified">
        <doc xml:space="preserve">Sets the modification flag of @buffer to @modified. You should normally set
the flag to %FALSE every time the document is saved onto disk. The buffer
itself will set it to %TRUE when it has been changed.

To get notified when the modification flag changes, connect to
GObject::notify for the InfBuffer:modified property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBuffer.</doc>
            <type name="Buffer" c:type="InfBuffer*"/>
          </instance-parameter>
          <parameter name="modified" transfer-ownership="none">
            <doc xml:space="preserve">Whether the buffer is considered modified or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="modified" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </interface>
    <record name="BufferInterface"
            c:type="InfBufferInterface"
            glib:is-gtype-struct-for="Buffer">
      <doc xml:space="preserve">The virtual methods of #InfBuffer.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_modified">
        <callback name="get_modified">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the buffer has been modified.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBuffer.</doc>
              <type name="Buffer" c:type="InfBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_modified">
        <callback name="set_modified">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">A #InfBuffer.</doc>
              <type name="Buffer" c:type="InfBuffer*"/>
            </parameter>
            <parameter name="modified" transfer-ownership="none">
              <doc xml:space="preserve">Whether the buffer is considered modified or not.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="CertUtilDescription" c:type="InfCertUtilDescription">
      <doc xml:space="preserve">This structure contains information that is used to generate a certificate
with the inf_cert_util_create_certificate(),
inf_cert_util_create_self_signed_certificate() and
inf_cert_util_create_signed_certificate() functions.</doc>
      <field name="validity" writable="1">
        <doc xml:space="preserve">The number of seconds the certificate is valid, beginning from
the current time.</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="dn_common_name" writable="1">
        <doc xml:space="preserve">The common name of the certificate, or %NULL.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="san_dnsname" writable="1">
        <doc xml:space="preserve">The DNS name of the certificate, or %NULL.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <record name="CertificateChain"
            c:type="InfCertificateChain"
            glib:type-name="InfCertificateChain"
            glib:get-type="inf_certificate_chain_get_type"
            c:symbol-prefix="certificate_chain">
      <doc xml:space="preserve">#InfCertificateChain is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_certificate_chain_new">
        <doc xml:space="preserve">Creates a new #InfCertificateChain with the given certificates. The @certs
array needs to be allocated with g_malloc. This function takes ownership
of @certs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCertificateChain.</doc>
          <type name="CertificateChain" c:type="InfCertificateChain*"/>
        </return-value>
        <parameters>
          <parameter name="certs" transfer-ownership="none">
            <doc xml:space="preserve">Array of certificates.</doc>
            <array length="1" zero-terminated="0" c:type="gnutls_x509_crt_t*">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </array>
          </parameter>
          <parameter name="n_certs" transfer-ownership="none">
            <doc xml:space="preserve">Number of elements in @certs.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_n_certificates"
              c:identifier="inf_certificate_chain_get_n_certificates">
        <doc xml:space="preserve">Returns the number of certificates in @chain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of certificates in @chain.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="const InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nth_certificate"
              c:identifier="inf_certificate_chain_get_nth_certificate"
              introspectable="0">
        <doc xml:space="preserve">Returns the @n&lt;!-- --&gt;th certificate in the chain.</doc>
        <return-value>
          <doc xml:space="preserve">The nth certificate in the chain.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="const InfCertificateChain*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">Index of the certificate to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_own_certificate"
              c:identifier="inf_certificate_chain_get_own_certificate"
              introspectable="0">
        <doc xml:space="preserve">TODO: Rename this function into something more appropriate.

Returns the first certificate in the chain.</doc>
        <return-value>
          <doc xml:space="preserve">The first certificate in the chain.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="const InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_raw"
              c:identifier="inf_certificate_chain_get_raw"
              introspectable="0">
        <doc xml:space="preserve">Returns the raw array of certificates in the chain.</doc>
        <return-value>
          <doc xml:space="preserve">An array of certificates owned by the chain.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="const InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root_certificate"
              c:identifier="inf_certificate_chain_get_root_certificate"
              introspectable="0">
        <doc xml:space="preserve">Returns the last certificate in the chain.</doc>
        <return-value>
          <doc xml:space="preserve">The last certificate in the chain.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="const InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="inf_certificate_chain_ref">
        <doc xml:space="preserve">Increases the reference count of @chain by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The same @chain.</doc>
          <type name="CertificateChain" c:type="InfCertificateChain*"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain:</doc>
            <type name="CertificateChain" c:type="InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="inf_certificate_chain_unref">
        <doc xml:space="preserve">Decreases the reference count of @chain by one. If the reference count
reaches zero, then @chain is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="chain" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateChain.</doc>
            <type name="CertificateChain" c:type="InfCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="CertificateCredentials"
            c:type="InfCertificateCredentials"
            glib:type-name="InfCertificateCredentials"
            glib:get-type="inf_certificate_credentials_get_type"
            c:symbol-prefix="certificate_credentials">
      <doc xml:space="preserve">#InfCertificateCredentials is an opaque data type. You should only access
it via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_certificate_credentials_new">
        <doc xml:space="preserve">Creates a new #InfCertificateCredentials with an initial reference count
of 1. Use inf_certificate_credentials_get() to access the underlying
#gnutls_certificate_credentials_t.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCertificateCredentials. Free with
inf_certificate_credentials_unref() when no longer needed.</doc>
          <type name="CertificateCredentials"
                c:type="InfCertificateCredentials*"/>
        </return-value>
      </constructor>
      <method name="get"
              c:identifier="inf_certificate_credentials_get"
              introspectable="0">
        <doc xml:space="preserve">Provides access to the @creds' underlying
#gnutls_certificate_credentials_t.</doc>
        <return-value>
          <doc xml:space="preserve">@creds' #gnutls_certificate_credentials_t.</doc>
          <type name="InfGnutls.CertificateCredentials"
                c:type="gnutls_certificate_credentials_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="creds" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateCredentials.</doc>
            <type name="CertificateCredentials"
                  c:type="InfCertificateCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="inf_certificate_credentials_ref">
        <doc xml:space="preserve">Increases the reference count of @creds by 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed #InfCertificateCredentials, @creds.</doc>
          <type name="CertificateCredentials"
                c:type="InfCertificateCredentials*"/>
        </return-value>
        <parameters>
          <instance-parameter name="creds" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateCredentials.</doc>
            <type name="CertificateCredentials"
                  c:type="InfCertificateCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="inf_certificate_credentials_unref">
        <doc xml:space="preserve">Decreases the reference count of @creds by 1. If its reference count
reaches 0, then the #InfCertificateCredentials will be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="creds" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateCredentials.</doc>
            <type name="CertificateCredentials"
                  c:type="InfCertificateCredentials*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="CertificateVerify"
           c:symbol-prefix="certificate_verify"
           c:type="InfCertificateVerify"
           parent="GObject.Object"
           glib:type-name="InfCertificateVerify"
           glib:get-type="inf_certificate_verify_get_type"
           glib:type-struct="CertificateVerifyClass">
      <doc xml:space="preserve">#InfCertificateVerify is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_certificate_verify_new">
        <doc xml:space="preserve">Creates a new #InfCertificateVerify. For each new client-side
#InfXmppConnection in @xmpp_manager, the certificate manager will verify
the server's certificate.

If the certificate is contained in @known_hosts_file, or is issued by a
trusted CA, then the certificate is accepted automatically. Otherwise,
the #InfCertificateVerify::check-certificate signal is emitted for a manual
check of the certificate to be performed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCertificateVerify.</doc>
          <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
        </return-value>
        <parameters>
          <parameter name="xmpp_manager" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmppManager whose #InfXmppConnection&lt;!-- --&gt;s to
manage the certificates for.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </parameter>
          <parameter name="known_hosts_file"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Path pointing to a file
that contains certificates of known hosts, or %NULL.</doc>
            <type name="filename" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="check_cancelled">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="verify" transfer-ownership="none">
            <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="check_certificate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="verify" transfer-ownership="none">
            <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
          <parameter name="certificate_chain" transfer-ownership="none">
            <type name="CertificateChain" c:type="InfCertificateChain*"/>
          </parameter>
          <parameter name="pinned_certificate" transfer-ownership="none">
            <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="CertificateVerifyFlags"
                  c:type="InfCertificateVerifyFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="checked" c:identifier="inf_certificate_verify_checked">
        <doc xml:space="preserve">This function should be called as a response to the
#InfCertificateVerify::check-certificate signal being emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="verify" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCertificateVerify.</doc>
            <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmppConnection whose certificate has been checked.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the certificate of @connection should be accepted, or
%FALSE if it should be rejected.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="known-hosts-file" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="xmpp-manager"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="XmppManager"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="check-cancelled" when="last">
        <doc xml:space="preserve">This signal is emitted when a manual certificate check as initiated
with the #InfCertificateVerify::check-certificate signal should be
cancelled. After this signal has been emitted,
inf_certificate_verify_checked() should not be called anymore for the
specified connection.

This typically happens when the connection to the remote host is lost
while the certificate check is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to the remote host whose certificate is
being verified.</doc>
            <type name="XmppConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="check-certificate" when="last">
        <doc xml:space="preserve">This signal is emitted every time a certificate presented by a remote
host needs to be checked manually. This happens when the issuer of the
certificate is not in the list of trusted CAs, or the certificate was
issued for a different hostname than we expected. In this case, if the
certificate is accepted manually, it will be pinned, so that next time a
connection is made to the same host under the same hostname, the
certificate is accepted automatically.

Consumers of this class should listen to this signal and call
inf_certificate_verify_checked() when they finished the manual
certificate check.

The @pinned_certificate instance is valid until either
inf_certificate_verify_checked() is called or the
#InfCertificateVerify::check-cancelled signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to the remote host whose certificate is
being verified.</doc>
            <type name="XmppConnection"/>
          </parameter>
          <parameter name="certificate_chain" transfer-ownership="none">
            <doc xml:space="preserve">The certificate chain presented by the remote host.</doc>
            <type name="CertificateChain"/>
          </parameter>
          <parameter name="pinned_certificate" transfer-ownership="none">
            <doc xml:space="preserve">The certificate that we have pinned for this
host, or %NULL.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags explaining why this certificate needs to be checked.</doc>
            <type name="CertificateVerifyFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CertificateVerifyClass"
            c:type="InfCertificateVerifyClass"
            glib:is-gtype-struct-for="CertificateVerify">
      <doc xml:space="preserve">This structure contains default signal handlers for #InfCertificateVerify.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="check_certificate">
        <callback name="check_certificate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="verify" transfer-ownership="none">
              <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmppConnection" c:type="InfXmppConnection*"/>
            </parameter>
            <parameter name="certificate_chain" transfer-ownership="none">
              <type name="CertificateChain" c:type="InfCertificateChain*"/>
            </parameter>
            <parameter name="pinned_certificate" transfer-ownership="none">
              <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="CertificateVerifyFlags"
                    c:type="InfCertificateVerifyFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_cancelled">
        <callback name="check_cancelled">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="verify" transfer-ownership="none">
              <type name="CertificateVerify" c:type="InfCertificateVerify*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmppConnection" c:type="InfXmppConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="CertificateVerifyFlags"
              glib:type-name="InfCertificateVerifyFlags"
              glib:get-type="inf_certificate_verify_flags_get_type"
              c:type="InfCertificateVerifyFlags">
      <doc xml:space="preserve">Various flags for why a certificate is not trusted.</doc>
      <member name="hostname_mismatch"
              value="1"
              c:identifier="INF_CERTIFICATE_VERIFY_HOSTNAME_MISMATCH"
              glib:nick="hostname-mismatch">
        <doc xml:space="preserve">The hostname of the
machine connected to does not match the one from the certificate.</doc>
      </member>
      <member name="issuer_not_known"
              value="2"
              c:identifier="INF_CERTIFICATE_VERIFY_ISSUER_NOT_KNOWN"
              glib:nick="issuer-not-known">
        <doc xml:space="preserve">The issuer of the
certificate is not trusted, i.e. is not in the list of trusted CAs.</doc>
      </member>
      <member name="not_pinned"
              value="4"
              c:identifier="INF_CERTIFICATE_VERIFY_NOT_PINNED"
              glib:nick="not-pinned">
        <doc xml:space="preserve">We have pinned a certificate for this
host, but the certificate presented is a different one.</doc>
      </member>
    </bitfield>
    <class name="ChatBuffer"
           c:symbol-prefix="chat_buffer"
           c:type="InfChatBuffer"
           parent="GObject.Object"
           glib:type-name="InfChatBuffer"
           glib:get-type="inf_chat_buffer_get_type"
           glib:type-struct="ChatBufferClass">
      <doc xml:space="preserve">#InfChatBuffer is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="Buffer"/>
      <constructor name="new" c:identifier="inf_chat_buffer_new">
        <doc xml:space="preserve">Creates a new #InfChatBuffer which contains no initial messages. @size
specifies how many messages to store before dropping old messages.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfChatBuffer.</doc>
          <type name="ChatBuffer" c:type="InfChatBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The number of messages to store.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="add_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="ChatBufferMessage"
                  c:type="const InfChatBufferMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_emote_message"
              c:identifier="inf_chat_buffer_add_emote_message">
        <doc xml:space="preserve">Adds a new emote message to the chat buffer. If the buffer is full
(meaning the number of messages in the buffer equals its size), then an
old message will get discarded. If the message to be added is older than
all other messages in the buffer, then it will not be added at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser who wrote the message.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The message text.</doc>
            <array length="2" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The length of @message, in bytes.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">The time at which the user has written the message.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to set for the message to add.</doc>
            <type name="ChatBufferMessageFlags"
                  c:type="InfChatBufferMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_message" c:identifier="inf_chat_buffer_add_message">
        <doc xml:space="preserve">Adds a new message to the chat buffer. If the buffer is full (meaning the
number of messages in the buffer equals its size), then an old message will
get discarded. If the message to be added is older than all other messages
in the buffer, then it will not be added at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="by" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser who wrote the message.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The message text.</doc>
            <array length="2" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The length of @message, in bytes.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">The time at which the user has written the message.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to set for the message to add.</doc>
            <type name="ChatBufferMessageFlags"
                  c:type="InfChatBufferMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_userjoin_message"
              c:identifier="inf_chat_buffer_add_userjoin_message">
        <doc xml:space="preserve">Adds a new userjoin message to the chat buffer. If the buffer is full
(meaning the number of messages in the buffer equals its size), then an
old message will get discarded. If the message to be added is older than
all other messages in the buffer, then it will not be added at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser who wrote the message.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">The time at which the user has written the message.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to set for the message to add.</doc>
            <type name="ChatBufferMessageFlags"
                  c:type="InfChatBufferMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_userpart_message"
              c:identifier="inf_chat_buffer_add_userpart_message">
        <doc xml:space="preserve">Adds a new userpart message to the chat buffer. If the buffer is full
(meaning the number of messages in the buffer equals its size), then an
old message will get discarded. If the message to be added is older than
all other messages in the buffer, then it will not be added at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser who wrote the message.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">The time at which the user has written the message.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to set for the message to add.</doc>
            <type name="ChatBufferMessageFlags"
                  c:type="InfChatBufferMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="inf_chat_buffer_get_message">
        <doc xml:space="preserve">Returns the message with the given index from the buffer. The oldest
message in the buffer has index 0, and the most recent one has index
inf_chat_buffer_get_n_messages() - 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #InfChatBufferMessage with the given index.</doc>
          <type name="ChatBufferMessage" c:type="const InfChatBufferMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">The index of the message to obtain.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_messages"
              c:identifier="inf_chat_buffer_get_n_messages">
        <doc xml:space="preserve">Returns the number of messages in the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of messages in the buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="inf_chat_buffer_get_size">
        <doc xml:space="preserve">Returns the size of the chat buffer, which is the maximum number of
messages that can be stored in the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of messages in the chat buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBuffer.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="size"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="add-message" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a message has been added to @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #InfChatBufferMessage that was received.</doc>
            <type name="ChatBufferMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChatBufferClass"
            c:type="InfChatBufferClass"
            glib:is-gtype-struct-for="ChatBuffer">
      <doc xml:space="preserve">This structure contains default signal handlers for #InfChatBuffer.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_message">
        <callback name="add_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <type name="ChatBuffer" c:type="InfChatBuffer*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="ChatBufferMessage"
                    c:type="const InfChatBufferMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ChatBufferMessage"
            c:type="InfChatBufferMessage"
            glib:type-name="InfChatBufferMessage"
            glib:get-type="inf_chat_buffer_message_get_type"
            c:symbol-prefix="chat_buffer_message">
      <doc xml:space="preserve">Represents a chat message.</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">The #InfChatBufferMessageType of the message.</doc>
        <type name="ChatBufferMessageType" c:type="InfChatBufferMessageType"/>
      </field>
      <field name="user" writable="1">
        <doc xml:space="preserve">The #InfUser that issued the message.</doc>
        <type name="User" c:type="InfUser*"/>
      </field>
      <field name="text" writable="1">
        <doc xml:space="preserve">The UTF-8 encoded text of the message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">The length of the message, in bytes.</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="time" writable="1">
        <doc xml:space="preserve">The time at which the message was received.</doc>
        <type name="glong" c:type="time_t"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Additional flags for the message, see #InfChatBufferMessageFlags.</doc>
        <type name="ChatBufferMessageFlags"
              c:type="InfChatBufferMessageFlags"/>
      </field>
      <method name="copy" c:identifier="inf_chat_buffer_message_copy">
        <doc xml:space="preserve">Creates a copy of the given message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfChatBufferMessage. Free with
inf_chat_buffer_message_free() when no longer needed.</doc>
          <type name="ChatBufferMessage" c:type="InfChatBufferMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #InfChatBufferMessage to copy.</doc>
            <type name="ChatBufferMessage"
                  c:type="const InfChatBufferMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_chat_buffer_message_free">
        <doc xml:space="preserve">Frees the given #InfChatBufferMessage which must have been created with
inf_chat_buffer_message_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatBufferMessage.</doc>
            <type name="ChatBufferMessage" c:type="InfChatBufferMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="ChatBufferMessageFlags"
              glib:type-name="InfChatBufferMessageFlags"
              glib:get-type="inf_chat_buffer_message_flags_get_type"
              c:type="InfChatBufferMessageFlags">
      <doc xml:space="preserve">Possible chat message flags.</doc>
      <member name="backlog"
              value="1"
              c:identifier="INF_CHAT_BUFFER_MESSAGE_BACKLOG"
              glib:nick="backlog">
        <doc xml:space="preserve">The message is a backlog message, i.e.
it originated in a previous session.</doc>
      </member>
    </bitfield>
    <enumeration name="ChatBufferMessageType"
                 glib:type-name="InfChatBufferMessageType"
                 glib:get-type="inf_chat_buffer_message_type_get_type"
                 c:type="InfChatBufferMessageType">
      <doc xml:space="preserve">Possible chat message types.</doc>
      <member name="normal"
              value="0"
              c:identifier="INF_CHAT_BUFFER_MESSAGE_NORMAL"
              glib:nick="normal">
        <doc xml:space="preserve">A normal chat message.</doc>
      </member>
      <member name="emote"
              value="1"
              c:identifier="INF_CHAT_BUFFER_MESSAGE_EMOTE"
              glib:nick="emote">
        <doc xml:space="preserve">An emote chat message (/me is doing
something).</doc>
      </member>
      <member name="userjoin"
              value="2"
              c:identifier="INF_CHAT_BUFFER_MESSAGE_USERJOIN"
              glib:nick="userjoin">
        <doc xml:space="preserve">A user join notification.</doc>
      </member>
      <member name="userpart"
              value="3"
              c:identifier="INF_CHAT_BUFFER_MESSAGE_USERPART"
              glib:nick="userpart">
        <doc xml:space="preserve">A user part notification.</doc>
      </member>
    </enumeration>
    <class name="ChatSession"
           c:symbol-prefix="chat_session"
           c:type="InfChatSession"
           parent="Session"
           glib:type-name="InfChatSession"
           glib:get-type="inf_chat_session_get_type"
           glib:type-struct="ChatSessionClass">
      <doc xml:space="preserve">#InfChatSession is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="CommunicationObject"/>
      <constructor name="new" c:identifier="inf_chat_session_new">
        <doc xml:space="preserve">Creates a new #InfChatSession with the messages contained in @buffer as
initial messages. The communication manager is used to send and receive
requests from subscription and synchronization.

If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
session will initially be synchronized, meaning an initial backlog is
retrieved from @sync_connection (which must not be %NULL in this case). If
you are subscribed to the session, set the subscription group via
inf_session_set_subscription_group().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfChatSession.</doc>
          <type name="ChatSession" c:type="InfChatSession*"/>
        </return-value>
        <parameters>
          <parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #InfChatBuffer to use for the session.</doc>
            <type name="ChatBuffer" c:type="InfChatBuffer*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">Initial status of the session. If this is
%INF_SESSION_SYNCHRONIZING or %INF_SESSION_PRESYNC, then @sync_group and
@sync_connection need to be set.</doc>
            <type name="SessionStatus" c:type="InfSessionStatus"/>
          </parameter>
          <parameter name="sync_group" transfer-ownership="none">
            <doc xml:space="preserve">A group in which the session is synchronized. Ignored if
@status is %INF_SESSION_RUNNING.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="sync_connection" transfer-ownership="none">
            <doc xml:space="preserve">A connection to synchronize the session from. Ignored if
@status is %INF_SESSION_RUNNING.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="receive_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="ChatSession" c:type="InfChatSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="ChatBufferMessage"
                  c:type="const InfChatBufferMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="ChatSession" c:type="InfChatSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="ChatBufferMessage"
                  c:type="const InfChatBufferMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="set_log_file"
              c:identifier="inf_chat_session_set_log_file"
              throws="1">
        <doc xml:space="preserve">Sets a file onto which all received messages are appended. The file is
created if it does not exist. If a previous log file was set, then it is
closed before opening the new file.

Backlog messages received upon synchronization are not logged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the log file could be opened, %FALSE otherwise (in which
case @error is set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfChatSession.</doc>
            <type name="ChatSession" c:type="InfChatSession*"/>
          </instance-parameter>
          <parameter name="log_file" transfer-ownership="none">
            <doc xml:space="preserve">A filename to store all received messages into.</doc>
            <type name="filename" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="log-file" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Session" c:type="InfSession"/>
      </field>
      <glib:signal name="receive-message" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a message has been received. If the
session is in %INF_SESSION_SYNCHRONIZING state the received message was
a backlog message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #InfChatBufferMessage that was received.</doc>
            <type name="ChatBufferMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="send-message" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a message is sent. Messages can be sent
by calling inf_chat_buffer_add_message() or
inf_chat_buffer_add_emote_message() on the session's #InfChatBuffer.
Messages of type %INF_CHAT_BUFFER_MESSAGE_USERJOIN or
%INF_CHAT_BUFFER_MESSAGE_USERPART can not be sent explicitely, so this
signal will never be emitted for such messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #InfChatBufferMessage that is sent.</doc>
            <type name="ChatBufferMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChatSessionClass"
            c:type="InfChatSessionClass"
            glib:is-gtype-struct-for="ChatSession">
      <doc xml:space="preserve">This structure contains default signal handlers for #InfChatSession.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="SessionClass" c:type="InfSessionClass"/>
      </field>
      <field name="receive_message">
        <callback name="receive_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="ChatSession" c:type="InfChatSession*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="ChatBufferMessage"
                    c:type="const InfChatBufferMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_message">
        <callback name="send_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="ChatSession" c:type="InfChatSession*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="ChatBufferMessage"
                    c:type="const InfChatBufferMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ChatSessionError" c:type="InfChatSessionError">
      <doc xml:space="preserve">Errors that can occur with a chat session, especially in the
process_xml_sync and process_xml_run vfunc implementations.</doc>
      <member name="type_invalid"
              value="0"
              c:identifier="INF_CHAT_SESSION_ERROR_TYPE_INVALID">
        <doc xml:space="preserve">An invalid message type was sent.</doc>
      </member>
      <member name="no_such_user"
              value="1"
              c:identifier="INF_CHAT_SESSION_ERROR_NO_SUCH_USER">
        <doc xml:space="preserve">A message referred to a nonexisting
user.</doc>
      </member>
      <member name="failed"
              value="2"
              c:identifier="INF_CHAT_SESSION_ERROR_FAILED">
        <doc xml:space="preserve">Generic error code when no further reason
of failure is known.</doc>
      </member>
    </enumeration>
    <class name="CommunicationCentralFactory"
           c:symbol-prefix="communication_central_factory"
           c:type="InfCommunicationCentralFactory"
           parent="GObject.Object"
           glib:type-name="InfCommunicationCentralFactory"
           glib:get-type="inf_communication_central_factory_get_type"
           glib:type-struct="CommunicationCentralFactoryClass">
      <doc xml:space="preserve">#InfCommunicationCentralFactory is an opaque data type. You should only
access it * via the public API functions.</doc>
      <implements name="CommunicationFactory"/>
      <function name="get_default"
                c:identifier="inf_communication_central_factory_get_default">
        <doc xml:space="preserve">Returns the default #InfCommunicationCentralFactory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfCommunicationCentralFactory. It should not
be unrefed or freed.</doc>
          <type name="CommunicationFactory" c:type="InfCommunicationFactory*"/>
        </return-value>
      </function>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CommunicationCentralFactoryClass"
            c:type="InfCommunicationCentralFactoryClass"
            glib:is-gtype-struct-for="CommunicationCentralFactory">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="CommunicationCentralMethod"
           c:symbol-prefix="communication_central_method"
           c:type="InfCommunicationCentralMethod"
           parent="GObject.Object"
           glib:type-name="InfCommunicationCentralMethod"
           glib:get-type="inf_communication_central_method_get_type"
           glib:type-struct="CommunicationCentralMethodClass">
      <doc xml:space="preserve">#InfCommunicationCentralMethod is an opaque data type. You should only
access it * via the public API functions.</doc>
      <implements name="CommunicationMethod"/>
      <property name="group"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationGroup"/>
      </property>
      <property name="registry"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationRegistry"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CommunicationCentralMethodClass"
            c:type="InfCommunicationCentralMethodClass"
            glib:is-gtype-struct-for="CommunicationCentralMethod">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="CommunicationFactory"
               c:symbol-prefix="communication_factory"
               c:type="InfCommunicationFactory"
               glib:type-name="InfCommunicationFactory"
               glib:get-type="inf_communication_factory_get_type"
               glib:type-struct="CommunicationFactoryInterface">
      <doc xml:space="preserve">#InfCommunicationFactory is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="instantiate" invoker="instantiate">
        <doc xml:space="preserve">Creates a new #InfCommunicationMethod for @network and @method_name. The
factory needs to support that method, see
inf_communication_factory_supports_method().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCommunicationMethod.</doc>
          <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
        </return-value>
        <parameters>
          <instance-parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
            <type name="CommunicationFactory"
                  c:type="InfCommunicationFactory*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry at which the created method can
register connections.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The #InfCommunicationGroup for which to create the method.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_method" invoker="supports_method">
        <doc xml:space="preserve">Returns whether @factory supports creating methods that implement
@method_name as communication method for connections on @network
(see #InfXmlConnection:network).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @factory supports the given network and method name.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
            <type name="CommunicationFactory"
                  c:type="InfCommunicationFactory*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="instantiate"
              c:identifier="inf_communication_factory_instantiate">
        <doc xml:space="preserve">Creates a new #InfCommunicationMethod for @network and @method_name. The
factory needs to support that method, see
inf_communication_factory_supports_method().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCommunicationMethod.</doc>
          <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
        </return-value>
        <parameters>
          <instance-parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
            <type name="CommunicationFactory"
                  c:type="InfCommunicationFactory*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry at which the created method can
register connections.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The #InfCommunicationGroup for which to create the method.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_method"
              c:identifier="inf_communication_factory_supports_method">
        <doc xml:space="preserve">Returns whether @factory supports creating methods that implement
@method_name as communication method for connections on @network
(see #InfXmlConnection:network).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @factory supports the given network and method name.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
            <type name="CommunicationFactory"
                  c:type="InfCommunicationFactory*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="CommunicationFactoryInterface"
            c:type="InfCommunicationFactoryInterface"
            glib:is-gtype-struct-for="CommunicationFactory">
      <doc xml:space="preserve">The virtual methods of #InfCommunicationFactory. These handle instantiating
a #InfCommunicationMethod for a #InfCommunicationGroup.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="supports_method">
        <callback name="supports_method">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether @factory supports the given network and method name.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="factory" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
              <type name="CommunicationFactory"
                    c:type="InfCommunicationFactory*"/>
            </parameter>
            <parameter name="network" transfer-ownership="none">
              <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="method_name" transfer-ownership="none">
              <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="instantiate">
        <callback name="instantiate">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A new #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </return-value>
          <parameters>
            <parameter name="factory" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationFactory.</doc>
              <type name="CommunicationFactory"
                    c:type="InfCommunicationFactory*"/>
            </parameter>
            <parameter name="network" transfer-ownership="none">
              <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="method_name" transfer-ownership="none">
              <doc xml:space="preserve">A method identifier, such as "central" or "groupchat".</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="registry" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationRegistry at which the created method can
register connections.</doc>
              <type name="CommunicationRegistry"
                    c:type="InfCommunicationRegistry*"/>
            </parameter>
            <parameter name="group" transfer-ownership="none">
              <doc xml:space="preserve">The #InfCommunicationGroup for which to create the method.</doc>
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="CommunicationGroup"
           c:symbol-prefix="communication_group"
           c:type="InfCommunicationGroup"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="InfCommunicationGroup"
           glib:get-type="inf_communication_group_get_type"
           glib:type-struct="CommunicationGroupClass">
      <doc xml:space="preserve">#InfCommunicationGroup is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="get_method">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_publisher_id" invoker="get_publisher_id">
        <doc xml:space="preserve">Returns a host identifier for the group's publisher (see
#InfXmlConnection:local-id and #InfXmlConnection:remote-id). If the local
host is the publisher, then this will simply return @for_connection's
local ID, otherwise the remote ID of the connection to the publisher on
@for_connection's network is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The publisher's host ID. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="for_connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="member_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="member_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="cancel_messages"
              c:identifier="inf_communication_group_cancel_messages">
        <doc xml:space="preserve">Stops all messages scheduled to be sent to @connection from being sent.
Messages for which inf_communication_object_enqueued() has already been
called cannot be cancelled anymore.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection for which to cancel messages.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method_for_connection"
              c:identifier="inf_communication_group_get_method_for_connection">
        <doc xml:space="preserve">Returns the method name of the method used for communication on @conn's
network within @group. @conn does not need to be a member of @grp for this
function to be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A method name. The string is owned by the group, you don't need
to free it.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="grp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection for which to retrieve the method.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method_for_network"
              c:identifier="inf_communication_group_get_method_for_network">
        <doc xml:space="preserve">Returns the method name of the method used for communication on @network
within @group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A method name. The string is owned by the group, you don't need
to free it.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network specifier, such as "tcp/ip" or "jabber".</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="inf_communication_group_get_name">
        <doc xml:space="preserve">Returns the name of the group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the group. The returned string is owned by the group,
you don't need to free it.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_publisher_id"
              c:identifier="inf_communication_group_get_publisher_id">
        <doc xml:space="preserve">Returns a host identifier for the group's publisher (see
#InfXmlConnection:local-id and #InfXmlConnection:remote-id). If the local
host is the publisher, then this will simply return @for_connection's
local ID, otherwise the remote ID of the connection to the publisher on
@for_connection's network is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The publisher's host ID. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="for_connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_target"
              c:identifier="inf_communication_group_get_target">
        <doc xml:space="preserve">Returns the group's target. The target of a group is the
#InfCommunicationObject to which received and sent messages are reported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfCommunicationGroup, or %NULL.</doc>
          <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_member"
              c:identifier="inf_communication_group_is_member">
        <doc xml:space="preserve">Returns whether @connection is a member of @group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @connection is a member of @group, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_group_message"
              c:identifier="inf_communication_group_send_group_message">
        <doc xml:space="preserve">Sends a message to all members of @group. This function takes ownership
of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message"
              c:identifier="inf_communication_group_send_message">
        <doc xml:space="preserve">Sends a message @connection which must be a member of @group. @connection
needs to be a member of this group. This function takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to which to send the message.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_target"
              c:identifier="inf_communication_group_set_target">
        <doc xml:space="preserve">Sets the group's target. The target of a group is the
#InfCommunicationObject to which received and sent messages are reported.
If @target is %NULL, then the target will be unset.

You can safely call this function with an object that holds a reference on
the group since the #InfCommunicationGroup only holds a weak reference to
its @target. This means that you need to keep a reference on @target
yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject, or %NULL.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </parameter>
        </parameters>
      </method>
      <property name="communication-manager"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationManager"/>
      </property>
      <property name="communication-registry"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationRegistry"/>
      </property>
      <property name="name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="target" writable="1" transfer-ownership="none">
        <type name="CommunicationObject"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="member-added" when="last">
        <doc xml:space="preserve">This signal is emitted when a connection has been added to the group.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The newly joined connection.</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="member-removed" when="last">
        <doc xml:space="preserve">This signal is emitted when a connection has been removed from the group.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection that was removed</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="CommunicationGroupClass"
            c:type="InfCommunicationGroupClass"
            glib:is-gtype-struct-for="CommunicationGroup">
      <doc xml:space="preserve">The virtual methods and default signal handlers of #InfCommunicationGroup.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="member_added">
        <callback name="member_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="group" transfer-ownership="none">
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="member_removed">
        <callback name="member_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="group" transfer-ownership="none">
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_method">
        <callback name="get_method">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="group" transfer-ownership="none">
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <type name="guint" c:type="unsigned int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_publisher_id">
        <callback name="get_publisher_id">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The publisher's host ID. Free with g_free().</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="group" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
            <parameter name="for_connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="CommunicationHostedGroup"
           c:symbol-prefix="communication_hosted_group"
           c:type="InfCommunicationHostedGroup"
           parent="CommunicationGroup"
           glib:type-name="InfCommunicationHostedGroup"
           glib:get-type="inf_communication_hosted_group_get_type"
           glib:type-struct="CommunicationHostedGroupClass">
      <doc xml:space="preserve">#InfCommunicationHostedGroup is an opaque data type. You should only
access it via the public API functions.</doc>
      <method name="add_member"
              c:identifier="inf_communication_hosted_group_add_member">
        <doc xml:space="preserve">Adds @connection as a member to @group. On the remote site, a
#InfCommunicationJoinedGroup with the same name and method used for
@connection (see inf_communication_group_get_method_for_connection())
needs to be created for successful communication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationHostedGroup"
                  c:type="InfCommunicationHostedGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection to add to group.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_method"
              c:identifier="inf_communication_hosted_group_add_method">
        <doc xml:space="preserve">Adds a method to the hosted group. When a connection from a given network
is added to the group the first time, a #InfCommunicationMethod is
instantiated to handle messaging for the group within this network.
The first method added will be tried first. If the communication manager
does support it (meaning inf_communication_manager_get_factory_for() for
the connection's network and the chosen method returns non-%NULL), then it
will be used, otherwise the next method will be tried, etc. If no method
is supported, or no methods are added to the group, then the "central"
method will be used as a fallback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationHostedGroup.</doc>
            <type name="CommunicationHostedGroup"
                  c:type="InfCommunicationHostedGroup*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">The method name to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_member"
              c:identifier="inf_communication_hosted_group_remove_member">
        <doc xml:space="preserve">Removes @connection's membership from @group. On the remote site, the
corresponding #InfCommunicationJoinedGroup needs to be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="grp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationHostedGroup"
                  c:type="InfCommunicationHostedGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The @InfXmlConnection to remove from the group.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="CommunicationGroup" c:type="InfCommunicationGroup"/>
      </field>
    </class>
    <record name="CommunicationHostedGroupClass"
            c:type="InfCommunicationHostedGroupClass"
            glib:is-gtype-struct-for="CommunicationHostedGroup">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="CommunicationGroupClass"
              c:type="InfCommunicationGroupClass"/>
      </field>
    </record>
    <class name="CommunicationJoinedGroup"
           c:symbol-prefix="communication_joined_group"
           c:type="InfCommunicationJoinedGroup"
           parent="CommunicationGroup"
           glib:type-name="InfCommunicationJoinedGroup"
           glib:get-type="inf_communication_joined_group_get_type"
           glib:type-struct="CommunicationJoinedGroupClass">
      <doc xml:space="preserve">#InfCommunicationJoinedGroup is an opaque data type. You should only
access it via the public API functions.</doc>
      <method name="get_publisher"
              c:identifier="inf_communication_joined_group_get_publisher">
        <doc xml:space="preserve">Returns a #InfXmlConnection to the group's publisher, or %NULL if the
publisher is no longer a group member.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfXmlConnection, or %NULL.</doc>
          <type name="XmlConnection" c:type="InfXmlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="g" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationJoinedGroup.</doc>
            <type name="CommunicationJoinedGroup"
                  c:type="InfCommunicationJoinedGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_member"
              c:identifier="inf_communication_joined_group_remove_member">
        <doc xml:space="preserve">Removes @connection as @grp's member. On the remote site, the
corresponding #InfCommunicationGroup needs to be freed (which may be a
#InfCommunicationJoinedGroup or a #InfCommunicationHostedGroup).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="grp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationJoinedGroup.</doc>
            <type name="CommunicationJoinedGroup"
                  c:type="InfCommunicationJoinedGroup*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A connection to a member of @grp.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <property name="method"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="publisher"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="XmlConnection"/>
      </property>
      <field name="parent_instance" readable="0" private="1">
        <type name="CommunicationGroup" c:type="InfCommunicationGroup"/>
      </field>
    </class>
    <record name="CommunicationJoinedGroupClass"
            c:type="InfCommunicationJoinedGroupClass"
            glib:is-gtype-struct-for="CommunicationJoinedGroup">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="CommunicationGroupClass"
              c:type="InfCommunicationGroupClass"/>
      </field>
    </record>
    <class name="CommunicationManager"
           c:symbol-prefix="communication_manager"
           c:type="InfCommunicationManager"
           parent="GObject.Object"
           glib:type-name="InfCommunicationManager"
           glib:get-type="inf_communication_manager_get_type"
           glib:type-struct="CommunicationManagerClass">
      <doc xml:space="preserve">#InfCommunicationManager is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_communication_manager_new">
        <doc xml:space="preserve">Creates a new #InfCommunicationManager.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCommunicationManager.</doc>
          <type name="CommunicationManager" c:type="InfCommunicationManager*"/>
        </return-value>
      </constructor>
      <method name="add_factory"
              c:identifier="inf_communication_manager_add_factory">
        <doc xml:space="preserve">Adds a new #InfCommunicationFactory to @manager. This makes @manager
support all method/network combinations that @factory supports. If multiple
added factories support the same combination, the one which was added first
will be used to instantiate the #InfCommunicationMethod.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </instance-parameter>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:space="preserve">The #InfCommunicationFactory to add.</doc>
            <type name="CommunicationFactory"
                  c:type="InfCommunicationFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_factory_for"
              c:identifier="inf_communication_manager_get_factory_for">
        <doc xml:space="preserve">Returns the #InfCommunicationFactory that @manager will use to instantiate
a #InfCommunicationMethod for @method_name on @network, or %NULL if the
network/method combination is not supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfCommunicationFactory,
or %NULL.</doc>
          <type name="CommunicationFactory" c:type="InfCommunicationFactory*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <doc xml:space="preserve">A network identifier.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:space="preserve">A method name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="join_group"
              c:identifier="inf_communication_manager_join_group">
        <doc xml:space="preserve">Joins a communication group published by a remote host. @publisher_conn
needs to be a to the publishing host with status %INF_XML_CONNECTION_OPEN
or %INF_XML_CONNECTION_OPENING. @group_name specifies the name of the group
to join.

@method specifies the communication method to use. It must match the
communication method the publisher has chosen for @publisher_conn's network
(see inf_communication_group_get_method_for_network()). The function
returns %NULL if @method is not supported (which means
inf_communication_manager_get_factory_for() for @publisher_conn's network
and @method returns %NULL).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfCommunicationJoinedGroup,
or %NULL. Free with g_object_unref() to leave the group.</doc>
          <type name="CommunicationJoinedGroup"
                c:type="InfCommunicationJoinedGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">The group to join.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="publisher_conn" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection to the publishing host.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">The communication method to use.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_group"
              c:identifier="inf_communication_manager_open_group">
        <doc xml:space="preserve">Opens a new communication group published by the local host. @group_name
is an identifier for the group via which other hosts can join the group
using inf_communication_manager_join_group(). It needs to be unique among
all groups opened by the local host.

@methods specifies what communication methods the group should use, in
order of priority. If a method is not supported for a given network, then
the next one in the array is tried. If none is supported, then the
"central" method will be used, which is guaranteed to be supported for
all networks.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfCommunicationHostedGroup. Free with
g_object_unref() to leave the group.</doc>
          <type name="CommunicationHostedGroup"
                c:type="InfCommunicationHostedGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationManager.</doc>
            <type name="CommunicationManager"
                  c:type="InfCommunicationManager*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">A name for the new group.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="methods"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Methods to support, or
%NULL.</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CommunicationManagerClass"
            c:type="InfCommunicationManagerClass"
            glib:is-gtype-struct-for="CommunicationManager">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="CommunicationMethod"
               c:symbol-prefix="communication_method"
               c:type="InfCommunicationMethod"
               glib:type-name="InfCommunicationMethod"
               glib:get-type="inf_communication_method_get_type"
               glib:type-struct="CommunicationMethodInterface">
      <doc xml:space="preserve">#InfCommunicationMethod is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="add_member" invoker="add_member">
        <doc xml:space="preserve">Adds a new connection to the group. The network of @connection must match
the network the method is handling, and @connection must not already be
a member of the group (see inf_communication_method_is_member()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to add.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="cancel_messages" invoker="cancel_messages">
        <doc xml:space="preserve">This function stops all messages to be sent to @connection that have not
yet been sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enqueued" invoker="enqueued">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
enqueued on registered connections
(see inf_communication_registry_register()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The enqueued message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_member" invoker="is_member">
        <doc xml:space="preserve">Returns whether @connection was added to the group via
inf_communication_method_add_member().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @connection is a member of the group.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="received" invoker="received">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
received on registered connections
(see inf_communication_registry_register()).

This function returns the scope of the message. If the scope is
%INF_COMMUNICATION_SCOPE_GROUP then the registry relays the message to
other connections on different networks (if any).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The scope of the message.</doc>
          <type name="CommunicationScope" c:type="InfCommunicationScope"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The received message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_member" invoker="remove_member">
        <doc xml:space="preserve">Removes a connection from the group. @connection needs to be a member of
the group (see inf_communication_method_is_member()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to remove.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_all" invoker="send_all">
        <doc xml:space="preserve">Sends an XML message to all group members on this network. This function
takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_single" invoker="send_single">
        <doc xml:space="preserve">Sends an XML message to @connection. This function takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sent" invoker="sent">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
sent on registered connections (see inf_communication_registry_register()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The sent message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_member"
              c:identifier="inf_communication_method_add_member">
        <doc xml:space="preserve">Adds a new connection to the group. The network of @connection must match
the network the method is handling, and @connection must not already be
a member of the group (see inf_communication_method_is_member()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to add.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel_messages"
              c:identifier="inf_communication_method_cancel_messages">
        <doc xml:space="preserve">This function stops all messages to be sent to @connection that have not
yet been sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enqueued" c:identifier="inf_communication_method_enqueued">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
enqueued on registered connections
(see inf_communication_registry_register()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The enqueued message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member"
              c:identifier="inf_communication_method_is_member">
        <doc xml:space="preserve">Returns whether @connection was added to the group via
inf_communication_method_add_member().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @connection is a member of the group.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="received" c:identifier="inf_communication_method_received">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
received on registered connections
(see inf_communication_registry_register()).

This function returns the scope of the message. If the scope is
%INF_COMMUNICATION_SCOPE_GROUP then the registry relays the message to
other connections on different networks (if any).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The scope of the message.</doc>
          <type name="CommunicationScope" c:type="InfCommunicationScope"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The received message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_member"
              c:identifier="inf_communication_method_remove_member">
        <doc xml:space="preserve">Removes a connection from the group. @connection needs to be a member of
the group (see inf_communication_method_is_member()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to remove.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_all" c:identifier="inf_communication_method_send_all">
        <doc xml:space="preserve">Sends an XML message to all group members on this network. This function
takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_single"
              c:identifier="inf_communication_method_send_single">
        <doc xml:space="preserve">Sends an XML message to @connection. This function takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="sent" c:identifier="inf_communication_method_sent">
        <doc xml:space="preserve">This function is called by the #InfCommunicationRegistry if data has been
sent on registered connections (see inf_communication_registry_register()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The sent message.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="add-member" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a new connection has been added to the
group on the network this method handles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection that was added.</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-member" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a connection has been removed from the
group on the network this method handles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection that was removed.</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="CommunicationMethodInterface"
            c:type="InfCommunicationMethodInterface"
            glib:is-gtype-struct-for="CommunicationMethod">
      <doc xml:space="preserve">The default signal handlers of virtual methods of #InfCommunicationMethod.
These implement communication within a #InfCommunicationGroup.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="add_member">
        <callback name="add_member">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">The #InfXmlConnection to add.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_member">
        <callback name="remove_member">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">The #InfXmlConnection to remove.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_member">
        <callback name="is_member">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether @connection is a member of the group.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_single">
        <callback name="send_single">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="full">
              <doc xml:space="preserve">The message to send.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_all">
        <callback name="send_all">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="full">
              <doc xml:space="preserve">The message to send.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel_messages">
        <callback name="cancel_messages">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="received">
        <callback name="received">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The scope of the message.</doc>
            <type name="CommunicationScope" c:type="InfCommunicationScope"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection that is a group member.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <doc xml:space="preserve">The received message.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enqueued">
        <callback name="enqueued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <doc xml:space="preserve">The enqueued message.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sent">
        <callback name="sent">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationMethod.</doc>
              <type name="CommunicationMethod"
                    c:type="InfCommunicationMethod*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <doc xml:space="preserve">The sent message.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="CommunicationObject"
               c:symbol-prefix="communication_object"
               c:type="InfCommunicationObject"
               glib:type-name="InfCommunicationObject"
               glib:get-type="inf_communication_object_get_type"
               glib:type-struct="CommunicationObjectInterface">
      <doc xml:space="preserve">#InfCommunicationObject is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="enqueued" invoker="enqueued">
        <doc xml:space="preserve">This function is called, when an XML message scheduled to be sent via
inf_communication_group_send_message() or
inf_communication_group_send_group_message() cannot be cancelled anymore,
because it was already passed to @conn.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The XML data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="received" invoker="received">
        <doc xml:space="preserve">This function is called when a #InfCommunicationManager received data from
@connection belonging to a group whose communication object is @object.
This function should process the incoming data. If it could not process it,
then it should set @error.

It should return %INF_COMMUNICATION_SCOPE_GROUP if the message is allowed
to be forwarded to other group members. Since recipients of forwarded
messages don't see the original sender (but just the forwarding host),
forwarding arbitrary messages could lead to a security problem in the worst
case.

For example, if, in central mode, a client sends an (invalid)
&amp;lt;add-node&amp;gt; request to the whole (InfDirectory) group, and the server
forwarded this to all clients, those clients would try to create a new node
although the server rejected the request. In decentral mode, this is not a
problem since all clients see where the message comes from, and can
themselves reject all messages not coming from the server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%INF_COMMUNICATION_SCOPE_GROUP if the message is allowed to
be forwarded, %INF_COMMUNICATION_SCOPE_PTP if not.</doc>
          <type name="CommunicationScope" c:type="InfCommunicationScope"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection data was received from.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The received data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sent" invoker="sent">
        <doc xml:space="preserve">This function is called when a XML message sent via
inf_communication_group_send_message() or
inf_communication_group_send_group_message() has actually been sent out.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The sent data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="enqueued" c:identifier="inf_communication_object_enqueued">
        <doc xml:space="preserve">This function is called, when an XML message scheduled to be sent via
inf_communication_group_send_message() or
inf_communication_group_send_group_message() cannot be cancelled anymore,
because it was already passed to @conn.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The XML data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="received" c:identifier="inf_communication_object_received">
        <doc xml:space="preserve">This function is called when a #InfCommunicationManager received data from
@connection belonging to a group whose communication object is @object.
This function should process the incoming data. If it could not process it,
then it should set @error.

It should return %INF_COMMUNICATION_SCOPE_GROUP if the message is allowed
to be forwarded to other group members. Since recipients of forwarded
messages don't see the original sender (but just the forwarding host),
forwarding arbitrary messages could lead to a security problem in the worst
case.

For example, if, in central mode, a client sends an (invalid)
&amp;lt;add-node&amp;gt; request to the whole (InfDirectory) group, and the server
forwarded this to all clients, those clients would try to create a new node
although the server rejected the request. In decentral mode, this is not a
problem since all clients see where the message comes from, and can
themselves reject all messages not coming from the server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%INF_COMMUNICATION_SCOPE_GROUP if the message is allowed to
be forwarded, %INF_COMMUNICATION_SCOPE_PTP if not.</doc>
          <type name="CommunicationScope" c:type="InfCommunicationScope"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection data was received from.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The received data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="sent" c:identifier="inf_communication_object_sent">
        <doc xml:space="preserve">This function is called when a XML message sent via
inf_communication_group_send_message() or
inf_communication_group_send_group_message() has actually been sent out.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationObject.</doc>
            <type name="CommunicationObject" c:type="InfCommunicationObject*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The sent data.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="CommunicationObjectInterface"
            c:type="InfCommunicationObjectInterface"
            glib:is-gtype-struct-for="CommunicationObject">
      <doc xml:space="preserve">The virtual methods of #InfCommunicationObject. These are called by the
#InfCommunicationMethod when appropriate.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="received">
        <callback name="received">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%INF_COMMUNICATION_SCOPE_GROUP if the message is allowed to
be forwarded, %INF_COMMUNICATION_SCOPE_PTP if not.</doc>
            <type name="CommunicationScope" c:type="InfCommunicationScope"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationObject.</doc>
              <type name="CommunicationObject"
                    c:type="InfCommunicationObject*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">The #InfXmlConnection data was received from.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="node" transfer-ownership="none">
              <doc xml:space="preserve">The received data.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enqueued">
        <callback name="enqueued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationObject.</doc>
              <type name="CommunicationObject"
                    c:type="InfCommunicationObject*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="node" transfer-ownership="none">
              <doc xml:space="preserve">The XML data.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sent">
        <callback name="sent">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">A #InfCommunicationObject.</doc>
              <type name="CommunicationObject"
                    c:type="InfCommunicationObject*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="node" transfer-ownership="none">
              <doc xml:space="preserve">The sent data.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="CommunicationRegistry"
           c:symbol-prefix="communication_registry"
           c:type="InfCommunicationRegistry"
           parent="GObject.Object"
           glib:type-name="InfCommunicationRegistry"
           glib:get-type="inf_communication_registry_get_type"
           glib:type-struct="CommunicationRegistryClass">
      <doc xml:space="preserve">#InfCommunicationRegistry is an opaque data type. You should only access it
via the public API functions.</doc>
      <method name="cancel_messages"
              c:identifier="inf_communication_registry_cancel_messages">
        <doc xml:space="preserve">Stops all messages scheduled to be sent to @connection in @group from being
sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The group for which to cancel messages.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A registered #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_registered"
              c:identifier="inf_communication_registry_is_registered">
        <doc xml:space="preserve">Returns whether @connection has been registered for @group with
inf_communication_registry_register().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @connection has been registered, or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The group for which to check whether @connection is registered.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to check for registration.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="inf_communication_registry_register">
        <doc xml:space="preserve">Registers connection with @group. This allows sending messages to
@connection via inf_communication_registry_send(). For received messages,
inf_communication_method_received() is called on @method.

@connection must have status %INF_XML_CONNECTION_OPEN.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The group for which to register a connection.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">The #InfCommunicationMethod used.</doc>
            <type name="CommunicationMethod" c:type="InfCommunicationMethod*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to register.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="inf_communication_registry_send">
        <doc xml:space="preserve">Sends an XML message to @connection. @connection must have been registered
with inf_communication_registry_register() before. If the message has been
sent, inf_communication_method_sent() is called on the method the
connection was registered with. inf_communication_method_enqueued() is
called when sending the message can no longer be cancelled via
inf_communication_registry_cancel_messages().

This function takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The group for which to send the message #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A registered #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister"
              c:identifier="inf_communication_registry_unregister">
        <doc xml:space="preserve">Unregisters @connection from @group. Incoming messages are no longer
reported to group's method, and inf_communication_registry_send() can
no longer be called for @connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="registry" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationRegistry.</doc>
            <type name="CommunicationRegistry"
                  c:type="InfCommunicationRegistry*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The group for which to unregister a connection.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The connection to unregister.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CommunicationRegistryClass"
            c:type="InfCommunicationRegistryClass"
            glib:is-gtype-struct-for="CommunicationRegistry">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="CommunicationScope"
                 glib:type-name="InfCommunicationScope"
                 glib:get-type="inf_communication_scope_get_type"
                 c:type="InfCommunicationScope">
      <doc xml:space="preserve">#InfCommunicationScope specifies to which hosts a message belongs.</doc>
      <member name="ptp"
              value="0"
              c:identifier="INF_COMMUNICATION_SCOPE_PTP"
              glib:nick="ptp">
        <doc xml:space="preserve">The message is sent from one group member to
another.</doc>
      </member>
      <member name="group"
              value="1"
              c:identifier="INF_COMMUNICATION_SCOPE_GROUP"
              glib:nick="group">
        <doc xml:space="preserve">The message is sent to all group members.</doc>
      </member>
    </enumeration>
    <enumeration name="DirectoryError"
                 c:type="InfDirectoryError"
                 glib:error-domain="INF_DIRECTORY_ERROR">
      <doc xml:space="preserve">These are errors related to the directory of documents. These errors can
be reason why requests created by #InfcBrowser fail.</doc>
      <member name="no_welcome_message"
              value="0"
              c:identifier="INF_DIRECTORY_ERROR_NO_WELCOME_MESSAGE">
        <doc xml:space="preserve">A client did not receive the
directory's initial welcome message.</doc>
      </member>
      <member name="version_mismatch"
              value="1"
              c:identifier="INF_DIRECTORY_ERROR_VERSION_MISMATCH">
        <doc xml:space="preserve">The server and client use
different versions of the protocol.</doc>
      </member>
      <member name="node_exists"
              value="2"
              c:identifier="INF_DIRECTORY_ERROR_NODE_EXISTS">
        <doc xml:space="preserve">A node with the given name exists
already in that subdirectory (in response to node creation requests).</doc>
      </member>
      <member name="invalid_name"
              value="3"
              c:identifier="INF_DIRECTORY_ERROR_INVALID_NAME">
        <doc xml:space="preserve">A node with an invalid name was
attempted to be created.</doc>
      </member>
      <member name="no_such_node"
              value="4"
              c:identifier="INF_DIRECTORY_ERROR_NO_SUCH_NODE">
        <doc xml:space="preserve">The node refered to in a request does
not exist in the directory (anymore).</doc>
      </member>
      <member name="no_such_subscription_request"
              value="5"
              c:identifier="INF_DIRECTORY_ERROR_NO_SUCH_SUBSCRIPTION_REQUEST">
        <doc xml:space="preserve">A &amp;lt;subscribe-ack&amp;gt;
or &amp;lt;subscribe-nack&amp;gt; has been received without a previous request.</doc>
      </member>
      <member name="chat_disabled"
              value="6"
              c:identifier="INF_DIRECTORY_ERROR_CHAT_DISABLED">
        <doc xml:space="preserve">A client attempted to subscribe to a
server's chat, but the chat is disabled on the server side.</doc>
      </member>
      <member name="not_a_subdirectory"
              value="7"
              c:identifier="INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY">
        <doc xml:space="preserve">The node refered to in a request
is not a subdirectory node, but the requested operation requires one.</doc>
      </member>
      <member name="not_a_note"
              value="8"
              c:identifier="INF_DIRECTORY_ERROR_NOT_A_NOTE">
        <doc xml:space="preserve">The node refered to in a request is not
a note (non-subdirectory) node, but the requested operations requires one.</doc>
      </member>
      <member name="note_type_unsupported"
              value="9"
              c:identifier="INF_DIRECTORY_ERROR_NOTE_TYPE_UNSUPPORTED">
        <doc xml:space="preserve">The node type is not supported
by the server.</doc>
      </member>
      <member name="root_node_remove_attempt"
              value="10"
              c:identifier="INF_DIRECTORY_ERROR_ROOT_NODE_REMOVE_ATTEMPT">
        <doc xml:space="preserve">A &amp;lt;remove-node&amp;gt;
request attempted to remove a directory's root node, which is not allowed.</doc>
      </member>
      <member name="not_explored"
              value="11"
              c:identifier="INF_DIRECTORY_ERROR_NOT_EXPLORED">
        <doc xml:space="preserve">An operation cannot be performed because
the corresponding node is not explored.</doc>
      </member>
      <member name="already_explored"
              value="12"
              c:identifier="INF_DIRECTORY_ERROR_ALREADY_EXPLORED">
        <doc xml:space="preserve">The node given in an exploration
request has already been explored earlier.</doc>
      </member>
      <member name="not_initiated"
              value="13"
              c:identifier="INF_DIRECTORY_ERROR_NOT_INITIATED">
        <doc xml:space="preserve">Exploration has begun before the client
was told how many entries to expect.</doc>
      </member>
      <member name="too_many_children"
              value="14"
              c:identifier="INF_DIRECTORY_ERROR_TOO_MANY_CHILDREN">
        <doc xml:space="preserve">Exploration yields more children
than announced at the beginning of the exploration.</doc>
      </member>
      <member name="too_few_children"
              value="15"
              c:identifier="INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN">
        <doc xml:space="preserve">Exploration yields less children
than announced at the beginning of the exploration.</doc>
      </member>
      <member name="type_unknown"
              value="16"
              c:identifier="INF_DIRECTORY_ERROR_TYPE_UNKNOWN">
        <doc xml:space="preserve">The type of a note is not known.</doc>
      </member>
      <member name="already_subscribed"
              value="17"
              c:identifier="INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED">
        <doc xml:space="preserve">The connection already subscribed
to the node refered to, but the requested operation requires it to be
unsubscribed.</doc>
      </member>
      <member name="unsubscribed"
              value="18"
              c:identifier="INF_DIRECTORY_ERROR_UNSUBSCRIBED">
        <doc xml:space="preserve">The connection is not subscribed to the
node refered to, but the requested operation requires it to be subscribed.</doc>
      </member>
      <member name="network_unsupported"
              value="19"
              c:identifier="INF_DIRECTORY_ERROR_NETWORK_UNSUPPORTED">
        <doc xml:space="preserve">The server does not support the
network of the incoming connection for the requested operation. For
example, subscribing to a session might require a network that has a
peer-to-peer communication method, but there is no implementation of that
method for the connection's network.</doc>
      </member>
      <member name="method_unsupported"
              value="20"
              c:identifier="INF_DIRECTORY_ERROR_METHOD_UNSUPPORTED">
        <doc xml:space="preserve">The server requested a
communaction method for subscription or synchronization that is not
supported by the client.</doc>
      </member>
      <member name="operation_unsupported"
              value="21"
              c:identifier="INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED">
        <doc xml:space="preserve">The requested operation is not
supported by the server.</doc>
      </member>
      <member name="unexpected_sync_in"
              value="22"
              c:identifier="INF_DIRECTORY_ERROR_UNEXPECTED_SYNC_IN">
        <doc xml:space="preserve">A client received a
&amp;lt;sync-in/&amp;gt; without having requested one. The client has no data to
sync to the server.</doc>
      </member>
      <member name="subscription_rejected"
              value="23"
              c:identifier="INF_DIRECTORY_ERROR_SUBSCRIPTION_REJECTED">
        <doc xml:space="preserve">A client replied with
&amp;lt;subscribe-nack&amp;gt; on an attempt to subscribe it to a session.</doc>
      </member>
      <member name="unexpected_message"
              value="24"
              c:identifier="INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE">
        <doc xml:space="preserve">A message that is not understood
was received.</doc>
      </member>
      <member name="no_storage"
              value="25"
              c:identifier="INF_DIRECTORY_ERROR_NO_STORAGE">
        <doc xml:space="preserve">A node cannot be stored permanently on the
server since it has no storage backend attached.</doc>
      </member>
      <member name="invalid_certificate"
              value="26"
              c:identifier="INF_DIRECTORY_ERROR_INVALID_CERTIFICATE">
        <doc xml:space="preserve">An invalid certificate or
certificate request have been sent.</doc>
      </member>
      <member name="account_list_already_queried"
              value="27"
              c:identifier="INF_DIRECTORY_ERROR_ACCOUNT_LIST_ALREADY_QUERIED">
        <doc xml:space="preserve">The account list has
already been queried before.</doc>
      </member>
      <member name="account_list_not_queried"
              value="28"
              c:identifier="INF_DIRECTORY_ERROR_ACCOUNT_LIST_NOT_QUERIED">
        <doc xml:space="preserve">The account list has not
been queried.</doc>
      </member>
      <member name="duplicate_account"
              value="29"
              c:identifier="INF_DIRECTORY_ERROR_DUPLICATE_ACCOUNT">
        <doc xml:space="preserve">When adding a new account the new
account ID exists already in the account list.</doc>
      </member>
      <member name="no_such_account"
              value="30"
              c:identifier="INF_DIRECTORY_ERROR_NO_SUCH_ACCOUNT">
        <doc xml:space="preserve">There is no such account with the
given ID.</doc>
      </member>
      <member name="acl_already_queried"
              value="31"
              c:identifier="INF_DIRECTORY_ERROR_ACL_ALREADY_QUERIED">
        <doc xml:space="preserve">The ACL for a node has
already been queried before.</doc>
      </member>
      <member name="acl_not_queried"
              value="32"
              c:identifier="INF_DIRECTORY_ERROR_ACL_NOT_QUERIED">
        <doc xml:space="preserve">The ACL for a node has
not yet been queried, but is required to perform the operation.</doc>
      </member>
      <member name="failed"
              value="33"
              c:identifier="INF_DIRECTORY_ERROR_FAILED">
        <doc xml:space="preserve">Generic error code when no further reason of
failure is known.</doc>
      </member>
    </enumeration>
    <interface name="Discovery"
               c:symbol-prefix="discovery"
               c:type="InfDiscovery"
               glib:type-name="InfDiscovery"
               glib:get-type="inf_discovery_get_type"
               glib:type-struct="DiscoveryInterface">
      <doc xml:space="preserve">#InfDiscovery is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="discover" invoker="discover">
        <doc xml:space="preserve">Starts the discovery of the given service type. Whenever a service of
this type is discovered, the "discovered" signal is emitted. If the
service disappears, the "undiscovered" signal is emitted. This can be
called more than once for the same type, but only the first call has
an effect.

Note also that implementations of #InfDiscovery might restrict the
service types that can be discovered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type to discover.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="discovered" invoker="discovered">
        <doc xml:space="preserve">Emits the "discovered" signal on @discovery.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The discovered #InfDiscoveryInfo.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_discovered" invoker="get_discovered">
        <doc xml:space="preserve">Returns a list of discovered #InfDiscoveryInfo for the given type.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">A newly
allocated list that needs to be freed with g_slist_free().</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="DiscoveryInfo"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type of which to get discovered infos for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="info_get_service_name"
                      invoker="info_get_service_name">
        <doc xml:space="preserve">Returns the service name of the discovered @info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string.
Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="info_get_service_type"
                      invoker="info_get_service_type">
        <doc xml:space="preserve">Returns the service type of the discovered @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @discovery.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resolve" invoker="resolve">
        <doc xml:space="preserve">Attempts to resolve @info. Resolving a #InfDiscoveryInfo means creating
a #InfXmlConnection to the publisher. The connection might not be
open when @complete_func runs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
          <parameter name="complete_func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">A callback that will be called when the
resolving process has completed.</doc>
            <type name="DiscoveryResolvCompleteFunc"
                  c:type="InfDiscoveryResolvCompleteFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Extra data to pass to @complete_func and @error_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="undiscovered" invoker="undiscovered">
        <doc xml:space="preserve">Emits the "undiscovered" signal on @discovery.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The undiscovered @InfDiscoveryInfo.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="discover" c:identifier="inf_discovery_discover">
        <doc xml:space="preserve">Starts the discovery of the given service type. Whenever a service of
this type is discovered, the "discovered" signal is emitted. If the
service disappears, the "undiscovered" signal is emitted. This can be
called more than once for the same type, but only the first call has
an effect.

Note also that implementations of #InfDiscovery might restrict the
service types that can be discovered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type to discover.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="discovered" c:identifier="inf_discovery_discovered">
        <doc xml:space="preserve">Emits the "discovered" signal on @discovery.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The discovered #InfDiscoveryInfo.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_discovered"
              c:identifier="inf_discovery_get_discovered">
        <doc xml:space="preserve">Returns a list of discovered #InfDiscoveryInfo for the given type.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">A newly
allocated list that needs to be freed with g_slist_free().</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="DiscoveryInfo"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type of which to get discovered infos for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_get_service_name"
              c:identifier="inf_discovery_info_get_service_name">
        <doc xml:space="preserve">Returns the service name of the discovered @info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string.
Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_get_service_type"
              c:identifier="inf_discovery_info_get_service_type">
        <doc xml:space="preserve">Returns the service type of the discovered @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string owned by @discovery.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve" c:identifier="inf_discovery_resolve">
        <doc xml:space="preserve">Attempts to resolve @info. Resolving a #InfDiscoveryInfo means creating
a #InfXmlConnection to the publisher. The connection might not be
open when @complete_func runs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
          <parameter name="complete_func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">A callback that will be called when the
resolving process has completed.</doc>
            <type name="DiscoveryResolvCompleteFunc"
                  c:type="InfDiscoveryResolvCompleteFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Extra data to pass to @complete_func and @error_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="undiscovered" c:identifier="inf_discovery_undiscovered">
        <doc xml:space="preserve">Emits the "undiscovered" signal on @discovery.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="discovery" transfer-ownership="none">
            <doc xml:space="preserve">A #InfDiscovery.</doc>
            <type name="Discovery" c:type="InfDiscovery*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The undiscovered @InfDiscoveryInfo.</doc>
            <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="discovered" when="last" detailed="1">
        <doc xml:space="preserve">This signal is detailed. The detail is the name of the service that has
been discovered, so you can connect to
&amp;quot;discovered::&lt;emphasis&gt;my-service-name&lt;/emphasis&gt;&amp;quot; if you are
only interested in a particular service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The #InfDiscoveryInfo describing the discovered service</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="undiscovered" when="last" detailed="1">
        <doc xml:space="preserve">This signal is emitted if a previously discovered service is no longer
available.

This signal is detailed. The detail is the name of the service that has
been undiscovered, so you can connect to
&amp;quot;undiscovered::&lt;emphasis&gt;my-service-name&lt;/emphasis&gt;&amp;quot; if you
are only interested in a particular service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">The #InfDiscoveryInfo describing the undiscovered service</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="DiscoveryInfo" c:type="InfDiscoveryInfo" disguised="1">
      <doc xml:space="preserve">#InfDiscoveryInfo is an opaque data type. You should only access it
via the public API functions.</doc>
    </record>
    <record name="DiscoveryInterface"
            c:type="InfDiscoveryInterface"
            glib:is-gtype-struct-for="Discovery">
      <doc xml:space="preserve">The virtual methods and default signal handlers of #InfDiscovery.
Implementing these allows discovering infinote servers.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="discover">
        <callback name="discover">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">The service type to discover.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_discovered">
        <callback name="get_discovered">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">A newly
allocated list that needs to be freed with g_slist_free().</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="DiscoveryInfo"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">The service type of which to get discovered infos for.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resolve">
        <callback name="resolve">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
              <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
            </parameter>
            <parameter name="complete_func"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve">A callback that will be called when the
resolving process has completed.</doc>
              <type name="DiscoveryResolvCompleteFunc"
                    c:type="InfDiscoveryResolvCompleteFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Extra data to pass to @complete_func and @error_func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="info_get_service_name">
        <callback name="info_get_service_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A newly allocated string.
Free with g_free().</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
              <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="info_get_service_type">
        <callback name="info_get_service_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A string owned by @discovery.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscoveryInfo discovered by @discovery.</doc>
              <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="discovered">
        <callback name="discovered">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">The discovered #InfDiscoveryInfo.</doc>
              <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="undiscovered">
        <callback name="undiscovered">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="discovery" transfer-ownership="none">
              <doc xml:space="preserve">A #InfDiscovery.</doc>
              <type name="Discovery" c:type="InfDiscovery*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">The undiscovered @InfDiscoveryInfo.</doc>
              <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="DiscoveryResolvCompleteFunc"
              c:type="InfDiscoveryResolvCompleteFunc">
      <doc xml:space="preserve">This callback is called when a call to inf_discovery_resolve() finished.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">The resolved #InfDiscoveryInfo.</doc>
          <type name="DiscoveryInfo" c:type="InfDiscoveryInfo*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">The resulting #InfXmlConnection.</doc>
          <type name="XmlConnection" c:type="InfXmlConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Reason in case of failure.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">The user_data passed to inf_discovery_resolve().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FileListFunc" c:type="InfFileListFunc" throws="1">
      <doc xml:space="preserve">This is the prototype of the callback function passed to
inf_file_util_list_directory(). If the function returns %FALSE then
directory traversal is stopped immediately. In addition @error can be set
and it is propagated to the caller of inf_file_util_list_directory().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the iteration should be continued or %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the current file.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">The full path to the current file.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">The type of the current file.</doc>
          <type name="FileType" c:type="InfFileType"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">User data specified at the time of the call.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="FileType" c:type="InfFileType">
      <doc xml:space="preserve">This type represents the possible file types that
inf_file_util_list_directory() can report.</doc>
      <member name="unknown" value="0" c:identifier="INF_FILE_TYPE_UNKNOWN">
        <doc xml:space="preserve">Unknown file type.</doc>
      </member>
      <member name="reg" value="1" c:identifier="INF_FILE_TYPE_REG">
        <doc xml:space="preserve">File is a regular file.</doc>
      </member>
      <member name="dir" value="2" c:identifier="INF_FILE_TYPE_DIR">
        <doc xml:space="preserve">File is a directory.</doc>
      </member>
      <member name="lnk" value="3" c:identifier="INF_FILE_TYPE_LNK">
        <doc xml:space="preserve">File is a symbolic link.</doc>
      </member>
    </enumeration>
    <interface name="Io"
               c:symbol-prefix="io"
               c:type="InfIo"
               glib:type-name="InfIo"
               glib:get-type="inf_io_get_type"
               glib:type-struct="IoInterface">
      <doc xml:space="preserve">#InfIo is an opaque data type. You should only access it via the public
API functions.</doc>
      <virtual-method name="add_dispatch" invoker="add_dispatch">
        <doc xml:space="preserve">Schedules @func to be called by the thread @io runs in. This function can
be used from a different thread to communicate to @io's thread.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A dispatch handle that can be used to stop the
dispatched function from being called as long as it has not yet been called.</doc>
          <type name="IoDispatch" c:type="InfIoDispatch*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">Function to be called when the function is dispatched.</doc>
            <type name="IoDispatchFunc" c:type="InfIoDispatchFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_timeout" invoker="add_timeout">
        <doc xml:space="preserve">Calls @func after at least @msecs milliseconds have elapsed. The timeout
is removed after it has elapsed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A timeout handle that can be used to remove
the timeout.</doc>
          <type name="IoTimeout" c:type="InfIoTimeout*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="msecs" transfer-ownership="none">
            <doc xml:space="preserve">Number of milliseconds after which the timeout should be elapsed.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">Function to be called when the timeout elapsed.</doc>
            <type name="IoTimeoutFunc" c:type="InfIoTimeoutFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_watch" invoker="add_watch">
        <doc xml:space="preserve">Monitors the given socket for activity and calls @func if one of the
events specified in @events occurs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIoWatch that can be used to update or
remove the watch.</doc>
          <type name="IoWatch" c:type="InfIoWatch*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">The socket to watch.</doc>
            <type name="NativeSocket" c:type="InfNativeSocket*"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve">Events to watch for.</doc>
            <type name="IoEvent" c:type="InfIoEvent"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="3"
                     destroy="4">
            <doc xml:space="preserve">Function to be called when one of the events occurs.</doc>
            <type name="IoWatchFunc" c:type="InfIoWatchFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_dispatch" invoker="remove_dispatch">
        <doc xml:space="preserve">Removes the given dispatch from @io so that it is not called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="dispatch" transfer-ownership="none">
            <doc xml:space="preserve">A dispatch handle obtained from inf_io_add_dispatch().</doc>
            <type name="IoDispatch" c:type="InfIoDispatch*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_timeout" invoker="remove_timeout">
        <doc xml:space="preserve">Removes the given timeout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">A timeout handle obtained from inf_io_add_timeout().</doc>
            <type name="IoTimeout" c:type="InfIoTimeout*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_watch" invoker="remove_watch">
        <doc xml:space="preserve">Removes @watch from @io and releases all resources allocated for the watch.
Events are no longer looked for on the socket.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="watch" transfer-ownership="none">
            <doc xml:space="preserve">The watch to remove, as returned by inf_io_add_watch().</doc>
            <type name="IoWatch" c:type="InfIoWatch*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_watch" invoker="update_watch">
        <doc xml:space="preserve">Changes the events that the socket bound to @watch is being watched for.
The callback of @watch will only be called if one of the newly watched for
events occurs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="watch" transfer-ownership="none">
            <doc xml:space="preserve">The watch to update, as returned by inf_io_add_watch().</doc>
            <type name="IoWatch" c:type="InfIoWatch*"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve">The new events to watch for.</doc>
            <type name="IoEvent" c:type="InfIoEvent"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_dispatch" c:identifier="inf_io_add_dispatch">
        <doc xml:space="preserve">Schedules @func to be called by the thread @io runs in. This function can
be used from a different thread to communicate to @io's thread.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A dispatch handle that can be used to stop the
dispatched function from being called as long as it has not yet been called.</doc>
          <type name="IoDispatch" c:type="InfIoDispatch*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">Function to be called when the function is dispatched.</doc>
            <type name="IoDispatchFunc" c:type="InfIoDispatchFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_timeout" c:identifier="inf_io_add_timeout">
        <doc xml:space="preserve">Calls @func after at least @msecs milliseconds have elapsed. The timeout
is removed after it has elapsed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A timeout handle that can be used to remove
the timeout.</doc>
          <type name="IoTimeout" c:type="InfIoTimeout*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="msecs" transfer-ownership="none">
            <doc xml:space="preserve">Number of milliseconds after which the timeout should be elapsed.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">Function to be called when the timeout elapsed.</doc>
            <type name="IoTimeoutFunc" c:type="InfIoTimeoutFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_watch" c:identifier="inf_io_add_watch">
        <doc xml:space="preserve">Monitors the given socket for activity and calls @func if one of the
events specified in @events occurs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIoWatch that can be used to update or
remove the watch.</doc>
          <type name="IoWatch" c:type="InfIoWatch*"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">The socket to watch.</doc>
            <type name="NativeSocket" c:type="InfNativeSocket*"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve">Events to watch for.</doc>
            <type name="IoEvent" c:type="InfIoEvent"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="3"
                     destroy="4">
            <doc xml:space="preserve">Function to be called when one of the events occurs.</doc>
            <type name="IoWatchFunc" c:type="InfIoWatchFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Extra data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dispatch" c:identifier="inf_io_remove_dispatch">
        <doc xml:space="preserve">Removes the given dispatch from @io so that it is not called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="dispatch" transfer-ownership="none">
            <doc xml:space="preserve">A dispatch handle obtained from inf_io_add_dispatch().</doc>
            <type name="IoDispatch" c:type="InfIoDispatch*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_timeout" c:identifier="inf_io_remove_timeout">
        <doc xml:space="preserve">Removes the given timeout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">A timeout handle obtained from inf_io_add_timeout().</doc>
            <type name="IoTimeout" c:type="InfIoTimeout*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_watch" c:identifier="inf_io_remove_watch">
        <doc xml:space="preserve">Removes @watch from @io and releases all resources allocated for the watch.
Events are no longer looked for on the socket.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="watch" transfer-ownership="none">
            <doc xml:space="preserve">The watch to remove, as returned by inf_io_add_watch().</doc>
            <type name="IoWatch" c:type="InfIoWatch*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_watch" c:identifier="inf_io_update_watch">
        <doc xml:space="preserve">Changes the events that the socket bound to @watch is being watched for.
The callback of @watch will only be called if one of the newly watched for
events occurs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo.</doc>
            <type name="Io" c:type="InfIo*"/>
          </instance-parameter>
          <parameter name="watch" transfer-ownership="none">
            <doc xml:space="preserve">The watch to update, as returned by inf_io_add_watch().</doc>
            <type name="IoWatch" c:type="InfIoWatch*"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve">The new events to watch for.</doc>
            <type name="IoEvent" c:type="InfIoEvent"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="IoDispatch" c:type="InfIoDispatch" disguised="1">
      <doc xml:space="preserve">#InfIoDispatch represents a function to be called by the thread executing
the #InfIo object. It is an opaque data type. You should only access it
via the public API functions.</doc>
    </record>
    <callback name="IoDispatchFunc" c:type="InfIoDispatchFunc">
      <doc xml:space="preserve">Callback function that is called when a dispatch is executed by the thread
that runs #InfIo.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:space="preserve">User-defined data specified in inf_io_add_dispatch().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="IoEvent"
              glib:type-name="InfIoEvent"
              glib:get-type="inf_io_event_get_type"
              c:type="InfIoEvent">
      <doc xml:space="preserve">This enumeration specifies events that can be watched.</doc>
      <member name="incoming"
              value="1"
              c:identifier="INF_IO_INCOMING"
              glib:nick="incoming">
        <doc xml:space="preserve">Data can be read from the socket without blocking, or
the connection has been closed (which is the case when recv() returns 0).</doc>
      </member>
      <member name="outgoing"
              value="2"
              c:identifier="INF_IO_OUTGOING"
              glib:nick="outgoing">
        <doc xml:space="preserve">Data can be sent without blocking.</doc>
      </member>
      <member name="error"
              value="4"
              c:identifier="INF_IO_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">An error with the socket occured, or the connection has
been closed. Use getsockopt() to read the %SO_ERROR option to find out what
the problem is.</doc>
      </member>
    </bitfield>
    <record name="IoInterface"
            c:type="InfIoInterface"
            glib:is-gtype-struct-for="Io">
      <doc xml:space="preserve">The virtual methods of #InfIo. These allow to set up socket watches,
timeouts and function dispatchers. All of these functions need to be
thread-safe.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="add_watch">
        <callback name="add_watch">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfIoWatch that can be used to update or
remove the watch.</doc>
            <type name="IoWatch" c:type="InfIoWatch*"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="socket" transfer-ownership="none">
              <doc xml:space="preserve">The socket to watch.</doc>
              <type name="NativeSocket" c:type="InfNativeSocket*"/>
            </parameter>
            <parameter name="events" transfer-ownership="none">
              <doc xml:space="preserve">Events to watch for.</doc>
              <type name="IoEvent" c:type="InfIoEvent"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="notified"
                       closure="4"
                       destroy="5">
              <doc xml:space="preserve">Function to be called when one of the events occurs.</doc>
              <type name="IoWatchFunc" c:type="InfIoWatchFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">Extra data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="notify" transfer-ownership="none" scope="async">
              <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_watch">
        <callback name="update_watch">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="watch" transfer-ownership="none">
              <doc xml:space="preserve">The watch to update, as returned by inf_io_add_watch().</doc>
              <type name="IoWatch" c:type="InfIoWatch*"/>
            </parameter>
            <parameter name="events" transfer-ownership="none">
              <doc xml:space="preserve">The new events to watch for.</doc>
              <type name="IoEvent" c:type="InfIoEvent"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_watch">
        <callback name="remove_watch">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="watch" transfer-ownership="none">
              <doc xml:space="preserve">The watch to remove, as returned by inf_io_add_watch().</doc>
              <type name="IoWatch" c:type="InfIoWatch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_timeout">
        <callback name="add_timeout">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A timeout handle that can be used to remove
the timeout.</doc>
            <type name="IoTimeout" c:type="InfIoTimeout*"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="msecs" transfer-ownership="none">
              <doc xml:space="preserve">Number of milliseconds after which the timeout should be elapsed.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="notified"
                       closure="3"
                       destroy="4">
              <doc xml:space="preserve">Function to be called when the timeout elapsed.</doc>
              <type name="IoTimeoutFunc" c:type="InfIoTimeoutFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">Extra data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="notify" transfer-ownership="none" scope="async">
              <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_timeout">
        <callback name="remove_timeout">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:space="preserve">A timeout handle obtained from inf_io_add_timeout().</doc>
              <type name="IoTimeout" c:type="InfIoTimeout*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_dispatch">
        <callback name="add_dispatch">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A dispatch handle that can be used to stop the
dispatched function from being called as long as it has not yet been called.</doc>
            <type name="IoDispatch" c:type="InfIoDispatch*"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="notified"
                       closure="2"
                       destroy="3">
              <doc xml:space="preserve">Function to be called when the function is dispatched.</doc>
              <type name="IoDispatchFunc" c:type="InfIoDispatchFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <doc xml:space="preserve">Extra data to pass to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="notify" transfer-ownership="none" scope="async">
              <doc xml:space="preserve">A #GDestroyNotify that is called when @user_data is no longer
needed, or %NULL.</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_dispatch">
        <callback name="remove_dispatch">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="io" transfer-ownership="none">
              <doc xml:space="preserve">A #InfIo.</doc>
              <type name="Io" c:type="InfIo*"/>
            </parameter>
            <parameter name="dispatch" transfer-ownership="none">
              <doc xml:space="preserve">A dispatch handle obtained from inf_io_add_dispatch().</doc>
              <type name="IoDispatch" c:type="InfIoDispatch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="IoTimeout" c:type="InfIoTimeout" disguised="1">
      <doc xml:space="preserve">#InfIoTimeout represents a timer which will call a specified function in
the future. It is an opaque data type. You should only access it via the
public API functions.</doc>
    </record>
    <callback name="IoTimeoutFunc" c:type="InfIoTimeoutFunc">
      <doc xml:space="preserve">Callback function that is called when a timeout has elapsed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:space="preserve">User-defined data specified in inf_io_add_timeout().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IoWatch" c:type="InfIoWatch" disguised="1">
      <doc xml:space="preserve">#InfIoWatch represents a watch on a #InfNativeSocket for events to occur.
It is an opaque data type. You should only access it via the public
API functions.</doc>
    </record>
    <callback name="IoWatchFunc" c:type="InfIoWatchFunc">
      <doc xml:space="preserve">Callback function that is called when an event occurs on a watched socket.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="socket" transfer-ownership="none">
          <doc xml:space="preserve">The socket on which an event occured.</doc>
          <array zero-terminated="0" c:type="InfNativeSocket*" fixed-size="1">
            <type name="NativeSocket" c:type="InfNativeSocket"/>
          </array>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve">A bitmask of the events that occured.</doc>
          <type name="IoEvent" c:type="InfIoEvent"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">User-defined data specified in inf_io_add_watch().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IpAddress"
            c:type="InfIpAddress"
            glib:type-name="InfIpAddress"
            glib:get-type="inf_ip_address_get_type"
            c:symbol-prefix="ip_address">
      <doc xml:space="preserve">#InfIpAddress is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new_from_string"
                   c:identifier="inf_ip_address_new_from_string">
        <doc xml:space="preserve">Creates a new IP address (either IPv4 or IPv6) from the given string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress, or %NULL.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">A string containing an IPv4 or IPv6 address in standard dots
notation.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_loopback4"
                   c:identifier="inf_ip_address_new_loopback4">
        <doc xml:space="preserve">Creates a new IPv4 address that contains the local host's IP address
("127.0.0.1").</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
      </constructor>
      <constructor name="new_loopback6"
                   c:identifier="inf_ip_address_new_loopback6">
        <doc xml:space="preserve">Creates a new IPv6 address that contains the local host's IP address
("::1").</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
      </constructor>
      <constructor name="new_raw4" c:identifier="inf_ip_address_new_raw4">
        <doc xml:space="preserve">Creates a new IPv4 address.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">An IPv4 address in network byte order.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_raw6" c:identifier="inf_ip_address_new_raw6">
        <doc xml:space="preserve">Creates a new IPv6 address.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">An IPv6 address in network bype order.</doc>
            <type name="guint8" c:type="const guint8"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="collate" c:identifier="inf_ip_address_collate">
        <doc xml:space="preserve">Compares the two addresses for sorting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 if @address1 compares before, 0 if it compares equal or
1 if it compares after @address.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="address1" transfer-ownership="none">
            <doc xml:space="preserve">First address.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </instance-parameter>
          <parameter name="address2" transfer-ownership="none">
            <doc xml:space="preserve">Second address.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_ip_address_copy">
        <doc xml:space="preserve">Creates a new #InfIpAddress that contains the same address as @address.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfIpAddress.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIpAddress.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_ip_address_free">
        <doc xml:space="preserve">Frees @address.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIpAddress.</doc>
            <type name="IpAddress" c:type="InfIpAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_family" c:identifier="inf_ip_address_get_family">
        <doc xml:space="preserve">Returns the address family of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIpAddressFamily.</doc>
          <type name="IpAddressFamily" c:type="InfIpAddressFamily"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIpAddress.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_raw" c:identifier="inf_ip_address_get_raw">
        <doc xml:space="preserve">Returns either 32 bit (IPv4) or 128 bit (IPv6) raw address data in host
byte order of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The raw address.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIpAddress.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="inf_ip_address_to_string">
        <doc xml:space="preserve">Returns a string representation of @address in standard dots format (like
"192.168.0.1" or "::1").</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-allocated string. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIpAddress.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="IpAddressFamily"
                 glib:type-name="InfIpAddressFamily"
                 glib:get-type="inf_ip_address_family_get_type"
                 c:type="InfIpAddressFamily">
      <doc xml:space="preserve">This enumeration specifies different types of IP addresses.</doc>
      <member name="IPv4"
              value="0"
              c:identifier="INF_IP_ADDRESS_IPV4"
              glib:nick="IPv4">
        <doc xml:space="preserve">This specifies an IPv4 address.</doc>
      </member>
      <member name="IPv6"
              value="1"
              c:identifier="INF_IP_ADDRESS_IPV6"
              glib:nick="IPv6">
        <doc xml:space="preserve">This specifies an IPv6 address.</doc>
      </member>
    </enumeration>
    <record name="Keepalive"
            c:type="InfKeepalive"
            glib:type-name="InfKeepalive"
            glib:get-type="inf_keepalive_get_type"
            c:symbol-prefix="keepalive">
      <doc xml:space="preserve">This structure contains the settings to configure keep-alive on TCP
connections.</doc>
      <field name="mask" writable="1">
        <doc xml:space="preserve">Which of the following settings are enabled. If a setting is
disabled, then the system default is taken.</doc>
        <type name="KeepaliveMask" c:type="InfKeepaliveMask"/>
      </field>
      <field name="enabled" writable="1">
        <doc xml:space="preserve">Whether sending keep-alive probes is enabled or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="time" writable="1">
        <doc xml:space="preserve">Time in seconds after which to send keep-alive probes.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="interval" writable="1">
        <doc xml:space="preserve">Time in seconds between keep-alive probes.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <method name="apply" c:identifier="inf_keepalive_apply" throws="1">
        <doc xml:space="preserve">Sets the keepalive settings of @keepalive for the socket @socket. This
function abstracts away the platform-dependent configuration of keepalives.

If @current_mask is not %INF_KEEPALIVE_ALL, it can help this function to
not do some unneccessary system calls.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE if an error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">A #InfKeepalive.</doc>
            <type name="Keepalive" c:type="const InfKeepalive*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">The socket to which to apply the keepalive settings.</doc>
            <type name="NativeSocket" c:type="InfNativeSocket*"/>
          </parameter>
          <parameter name="current_mask" transfer-ownership="none">
            <doc xml:space="preserve">The mask of currently applied keepalive settings on the
socket, or %INF_KEEPALIVE_ALL if unknown.</doc>
            <type name="KeepaliveMask" c:type="InfKeepaliveMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="inf_keepalive_copy">
        <doc xml:space="preserve">Makes a dynamically allocated copy of @keepalive. This is typically not
needed, since the structure can be copied by value, but might prove useful
for language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of @keepalive. Free with
inf_keepalive_free().</doc>
          <type name="Keepalive" c:type="InfKeepalive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">The #InfKeepalive to copy.</doc>
            <type name="Keepalive" c:type="const InfKeepalive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_keepalive_free">
        <doc xml:space="preserve">Frees a #InfKeepalive obtained with inf_keepalive_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">A dynamically allocated #InfKeepalive.</doc>
            <type name="Keepalive" c:type="InfKeepalive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_default" c:identifier="inf_keepalive_load_default">
        <doc xml:space="preserve">This function attempts to obtain the default keepalive settings from the
system. If it cannot obtain the default settings, the documented standard
values for the host platform are used.

Only the values specified in @mask are obtained, and other fields in
@keepalive are left untouched.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="keepalive"
                              direction="inout"
                              caller-allocates="0"
                              transfer-ownership="full">
            <doc xml:space="preserve">A #InfKeepalive.</doc>
            <type name="Keepalive" c:type="InfKeepalive*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">A mask that specifies which values to obtain.</doc>
            <type name="KeepaliveMask" c:type="InfKeepaliveMask"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="KeepaliveMask"
              glib:type-name="InfKeepaliveMask"
              glib:get-type="inf_keepalive_mask_get_type"
              c:type="InfKeepaliveMask">
      <doc xml:space="preserve">This bitmask specifies which of the fields in #InfKeepalive
override the system defaults. For fields that are not enabled in the
bitmask, the system default value is taken, and the corresponding field in
#InfKeepalive is ignored.</doc>
      <member name="enabled"
              value="1"
              c:identifier="INF_KEEPALIVE_ENABLED"
              glib:nick="enabled">
        <doc xml:space="preserve">Whether the keepalive mechanism is
explicitly enabled or disabled.</doc>
      </member>
      <member name="time"
              value="2"
              c:identifier="INF_KEEPALIVE_TIME"
              glib:nick="time">
        <doc xml:space="preserve">Whether the keepalive time is
overriding the system default.</doc>
      </member>
      <member name="interval"
              value="4"
              c:identifier="INF_KEEPALIVE_INTERVAL"
              glib:nick="interval">
        <doc xml:space="preserve">Whether the keepalive interval is
overriding the system default.</doc>
      </member>
      <member name="all"
              value="7"
              c:identifier="INF_KEEPALIVE_ALL"
              glib:nick="all">
        <doc xml:space="preserve">All previous values combined.</doc>
      </member>
    </bitfield>
    <interface name="LocalPublisher"
               c:symbol-prefix="local_publisher"
               c:type="InfLocalPublisher"
               glib:type-name="InfLocalPublisher"
               glib:get-type="inf_local_publisher_get_type"
               glib:type-struct="LocalPublisherInterface">
      <doc xml:space="preserve">#InfLocalPublisher is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="publish" invoker="publish">
        <doc xml:space="preserve">Publishes a service through @publisher so that it can be discovered with
an appropriate #InfDiscovery.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfLocalPublisherItem that can be used
to unpublish the service again.</doc>
          <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
        </return-value>
        <parameters>
          <instance-parameter name="publisher" transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisher.</doc>
            <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type to publish, such as _http._tcp.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the service.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The port the service is listening on.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unpublish" invoker="unpublish">
        <doc xml:space="preserve">Unpublishes @item so that it can no longer be found in the network.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="publisher" transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisher.</doc>
            <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">A published item obtained from inf_local_publisher_publish().</doc>
            <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="publish" c:identifier="inf_local_publisher_publish">
        <doc xml:space="preserve">Publishes a service through @publisher so that it can be discovered with
an appropriate #InfDiscovery.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfLocalPublisherItem that can be used
to unpublish the service again.</doc>
          <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
        </return-value>
        <parameters>
          <instance-parameter name="publisher" transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisher.</doc>
            <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The service type to publish, such as _http._tcp.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the service.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The port the service is listening on.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish" c:identifier="inf_local_publisher_unpublish">
        <doc xml:space="preserve">Unpublishes @item so that it can no longer be found in the network.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="publisher" transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisher.</doc>
            <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">A published item obtained from inf_local_publisher_publish().</doc>
            <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="LocalPublisherInterface"
            c:type="InfLocalPublisherInterface"
            glib:is-gtype-struct-for="LocalPublisher">
      <doc xml:space="preserve">Virtual functions for #InfLocalPublisher.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="publish">
        <callback name="publish">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfLocalPublisherItem that can be used
to unpublish the service again.</doc>
            <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
          </return-value>
          <parameters>
            <parameter name="publisher" transfer-ownership="none">
              <doc xml:space="preserve">A #InfLocalPublisher.</doc>
              <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">The service type to publish, such as _http._tcp.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">The name of the service.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="port" transfer-ownership="none">
              <doc xml:space="preserve">The port the service is listening on.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unpublish">
        <callback name="unpublish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="publisher" transfer-ownership="none">
              <doc xml:space="preserve">A #InfLocalPublisher.</doc>
              <type name="LocalPublisher" c:type="InfLocalPublisher*"/>
            </parameter>
            <parameter name="item" transfer-ownership="none">
              <doc xml:space="preserve">A published item obtained from inf_local_publisher_publish().</doc>
              <type name="LocalPublisherItem" c:type="InfLocalPublisherItem*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="LocalPublisherItem"
            c:type="InfLocalPublisherItem"
            disguised="1">
      <doc xml:space="preserve">#InfLocalPublisherItem is an opaque data type. You should only access it
via the public API functions.</doc>
    </record>
    <constant name="NATIVE_SOCKET_SENDRECV_FLAGS"
              value="0"
              c:type="INF_NATIVE_SOCKET_SENDRECV_FLAGS">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="NameResolver"
           c:symbol-prefix="name_resolver"
           c:type="InfNameResolver"
           parent="GObject.Object"
           glib:type-name="InfNameResolver"
           glib:get-type="inf_name_resolver_get_type"
           glib:type-struct="NameResolverClass">
      <doc xml:space="preserve">#InfNameResolver is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_name_resolver_new">
        <doc xml:space="preserve">Creates a new #InfNameResolver. Use inf_name_resolver_start() to start
resolving the hostname.

If @service is not %NULL, it should be a decimal port number or a
well-known service name that is translated into a port number, such as
&amp;quot;http&amp;quot. If @srv is not %NULL, the function will first attempt
a SRV lookup, and fall back to a regular A/AAAA lookup in case no SRV
record exists. Otherwise the SRV result is taken. If @service is
provided, it always overwrites the port number obtained from the hostname
lookup.

The recommended procedure is to call this function with @service equal to
the port number entered by the user, or %NULL if the user did not provide
an explicit port number. If the resulting port number obtained with
inf_name_resolver_get_port() is then different from 0, then use that
port number, otherwise the default port number for the service.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfNameResolver. Free with
g_object_unref().</doc>
          <type name="NameResolver" c:type="InfNameResolver*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object used to schedule events in the main thread.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">The hostname to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The name of the service to look up, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="srv"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The SRV record to look up, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="resolved">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="finished" c:identifier="inf_name_resolver_finished">
        <doc xml:space="preserve">Returns whether the resolver is currently looking up a hostname, or whether
it is ready to start a new lookup with inf_name_resolver_start().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a call to inf_name_resolver_start() can be made.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="inf_name_resolver_get_address">
        <doc xml:space="preserve">Returns the @index&lt;!-- --&gt;th address looked up in the last hostname
resolution operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The looked up #InfIpAddress.</doc>
          <type name="IpAddress" c:type="const InfIpAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index for which to return the address, in case multiple
IP addresses correspond to the same hostname.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_hostname"
              c:identifier="inf_name_resolver_get_hostname">
        <doc xml:space="preserve">Returns the currently configured hostname that @resolver will look up.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The currently configured hostname.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_addresses"
              c:identifier="inf_name_resolver_get_n_addresses">
        <doc xml:space="preserve">Returns the number of resolved addresses that belongs to the hostname
that was looked up.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of addresses available.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="inf_name_resolver_get_port">
        <doc xml:space="preserve">Returns the @index&lt;!-- --&gt;th port looked up in the last hostname
resolution operation. This can be 0 if the @service parameter in
inf_name_resolver_start() has been set to %NULL and no SRV record has
been found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The looked up #InfIpAddress.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index for which to return the port, in case multiple
IP addresses correspond to the same hostname.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service" c:identifier="inf_name_resolver_get_service">
        <doc xml:space="preserve">Returns the currently configured service that @resolver will look up.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The currently configured service.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_srv" c:identifier="inf_name_resolver_get_srv">
        <doc xml:space="preserve">Returns the currently configured SRV record that @resolver will look up.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The currently configured SRV record.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_backup"
              c:identifier="inf_name_resolver_lookup_backup"
              throws="1">
        <doc xml:space="preserve">Tries to look up backup addresses for the configured hostname. This should
be used if connecting to none of the initially reported addresses works.
The function returns %FALSE if there are no backup addresses available, or
%TRUE otherwise. If it returns %TRUE, it the #InfNameResolver::resolved
signal will be emitted again, and when it is, more addresses might be
available from the resolver object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if looking up backup addresses is attempted, or %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="inf_name_resolver_start" throws="1">
        <doc xml:space="preserve">Starts the name resolution for the hostname configured with @resolver.

When the hostname lookup has finished, the #InfNameResolver::resolved
signal is emitted. The function can only be called again once this signal
has been emitted. When this function is called, the previously looked up
result can no longer be obtained with the inf_name_resolver_get_address()
and inf_name_resolver_get_port() functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE if a (synchronous) error occurred.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">A #InfNameResolver.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hostname"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="io" writable="1" construct="1" transfer-ownership="none">
        <type name="Io"/>
      </property>
      <property name="service"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="srv"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="resolved" when="last">
        <doc xml:space="preserve">This signal is emitted when the hostname has been resolved. The function
inf_name_resolver_get_address() and inf_name_resolver_get_port() can be
called to obtain the resolved addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A description of the error that occurred, or %NULL.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="NameResolverClass"
            c:type="InfNameResolverClass"
            glib:is-gtype-struct-for="NameResolver">
      <doc xml:space="preserve">This structure contains the default signal handlers of #InfNameResolver.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="resolved">
        <callback name="resolved">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="NameResolver" c:type="InfNameResolver*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="Request"
               c:symbol-prefix="request"
               c:type="InfRequest"
               glib:type-name="InfRequest"
               glib:get-type="inf_request_get_type"
               glib:type-struct="RequestInterface">
      <doc xml:space="preserve">#InfRequest is an opaque data type. You should only access it
via the public API functions.</doc>
      <function name="error_quark" c:identifier="inf_request_error_quark">
        <doc xml:space="preserve">Error domain for request errors. Errors in this domain will be from the
#InfRequestError enumeration. See #GError for information on error domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="strerror" c:identifier="inf_request_strerror">
        <doc xml:space="preserve">Returns a human-readable string for the given error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A static string that must not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">An error code from the #InfRequestError enumeration.</doc>
            <type name="RequestError" c:type="InfRequestError"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <type name="Request" c:type="InfRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_local" invoker="is_local">
        <doc xml:space="preserve">Returns whether @request is local or remote. A local request was triggered
by a local API call, whereas a remote request was caused by a remote
participant from the network.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request is local and %FALSE if it is remote.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="fail" c:identifier="inf_request_fail">
        <doc xml:space="preserve">Declares the request as failed by emitting the #InfRequest::finished
signal with the given error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError describing the reason for why the request failed.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish" c:identifier="inf_request_finish">
        <doc xml:space="preserve">Declares the request as succeeded by emitting the #InfRequest::finished
signal with the given result. The function takes ownership of @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="full">
            <doc xml:space="preserve">A #InfRequestResult containing the result of
the request.</doc>
            <type name="RequestResult" c:type="InfRequestResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_local" c:identifier="inf_request_is_local">
        <doc xml:space="preserve">Returns whether @request is local or remote. A local request was triggered
by a local API call, whereas a remote request was caused by a remote
participant from the network.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request is local and %FALSE if it is remote.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="request" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="progress" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="finished" when="last">
        <doc xml:space="preserve">This signal is emitted when the request finishes. If @error is
non-%NULL the request failed, otherwise it finished successfully.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult which contains the result of the request.</doc>
            <type name="RequestResult"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">Error information in case the request failed, or %NULL
otherwise.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <enumeration name="RequestError"
                 c:type="InfRequestError"
                 glib:error-domain="INF_REQUEST_ERROR">
      <doc xml:space="preserve">These are general request errors that all #InfcRequest&lt;!-- --&gt;s can
fail with. Specific requests may also fail with more errors, such as
#InfDirectoryError.</doc>
      <member name="unknown_domain"
              value="0"
              c:identifier="INF_REQUEST_ERROR_UNKNOWN_DOMAIN">
        <doc xml:space="preserve">The server sent &amp;lt;request-failed/&amp;gt;
with an unknown error domain.</doc>
      </member>
      <member name="reply_unprocessed"
              value="1"
              c:identifier="INF_REQUEST_ERROR_REPLY_UNPROCESSED">
        <doc xml:space="preserve">An error occured while processing the
server reply for a request.</doc>
      </member>
      <member name="invalid_seq"
              value="2"
              c:identifier="INF_REQUEST_ERROR_INVALID_SEQ">
        <doc xml:space="preserve">The server sent an invalid sequence number
in a reply to a request.</doc>
      </member>
      <member name="no_such_attribute"
              value="3"
              c:identifier="INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE">
        <doc xml:space="preserve">A request did not contain a XML
attribute that is required to complete the request.</doc>
      </member>
      <member name="invalid_attribute"
              value="4"
              c:identifier="INF_REQUEST_ERROR_INVALID_ATTRIBUTE">
        <doc xml:space="preserve">A request contains an XML attribute
with unexpected content.</doc>
      </member>
      <member name="invalid_number"
              value="5"
              c:identifier="INF_REQUEST_ERROR_INVALID_NUMBER">
        <doc xml:space="preserve">A number in a request was invalid.
Either it was not numerical, or it produced an underflow or an overflow.</doc>
      </member>
      <member name="not_authorized"
              value="6"
              c:identifier="INF_REQUEST_ERROR_NOT_AUTHORIZED">
        <doc xml:space="preserve">The requesting host is not authorized
to perform the requested action.</doc>
      </member>
      <member name="failed" value="7" c:identifier="INF_REQUEST_ERROR_FAILED">
        <doc xml:space="preserve">Generic error code when no further reason of
failure is known.</doc>
      </member>
    </enumeration>
    <callback name="RequestFunc" c:type="InfRequestFunc">
      <doc xml:space="preserve">Signature of a signal handler for the #InfRequest::finished signal.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="request" transfer-ownership="none">
          <doc xml:space="preserve">The #InfRequest that emits the signal.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequestResult which contains the result of the request.</doc>
          <type name="RequestResult" c:type="const InfRequestResult*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Error information in case the request failed, or %NULL
otherwise.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">Additional data set when the signal handler was connected.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="RequestInterface"
            c:type="InfRequestInterface"
            glib:is-gtype-struct-for="Request">
      <doc xml:space="preserve">Virtual functions of the #InfRequest interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="finished">
        <callback name="finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="RequestResult" c:type="const InfRequestResult*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_local">
        <callback name="is_local">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the request is local and %FALSE if it is remote.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="request" transfer-ownership="none">
              <doc xml:space="preserve">A #InfRequest.</doc>
              <type name="Request" c:type="InfRequest*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="RequestResult"
            c:type="InfRequestResult"
            glib:type-name="InfRequestResult"
            glib:get-type="inf_request_result_get_type"
            c:symbol-prefix="request_result">
      <doc xml:space="preserve">#InfRequestResult is an opaque data type. You should only access it
via the public API functions.</doc>
      <constructor name="new" c:identifier="inf_request_result_new">
        <doc xml:space="preserve">This function creates a new #InfRequestResult with the given data. The
function takes ownership of the data which must have been allocated with
g_malloc(). The memory segment at @data must not hold any object references
or require deinitialization in a way other than with g_free().

Under normal circumstances, this function should not be used, and instead
one of the inf_request_result_make_*() functions should be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free
with inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The data representing the result of the request.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of the data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="inf_request_result_copy">
        <doc xml:space="preserve">Creates a copy of @result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult.</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="inf_request_result_free">
        <doc xml:space="preserve">Releases all resources associated with @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult.</doc>
            <type name="RequestResult" c:type="InfRequestResult*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="inf_request_result_get">
        <doc xml:space="preserve">Returns the data of @result, as given to inf_request_result_new(). The
length of the data is stored in @length. Normally this function does not
need to be used and one of the inf_request_result_get_*() functions
should be used instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A pointer
to the request data.</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8" c:type="gconstpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult.</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">An output parameter for the length of the
result data, or %NULL.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_add_node"
              c:identifier="inf_request_result_get_add_node">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_add_node().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node to
which a node has been added, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
          <parameter name="new_node"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the
new node, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_create_acl_account"
              c:identifier="inf_request_result_get_create_acl_account">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_create_acl_account().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="account"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the created
#InfAclAccount, or %NULL.</doc>
            <type name="AclAccount" c:type="const InfAclAccount**"/>
          </parameter>
          <parameter name="certificate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the
certificate which can be used to log into the account, or %NULL.</doc>
            <type name="CertificateChain" c:type="InfCertificateChain**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_explore_node"
              c:identifier="inf_request_result_get_explore_node">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_explore_node().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node that
has been explored, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_join_user"
              c:identifier="inf_request_result_get_join_user">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_join_user().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="proxy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the session
proxy that made the request, or %NULL.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy**"/>
          </parameter>
          <parameter name="user"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the joined
user.</doc>
            <type name="User" c:type="InfUser**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_lookup_acl_accounts"
              c:identifier="inf_request_result_get_lookup_acl_accounts">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_lookup_acl_accounts().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
Output value for the list of accounts, or %NULL.</doc>
            <array length="2" zero-terminated="0" c:type="InfAclAccount**">
              <type name="AclAccount" c:type="InfAclAccount*"/>
            </array>
          </parameter>
          <parameter name="n_accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the size
of the account list, or %NULL.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_query_acl"
              c:identifier="inf_request_result_get_query_acl">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_query_acl().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node
whose ACL was queried.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
          <parameter name="sheet_set"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the
node's ACL sheets.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_query_acl_account_list"
              c:identifier="inf_request_result_get_query_acl_account_list">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_query_acl_account_list().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
Output value for the list of accounts, or %NULL.</doc>
            <array length="2" zero-terminated="0" c:type="InfAclAccount**">
              <type name="AclAccount" c:type="InfAclAccount*"/>
            </array>
          </parameter>
          <parameter name="n_accounts"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the size
of the account list, or %NULL.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="does_notifications" transfer-ownership="none">
            <doc xml:space="preserve">Output value for the flag whether the server notifies
the client about added or removed accounts, or %NULL.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_remove_acl_account"
              c:identifier="inf_request_result_get_remove_acl_account">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_remove_acl_account().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="account"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the removed
#InfAclAccount, or %NULL.</doc>
            <type name="AclAccount" c:type="const InfAclAccount**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_remove_node"
              c:identifier="inf_request_result_get_remove_node">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_remove_node().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node that
has been removed, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_save_session"
              c:identifier="inf_request_result_get_save_session">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_save_session().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node that
has been saved, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_set_acl" c:identifier="inf_request_result_get_set_acl">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_set_acl().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node whose
ACL was set.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_subscribe_chat"
              c:identifier="inf_request_result_get_subscribe_chat">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_subscribe_chat().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="proxy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the
subscribed session's proxy, or %NULL.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_subscribe_session"
              c:identifier="inf_request_result_get_subscribe_session">
        <doc xml:space="preserve">Decomposes @result into its components. The object must have been created
with inf_request_result_make_subscribe_session().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequestResult:</doc>
            <type name="RequestResult" c:type="const InfRequestResult*"/>
          </instance-parameter>
          <parameter name="browser"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value of the browser
that made the request, or %NULL.</doc>
            <type name="Browser" c:type="InfBrowser**"/>
          </parameter>
          <parameter name="iter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the node that
has been subscribed to, or %NULL.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter**"/>
          </parameter>
          <parameter name="proxy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">Output value for the subscribed
session's proxy, or %NULL.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy**"/>
          </parameter>
        </parameters>
      </method>
      <function name="make_add_node"
                c:identifier="inf_request_result_make_add_node">
        <doc xml:space="preserve">Creates a new #InfRequestResult for an "add-node" request, see
inf_browser_add_note() or inf_browser_add_subdirectory(). The
#InfRequestResult object is only valid as long as the caller maintains
a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which a node has been added.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="new_node" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the new node.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_create_acl_account"
                c:identifier="inf_request_result_make_create_acl_account">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "create-acl-account" request, see
inf_browser_create_acl_account(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The created #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">The certificate which can be used to log into @account.</doc>
            <type name="CertificateChain" c:type="InfCertificateChain*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_explore_node"
                c:identifier="inf_request_result_make_explore_node">
        <doc xml:space="preserve">Creates a new #InfRequestResult for an "explore-node" request, see
inf_browser_explore(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which was explored.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_join_user"
                c:identifier="inf_request_result_make_join_user">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "join-user" request, see
inf_session_proxy_join_user(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The joined user.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_lookup_acl_accounts"
                c:identifier="inf_request_result_make_lookup_acl_accounts">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "lookup-acl-accounts" request, see
inf_browser_lookup_acl_accounts(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="accounts" transfer-ownership="none">
            <doc xml:space="preserve">The list of accounts.</doc>
            <array length="2" zero-terminated="0" c:type="InfAclAccount*">
              <type name="AclAccount" c:type="InfAclAccount"/>
            </array>
          </parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <doc xml:space="preserve">The number of entries in the account list.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_query_acl"
                c:identifier="inf_request_result_make_query_acl">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "query-acl" request, see
inf_browser_query_acl(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node whose ACL was queried.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="sheet_set" transfer-ownership="none">
            <doc xml:space="preserve">The sheet set for the queried node.</doc>
            <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_query_acl_account_list"
                c:identifier="inf_request_result_make_query_acl_account_list">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "query-acl-account-list" request, see
inf_browser_query_acl_account_list(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="accounts" transfer-ownership="none">
            <doc xml:space="preserve">The list of accounts.</doc>
            <array length="2" zero-terminated="0" c:type="InfAclAccount*">
              <type name="AclAccount" c:type="InfAclAccount"/>
            </array>
          </parameter>
          <parameter name="n_accounts" transfer-ownership="none">
            <doc xml:space="preserve">The number of items in the account list.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="does_notifications" transfer-ownership="none">
            <doc xml:space="preserve">Whether the server notifies the clients about added
or removed accounts.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_remove_acl_account"
                c:identifier="inf_request_result_make_remove_acl_account">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "remove-acl-account" request, see
inf_browser_remove_acl_account(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="account" transfer-ownership="none">
            <doc xml:space="preserve">The removed #InfAclAccount.</doc>
            <type name="AclAccount" c:type="const InfAclAccount*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_remove_node"
                c:identifier="inf_request_result_make_remove_node">
        <doc xml:space="preserve">Creates a new #InfRequestResult for an "remove-node" request, see
inf_browser_remove_node(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which was removed.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_save_session"
                c:identifier="inf_request_result_make_save_session">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "save-session" request, see
infc_browser_iter_save_session(). The #InfRequestResult object is only
valid as long as the caller maintains a reference to @browser.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which was saved.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_set_acl"
                c:identifier="inf_request_result_make_set_acl">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "set-acl" request, see
inf_browser_set_acl(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node whose ACL was set.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_subscribe_chat"
                c:identifier="inf_request_result_make_subscribe_chat">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "subscribe-chat" request, see
infc_browser_subscribe_chat(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #InfSessionProxy for the subscribed session.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make_subscribe_session"
                c:identifier="inf_request_result_make_subscribe_session">
        <doc xml:space="preserve">Creates a new #InfRequestResult for a "subscribe-session" request, see
inf_browser_subscribe(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
          <type name="RequestResult" c:type="InfRequestResult*"/>
        </return-value>
        <parameters>
          <parameter name="browser" transfer-ownership="none">
            <doc xml:space="preserve">A #InfBrowser.</doc>
            <type name="Browser" c:type="InfBrowser*"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">An iterator pointing to the node to which a subscription was made.</doc>
            <type name="BrowserIter" c:type="const InfBrowserIter*"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">The #InfSessionProxy for the subscription.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="SaslContext"
            c:type="InfSaslContext"
            glib:type-name="InfSaslContext"
            glib:get-type="inf_sasl_context_get_type"
            c:symbol-prefix="sasl_context">
      <doc xml:space="preserve">#InfSaslContext is an opaque data type. You should only access it via the
public API functions.</doc>
      <constructor name="new" c:identifier="inf_sasl_context_new" throws="1">
        <doc xml:space="preserve">Creates a new #InfSaslContext with a reference count of 1. If the function
fails it returns %NULL and @error is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfSaslContext, or %NULL on error. Free
with inf_sasl_context_unref() when no longer needed.</doc>
          <type name="SaslContext" c:type="InfSaslContext*"/>
        </return-value>
      </constructor>
      <method name="client_list_mechanisms"
              c:identifier="inf_sasl_context_client_list_mechanisms"
              throws="1">
        <doc xml:space="preserve">Returns a newly allocated space-separated string containing SASL mechanisms
that @context supports for client sessions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string. Free with g_free()
when no longer in use.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="client_start_session"
              c:identifier="inf_sasl_context_client_start_session"
              throws="1">
        <doc xml:space="preserve">Starts a new client-side SASL session using @mech for authentication. When
the session finished, that is either when an error occurred or the
authentication finished successfully, use inf_sasl_context_stop_session().

The callback function will be called in the thread that @io runs in.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfSaslContextSession.</doc>
          <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">The #InfIo main loop to which to dispatch callbacks.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="mech" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for the session.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="session_data" transfer-ownership="none">
            <doc xml:space="preserve">Session-specific data to provide to the
#InfSaslContextCallbackFunc.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="client_suggest_mechanism"
              c:identifier="inf_sasl_context_client_suggest_mechanism">
        <doc xml:space="preserve">Given a list of SASL mechanisms this function suggests the which is the
"best" one to be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the suggested mechanism.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="mechanisms" transfer-ownership="none">
            <doc xml:space="preserve">Space-separated list of SASL mechanism names.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="client_supports_mechanism"
              c:identifier="inf_sasl_context_client_supports_mechanism">
        <doc xml:space="preserve">Checks whether @context supports the mechanism with name @mech for
client sessions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mech is supported or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="mech" transfer-ownership="none">
            <doc xml:space="preserve">The name of the mechanism to be tested.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="inf_sasl_context_ref">
        <doc xml:space="preserve">Increases the reference count of @context by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in pointer, @context.</doc>
          <type name="SaslContext" c:type="InfSaslContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="server_list_mechanisms"
              c:identifier="inf_sasl_context_server_list_mechanisms"
              throws="1">
        <doc xml:space="preserve">Returns a newly allocated space-separated string containing SASL mechanisms
that @context supports for server sessions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string. Free with g_free()
when no longer in use.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="server_start_session"
              c:identifier="inf_sasl_context_server_start_session"
              throws="1">
        <doc xml:space="preserve">Starts a new server-side SASL session using @mech for authentication. When
the session finished, that is either when an error occurred or the
authentication finished successfully, use inf_sasl_context_stop_session().

The callback function will be called in the thread that @io runs in.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfSaslContextSession.</doc>
          <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">The #InfIo main loop to which to dispatch callbacks.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="mech" transfer-ownership="none">
            <doc xml:space="preserve">The mechanism to use for the session.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="session_data" transfer-ownership="none">
            <doc xml:space="preserve">Session-specific data to provide to the
#InfSaslContextCallbackFunc.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="server_supports_mechanism"
              c:identifier="inf_sasl_context_server_supports_mechanism">
        <doc xml:space="preserve">Checks whether @context supports the mechanism with name @mech for
server sessions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mech is supported or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="mech" transfer-ownership="none">
            <doc xml:space="preserve">The name of the mechanism to be tested.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_callback" c:identifier="inf_sasl_context_set_callback">
        <doc xml:space="preserve">Sets the callback to call when, during authentication, a certain properties
needs to be provided, such as a username or a password. The callback
function is expected to set the requested property using
inf_sasl_context_session_set_property() and then call
inf_sasl_context_session_continue() with retval being GSASL_OK. If it
cannot provide the property then it should only call
inf_sasl_context_session_continue() with retval indicating the problem.

The callback function does not need to provide the property immediately.
It is also allowed return and call inf_sasl_context_session_continue()
later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">A function to call to query properties for authentication.</doc>
            <type name="SaslContextCallbackFunc"
                  c:type="InfSaslContextCallbackFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional context to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">Function called to destroy @user_data once it is no longer needed,
or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_session" c:identifier="inf_sasl_context_stop_session">
        <doc xml:space="preserve">Finishes @session and frees all resources allocated to it. This can be used
to cancel an authentication session, or to free it after it finished
(either successfully or not).

@session should no longer be used after this function was called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession created with @context.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="inf_sasl_context_unref">
        <doc xml:space="preserve">Decreases the reference count of @sasl by one. When the reference count
reaches zero then the object is freed and may no longer be used. If that
happens then also all sessions created with
inf_sasl_context_client_start_session() or
inf_sasl_context_server_start_session() are stopped automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContext.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="SaslContextCallbackFunc"
              c:type="InfSaslContextCallbackFunc">
      <doc xml:space="preserve">This callback is called whenever a property is required to proceed with
authentication. For example, when a password is required, the callback is
called with @property set to %GSASL_PASSCODE.

The function is then expected to set that property using
inf_sasl_context_session_set_property() and, once it is done, call
inf_sasl_context_session_continue(). This can happen fully asynchronously,
that is it does not need to take place directly within the callback but the
callback can, for example, open a dialog for the user to enter a password
and then once the user closes the dialog call the two functions mentioned
above.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">A #InfSaslContextSession.</doc>
          <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
        </parameter>
        <parameter name="property" transfer-ownership="none">
          <doc xml:space="preserve">The property requested.</doc>
          <type name="InfGsasl.Property" c:type="Gsasl_property"/>
        </parameter>
        <parameter name="session_data" transfer-ownership="none">
          <doc xml:space="preserve">The session data for session specified in
inf_sasl_context_server_start_session() or
inf_sasl_context_client_start_session().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">The user data specified in inf_sasl_context_set_callback().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SaslContextSession"
            c:type="InfSaslContextSession"
            disguised="1"
            foreign="1">
      <doc xml:space="preserve">#InfSaslContextSession represents an ongoing authentication session. Create
with inf_sasl_context_server_start_session() or
inf_sasl_context_client_start_session().</doc>
      <method name="continue" c:identifier="inf_sasl_context_session_continue">
        <doc xml:space="preserve">When the callback function specified in inf_sasl_context_set_callback()
is called then @session waits for the user to call
inf_sasl_context_session_continue(). It should do so once it provided the
requested property using inf_sasl_context_session_set_property() with
@retval being %GSASL_OK. If it decides that the property cannot be provided
then it should still call this function with @retval being a SASL error
code specifying the problem.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </instance-parameter>
          <parameter name="retval" transfer-ownership="none">
            <doc xml:space="preserve">Error code of the operation requested.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="feed" c:identifier="inf_sasl_context_session_feed">
        <doc xml:space="preserve">This function feeds data from the session's remote counterpart to @session.
It should be base64 encoded. This function will, asynchronously, process
the data and query for properties it requires to do so. Once it has
finished, @func is called with output data to send to the remote side to
be fed to its session counterpart.

This function must not be called again before @func was called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The data to feed to the SASL session.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">The function to call when the data has been
processed.</doc>
            <type name="SaslContextSessionFeedFunc"
                  c:type="InfSaslContextSessionFeedFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional user data to pass to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property"
              c:identifier="inf_sasl_context_session_get_property">
        <doc xml:space="preserve">Returns the value of the property @prop in @session. If the value does not
yet exist then this function returns %NULL. It does not invoke the
#InfSaslContextCallbackFunc to query it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the property, or %NULL. The value is
owned by the session and must not be freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </instance-parameter>
          <parameter name="prop" transfer-ownership="none">
            <doc xml:space="preserve">A SASL property.</doc>
            <type name="InfGsasl.Property" c:type="Gsasl_property"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_processing"
              c:identifier="inf_sasl_context_session_is_processing">
        <doc xml:space="preserve">Returns whether the session is currently asynchronously processing data
fed to it with inf_sasl_context_session_feed(). In this case the first
call needs to finish before another one is allowed to be made.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @session is currently processing data asynchronously.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_property"
              c:identifier="inf_sasl_context_session_set_property">
        <doc xml:space="preserve">Sets the property @prop in @session to @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSaslContextSession.</doc>
            <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
          </instance-parameter>
          <parameter name="prop" transfer-ownership="none">
            <doc xml:space="preserve">A SASL property.</doc>
            <type name="InfGsasl.Property" c:type="Gsasl_property"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The value to set the property to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="SaslContextSessionFeedFunc"
              c:type="InfSaslContextSessionFeedFunc">
      <doc xml:space="preserve">This function is called in response to inf_sasl_context_session_feed().
When all required properties (if any) have been provided by the callback
function then this function is called with the response to send to the
remote site.

If an error occurred then @error will be set and @data will be %NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">A #InfSaslContextSession.</doc>
          <type name="SaslContextSession" c:type="InfSaslContextSession*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The response to the fed data, base64 encoded and null-terminated.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="needs_more" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE then inf_sasl_context_session_feed() needs to be
called again with more data, otherwise the authentication has finished.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">This is nonzero if an error occured while processing the input
data.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">The user data specified in inf_sasl_context_session_feed().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="InfSession"
           parent="GObject.Object"
           glib:type-name="InfSession"
           glib:get-type="inf_session_get_type"
           glib:type-struct="SessionClass">
      <doc xml:space="preserve">#InfSession is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="CommunicationObject"/>
      <function name="get_user_property"
                c:identifier="inf_session_get_user_property">
        <doc xml:space="preserve">Looks up the paremeter with the given name in @array. If there is no such
parameter, a new one will be created.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GParameter.</doc>
          <type name="GObject.Parameter" c:type="GParameter*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">A #GArray containing #GParameter values.</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GObject.Parameter"/>
            </array>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">Name to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_user_property"
                c:identifier="inf_session_lookup_user_property">
        <doc xml:space="preserve">Looks up the parameter with the given name in @array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GParameter, or %NULL.</doc>
          <type name="GObject.Parameter" c:type="const GParameter*"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an array of containing
#GParameter values.</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">The number of elements in the aforementioned array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">Name to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="close" invoker="close">
        <doc xml:space="preserve">Closes a running session. When a session is closed, it unrefs all
connections and no longer handles requests.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_xml_user_props" introspectable="0">
        <return-value>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="conn" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_xml_run" throws="1">
        <return-value transfer-ownership="none">
          <type name="CommunicationScope" c:type="InfCommunicationScope"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_xml_sync" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_xml_user_props">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="GObject.Parameter" c:type="const GParameter*"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronization_begin">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronization_complete">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronization_failed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronization_progress">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
          <parameter name="percentage" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_xml_sync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="user_new" introspectable="0">
        <return-value>
          <type name="User" c:type="InfUser*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="GObject.Parameter" c:type="GParameter*"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="validate_user_props" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="GObject.Parameter" c:type="const GParameter*"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="exclude" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_user" c:identifier="inf_session_add_user">
        <doc xml:space="preserve">Adds a user to @session. The user object is constructed via the
user_new vfunc of #InfSessionClass. This will create a new #InfUser
object by default, but may be overridden by subclasses to create
different kinds of users.

Note that this function does not tell the other participants that the
user was added. To avoid conflicts, normally only the publisher of the
session can add users and notifies others accordingly. This is handled
by #InfdSessionProxy or #InfcSessionProxy, respectively.

You should not call this function unless you know what you are doing.
If @params comes from an untrusted source, they should be checked first
with the validate_user_props virtual function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new #InfUser.</doc>
          <type name="User" c:type="InfUser*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">Construction parameters for the #InfUser
(or derived) object.</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">Number of parameters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel_synchronization"
              c:identifier="inf_session_cancel_synchronization">
        <doc xml:space="preserve">Cancells an ongaing synchronization to or from @connection. If @session
is in state %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING,
@connection must match the connection that @session is synchronizing with.
If @session is in state %INF_SESSION_RUNNING, @connection can be any
connection that the session is currently being synchronized to.

In any case, the #InfSession::synchronization-failed signal will be
emitted for the cancelled synchronization. If the session is in state
%INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, the session will also
be closed, with the #InfSession::close signal being emited.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection with which to cancel synchronization.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="inf_session_close">
        <doc xml:space="preserve">Closes a running session. When a session is closed, it unrefs all
connections and no longer handles requests.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer" c:identifier="inf_session_get_buffer">
        <doc xml:space="preserve">Returns the buffer used by @session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfBuffer.</doc>
          <type name="Buffer" c:type="InfBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_communication_manager"
              c:identifier="inf_session_get_communication_manager">
        <doc xml:space="preserve">Returns the communication manager for @session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfCommunicationManager.</doc>
          <type name="CommunicationManager" c:type="InfCommunicationManager*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="inf_session_get_status">
        <doc xml:space="preserve">Returns the session's status.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The status of @session.</doc>
          <type name="SessionStatus" c:type="InfSessionStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subscription_group"
              c:identifier="inf_session_get_subscription_group">
        <doc xml:space="preserve">Returns the subscription group for @session, if any.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfCommunicationGroup, or %NULL.</doc>
          <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_synchronization_progress"
              c:identifier="inf_session_get_synchronization_progress">
        <doc xml:space="preserve">This function requires that the synchronization status of @connection
is %INF_SESSION_SYNC_IN_PROGRESS or %INF_SESSION_SYNC_AWAITING_ACK
(see inf_session_get_synchronization_status()). Then, it returns a value
between 0.0 and 1.0 specifying how much synchronization data has already
been transferred to the remote site.

Note that if the session is in status %INF_SESSION_RUNNING, it is
possible that this function returns 1.0 (i.e. all data has been
transmitted) but the synchronization is not yet complete, because the
remote site must still acknowledge the synchronization. The synchronization
then is in status %INF_SESSION_SYNC_AWAITING_ACK.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A value between 0.0 and 1.0.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_synchronization_status"
              c:identifier="inf_session_get_synchronization_status">
        <doc xml:space="preserve">If @session is in status %INF_SESSION_SYNCHRONIZING, this always returns
%INF_SESSION_SYNC_IN_PROGRESS if @connection is the connection with which
the session is synchronized, and %INF_SESSION_SYNC_NONE otherwise.

If @session is in status %INF_SESSION_RUNNING, this returns the status
of the synchronization to @connection. %INF_SESSION_SYNC_NONE is returned,
when there is currently no synchronization ongoing to @connection,
%INF_SESSION_SYNC_IN_PROGRESS is returned, if there is one, and
%INF_SESSION_SYNC_AWAITING_ACK if the synchronization is finished but we
are waiting for the acknowledgement from the remote site that all
synchronization data has been progressed successfully. The synchronization
can still fail in this state but it can no longer by cancelled.

If @session is in status $INF_SESSION_CLOSED, this always returns
%INF_SESSION_SYNC_NONE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The synchronization status of @connection.</doc>
          <type name="SessionSyncStatus" c:type="InfSessionSyncStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_table" c:identifier="inf_session_get_user_table">
        <doc xml:space="preserve">Returns the user table used by @session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfUserTable.</doc>
          <type name="UserTable" c:type="InfUserTable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_synchronizations"
              c:identifier="inf_session_has_synchronizations">
        <doc xml:space="preserve">Returns whether there are currently ongoing synchronizations. If the
session is in status %INF_SESSION_SYNCHRONIZING, then this returns always
%TRUE, if it is in %INF_SESSION_CLOSED, then it returns always %FALSE.
If the session is in status %INF_SESSION_RUNNING, then it returns %TRUE
when the session is currently at least synchronized to one connection and
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether there are ongoing synchronizations.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_to_subscriptions"
              c:identifier="inf_session_send_to_subscriptions">
        <doc xml:space="preserve">Sends a XML message to the all members of @session's subscription group.
This function can only be called if the subscription group is non-%NULL. It
takes ownership of @xml.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">The message to send.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subscription_group"
              c:identifier="inf_session_set_subscription_group">
        <doc xml:space="preserve">Sets the subscription group for @session. The subscription group is the
group in which all connections subscribed to the session are a member of.

#InfSession itself does not deal with subscriptions, so it is your job
to keep @group up-to-date (for example if you add non-local users to
@session). This is normally done by a so-called session proxy such as
#InfcSessionProxy or #InfdSessionProxy, respectively.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_status"
              c:identifier="inf_session_set_user_status">
        <doc xml:space="preserve">Changes the status of the given @user which needs to have the
%INF_USER_LOCAL flag set for this function to be called. If the status
is changed to %INF_USER_UNAVAILABLE, then the user leaves the session. To
rejoin use inf_session_proxy_join_user() for a proxy proxying @session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A local #InfUser from @session's user table.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">New status for @user.</doc>
            <type name="UserStatus" c:type="InfUserStatus"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_from"
              c:identifier="inf_session_synchronize_from">
        <doc xml:space="preserve">Switches @session's status to %INF_SESSION_SYNCHRONIZING. In
%INF_SESSION_PRESYNC, all messages from incoming the synchronizing
connection are ignored, and no cancellation request is sent to the remote
site if the status changes to %INF_SESSION_CLOSED. The rationale behind
that status is that one can prepare a session for synchronization but start
the actual synchronization later, after having made sure that the remote
site is ready to perform the synchronization.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession in status %INF_SESSION_PRESYNC.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="synchronize_to" c:identifier="inf_session_synchronize_to">
        <doc xml:space="preserve">Initiates a synchronization to @connection. On the other end of
@connection, a new session with the sync-connection and sync-group
construction properties set should have been created. @group is used
as a group in the communication manager. It is allowed for @group to have
another #InfCommunicationObject than @session, however, you should forward
the #InfCommunicationObject messages your object receives to @session then.
Also, @connection must already be present in @group, and should not be
removed until synchronization finished.

A synchronization can only be initiated if @session is in state
%INF_SESSION_RUNNING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession in status %INF_SESSION_RUNNING.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">A #InfCommunicationGroup.</doc>
            <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="user_to_xml" c:identifier="inf_session_user_to_xml">
        <doc xml:space="preserve">This is a convenience function that queries @user's properties and
calls set_xml_user_props with them. This adds the properties of @user
to @xml.

An equivalent user object may be built by calling the get_xml_user_props
vfunc on @xml and then calling the user_new vfunc with the resulting
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSession.</doc>
            <type name="Session" c:type="InfSession*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser contained in @session.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">An XML node to which to add user information.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <property name="buffer"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Buffer"/>
      </property>
      <property name="communication-manager"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationManager"/>
      </property>
      <property name="status"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SessionStatus"/>
      </property>
      <property name="subscription-group"
                writable="1"
                transfer-ownership="none">
        <type name="CommunicationGroup"/>
      </property>
      <property name="sync-connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="XmlConnection"/>
      </property>
      <property name="sync-group"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CommunicationGroup"/>
      </property>
      <property name="user-table"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="UserTable"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="close" when="last">
        <doc xml:space="preserve">This signal is emitted if the session is closed. Note that this signal
is not called as a client if the connection to the sessions has merely
been lost, only the relevant #InfXmlConnection has its
#InfXmlConnection:status property changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted when the session detects an error. The session
itself does not know much about the nature of the error. It might mean
the session is in an inconsistent state, or it might be recoverable.
This signal can be used to handle the error or to write error
information into a log file or bring to a user's attention in another
manner.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection which sent the erroneous request.</doc>
            <type name="XmlConnection"/>
          </parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML request that produced the error.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError providing information about the error.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="synchronization-begin" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the session is started to be synchronized
to another connection. Note that, in contrast to
#InfSession::synchronization-progress,
#InfSession::synchronization-failed and
#InfSession::synchronization-complete it cannot happen that the signal
is emitted when @session is being synchronized itself, because that can
happen at construction time only when no one had a chance to connect
signal handlers anyway.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">The #InfCommunicationGroup used for synchronization.</doc>
            <type name="CommunicationGroup"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection to which the session is synchronized.</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="synchronization-complete" when="last">
        <doc xml:space="preserve">This signal is emitted when synchronization has completed, in addition
to #InfSession::synchronization-progress with a progress value of 1.0.

If a callback is connected before the default handler, it can find out
whether the remote side is synchronizing the local side by comparing
@sessions&amp;apos;s status with %INF_SESSION_SYNCHRONIZING. The default
signal handler sets the status to %INF_SESSION_RUNNING, so checking
afterwards is not too useful.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection through which synchronization happened</doc>
            <type name="XmlConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="synchronization-failed" when="last">
        <doc xml:space="preserve">This signal is emitted when synchronization has failed before its
completion due to malformed data from the other side or network failure.

If this happens during initial synchronization, #InfSession::close is
emitted as well at this point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection through which synchronization happened</doc>
            <type name="XmlConnection"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #GError object with details on the error</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="synchronization-progress" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a new XML node has been sent or received
over @connection as part of a synchronization. The process is completed
when @progress reaches the value 1.0. At this point,
#InfSession::synchronization-complete is also emitted.

If @session&amp;apos;s status is %INF_SESSION_SYNCHRONIZING, the local
side is being synchronized by the remote side. If the status is
%INF_SESSION_RUNNING, the local side is updating the remote side.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmlConnection through which progress is made</doc>
            <type name="XmlConnection"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">A #gdouble value ranging from 0.0 to 1.0.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SessionClass"
            c:type="InfSessionClass"
            glib:is-gtype-struct-for="Session">
      <doc xml:space="preserve">This structure contains the virtual functions and default signal handlers
of #InfSession.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="to_xml_sync">
        <callback name="to_xml_sync">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="parent" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="process_xml_sync">
        <callback name="process_xml_sync" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="process_xml_run">
        <callback name="process_xml_run" throws="1">
          <return-value transfer-ownership="none">
            <type name="CommunicationScope" c:type="InfCommunicationScope"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_xml_user_props" introspectable="0">
        <callback name="get_xml_user_props" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_xml_user_props">
        <callback name="set_xml_user_props">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GObject.Parameter" c:type="const GParameter*"/>
            </parameter>
            <parameter name="n_params" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="validate_user_props">
        <callback name="validate_user_props" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GObject.Parameter" c:type="const GParameter*"/>
            </parameter>
            <parameter name="n_params" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="exclude" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="user_new" introspectable="0">
        <callback name="user_new" introspectable="0">
          <return-value>
            <type name="User" c:type="InfUser*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GObject.Parameter" c:type="GParameter*"/>
            </parameter>
            <parameter name="n_params" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">A #InfSession.</doc>
              <type name="Session" c:type="InfSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronization_begin">
        <callback name="synchronization_begin">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="group" transfer-ownership="none">
              <type name="CommunicationGroup" c:type="InfCommunicationGroup*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronization_progress">
        <callback name="synchronization_progress">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="percentage" transfer-ownership="none">
              <type name="gdouble" c:type="gdouble"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronization_complete">
        <callback name="synchronization_complete">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronization_failed">
        <callback name="synchronization_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="InfSession*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="SessionProxy"
               c:symbol-prefix="session_proxy"
               c:type="InfSessionProxy"
               glib:type-name="InfSessionProxy"
               glib:get-type="inf_session_proxy_get_type"
               glib:type-struct="SessionProxyInterface">
      <doc xml:space="preserve">#InfSessionProxy is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="join_user" invoker="join_user">
        <doc xml:space="preserve">Requests a user join for a user with the given properties (which must not
include #InfUser:id or #InfUser:flags since these are chosen by the session
proxy). The #InfUser:status property is optional and defaults to
%INF_USER_ACTIVE if not given. It must not be %INF_USER_UNAVAILABLE.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest object that may be used to get
notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </instance-parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">Number of parameters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">Construction properties for the
#InfUser (or derived) object.</doc>
            <array length="0" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">Function to be called on completion of the user
join, or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">Additional data to be passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="join_user" c:identifier="inf_session_proxy_join_user">
        <doc xml:space="preserve">Requests a user join for a user with the given properties (which must not
include #InfUser:id or #InfUser:flags since these are chosen by the session
proxy). The #InfUser:status property is optional and defaults to
%INF_USER_ACTIVE if not given. It must not be %INF_USER_UNAVAILABLE.

The request might either finish during the call to this function, in which
case @func will be called and %NULL being returned. If the request does not
finish within the function call, a #InfRequest object is returned,
where @func has been installed for the #InfRequest::finished signal,
so that it is called as soon as the request finishes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfRequest object that may be used to get
notified when the request finishes, or %NULL.</doc>
          <type name="Request" c:type="InfRequest*"/>
        </return-value>
        <parameters>
          <instance-parameter name="proxy" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSessionProxy.</doc>
            <type name="SessionProxy" c:type="InfSessionProxy*"/>
          </instance-parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">Number of parameters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">Construction properties for the
#InfUser (or derived) object.</doc>
            <array length="0" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">Function to be called on completion of the user
join, or %NULL.</doc>
            <type name="RequestFunc" c:type="InfRequestFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to be passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="session"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Session"/>
      </property>
    </interface>
    <record name="SessionProxyInterface"
            c:type="InfSessionProxyInterface"
            glib:is-gtype-struct-for="SessionProxy">
      <doc xml:space="preserve">Virtual functions for the #InfSessionProxy interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="join_user">
        <callback name="join_user">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">A #InfRequest object that may be used to get
notified when the request finishes, or %NULL.</doc>
            <type name="Request" c:type="InfRequest*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <doc xml:space="preserve">A #InfSessionProxy.</doc>
              <type name="SessionProxy" c:type="InfSessionProxy*"/>
            </parameter>
            <parameter name="n_params" transfer-ownership="none">
              <doc xml:space="preserve">Number of parameters.</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <doc xml:space="preserve">Construction properties for the
#InfUser (or derived) object.</doc>
              <array length="1" zero-terminated="0" c:type="GParameter*">
                <type name="GObject.Parameter" c:type="GParameter"/>
              </array>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">Function to be called on completion of the user
join, or %NULL.</doc>
              <type name="RequestFunc" c:type="InfRequestFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">Additional data to be passed to @func.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="SessionStatus"
                 glib:type-name="InfSessionStatus"
                 glib:get-type="inf_session_status_get_type"
                 c:type="InfSessionStatus">
      <doc xml:space="preserve">#InfSessionStatus defines in what state a session is in.</doc>
      <member name="presync"
              value="0"
              c:identifier="INF_SESSION_PRESYNC"
              glib:nick="presync">
        <doc xml:space="preserve">The session is scheduled to be synchronized from a
remote host. This can be useful if the session is needed to be present
before the actual synchronization begins. Use
inf_session_synchronize_from() to switch to
%INF_SESSION_SYNCHRONIZING.</doc>
      </member>
      <member name="synchronizing"
              value="1"
              c:identifier="INF_SESSION_SYNCHRONIZING"
              glib:nick="synchronizing">
        <doc xml:space="preserve">The session is currently being synchronized
from a remote host. When done synchronizing, it will enter into
%INF_SESSION_RUNNING state.</doc>
      </member>
      <member name="running"
              value="2"
              c:identifier="INF_SESSION_RUNNING"
              glib:nick="running">
        <doc xml:space="preserve">The session is running and ready to synchronize
other hosts. If a subscription group is set
(see inf_session_set_subscription_group()), then changes to the
underlying buffer are transmitted to all subscribed connections.</doc>
      </member>
      <member name="closed"
              value="3"
              c:identifier="INF_SESSION_CLOSED"
              glib:nick="closed">
        <doc xml:space="preserve">The session is closed and can no longer be used. The
session enters this state if the synchronization fails in
%INF_SESSION_SYNCHRONIZING state or inf_session_close() is called.</doc>
      </member>
    </enumeration>
    <enumeration name="SessionSyncError" c:type="InfSessionSyncError">
      <doc xml:space="preserve">These are errors that can occur during a synchronization of a session.
Additional errors may occur depending on the session type.</doc>
      <member name="got_message_in_presync"
              value="0"
              c:identifier="INF_SESSION_SYNC_ERROR_GOT_MESSAGE_IN_PRESYNC">
        <doc xml:space="preserve">Received a message
in state %INF_SESSION_PRESYNC. It is not processed because
inf_session_synchronize_from() was not yet called.</doc>
      </member>
      <member name="unexpected_node"
              value="1"
              c:identifier="INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE">
        <doc xml:space="preserve">A message has been received that
was not understood.</doc>
      </member>
      <member name="id_not_present"
              value="2"
              c:identifier="INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT">
        <doc xml:space="preserve">An ID was not provided for a user
in the session.</doc>
      </member>
      <member name="id_in_use"
              value="3"
              c:identifier="INF_SESSION_SYNC_ERROR_ID_IN_USE">
        <doc xml:space="preserve">The ID of a user is already in use by
another user.</doc>
      </member>
      <member name="name_not_present"
              value="4"
              c:identifier="INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT">
        <doc xml:space="preserve">A name was not provided for a
user in the session.</doc>
      </member>
      <member name="name_in_use"
              value="5"
              c:identifier="INF_SESSION_SYNC_ERROR_NAME_IN_USE">
        <doc xml:space="preserve">The name of a user is already in use
by another user.</doc>
      </member>
      <member name="connection_closed"
              value="6"
              c:identifier="INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED">
        <doc xml:space="preserve">The synchronization connection
has been closed.</doc>
      </member>
      <member name="sender_cancelled"
              value="7"
              c:identifier="INF_SESSION_SYNC_ERROR_SENDER_CANCELLED">
        <doc xml:space="preserve">The sender has cancelled the
synchronization.</doc>
      </member>
      <member name="receiver_cancelled"
              value="8"
              c:identifier="INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED">
        <doc xml:space="preserve">The receiver has cancelled the
synchronization.</doc>
      </member>
      <member name="unexpected_begin_of_sync"
              value="9"
              c:identifier="INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC">
        <doc xml:space="preserve">Received
&amp;lt;sync-begin/&amp;gt;
not a the beginning of the synchronization.</doc>
      </member>
      <member name="num_messages_missing"
              value="10"
              c:identifier="INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING">
        <doc xml:space="preserve">The &amp;lt;sync-begin/&amp;gt;
message does not contain the number of synchronization messages to expect.</doc>
      </member>
      <member name="unexpected_end_of_sync"
              value="11"
              c:identifier="INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC">
        <doc xml:space="preserve">The &amp;lt;sync-end/&amp;gt;
message was not received at the end of the synchronization.</doc>
      </member>
      <member name="expected_begin_of_sync"
              value="12"
              c:identifier="INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC">
        <doc xml:space="preserve">The &amp;lt;sync-begin/&amp;gt;
message was not received at the beginning of the synchronization.</doc>
      </member>
      <member name="expected_end_of_sync"
              value="13"
              c:identifier="INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC">
        <doc xml:space="preserve">The &amp;lt;sync-end/&amp;gt; message
was not received at the end of the synchronization.</doc>
      </member>
      <member name="failed"
              value="14"
              c:identifier="INF_SESSION_SYNC_ERROR_FAILED">
        <doc xml:space="preserve">Generic error code when no further reason
of failure is known.</doc>
      </member>
    </enumeration>
    <enumeration name="SessionSyncStatus" c:type="InfSessionSyncStatus">
      <doc xml:space="preserve">#InfSessionSyncStatus represents the status of a synchronization. It is
used by inf_session_get_synchronization_status().</doc>
      <member name="none" value="0" c:identifier="INF_SESSION_SYNC_NONE">
        <doc xml:space="preserve">No synchronization is ongoing.</doc>
      </member>
      <member name="in_progress"
              value="1"
              c:identifier="INF_SESSION_SYNC_IN_PROGRESS">
        <doc xml:space="preserve">Synchronization is currently in progress.</doc>
      </member>
      <member name="awaiting_ack"
              value="2"
              c:identifier="INF_SESSION_SYNC_AWAITING_ACK">
        <doc xml:space="preserve">All synchronization data has been sent
(progress is 1.0), but we are still waiting for an acknowledgment from the
remote site. Synchronization can no longer be cancelled, but it can stiff
fail.</doc>
      </member>
    </enumeration>
    <class name="SimulatedConnection"
           c:symbol-prefix="simulated_connection"
           c:type="InfSimulatedConnection"
           parent="GObject.Object"
           glib:type-name="InfSimulatedConnection"
           glib:get-type="inf_simulated_connection_get_type"
           glib:type-struct="SimulatedConnectionClass">
      <doc xml:space="preserve">#InfSimulatedConnection is an opaque data type. You should only access it
via the public API functions.</doc>
      <implements name="XmlConnection"/>
      <constructor name="new" c:identifier="inf_simulated_connection_new">
        <doc xml:space="preserve">Creates a new #InfSimulatedConnection. A connection created this way cannot
be switched to %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode. Use
inf_simulated_connection_new_with_io() instead if you intend to do that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfSimulatedConnection.</doc>
          <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_io"
                   c:identifier="inf_simulated_connection_new_with_io">
        <doc xml:space="preserve">Creates a new #InfSimulatedConnection with the given #InfIo. This
connection can be used with %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode.
If you don't intend to use that mode then using
inf_simulated_connection_new() is also good enough since the #InfIo object
is not required in that case.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfSimulatedConnection.</doc>
          <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">The main loop to be used for %INF_SIMULATED_CONNECTION_IO_CONTROLLED
mode.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="connect" c:identifier="inf_simulated_connection_connect">
        <doc xml:space="preserve">Connects two simulated connections, so that data sent through one of them
is received by the other one and vice versa. So one call to this function
connects both #InfSimulatedConnection&lt;!-- --&gt;s to each other. There is no
need to call this function once for each connection.

If one or both of the connections already have another target, then the
simulated connection between those is closed first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSimulatedConnection.</doc>
            <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
          </instance-parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">The target connection.</doc>
            <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="inf_simulated_connection_flush">
        <doc xml:space="preserve">When @connection's mode is %INF_SIMULATED_CONNECTION_DELAYED or
%INF_SIMULATED_CONNECTION_IO_CONTROLLED, then calling this function makes
the target connection receive all the queued messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSimulatedConnection.</doc>
            <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_mode" c:identifier="inf_simulated_connection_set_mode">
        <doc xml:space="preserve">Sets the mode of the simulated connection.

In %INF_SIMULATED_CONNECTION_IMMEDIATE mode, messages sent through the
connection are received by the target during the call to
inf_xml_connection_send().

In %INF_SIMULATED_CONNECTION_DELAYED mode, messages sent are queued and
received by the target when inf_simulated_connection_flush() is called.

In %INF_SIMULATED_CONNECTION_IO_CONTROLLED mode, messages are queued and
received by the target as soon as a dispatch handler (see
inf_io_add_dispatch()) installed on the main loop is called.

When changing the mode from %INF_SIMULATED_CONNECTION_DELAYED or
%INF_SIMULATED_CONNECTION_IO_CONTROLLED to
%INF_SIMULATED_CONNECTION_IMMEDIATE, then the queue is flushed, too.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfSimulatedConnection.</doc>
            <type name="SimulatedConnection" c:type="InfSimulatedConnection*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">The new mode to set.</doc>
            <type name="SimulatedConnectionMode"
                  c:type="InfSimulatedConnectionMode"/>
          </parameter>
        </parameters>
      </method>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Io"/>
      </property>
      <property name="mode"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SimulatedConnectionMode"/>
      </property>
      <property name="target" writable="1" transfer-ownership="none">
        <type name="SimulatedConnection"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SimulatedConnectionClass"
            c:type="InfSimulatedConnectionClass"
            glib:is-gtype-struct-for="SimulatedConnection">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="SimulatedConnectionMode"
                 glib:type-name="InfSimulatedConnectionMode"
                 glib:get-type="inf_simulated_connection_mode_get_type"
                 c:type="InfSimulatedConnectionMode">
      <doc xml:space="preserve">The mode of a simulated connection defines when sent messages arrive at
the target connection.</doc>
      <member name="immediate"
              value="0"
              c:identifier="INF_SIMULATED_CONNECTION_IMMEDIATE"
              glib:nick="immediate">
        <doc xml:space="preserve">Messages are received directly by the
target site when calling inf_xml_connection_send().</doc>
      </member>
      <member name="delayed"
              value="1"
              c:identifier="INF_SIMULATED_CONNECTION_DELAYED"
              glib:nick="delayed">
        <doc xml:space="preserve">Messages are queued, and delivered to
the target site when inf_simulated_connection_flush() is called.</doc>
      </member>
      <member name="io_controlled"
              value="2"
              c:identifier="INF_SIMULATED_CONNECTION_IO_CONTROLLED"
              glib:nick="io-controlled">
        <doc xml:space="preserve">Messages are queued and delivered
once the application main loop regains control. This requires the simulated
connection to have been created with
inf_simulated_connection_new_with_io().</doc>
      </member>
    </enumeration>
    <class name="StandaloneIo"
           c:symbol-prefix="standalone_io"
           c:type="InfStandaloneIo"
           parent="GObject.Object"
           glib:type-name="InfStandaloneIo"
           glib:get-type="inf_standalone_io_get_type"
           glib:type-struct="StandaloneIoClass">
      <doc xml:space="preserve">#InfStandaloneIo is an opaque data type. You should only access it via the
public API functions.</doc>
      <implements name="Io"/>
      <constructor name="new" c:identifier="inf_standalone_io_new">
        <doc xml:space="preserve">Creates a new #InfStandaloneIo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfStandaloneIo. Free with
g_object_unref() when no longer needed.</doc>
          <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
        </return-value>
      </constructor>
      <method name="iteration" c:identifier="inf_standalone_io_iteration">
        <doc xml:space="preserve">Performs a single iteration of @io. The call will block until a first
event has occured. Then, it will process that event and return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfStandaloneIo.</doc>
            <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="iteration_timeout"
              c:identifier="inf_standalone_io_iteration_timeout">
        <doc xml:space="preserve">Performs a single iteration of @io. The call will block until either an
event occured or @timeout milliseconds have elapsed. If an event occured,
the event will be processed before returning.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfStandaloneIo.</doc>
            <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">Maximum number of milliseconds to block.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="loop" c:identifier="inf_standalone_io_loop">
        <doc xml:space="preserve">This call will cause @io to wait for events and process them, but not
return until inf_standalone_io_loop_quit() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfStandaloneIo.</doc>
            <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="loop_quit" c:identifier="inf_standalone_io_loop_quit">
        <doc xml:space="preserve">Exits a loop in which @io is running through a call to
inf_standalone_io_loop().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfStandaloneIo.</doc>
            <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="loop_running"
              c:identifier="inf_standalone_io_loop_running">
        <doc xml:space="preserve">Returns whether @io runs currently in a loop initiated with
inf_standalone_io_loop().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @io runs in a loop.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfStandaloneIo.</doc>
            <type name="StandaloneIo" c:type="InfStandaloneIo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="StandaloneIoClass"
            c:type="InfStandaloneIoClass"
            glib:is-gtype-struct-for="StandaloneIo">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="TcpConnection"
           c:symbol-prefix="tcp_connection"
           c:type="InfTcpConnection"
           parent="GObject.Object"
           glib:type-name="InfTcpConnection"
           glib:get-type="inf_tcp_connection_get_type"
           glib:type-struct="TcpConnectionClass">
      <doc xml:space="preserve">#InfTcpConnection is an opaque data type. You should only access it via
the public API functions.</doc>
      <constructor name="new" c:identifier="inf_tcp_connection_new">
        <doc xml:space="preserve">Creates a new #InfTcpConnection. The arguments are stored as properties for
an eventual inf_tcp_connection_open() call, this function itself does not
establish a connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTcpConnection. Free with
g_object_unref().</doc>
          <type name="TcpConnection" c:type="InfTcpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object used to watch for activity.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="remote_addr" transfer-ownership="none">
            <doc xml:space="preserve">The address to eventually connect to.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </parameter>
          <parameter name="remote_port" transfer-ownership="none">
            <doc xml:space="preserve">The port to eventually connect to.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_and_open"
                   c:identifier="inf_tcp_connection_new_and_open"
                   throws="1">
        <doc xml:space="preserve">Creates a new #InfTcpConnection and connects it to the given TCP endpoint.
Like inf_tcp_connection_new(), but calls inf_tcp_connection_open().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTcpConnection, or %NULL on error.
Free with g_object_unref().</doc>
          <type name="TcpConnection" c:type="InfTcpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object used to watch for activity.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="remote_addr" transfer-ownership="none">
            <doc xml:space="preserve">The address to connect to.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </parameter>
          <parameter name="remote_port" transfer-ownership="none">
            <doc xml:space="preserve">The port to connect to.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_resolve"
                   c:identifier="inf_tcp_connection_new_resolve">
        <doc xml:space="preserve">Creates a new #InfTcpConnection and instead of setting the remote IP
address and port number directly, a hostname resolver is used to look up
the remote hostname before connecting. This has the advantage that all
available addresses for that hostname are tried before giving up.

The argument is stored as a property for an eventual
inf_tcp_connection_open() call, this function itself does not
establish a connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfTcpConnection. Free with
g_object_unref().</doc>
          <type name="TcpConnection" c:type="InfTcpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="io" transfer-ownership="none">
            <doc xml:space="preserve">A #InfIo object used to watch for activity.</doc>
            <type name="Io" c:type="InfIo*"/>
          </parameter>
          <parameter name="resolver" transfer-ownership="none">
            <doc xml:space="preserve">The hostname resolver object used to look up the remote
hostname.</doc>
            <type name="NameResolver" c:type="InfNameResolver*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="error">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="received">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sent">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="inf_tcp_connection_close">
        <doc xml:space="preserve">Closes a TCP connection that is either open or currently connecting.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_keepalive"
              c:identifier="inf_tcp_connection_get_keepalive">
        <doc xml:space="preserve">Returns the current keepalive settings for @connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current keepalive configuration for @connection, owned by
@connection.</doc>
          <type name="Keepalive" c:type="const InfKeepalive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address"
              c:identifier="inf_tcp_connection_get_remote_address">
        <doc xml:space="preserve">Returns the IP address of the remote site.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfIpAddress owned by @connection. You do not
need to free it, but need to make your own copy if you want to keep it
longer than @connection's lifetime.</doc>
          <type name="IpAddress" c:type="InfIpAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_port"
              c:identifier="inf_tcp_connection_get_remote_port">
        <doc xml:space="preserve">Returns the port of the remote site to which @connection is (or was)
connected or connecting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The port of the remote site.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="inf_tcp_connection_open" throws="1">
        <doc xml:space="preserve">Attempts to open @connection. Make sure to have set the "remote-address"
and "remote-port" property before calling this function. If an error
occurs, the function returns %FALSE and @error is set. Note however that
the connection might not be fully open when the function returns
(check the "status" property if you need to know). If an asynchronous
error occurs while the connection is being opened, the "error" signal
is emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if an error occured and %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="inf_tcp_connection_send">
        <doc xml:space="preserve">Sends data through the TCP connection. The data is not sent immediately,
but enqueued to a buffer and will be sent as soon as kernel space
becomes available. The "sent" signal will be emitted when data has
really been sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection with status %INF_TCP_CONNECTION_CONNECTED.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The data to send.</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8" c:type="gconstpointer"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">Number of bytes to send.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_keepalive"
              c:identifier="inf_tcp_connection_set_keepalive"
              throws="1">
        <doc xml:space="preserve">Sets the keepalive settings for @connection. When this function is not
called, the system defaults are used. If the connection is closed, then
the function always succeeds and stores the keepalive values internally.
The values are actually set on the underlying socket when the connection
is opened. If the connection is already open, the function might fail if
the system call fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new keeplalive values were set, or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfTcpConnection.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </instance-parameter>
          <parameter name="keepalive" transfer-ownership="none">
            <doc xml:space="preserve">New keepalive settings for the connection.</doc>
            <type name="Keepalive" c:type="const InfKeepalive*"/>
          </parameter>
        </parameters>
      </method>
      <property name="device-index" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="device-name" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="io"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Io"/>
      </property>
      <property name="keepalive" writable="1" transfer-ownership="none">
        <type name="Keepalive"/>
      </property>
      <property name="local-address" transfer-ownership="none">
        <type name="IpAddress"/>
      </property>
      <property name="local-port" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="remote-address" writable="1" transfer-ownership="none">
        <type name="IpAddress"/>
      </property>
      <property name="remote-port" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="resolver"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="NameResolver"/>
      </property>
      <property name="status" transfer-ownership="none">
        <type name="TcpConnectionStatus"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted when an error occured with the connection. If the
error is fatal, the connection will change its status to
%INF_TCP_CONNECTION_CLOSED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #GError object with details on the error.</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="received" when="last">
        <doc xml:space="preserve">This signal is emitted whenever data has been received from the
connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A #gpointer refering to the data that has been received.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">A #guint holding the number of bytes that has been received.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="sent" when="last">
        <doc xml:space="preserve">This signal is emitted whenever data has been sent over the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A #gpointer refering to the data that has been sent.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">A #guint holding the number of bytes that has been sent.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TcpConnectionClass"
            c:type="InfTcpConnectionClass"
            glib:is-gtype-struct-for="TcpConnection">
      <doc xml:space="preserve">This structure contains the default signal handlers of #InfTcpConnection.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="sent">
        <callback name="sent">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="TcpConnection" c:type="InfTcpConnection*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gconstpointer"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="received">
        <callback name="received">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="TcpConnection" c:type="InfTcpConnection*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gconstpointer"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="TcpConnection" c:type="InfTcpConnection*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="TcpConnectionStatus"
                 glib:type-name="InfTcpConnectionStatus"
                 glib:get-type="inf_tcp_connection_status_get_type"
                 c:type="InfTcpConnectionStatus">
      <doc xml:space="preserve">#InfTcpConnectionStatus specifies the connection status of a
#InfTcpConnection.</doc>
      <member name="connecting"
              value="0"
              c:identifier="INF_TCP_CONNECTION_CONNECTING"
              glib:nick="connecting">
        <doc xml:space="preserve">A new connection is currently being
established.</doc>
      </member>
      <member name="connected"
              value="1"
              c:identifier="INF_TCP_CONNECTION_CONNECTED"
              glib:nick="connected">
        <doc xml:space="preserve">The connection is ready to send and
receive data.</doc>
      </member>
      <member name="closed"
              value="2"
              c:identifier="INF_TCP_CONNECTION_CLOSED"
              glib:nick="closed">
        <doc xml:space="preserve">The connection is closed. Before data can be
transmitted, it needs to be opened with inf_tcp_connection_open().</doc>
      </member>
    </enumeration>
    <class name="User"
           c:symbol-prefix="user"
           c:type="InfUser"
           parent="GObject.Object"
           glib:type-name="InfUser"
           glib:get-type="inf_user_get_type"
           glib:type-struct="UserClass">
      <doc xml:space="preserve">#InfUser is an opaque data type. You should only access it via
the public API functions.</doc>
      <function name="error_quark" c:identifier="inf_user_error_quark">
        <doc xml:space="preserve">Error domain for user-related errors. Errors in this domain will be from
the #InfUserError enumeration. See #GError for information on error
domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="strerror" c:identifier="inf_user_strerror">
        <doc xml:space="preserve">Returns a human-readable string for the given error code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A static string that must not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">An error code from the #InfUserError enumeration.</doc>
            <type name="UserError" c:type="InfUserError"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="set_status">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="UserStatus" c:type="InfUserStatus"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connection" c:identifier="inf_user_get_connection">
        <doc xml:space="preserve">Returns a connection to the given #InfUser, or %NULL. If a non-%NULL
connection is returned, then this is the connection through which records
from that user come from. This means that, when this connection is closed,
then the user is no longer available. However, you cannot send something
to this connection expecting the user will receive it. For example,
in central messaging mode, this connection is always the publisher, because
all records from the user are relayed via the publisher.

If this functions returns %NULL, this either means @user is a local user
(%INF_USER_LOCAL flag set) or it is not available (status is
%INF_USER_UNAVAILABLE).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfXmlConnection, or %NULL.</doc>
          <type name="XmlConnection" c:type="InfXmlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser.</doc>
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="inf_user_get_flags">
        <doc xml:space="preserve">Returns the flags for the given #InfUser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user's flags.</doc>
          <type name="UserFlags" c:type="InfUserFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser.</doc>
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="inf_user_get_id">
        <doc xml:space="preserve">Returns the ID of the given #InfUser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A numerical User ID.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser.</doc>
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="inf_user_get_name">
        <doc xml:space="preserve">Returns the name of the given #InfUser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user's name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser.</doc>
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="inf_user_get_status">
        <doc xml:space="preserve">Returns the status of the given #InfUser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The user's status.</doc>
          <type name="UserStatus" c:type="InfUserStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser.</doc>
            <type name="User" c:type="InfUser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection" writable="1" transfer-ownership="none">
        <type name="XmlConnection"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="UserFlags"/>
      </property>
      <property name="id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="name" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="status" writable="1" transfer-ownership="none">
        <type name="UserStatus"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="set-status" when="last">
        <doc xml:space="preserve">This signal is emitted whenever the user's status changes. This is
basically the same as a notification for the #InfUser:status property,
but it allows to access the previous user status when connecting before
the default signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">The new user status.</doc>
            <type name="UserStatus"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="UserClass"
            c:type="InfUserClass"
            glib:is-gtype-struct-for="User">
      <doc xml:space="preserve">This structure contains virtual functions for the #InfUser class.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="set_status">
        <callback name="set_status">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
            <parameter name="status" transfer-ownership="none">
              <type name="UserStatus" c:type="InfUserStatus"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="UserError" c:type="InfUserError">
      <doc xml:space="preserve">These are errors related to users. They may occur during user join or
during processing a user-related message, such as a user status change
message in an #InfSession.</doc>
      <member name="name_in_use"
              value="0"
              c:identifier="INF_USER_ERROR_NAME_IN_USE">
        <doc xml:space="preserve">The requested name is already in use by
another user.</doc>
      </member>
      <member name="id_provided"
              value="1"
              c:identifier="INF_USER_ERROR_ID_PROVIDED">
        <doc xml:space="preserve">The client provided a user ID field in a
user join request, but it's the server's job to find an ID.</doc>
      </member>
      <member name="no_such_user"
              value="2"
              c:identifier="INF_USER_ERROR_NO_SUCH_USER">
        <doc xml:space="preserve">A request referred to a user ID that no user
is associated with.</doc>
      </member>
      <member name="status_unavailable"
              value="3"
              c:identifier="INF_USER_ERROR_STATUS_UNAVAILABLE">
        <doc xml:space="preserve">The initial user status was given as
unavailable during user join or rejoin.</doc>
      </member>
      <member name="not_joined"
              value="4"
              c:identifier="INF_USER_ERROR_NOT_JOINED">
        <doc xml:space="preserve">The user did not join from the connection the
request comes from. For example, a user status change can only be requested
from the same connection that joined the user.</doc>
      </member>
      <member name="invalid_status"
              value="5"
              c:identifier="INF_USER_ERROR_INVALID_STATUS">
        <doc xml:space="preserve">An invalid status was used in a XML
request. Allowed status values are "unavailable", "inactive" or "active".</doc>
      </member>
      <member name="failed" value="6" c:identifier="INF_USER_ERROR_FAILED">
        <doc xml:space="preserve">Generic error code when no further reason of
failure is known.</doc>
      </member>
    </enumeration>
    <bitfield name="UserFlags"
              glib:type-name="InfUserFlags"
              glib:get-type="inf_user_flags_get_type"
              c:type="InfUserFlags">
      <doc xml:space="preserve">Additional flags for #InfUser.</doc>
      <member name="local"
              value="1"
              c:identifier="INF_USER_LOCAL"
              glib:nick="local">
        <doc xml:space="preserve">The user is local, i.e. joined by the local instance.</doc>
      </member>
    </bitfield>
    <enumeration name="UserStatus"
                 glib:type-name="InfUserStatus"
                 glib:get-type="inf_user_status_get_type"
                 c:type="InfUserStatus">
      <doc xml:space="preserve">Different possible types of status an #InfUser can have.</doc>
      <member name="active"
              value="0"
              c:identifier="INF_USER_ACTIVE"
              glib:nick="active">
        <doc xml:space="preserve">The user is available and currently looking at this
session.</doc>
      </member>
      <member name="inactive"
              value="1"
              c:identifier="INF_USER_INACTIVE"
              glib:nick="inactive">
        <doc xml:space="preserve">The user is available but currently not paying
attention to this session.</doc>
      </member>
      <member name="unavailable"
              value="2"
              c:identifier="INF_USER_UNAVAILABLE"
              glib:nick="unavailable">
        <doc xml:space="preserve">The user is not available, i.e. not joined into the
session.</doc>
      </member>
      <function name="from_string"
                c:identifier="inf_user_status_from_string"
                throws="1">
        <doc xml:space="preserve">This function does the opposite of inf_user_status_to_string(). It turns
the given string back to a #InfUserStatus, storing the result in @status
if @status is non-%NULL. If @string is invalid, then @status is left
untouched, @error is set and %FALSE is returned. Otherwise, the function
returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">When an error occured during the conversion, %FALSE is returned,
and %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">A string representation of a #InfUserStatus.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to a #InfUserStatus value, or %NULL.</doc>
            <type name="UserStatus" c:type="InfUserStatus*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="inf_user_status_to_string">
        <doc xml:space="preserve">Returns a non-localized string identifying the given status. This is not
meant to be shown to a user, but rather to serialize a user status, for
example to store it in XML.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A static string representation of @status.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">A value from the #InfUserStatus enumeration.</doc>
            <type name="UserStatus" c:type="InfUserStatus"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <class name="UserTable"
           c:symbol-prefix="user_table"
           c:type="InfUserTable"
           parent="GObject.Object"
           glib:type-name="InfUserTable"
           glib:get-type="inf_user_table_get_type"
           glib:type-struct="UserTableClass">
      <doc xml:space="preserve">#InfUserTable is an opaque data type. You should only access it via the
public API functions.</doc>
      <constructor name="new" c:identifier="inf_user_table_new">
        <doc xml:space="preserve">Creates a new, empty user table.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #InfUserTable.</doc>
          <type name="UserTable" c:type="InfUserTable*"/>
        </return-value>
      </constructor>
      <virtual-method name="add_available_user">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_local_user">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_user" invoker="add_user">
        <doc xml:space="preserve">Inserts @user into @user_table.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser not already contained in @user_table.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_available_user">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_local_user">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_user" invoker="remove_user">
        <doc xml:space="preserve">Removes @user from @uesr_table.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser contained in @table.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_user" c:identifier="inf_user_table_add_user">
        <doc xml:space="preserve">Inserts @user into @user_table.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser not already contained in @user_table.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_local_user"
              c:identifier="inf_user_table_foreach_local_user">
        <doc xml:space="preserve">Calls the given function for each local user in the user_table. A local
user is a user that has the %INF_USER_LOCAL flag set and that has not
status %INF_USER_UNAVAILABLE. You should not add or remove users while this
function is being executed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">The function to call for each user.</doc>
            <type name="UserTableForeachUserFunc"
                  c:type="InfUserTableForeachUserFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">User data to pass to the function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_user" c:identifier="inf_user_table_foreach_user">
        <doc xml:space="preserve">Calls the given function for each user in the user_table. You should not
add or remove users while this function is being executed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">The function to call for each user.</doc>
            <type name="UserTableForeachUserFunc"
                  c:type="InfUserTableForeachUserFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">User data to pass to the function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_user_by_id"
              c:identifier="inf_user_table_lookup_user_by_id">
        <doc xml:space="preserve">Returns the #InfUser with the given User ID in @user_table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfUser, or %NULL.</doc>
          <type name="User" c:type="InfUser*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">User ID to lookup.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_user_by_name"
              c:identifier="inf_user_table_lookup_user_by_name">
        <doc xml:space="preserve">Returns an #InfUser with the given name if there is one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfUser, or %NULL.</doc>
          <type name="User" c:type="InfUser*"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">User name to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_user" c:identifier="inf_user_table_remove_user">
        <doc xml:space="preserve">Removes @user from @uesr_table.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="user_table" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUserTable.</doc>
            <type name="UserTable" c:type="InfUserTable*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">A #InfUser contained in @table.</doc>
            <type name="User" c:type="InfUser*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="add-available-user" when="last">
        <doc xml:space="preserve">This signal is emitted when a user in the user table becomes available,
i.e. its status is not %INF_USER_UNAVAILABLE. The signal is also emitted
when a new user is added to the user table who is available, in addition
to #InfUserTable::add-user and possibly #InfUserTable::add-local-user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that became available.</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="add-local-user" when="last">
        <doc xml:space="preserve">This signal is emitted when a user is added to the user table and has the
%INF_USER_LOCAL flag set. In this case, #InfUserTable::add-user is
emitted as well.

This signal is also emitted when an existing user receives the
%INF_USER_LOCAL flag. This occurs when a user rejoins locally after
leaving the session (possibly having the %INF_USER_LOCAL flag removed
during their absence). #InfUserTable::add-user is not emitted in this
case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that has set as local</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="add-user" when="last">
        <doc xml:space="preserve">This signal is emitted when inf_user_table_add_user() is called. Note
that this does not happen if @user rejoins the session and has already
been added to @user_table previously.

#InfUserTable::add-local-user may also be emitted at this point if
@user has the %INF_USER_LOCAL flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that has been added into @user_table</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-available-user" when="last">
        <doc xml:space="preserve">This signal is emitted when a user in the user table became unavailable,
i.e. its status has changed to %INF_USER_UNAVAILABLE. The signal is also
emitted when a user who was available has been removed from the user
table, in addition to #InfUserTable::remove-user and possibly
#InfUserTable::remove-local-user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that became unavailable.</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-local-user" when="last">
        <doc xml:space="preserve">This signal is emitted when a user is removed from the user table and
had the %INF_USER_LOCAL flag set. In this case,
#InfUserTable::remove-user is emitted as well.

This signal is also emitted when @user loses the %INF_USER_LOCAL flag.
This occurs when the local @user leaves the session.
#InfUserTable::remove-user is not emitted and the status of @user is set
to %INF_USER_UNAVAILABLE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that is no longer local</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-user" when="last">
        <doc xml:space="preserve">This signal is emitted when inf_user_table_remove_user() is called. This
does not usually happen, as users leaving a session do not get removed
from the table.

#InfUserTable::remove-local-user may also be emitted at this point if
@user has the %INF_USER_LOCAL flag set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">The #InfUser that has been removed from @user_table</doc>
            <type name="User"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="UserTableClass"
            c:type="InfUserTableClass"
            glib:is-gtype-struct-for="UserTable">
      <doc xml:space="preserve">Signals for the #InfUserTable class.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_user">
        <callback name="add_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <doc xml:space="preserve">A #InfUserTable.</doc>
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <doc xml:space="preserve">A #InfUser not already contained in @user_table.</doc>
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_user">
        <callback name="remove_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <doc xml:space="preserve">A #InfUserTable.</doc>
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <doc xml:space="preserve">A #InfUser contained in @table.</doc>
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_available_user">
        <callback name="add_available_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_available_user">
        <callback name="remove_available_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_local_user">
        <callback name="add_local_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_local_user">
        <callback name="remove_local_user">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="user_table" transfer-ownership="none">
              <type name="UserTable" c:type="InfUserTable*"/>
            </parameter>
            <parameter name="user" transfer-ownership="none">
              <type name="User" c:type="InfUser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="UserTableForeachUserFunc"
              c:type="InfUserTableForeachUserFunc">
      <doc xml:space="preserve">This callback is called for every user iterated by
inf_user_table_foreach_user() or inf_user_table_foreach_local_user().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user" transfer-ownership="none">
          <doc xml:space="preserve">The #InfUser for the current iteration.</doc>
          <type name="User" c:type="InfUser*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">The user_data passed to inf_user_table_foreach_user() or
inf_user_table_foreach_local_user().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="XmlConnection"
               c:symbol-prefix="xml_connection"
               c:type="InfXmlConnection"
               glib:type-name="InfXmlConnection"
               glib:get-type="inf_xml_connection_get_type"
               glib:type-struct="XmlConnectionInterface">
      <doc xml:space="preserve">#InfXmlConnection is an opaque data type. You should only access it
via the public API functions.</doc>
      <virtual-method name="close" invoker="close">
        <doc xml:space="preserve">Closes the given connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="error" invoker="error">
        <doc xml:space="preserve">Emits the "error" signal on @connection. This will most likely only
be useful to implementors.

Note that the error may or may not be fatal for the connection. If it
is fatal, then a status notify to %INF_XML_CONNECTION_CLOSING or
%INF_XML_CONNECTION_CLOSED will follow. If you are implementing a custom
class implementing #InfXmlConnection, make sure to always emit the "error"
signal before doing the status notify because many users of the connection
will release their reference when the connection is no longer connected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">The error that occured.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open" invoker="open" throws="1">
        <doc xml:space="preserve">Attempts to open the given XML connection. If the process fails, @error
will be set. The connection needs to be in status
%INF_XML_CONNECTION_CLOSED for this function to be called. Even if this
function succeeds, the connection process can fail later. In that case
the status of @connection will be reset to %INF_XML_CONNECTION_CLOSED
and the #InfXmlConnection::error signal will be emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on succes, or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #infXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="received" invoker="received">
        <doc xml:space="preserve">Emits the "received" signal on @connection. This will most likely only
be useful to implementors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML message that has been received.</doc>
            <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send" invoker="send">
        <doc xml:space="preserve">Sends the given XML message to the remote host.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">A XML message to send. The function takes ownership
of the XML node.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sent" invoker="sent">
        <doc xml:space="preserve">Emits the "sent" signal on @connection. This will most likely only be
useful to implementors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML message that has been sent.</doc>
            <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="inf_xml_connection_close">
        <doc xml:space="preserve">Closes the given connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="error" c:identifier="inf_xml_connection_error">
        <doc xml:space="preserve">Emits the "error" signal on @connection. This will most likely only
be useful to implementors.

Note that the error may or may not be fatal for the connection. If it
is fatal, then a status notify to %INF_XML_CONNECTION_CLOSING or
%INF_XML_CONNECTION_CLOSED will follow. If you are implementing a custom
class implementing #InfXmlConnection, make sure to always emit the "error"
signal before doing the status notify because many users of the connection
will release their reference when the connection is no longer connected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">The error that occured.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="inf_xml_connection_open" throws="1">
        <doc xml:space="preserve">Attempts to open the given XML connection. If the process fails, @error
will be set. The connection needs to be in status
%INF_XML_CONNECTION_CLOSED for this function to be called. Even if this
function succeeds, the connection process can fail later. In that case
the status of @connection will be reset to %INF_XML_CONNECTION_CLOSED
and the #InfXmlConnection::error signal will be emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on succes, or %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #infXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="received" c:identifier="inf_xml_connection_received">
        <doc xml:space="preserve">Emits the "received" signal on @connection. This will most likely only
be useful to implementors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML message that has been received.</doc>
            <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="inf_xml_connection_send">
        <doc xml:space="preserve">Sends the given XML message to the remote host.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="full">
            <doc xml:space="preserve">A XML message to send. The function takes ownership
of the XML node.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="sent" c:identifier="inf_xml_connection_sent">
        <doc xml:space="preserve">Emits the "sent" signal on @connection. This will most likely only be
useful to implementors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmlConnection.</doc>
            <type name="XmlConnection" c:type="InfXmlConnection*"/>
          </instance-parameter>
          <parameter name="xml" transfer-ownership="none">
            <doc xml:space="preserve">The XML message that has been sent.</doc>
            <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <property name="local-certificate" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="local-id" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="remote-certificate" transfer-ownership="none">
        <type name="CertificateChain"/>
      </property>
      <property name="remote-id" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="status" transfer-ownership="none">
        <type name="XmlConnectionStatus"/>
      </property>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted when an error occurs for this connection.
For example, if the connection cannot be established and the status
changes from %INF_XML_CONNECTION_OPENING to %INF_XML_CONNECTION_CLOSED,
then this signal is usually emitted with more details on the error.

Note however that the error may or may not be fatal for the
connection. If it is fatal, then a status notify to
%INF_XML_CONNECTION_CLOSING or %INF_XML_CONNECTION_CLOSED will follow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #GError object with details on the error</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="received" when="last">
        <doc xml:space="preserve">Signal which is emitted when an XML node has been received by this
connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">An #xmlNodePtr refering to the XML node that has been received</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="sent" when="last">
        <doc xml:space="preserve">Signal which is emitted when an XML node has been successfully
transmitted with this connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">An #xmlNodePtr refering to the XML node that has been sent</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="XmlConnectionInterface"
            c:type="InfXmlConnectionInterface"
            glib:is-gtype-struct-for="XmlConnection">
      <doc xml:space="preserve">Virtual functions and default signal handlers for the #InfXmlConnection
interface.</doc>
      <field name="parent" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="open">
        <callback name="open" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on succes, or %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #infXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send">
        <callback name="send">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="full">
              <doc xml:space="preserve">A XML message to send. The function takes ownership
of the XML node.</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sent">
        <callback name="sent">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <doc xml:space="preserve">The XML message that has been sent.</doc>
              <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="received">
        <callback name="received">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="xml" transfer-ownership="none">
              <doc xml:space="preserve">The XML message that has been received.</doc>
              <type name="libxml2.NodePtr" c:type="const xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">A #InfXmlConnection.</doc>
              <type name="XmlConnection" c:type="InfXmlConnection*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <doc xml:space="preserve">The error that occured.</doc>
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="XmlConnectionStatus"
                 glib:type-name="InfXmlConnectionStatus"
                 glib:get-type="inf_xml_connection_status_get_type"
                 c:type="InfXmlConnectionStatus">
      <doc xml:space="preserve">The possible connection status of an #InfXmlConnection.</doc>
      <member name="closed"
              value="0"
              c:identifier="INF_XML_CONNECTION_CLOSED"
              glib:nick="closed">
        <doc xml:space="preserve">The connection is currently not established.</doc>
      </member>
      <member name="closing"
              value="1"
              c:identifier="INF_XML_CONNECTION_CLOSING"
              glib:nick="closing">
        <doc xml:space="preserve">The connection is in the process of being
closed, no more data can be sent.</doc>
      </member>
      <member name="open"
              value="2"
              c:identifier="INF_XML_CONNECTION_OPEN"
              glib:nick="open">
        <doc xml:space="preserve">The connection is up and data can be transmitted.</doc>
      </member>
      <member name="opening"
              value="3"
              c:identifier="INF_XML_CONNECTION_OPENING"
              glib:nick="opening">
        <doc xml:space="preserve">The connection is being established.</doc>
      </member>
    </enumeration>
    <class name="XmppConnection"
           c:symbol-prefix="xmpp_connection"
           c:type="InfXmppConnection"
           parent="GObject.Object"
           glib:type-name="InfXmppConnection"
           glib:get-type="inf_xmpp_connection_get_type"
           glib:type-struct="XmppConnectionClass">
      <doc xml:space="preserve">#InfXmppConnection is an opaque data type. You should only access it via
the public API functions.</doc>
      <implements name="XmlConnection"/>
      <constructor name="new" c:identifier="inf_xmpp_connection_new">
        <doc xml:space="preserve">Creates a new #InfXmppConnection with @tcp as communication channel. No
attempt is being made to open @tcp, if it is not already open. However,
communication is initiated as soon as @tcp gets into
%INF_TCP_CONNECTION_CONNECTED state, so you might still open it
lateron yourself.

@local_hostname specifies the hostname of the local host, and
@remote_hostname specifies the hostname of the remote host, as known to
the caller. These can be a string representation of the IP address of
@tcp, or a DNS name such as "example.com". @local_hostname can be %NULL
in which case the host name as reported by g_get_host_name() is used.

@creds may be %NULL in which case the connection creates the credentials
as soon as they are required. However, this only works if
@site is %INF_XMPP_CONNECTION_CLIENT or @security_policy is
%INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED (or both, of course). For
server connections @creds must contain a valid server certificate in case
@security_policy is not %INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED.
@creds can contain a certificate for the client site and, if so, is used
for client authentication.

If @sasl_context is %NULL, #InfXmppConnection uses a built-in context
that only supports ANONYMOUS authentication. In @sasl_context's
callback function, the #InfXmppConnection for which the authentication
shall be performed can be accessed via the @session_data parameter of
#InfSaslContextCallbackFunc.

If @sasl_context is not %NULL, then the @sasl_mechanisms parameter defines
what SASL mechanisms are used. On the server side, these are the mechanisms
offered to the client, and on the client side, these are the accepted
mechanisms (meaning that if a server does not offer any of these, the
connection will be closed). If @sasl_context is %NULL, then this parameter
is ignored. @sasl_mechanisms can be %NULL in which case all available
mechanisms are accepted or offered, respectively.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfXmppConnection.</doc>
          <type name="XmppConnection" c:type="InfXmppConnection*"/>
        </return-value>
        <parameters>
          <parameter name="tcp" transfer-ownership="none">
            <doc xml:space="preserve">The underlaying TCP connection to use.</doc>
            <type name="TcpConnection" c:type="InfTcpConnection*"/>
          </parameter>
          <parameter name="site" transfer-ownership="none">
            <doc xml:space="preserve">Whether this is a XMPP client or server.</doc>
            <type name="XmppConnectionSite" c:type="InfXmppConnectionSite"/>
          </parameter>
          <parameter name="local_hostname"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The hostname of the local host, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="remote_hostname" transfer-ownership="none">
            <doc xml:space="preserve">The hostname of the remote host.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="security_policy" transfer-ownership="none">
            <doc xml:space="preserve">Whether to use (or offer, as a server) TLS. See
#InfXmppConnectionSecurityPolicy for the meaning of this parameter.</doc>
            <type name="XmppConnectionSecurityPolicy"
                  c:type="InfXmppConnectionSecurityPolicy"/>
          </parameter>
          <parameter name="creds"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Certificate credentials used to secure the
communication.</doc>
            <type name="CertificateCredentials"
                  c:type="InfCertificateCredentials*"/>
          </parameter>
          <parameter name="sasl_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A SASL context used for authentication.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </parameter>
          <parameter name="sasl_mechanisms"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A whitespace-separated list of SASL
mechanisms to accept/offer, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="error_quark"
                c:identifier="inf_xmpp_connection_error_quark">
        <doc xml:space="preserve">Error domain for generic connection errors. Errors in this domain will be
from the #InfXmppConnectionError enumeration. See #GError for information
on error domains.</doc>
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="certificate_verify_cancel"
              c:identifier="inf_xmpp_connection_certificate_verify_cancel">
        <doc xml:space="preserve">Call this function when your callback set in
inf_xmpp_connection_set_certificate_callback() was called and you do not
trust the peer's certificate. The connection will then be closed with a
corresponding error.

If @error is non-%NULL, then it should contain a reason why the certificate
was not trusted. If you verified the peer's certificate with
gnutls_certificate_verify_peers2(), or gnutls_x509_crt_list_verify(), then
a corresponding error can be generated with the verification result
with inf_gnutls_certificate_verification_set_error(). The reason is then
shown to the local user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">Reason why the certificate is not trusted, or %NULL.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="certificate_verify_continue"
              c:identifier="inf_xmpp_connection_certificate_verify_continue">
        <doc xml:space="preserve">Call this function when your callback set in
inf_xmpp_connection_set_certificate_callback() was called and you do trust
the peer's certificate. The connection process will then continue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cipher_algorithm"
              c:identifier="inf_xmpp_connection_get_cipher_algorithm"
              introspectable="0">
        <doc xml:space="preserve">Returns the cipher algorithm used for this connection. This function can
only be used if inf_xmpp_connection_get_tls_enabled() returns true.</doc>
        <return-value>
          <doc xml:space="preserve">The cipher algorithm used.</doc>
          <type c:type="gnutls_cipher_algorithm_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dh_prime_bits"
              c:identifier="inf_xmpp_connection_get_dh_prime_bits">
        <doc xml:space="preserve">Returns the number of prime bits used for the Diffie-Hellman group if
a key exchange algorithm based on Diffie-Hellman is used. Otherwise, 0
is returned. This function can only be used if
inf_xmpp_connection_get_tls_enabled() returns true.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of Diffie-Hellman prime bits.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_kx_algorithm"
              c:identifier="inf_xmpp_connection_get_kx_algorithm"
              introspectable="0">
        <doc xml:space="preserve">Returns the key exchange algorithm used for this connection. This function
can only be used if inf_xmpp_connection_get_tls_enabled() returns true.</doc>
        <return-value>
          <doc xml:space="preserve">The key exchange algorithm used.</doc>
          <type c:type="gnutls_kx_algorithm_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_algorithm"
              c:identifier="inf_xmpp_connection_get_mac_algorithm"
              introspectable="0">
        <doc xml:space="preserve">Returns the MAC algorithm used for this connection. This function can
only be used if inf_xmpp_connection_get_tls_enabled() returns true.</doc>
        <return-value>
          <doc xml:space="preserve">The MAC algorithm used.</doc>
          <type c:type="gnutls_mac_algorithm_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_own_certificate"
              c:identifier="inf_xmpp_connection_get_own_certificate">
        <doc xml:space="preserve">Returns the local host's certificate that was used to authenticate with
the remote host, or %NULL if no certificate was used. This function can
only be used after the TLS handshake has completed, see
inf_xmpp_connection_get_tls_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The certificate of the local host. The returned
value should not be freed, it is owned by the #InfXmppConnection.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_peer_certificate"
              c:identifier="inf_xmpp_connection_get_peer_certificate">
        <doc xml:space="preserve">Returns the certificate chain that the remote host authenticated itself
with. This function can only be used after the TLS handshake has completed,
see inf_xmpp_connection_get_tls_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The certificate chain of the remote host. The
returned value should not be freed, it is owned by the #InfXmppConnection.</doc>
          <type name="CertificateChain" c:type="InfCertificateChain*"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sasl_error"
              c:identifier="inf_xmpp_connection_get_sasl_error">
        <doc xml:space="preserve">Gets the SASL error of @xmpp. See inf_xmpp_connection_set_sasl_error().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a #GError object owned by @xmpp.</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_enabled"
              c:identifier="inf_xmpp_connection_get_tls_enabled">
        <doc xml:space="preserve">Returns whether TLS encryption is enabled for @xmpp. This returns %TRUE
as soon as the TLS handshake is completed but before the server certificate
was verified (see inf_xmpp_connection_set_certificate_callback()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if TLS is enabled and %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_protocol"
              c:identifier="inf_xmpp_connection_get_tls_protocol"
              introspectable="0">
        <doc xml:space="preserve">Returns the TLS protocol version used for this connection. This function
can only be used if inf_xmpp_connection_get_tls_enabled() returns true.</doc>
        <return-value>
          <doc xml:space="preserve">The TLS protocol version used.</doc>
          <type c:type="gnutls_protocol_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_sasl_authentication"
              c:identifier="inf_xmpp_connection_reset_sasl_authentication">
        <doc xml:space="preserve">Sets a new SASL context and mechanisms to use for authentication. This does
not have any effect if authentication has already been performed. This can
be useful if a server decides to use a stricter authentication policy and
gets away with its previous SASL context. If @new_context is %NULL, then a
built-in SASL context is used which only accepts anonymous authentication.

If the authentication is currently in progress then it is aborted. The
server sends an %INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
error to the client with %INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN detail
(see inf_xmpp_connection_get_sasl_error()).

On the client side, if authentication is in progress, a request to abort
the authentication is sent to the server. The server will then reply with
an %INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED error. In the signal handler of
the #InfXmlConnection::error signal you should reinitiate the authentication
with inf_xmpp_connection_retry_sasl_authentication() or the connection will
be closed. It is also possible that the final authentication request has
already been sent, and the server replies with successful authentication
instead. In that case calling this function will have no effect apart from
closing and reopening the connection will use the new context and
mechanisms.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
          <parameter name="new_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The new sasl context to set, or %NULL.</doc>
            <type name="SaslContext" c:type="InfSaslContext*"/>
          </parameter>
          <parameter name="new_mechanisms"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Allowed SASL mechanisms to use. Ignored if
@new_context is %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="retry_sasl_authentication"
              c:identifier="inf_xmpp_connection_retry_sasl_authentication"
              throws="1">
        <doc xml:space="preserve">When SASL authentication failed then the #InfXmlConnection::error signal
is emitted with an error from the INF_XMPP_CONNECTION_AUTH_ERROR domain.
If the signal handler wants to retry authentication then it should call
this function, possibly modifying the #InfXmppConnection:sasl-mechanisms
property before. If this function is not called then the connection will
terminate.

The function can fail if the server does not support any of the available
mechanisms given in #InfXmppConnection:sasl-mechanisms. If so, the function
returns %FALSE and @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if auth retry is being performed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_certificate_callback"
              c:identifier="inf_xmpp_connection_set_certificate_callback"
              introspectable="0">
        <doc xml:space="preserve">This function sets a callback that is called when the connection needs to
verify the peer's certificate. It does not need to respond immediately,
but can, for example, show a dialog to a user and continue when the user
finished with it.

When the certificate is trusted, then call
inf_xmpp_connection_certificate_verify_continue(),
otherwise inf_xmpp_connection_certificate_verify_cancel(). This can happen
in the callback or some time later. The connection process is stopped until
either of these functions is called.

Note that the function is also called if the peer did not send a
certificate, in which case the certificate chain parameter in the callback
will be %NULL.

If @cb is %NULL, or this function has not been called before a certificate
needs to be verified, then the certificate is always trusted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
          <parameter name="req" transfer-ownership="none">
            <doc xml:space="preserve">Whether to request a client certificate from the peer.</doc>
            <type name="gint" c:type="gnutls_certificate_request_t"/>
          </parameter>
          <parameter name="cb"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">Function to be called to verify the peer's
certificate, or %NULL.</doc>
            <type name="XmppConnectionCrtCallback"
                  c:type="InfXmppConnectionCrtCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Additional data to pass to the callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">Function to call to free the user data, or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sasl_error"
              c:identifier="inf_xmpp_connection_set_sasl_error">
        <doc xml:space="preserve">Sets the SASL error of @xmpp. The SASL error is an additional hint of what
went wrong during authentication. It should be set on the server side
in the gsasl callback checking the user authentication. If on the
client side #InfXmlConnection::error is emitted with an error from the
INF_XMPP_CONNECTION_AUTH_ERROR domain then
inf_xmpp_connection_get_sasl_error() can be used to obtain more detailed
error information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="xmpp" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">The SASL error to set.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <property name="credentials"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="CertificateCredentials"/>
      </property>
      <property name="local-hostname"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="remote-hostname"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="sasl-context"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SaslContext"/>
      </property>
      <property name="sasl-mechanisms"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="security-policy"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="XmppConnectionSecurityPolicy"/>
      </property>
      <property name="site"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="XmppConnectionSite"/>
      </property>
      <property name="tcp-connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="TcpConnection"/>
      </property>
      <property name="tls-enabled" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <enumeration name="XmppConnectionAuthError"
                 c:type="InfXmppConnectionAuthError">
      <doc xml:space="preserve">Specifies the error codes in the
&lt;literal&gt;INF_XMPP_CONNECTION_AUTH_ERROR&lt;/literal&gt; error domain. These
errors correspond to the ones defined in RFC 3920, section 6.4.</doc>
      <member name="aborted"
              value="0"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED">
        <doc xml:space="preserve">The receiving entity acknowledged
an &lt;literal&gt;&amp;lt;abort/&amp;gt;&lt;/literal&gt; element sent by the initiating entity.</doc>
      </member>
      <member name="incorrect_encoding"
              value="1"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING">
        <doc xml:space="preserve">The data provided by
the initiating entity could not be processed because the Base64 encoding
is incorrect.</doc>
      </member>
      <member name="invalid_authzid"
              value="2"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID">
        <doc xml:space="preserve">The authzid provided by
the initiating entity is invalid, either because it is incorrectly
formatted or because the initiating entity does not have permissions
to authorize that ID.</doc>
      </member>
      <member name="invalid_mechanism"
              value="3"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM">
        <doc xml:space="preserve">The initiating entity
did not provide a mechanism or requested a mechanism that is not supported
by the receiving entity.</doc>
      </member>
      <member name="mechanism_too_weak"
              value="4"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK">
        <doc xml:space="preserve">The mechanism requsted
by the initiating entity is weaker than server policy permits for that
initiating entity.</doc>
      </member>
      <member name="not_authorized"
              value="5"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED">
        <doc xml:space="preserve">The authentication failed
because the initiating entity did not provide valid credentials.</doc>
      </member>
      <member name="temporary_auth_failure"
              value="6"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE">
        <doc xml:space="preserve">The authentication
failed because of a temporary error condition within the receiving entity.</doc>
      </member>
      <member name="failed"
              value="7"
              c:identifier="INF_XMPP_CONNECTION_AUTH_ERROR_FAILED">
        <doc xml:space="preserve">General error code for otherwise
unknown errors.</doc>
      </member>
    </enumeration>
    <record name="XmppConnectionClass"
            c:type="InfXmppConnectionClass"
            glib:is-gtype-struct-for="XmppConnection">
      <doc xml:space="preserve">This structure does not contain any public fields.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="XmppConnectionCrtCallback"
              c:type="InfXmppConnectionCrtCallback"
              introspectable="0">
      <doc xml:space="preserve">Specifies the callback signature for the certificate callback set with
inf_xmpp_connection_set_certificate_callback(). The callback should decide
whether to trust the certificate in @chain or not.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xmpp" transfer-ownership="none">
          <doc xml:space="preserve">The #InfXmppConnection validating a certificate.</doc>
          <type name="XmppConnection" c:type="InfXmppConnection*"/>
        </parameter>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">The underlying GnuTLS session.</doc>
          <type c:type="gnutls_session_t"/>
        </parameter>
        <parameter name="chain" transfer-ownership="none">
          <doc xml:space="preserve">The certificate chain presented by the remote host.</doc>
          <type name="CertificateChain" c:type="InfCertificateChain*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">Additional data supplied when
inf_xmpp_connection_set_certificate_callback() was called.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="XmppConnectionError" c:type="InfXmppConnectionError">
      <doc xml:space="preserve">Specifies the error codes in the
&lt;literal&gt;INF_XMPP_CONNECTION_ERROR&lt;/literal&gt; error domain.</doc>
      <member name="tls_unsupported"
              value="0"
              c:identifier="INF_XMPP_CONNECTION_ERROR_TLS_UNSUPPORTED">
        <doc xml:space="preserve">Server does not support TLS,
but the security policy is set to %INF_XMPP_CONNECTION_SECURITY_ONLY_TLS.</doc>
      </member>
      <member name="tls_required"
              value="1"
              c:identifier="INF_XMPP_CONNECTION_ERROR_TLS_REQUIRED">
        <doc xml:space="preserve">The server requires TLS, but the
security policy is set to %INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED.</doc>
      </member>
      <member name="tls_failure"
              value="2"
              c:identifier="INF_XMPP_CONNECTION_ERROR_TLS_FAILURE">
        <doc xml:space="preserve">Server cannot proceed with the TLS
handshake.</doc>
      </member>
      <member name="no_certificate_provided"
              value="3"
              c:identifier="INF_XMPP_CONNECTION_ERROR_NO_CERTIFICATE_PROVIDED">
        <doc xml:space="preserve">The server did not
provide a certificate.</doc>
      </member>
      <member name="certificate_not_trusted"
              value="4"
              c:identifier="INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED">
        <doc xml:space="preserve">The server certificate
is not trusted. Whether the server certificate is trusted or not is defined
by the API user, by providing a certificate callback with
inf_xmpp_connection_set_certificate_callback().</doc>
      </member>
      <member name="authentication_unsupported"
              value="5"
              c:identifier="INF_XMPP_CONNECTION_ERROR_AUTHENTICATION_UNSUPPORTED">
        <doc xml:space="preserve">The server does not
provide any authentication mechanisms.</doc>
      </member>
      <member name="no_suitable_mechanism"
              value="6"
              c:identifier="INF_XMPP_CONNECTION_ERROR_NO_SUITABLE_MECHANISM">
        <doc xml:space="preserve">The server does not offer
a suitable authentication mechanism that is accepted by the client.</doc>
      </member>
      <member name="failed"
              value="7"
              c:identifier="INF_XMPP_CONNECTION_ERROR_FAILED">
        <doc xml:space="preserve">General error code for otherwise
unknown errors.</doc>
      </member>
    </enumeration>
    <enumeration name="XmppConnectionSecurityPolicy"
                 glib:type-name="InfXmppConnectionSecurityPolicy"
                 glib:get-type="inf_xmpp_connection_security_policy_get_type"
                 c:type="InfXmppConnectionSecurityPolicy">
      <doc xml:space="preserve">The #InfXmppConnectionSecurityPolicy enumeration specifies various options
of how to deal with the other site allowing or requiring TLS-secured
connections. Note that if the local site is a server, then
@INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED and
@INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS are equivalent.</doc>
      <member name="only_unsecured"
              value="0"
              c:identifier="INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED"
              glib:nick="only-unsecured">
        <doc xml:space="preserve">In the case of a server, do
not offer TLS to the client. As a client, only connect if the server does
not require TLS.</doc>
      </member>
      <member name="only_tls"
              value="1"
              c:identifier="INF_XMPP_CONNECTION_SECURITY_ONLY_TLS"
              glib:nick="only-tls">
        <doc xml:space="preserve">In the case of a server, require
all connections to be TLS-secured. As a client, only connect if the server
supports TLS.</doc>
      </member>
      <member name="both_prefer_unsecured"
              value="2"
              c:identifier="INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED"
              glib:nick="both-prefer-unsecured">
        <doc xml:space="preserve">In the case of a
server, offer both unsecured and secured messaging to the client. As a
client, use unsecured communication unless TLS is required by the server.</doc>
      </member>
      <member name="both_prefer_tls"
              value="3"
              c:identifier="INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS"
              glib:nick="both-prefer-tls">
        <doc xml:space="preserve">In the case of a server,
offer both unsecured and secured messaging to the client. As a client,
use TLS unless not supported by the server.</doc>
      </member>
    </enumeration>
    <enumeration name="XmppConnectionSite"
                 glib:type-name="InfXmppConnectionSite"
                 glib:get-type="inf_xmpp_connection_site_get_type"
                 c:type="InfXmppConnectionSite">
      <doc xml:space="preserve">Specifies whether the local site of the connection is a client or a
server.</doc>
      <member name="client"
              value="1"
              c:identifier="INF_XMPP_CONNECTION_CLIENT"
              glib:nick="client">
        <doc xml:space="preserve">The local site of this connection is a
XMPP client and the remote counterpart is a server.</doc>
      </member>
      <member name="server"
              value="0"
              c:identifier="INF_XMPP_CONNECTION_SERVER"
              glib:nick="server">
        <doc xml:space="preserve">The local site of this connection is an
XMPP server and the remote counterpart is a client.</doc>
      </member>
    </enumeration>
    <enumeration name="XmppConnectionStreamError"
                 c:type="InfXmppConnectionStreamError">
      <doc xml:space="preserve">Specifies the error codes in the
&lt;literal&gt;INF_XMPP_CONNECTION_STREAM_ERROR&lt;/literal&gt; error domain. These
errors correspond to the ones defined in RFC 3920, section 4.7.3.</doc>
      <member name="bad_format"
              value="0"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT">
        <doc xml:space="preserve">The entity has sent XML that
cannot be processed.</doc>
      </member>
      <member name="bad_namespace_prefix"
              value="1"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX">
        <doc xml:space="preserve">The entity has sent
a namespace prefix that is unsupported, or has sent no namespace prefix on
an element that requires such a prefix.</doc>
      </member>
      <member name="conflict"
              value="2"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT">
        <doc xml:space="preserve">The server is closing the
active stream for this entity because a new stream has been initiated
that conflicts with the existing stream.</doc>
      </member>
      <member name="connection_timeout"
              value="3"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT">
        <doc xml:space="preserve">The entity has not
generated any traffic over the stream for some period of time.</doc>
      </member>
      <member name="host_gone"
              value="4"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE">
        <doc xml:space="preserve">The value of the 'to'
attribute provided by the initiating entity in the stream header
corresponds to a hostname that is no longer hosted by the server.</doc>
      </member>
      <member name="host_unknown"
              value="5"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN">
        <doc xml:space="preserve">The value of the 'to'
attribute provided by the initiating entity in the stream header does
not correspond to a hostname that is hosted by the server.</doc>
      </member>
      <member name="improper_addressing"
              value="6"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING">
        <doc xml:space="preserve">A stanza sent
between two servers lacks a 'to' or 'from' attribute.</doc>
      </member>
      <member name="internal_server_error"
              value="7"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR">
        <doc xml:space="preserve">The server has
experienced a misconfiguration or an otherwise-undefined internal error
that prevents it from servicing the stream.</doc>
      </member>
      <member name="invalid_from"
              value="8"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM">
        <doc xml:space="preserve">The JID or hostname
provided in a 'from' address does not match an authorized JID or
validated domain negotiated between servers via SASL or dialback, or
between a client and a server via authentication and resource binding.</doc>
      </member>
      <member name="invalid_id"
              value="9"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID">
        <doc xml:space="preserve">The stream ID or dialback
ID is invalid or does not match an ID previously provided.</doc>
      </member>
      <member name="invalid_namespace"
              value="10"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE">
        <doc xml:space="preserve">The streams namespace
is something other than &lt;literal&gt;http://etherx.jabber.org/streams&lt;/literal&gt;
or the dialback namespace name is something other than
&lt;literal&gt;jabber:server:dialback&lt;/literal&gt;.</doc>
      </member>
      <member name="invalid_xml"
              value="11"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML">
        <doc xml:space="preserve">The entity has sent invalid
XML over the stream to a server that performs validation.</doc>
      </member>
      <member name="not_authorized"
              value="12"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED">
        <doc xml:space="preserve">The entity has attempted
to send data before the stream has been authenticated, or otherwise is not
authorized to perform an action related to stream negotiation.</doc>
      </member>
      <member name="policy_violation"
              value="13"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION">
        <doc xml:space="preserve">The entity has violated
some local service policy.</doc>
      </member>
      <member name="remote_connection_failed"
              value="14"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED">
        <doc xml:space="preserve">The server is
unable to properly connect to a remote entity that is required for
authentication or authorization.</doc>
      </member>
      <member name="resource_constraint"
              value="15"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT">
        <doc xml:space="preserve">The server lacks the
system resources necessary to service the stream.</doc>
      </member>
      <member name="restricted_xml"
              value="16"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML">
        <doc xml:space="preserve">The entity has attempted
to send restricted XML features.</doc>
      </member>
      <member name="see_other_host"
              value="17"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST">
        <doc xml:space="preserve">The server will not
provide service to the initiating entity but is redirecting traffic
to another host.</doc>
      </member>
      <member name="system_shutdown"
              value="18"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN">
        <doc xml:space="preserve">The server is being
shut down and all active streams are being closed.</doc>
      </member>
      <member name="undefined_condition"
              value="19"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION">
        <doc xml:space="preserve">The error condition
is not one of those defined by the other conditions.</doc>
      </member>
      <member name="unsupported_encoding"
              value="20"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING">
        <doc xml:space="preserve">The initiating
entity has encoded the stream in an encoding that is not supported by
the server.</doc>
      </member>
      <member name="unsupported_stanza_type"
              value="21"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE">
        <doc xml:space="preserve">The initiating
entity has sent a first-level child of the stream that is not supported
by the server.</doc>
      </member>
      <member name="unsupported_version"
              value="22"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION">
        <doc xml:space="preserve">The value of the
'version' attribute provided by the initiating entity in the stream header
specifies a version of XMPP that is not supported by the server.</doc>
      </member>
      <member name="xml_not_well_formed"
              value="23"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED">
        <doc xml:space="preserve">The initiating
entity has sent XML that is not well-formed.</doc>
      </member>
      <member name="failed"
              value="24"
              c:identifier="INF_XMPP_CONNECTION_STREAM_ERROR_FAILED">
        <doc xml:space="preserve">General error code for otherwise
unknown errors.</doc>
      </member>
    </enumeration>
    <class name="XmppManager"
           c:symbol-prefix="xmpp_manager"
           c:type="InfXmppManager"
           parent="GObject.Object"
           glib:type-name="InfXmppManager"
           glib:get-type="inf_xmpp_manager_get_type"
           glib:type-struct="XmppManagerClass">
      <doc xml:space="preserve">#InfXmppManager is an opaque data type. You should only access it via the
public API functions.</doc>
      <constructor name="new" c:identifier="inf_xmpp_manager_new">
        <doc xml:space="preserve">Creates a new xmpp manager.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #InfXmppManager.</doc>
          <type name="XmppManager" c:type="InfXmppManager*"/>
        </return-value>
      </constructor>
      <virtual-method name="connection_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connection_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
          <parameter name="replaced_by" transfer-ownership="none">
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_connection"
              c:identifier="inf_xmpp_manager_add_connection">
        <doc xml:space="preserve">Adds the given connection to @manager so that it is found by
inf_xmpp_manager_lookup_connection_by_address(),
inf_xmpp_manager_lookup_connection_by_hostname() and
inf_xmpp_manager_contains_connection().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppManager.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection not yet contained in @manager.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_connection"
              c:identifier="inf_xmpp_manager_contains_connection">
        <doc xml:space="preserve">Returns whether @connection is contained in @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @connection is contained in @manager, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppManager.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_connection_by_address"
              c:identifier="inf_xmpp_manager_lookup_connection_by_address">
        <doc xml:space="preserve">Looks for a #InfXmppConnection contained in @manager whose underlaying
#InfTcpConnection has the given address and port set. Returns %NULL if
there is no such connection.

This function may also return a closed connection. You can then attempt to
reopen it, or remove it from the manager using
inf_xmpp_manager_remove_connection() when that fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfXmppConnection with the given
address and port, or %NULL if not found.</doc>
          <type name="XmppConnection" c:type="InfXmppConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppManager.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">The remote #InfIpAddress of the connection to look for.</doc>
            <type name="IpAddress" c:type="const InfIpAddress*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The remote port number of the connection to look for.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_connection_by_hostname"
              c:identifier="inf_xmpp_manager_lookup_connection_by_hostname">
        <doc xml:space="preserve">Looks for a #InfXmppConnection contained in @manager whose underlaying
#InfTcpConnection has a #InfNameResolver with the given properties.

This function may also return a closed connection. You can then attempt to
reopen it, or remove it from the manager using
inf_xmpp_manager_remove_connection() when that fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #InfXmppConnection with the given
hostname, service and srv, or %NULL if not found.</doc>
          <type name="XmppConnection" c:type="InfXmppConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppManager.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">The remote hostname to look for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The service string of the connection to look for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="srv"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The SRV record corresponding to the connection.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_connection"
              c:identifier="inf_xmpp_manager_remove_connection">
        <doc xml:space="preserve">Removes the given connection from @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppManager.</doc>
            <type name="XmppManager" c:type="InfXmppManager*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">A #InfXmppConnection contained in @manager.</doc>
            <type name="XmppConnection" c:type="InfXmppConnection*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="connection-added" when="last">
        <doc xml:space="preserve">This signal is emitted whenever a new connection has been added to the
#InfXmppManager, via inf_xmpp_manager_add_connection().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #InfXmppConnection that was added to @xmpp_manager.</doc>
            <type name="XmppConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connection-removed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="XmppConnection"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="XmppConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="XmppManagerClass"
            c:type="InfXmppManagerClass"
            glib:is-gtype-struct-for="XmppManager">
      <doc xml:space="preserve">This structure contains the default signal handlers for #InfXmppManager.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="connection_added">
        <callback name="connection_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="XmppManager" c:type="InfXmppManager*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmppConnection" c:type="InfXmppConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_removed">
        <callback name="connection_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="manager" transfer-ownership="none">
              <type name="XmppManager" c:type="InfXmppManager*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="XmppConnection" c:type="InfXmppConnection*"/>
            </parameter>
            <parameter name="replaced_by" transfer-ownership="none">
              <type name="XmppConnection" c:type="InfXmppConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function name="acl_account_array_free"
              c:identifier="inf_acl_account_array_free"
              moved-to="AclAccount.array_free">
      <doc xml:space="preserve">Releases all resources allocated by an array of #InfAclAccount&lt;!-- --&gt;s.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="accounts" transfer-ownership="none">
          <doc xml:space="preserve">An array of #InfAclAccount objects.</doc>
          <array length="1" zero-terminated="0" c:type="InfAclAccount*">
            <type name="AclAccount" c:type="InfAclAccount"/>
          </array>
        </parameter>
        <parameter name="n_accounts" transfer-ownership="none">
          <doc xml:space="preserve">The number of elements in the array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_account_from_xml"
              c:identifier="inf_acl_account_from_xml"
              moved-to="AclAccount.from_xml"
              throws="1">
      <doc xml:space="preserve">Attempts to deserialize an #InfAclAccount that was written to an XML node
by the function inf_acl_account_to_xml(). If an error occurs, such as
mandatory fields being missing, the function returns %NULL and @error is
set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfAclAccount on success, or %NULL on
failure. Free with inf_acl_account_free() when no longer needed.</doc>
        <type name="AclAccount" c:type="InfAclAccount*"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">An XML node.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_account_id_from_string"
              c:identifier="inf_acl_account_id_from_string"
              moved-to="AclAccount.id_from_string">
      <doc xml:space="preserve">Converts the given string into a unique account identifier which can be
used with the rest of the ACL API.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The account ID which is equivalent to the given
string.</doc>
        <type name="AclAccountId" c:type="InfAclAccountId"/>
      </return-value>
      <parameters>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve">A string representation of an account ID.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_account_id_to_string"
              c:identifier="inf_acl_account_id_to_string"
              moved-to="AclAccount.id_to_string">
      <doc xml:space="preserve">Translates the given account ID to a unique string identifier.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A string representation of the given account ID, or %NULL if
the account does not exist. The return value must not be freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">A #InfAclAccountId.</doc>
          <type name="AclAccountId" c:type="InfAclAccountId"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_sheet_perms_from_xml"
              c:identifier="inf_acl_sheet_perms_from_xml"
              moved-to="AclSheet.perms_from_xml"
              throws="1">
      <doc xml:space="preserve">This function extracts the permission mask and the permission flags from
the XML node @xml. The counterpart to this function is
inf_acl_sheet_perms_to_xml(). If an error occurs the function returns
%FALSE and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the operation was successful, or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">The XML node to read from.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="mask"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">Output parameter to write the permission mask to.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </parameter>
        <parameter name="perms"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">Output parameter to write the permissions to.</doc>
          <type name="AclMask" c:type="InfAclMask*"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_sheet_perms_to_xml"
              c:identifier="inf_acl_sheet_perms_to_xml"
              moved-to="AclSheet.perms_to_xml">
      <doc xml:space="preserve">This function writes the given permission mask and permission flags to the
XML node @xml. They can be converted back using the
inf_acl_sheet_perms_from_xml() function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">Permission mask to write.</doc>
          <type name="AclMask" c:type="const InfAclMask*"/>
        </parameter>
        <parameter name="perms" transfer-ownership="none">
          <doc xml:space="preserve">Individiual permissions to write.</doc>
          <type name="AclMask" c:type="const InfAclMask*"/>
        </parameter>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">error: Location to store error information, if any.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="acl_sheet_set_from_xml"
              c:identifier="inf_acl_sheet_set_from_xml"
              moved-to="AclSheetSet.from_xml"
              throws="1">
      <doc xml:space="preserve">Reads a sheet set from @xml that has been written with
inf_acl_sheet_set_to_xml(). If an error occurs the function returns
%NULL and @error is set. If there is no ACL stored in @xml, the function
returns %NULL without setting @error.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A #InfAclSheetSet, or %NULL. Free with
inf_acl_sheet_set_free() when no longer needed.</doc>
        <type name="AclSheetSet" c:type="InfAclSheetSet*"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">The XML node from which to read the sheet set.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="adopted_state_vector_error_quark"
              c:identifier="inf_adopted_state_vector_error_quark"
              moved-to="AdoptedStateVector.error_quark">
      <doc xml:space="preserve">The domain for #InfAdoptedStateVectorError errors.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A #GQuark for that domain.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="adopted_state_vector_from_string"
              c:identifier="inf_adopted_state_vector_from_string"
              moved-to="AdoptedStateVector.from_string"
              throws="1">
      <doc xml:space="preserve">Recreates the #InfAdoptedStateVector from its string representation. If
an error occurs, the function returns %NULL and @error is set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfAdoptedStateVector, or %NULL.</doc>
        <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">A string representation of a #InfAdoptedStateVector.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="adopted_state_vector_from_string_diff"
              c:identifier="inf_adopted_state_vector_from_string_diff"
              moved-to="AdoptedStateVector.from_string_diff"
              throws="1">
      <doc xml:space="preserve">Recreates a vector from its string representation diff and the original
vector. If an error returns, the function returns %NULL and @error is set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The created state vector, or %NULL on error.
Free with inf_adopted_state_vector_free() when no longer needed.</doc>
        <type name="AdoptedStateVector" c:type="InfAdoptedStateVector*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">A string representation of a diff between state vectors.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="orig" transfer-ownership="none">
          <doc xml:space="preserve">The state vector used to create @str in
inf_adopted_state_vector_to_string_diff().</doc>
          <type name="AdoptedStateVector"
                c:type="const InfAdoptedStateVector*"/>
        </parameter>
      </parameters>
    </function>
    <function name="authentication_detail_error_quark"
              c:identifier="inf_authentication_detail_error_quark">
      <doc xml:space="preserve">Error domain for further information on authentication errors. Errors in
this domain will be from the #InfAuthenticationDetailError enumeration.
See #GError for information on error domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="authentication_detail_strerror"
              c:identifier="inf_authentication_detail_strerror">
      <doc xml:space="preserve">Returns a human-readable string for the given error code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A static string that must not be freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">An error code from the #InfAuthenticationDetailError enumeration.</doc>
          <type name="AuthenticationDetailError"
                c:type="InfAuthenticationDetailError"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_check_certificate_key"
              c:identifier="inf_cert_util_check_certificate_key">
      <doc xml:space="preserve">This function returns %TRUE if @key is the private key belonging to @cert,
or %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @cert was signed with @key, or %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">The certificate to be checked.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The private key to be checked.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_compare_fingerprint"
              c:identifier="inf_cert_util_compare_fingerprint"
              throws="1">
      <doc xml:space="preserve">Checks whether the SHA-256 fingerprints of the two given certificates are
identical or not. If a fingerprint cannot be obtained, the function
returns %FALSE and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the two certificates have identical fingerprints. Returns
%FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cert1" transfer-ownership="none">
          <doc xml:space="preserve">The first certificate to compare.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="cert2" transfer-ownership="none">
          <doc xml:space="preserve">The second certificate to compare.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_copy_certificate"
              c:identifier="inf_cert_util_copy_certificate"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Creates a copy of the certificate @src and returns the copy. If the
function fails %FALSE is returned and @error is set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A copy of @src, or %NULL on error. Free
with gnutls_x509_crt_deinit() when no longer in use.</doc>
        <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">The certificate to copy.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_create_certificate"
              c:identifier="inf_cert_util_create_certificate"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Creates a new X.509 certificate with the given key and properties. If
an error occurs the function returns %NULL and @error is set. The
returned certificate will not be signed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #gnutls_x509_crt_t, or %NULL.
Free with gnutls_x509_crt_deinit() when no longer needed.</doc>
        <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The private key to be used for the new
certificate.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
        <parameter name="desc" transfer-ownership="none">
          <doc xml:space="preserve">The certificate properties.</doc>
          <type name="CertUtilDescription"
                c:type="const InfCertUtilDescription*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_create_dh_params"
              c:identifier="inf_cert_util_create_dh_params"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Creates new, random Diffie-Hellman parameters.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">New dhparams to be freed
with gnutls_dh_params_deinit(), or %NULL in case of error.</doc>
        <type name="InfGnutls.DHParams" c:type="gnutls_dh_params_t"/>
      </return-value>
    </function>
    <function name="cert_util_create_private_key"
              c:identifier="inf_cert_util_create_private_key"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Generates a new, random X.509 private key. This function is a thin
wrapper around gnutls_x509_privkey_generate() which provides GError-style
error reporting.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new key to be freed with
gnutls_x509_privkey_deinit(), or %NULL if an error occured.</doc>
        <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
      </return-value>
      <parameters>
        <parameter name="algo" transfer-ownership="none">
          <doc xml:space="preserve">The key algorithm to use (RSA or DSA).</doc>
          <type name="InfGnutls.PKAlgorithm" c:type="gnutls_pk_algorithm_t"/>
        </parameter>
        <parameter name="bits" transfer-ownership="none">
          <doc xml:space="preserve">The length of the key to generate.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_create_self_signed_certificate"
              c:identifier="inf_cert_util_create_self_signed_certificate"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Creates a new X.509 certificate with the given key and properties. If
an error occurs the function returns %NULL and @error is set. The
returned certificate will be signed by itself.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #gnutls_x509_crt_t, or %NULL.
Free with gnutls_x509_crt_deinit() when no longer needed.</doc>
        <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The private key to be used for the new
certificate.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
        <parameter name="desc" transfer-ownership="none">
          <doc xml:space="preserve">The certificate properties.</doc>
          <type name="CertUtilDescription"
                c:type="const InfCertUtilDescription*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_create_signed_certificate"
              c:identifier="inf_cert_util_create_signed_certificate"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Creates a new X.509 certificate with the given key and properties. If
an error occurs the function returns %NULL and @error is set. The
returned certificate will be signed by @sign_cert.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #gnutls_x509_crt_t, or %NULL.
Free with gnutls_x509_crt_deinit() when no longer needed.</doc>
        <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The private key to be used for the new
certificate.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
        <parameter name="desc" transfer-ownership="none">
          <doc xml:space="preserve">The certificate properties.</doc>
          <type name="CertUtilDescription"
                c:type="const InfCertUtilDescription*"/>
        </parameter>
        <parameter name="sign_cert" transfer-ownership="none">
          <doc xml:space="preserve">A certificate used to sign the newly
created certificate.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="sign_key" transfer-ownership="none">
          <doc xml:space="preserve">The private key for @sign_cert.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_activation_time"
              c:identifier="inf_cert_util_get_activation_time">
      <doc xml:space="preserve">Returns the activation time of the certificate as a string in
human-readable format. If the activation time cannot be read %NULL is
returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The activation time of the certificate, or %NULL.
Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_dn" c:identifier="inf_cert_util_get_dn">
      <doc xml:space="preserve">Retrieves the full distinguished name (DN) from the certificate, allocating
memory for the return value.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The DN of the certificate. Free with g_free()
after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_dn_by_oid"
              c:identifier="inf_cert_util_get_dn_by_oid">
      <doc xml:space="preserve">Retrieves the given item from the certificate. This function is a thin
wrapper around gnutls_x509_crt_get_dn_by_oid(), allocating memory for the
return value. The function returns %NULL if there is no such entry in the
certificate.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The certificate entry, or %NULL if it is not
present. Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="oid" transfer-ownership="none">
          <doc xml:space="preserve">The name of the requested entry.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve">Index of the entry to retrieve.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_expiration_time"
              c:identifier="inf_cert_util_get_expiration_time">
      <doc xml:space="preserve">Returns the expiration time of the certificate as a string in
human-readable format. If the expiration time cannot be read %NULL is
returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The expiration time of the certificate, or %NULL.
Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_fingerprint"
              c:identifier="inf_cert_util_get_fingerprint">
      <doc xml:space="preserve">Returns the fingerprint of the certificate hashed with the specified
algorithm, in hexadecimal format. If the fingerprint cannot be read %NULL
is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The fingerprint of the certificate, or %NULL.
Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="algo" transfer-ownership="none">
          <doc xml:space="preserve">The hashing algorithm to use.</doc>
          <type name="InfGnutls.DigestAlgorithm"
                c:type="gnutls_digest_algorithm_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_hostname"
              c:identifier="inf_cert_util_get_hostname">
      <doc xml:space="preserve">Attempts to read the hostname of a certificate. This is done by looking
at the DNS name and IP address SANs. If both are not available, the common
name of the certificate is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The best guess for the
certificate's hostname, or %NULL when it cannot be retrieved. Free with
g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_issuer_dn_by_oid"
              c:identifier="inf_cert_util_get_issuer_dn_by_oid">
      <doc xml:space="preserve">Retrieves the given item from the issuer of the certificate. This function
is a thin wrapper around gnutls_x509_crt_get_issuer_dn_by_oid(),
allocating memory for the return value. The functions returns %NULL if
there is no such entry in the certificate.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The certificate entry, or %NULL if it is not
present. Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
        <parameter name="oid" transfer-ownership="none">
          <doc xml:space="preserve">The name of the requested entry.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve">Index of the entry to retrieve.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_get_serial_number"
              c:identifier="inf_cert_util_get_serial_number">
      <doc xml:space="preserve">Read the serial number of a certificate and return it in hexadecimal
format. If the serial number cannot be read %NULL is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The serial number of the certificate, or %NULL.
Free with g_free() after use.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="cert" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_crt_t.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_read_certificate"
              c:identifier="inf_cert_util_read_certificate"
              throws="1">
      <doc xml:space="preserve">Loads X.509 certificates in PEM format from the file at @filename. There
can be any number of certificates in the file. If @current is not %NULL,
the new certificates are appended to the array. Otherwise, a new array
with the read certificates is returned.

If an error occurs, the function returns %NULL and @error is set. If
@current is non-%NULL and the function succeeds, the return value is the
same as @current.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">An array of the
read certificates, or %NULL on error.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="InfGnutls.X509Crt"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">A path to a X.509 certificate file.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="current"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">An
array of #gnutls_x509_crt_t objects, or %NULL.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="InfGnutls.X509Crt"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_read_certificate_map"
              c:identifier="inf_cert_util_read_certificate_map"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Reads a certificate map, i.e. a mapping from hostname to certificate,
from the given file. The format of the file is expected to be one entry
per line, where each entry consists of the hostname, then a colon
character (':'), and then the base64-encoded certificate in DER format.

If the file with the given filename does not exist, an empty hash table
is returned and the function succeeds.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">
A hash table with the read mapping, or %NULL on error. Use
g_hash_table_unref() to free the hash table when no longer needed.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type c:type="string"/>
          <type name="InfGnutls.X509Crt"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The filename to read the certificate map from.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_read_dh_params"
              c:identifier="inf_cert_util_read_dh_params"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Reads the Diffie-Hellman parameters located at @filename into a
gnutls_dh_params_t structure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">New dhparams to be freed with
gnutls_dh_params_deinit(), or %NULL in case of error.</doc>
        <type name="InfGnutls.DHParams" c:type="gnutls_dh_params_t"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">A path to a DH parameters file.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_read_private_key"
              c:identifier="inf_cert_util_read_private_key"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Reads the key located at @filename into a gnutls_x509_privkey_t
structure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A private key. Free with
gnutls_x509_privkey_deinit().</doc>
        <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">A path to a X.509 private key file</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_certificate"
              c:identifier="inf_cert_util_write_certificate"
              throws="1">
      <doc xml:space="preserve">This function writes the certificates in the array @certs to disk, in
PEM format. If an error occurs the function returns %FALSE and @error
is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="certs" transfer-ownership="none">
          <doc xml:space="preserve">An array of
#gnutls_x509_crt_t objects.</doc>
          <array length="1" zero-terminated="0" c:type="gnutls_x509_crt_t*">
            <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
          </array>
        </parameter>
        <parameter name="n_certs" transfer-ownership="none">
          <doc xml:space="preserve">Number of certificates in the error.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The path at which to store the certificates.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_certificate_map"
              c:identifier="inf_cert_util_write_certificate_map"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Writes the given certificate mapping to a file with the given filename.
See inf_cert_util_read_certificate_map() for the format of the written
file. If an error occurs, @error is set and the function returns %FALSE.

This function can be useful to implement trust-on-first-use (TOFU)
semantics.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cert_map" transfer-ownership="none">
          <doc xml:space="preserve">A
certificate mapping, i.e. a hash table mapping hostname strings to
#gnutls_x509_crt_t instances.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type c:type="string"/>
            <type name="InfGnutls.X509Crt"/>
          </type>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The name of the file to write the mapping to.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_certificate_mem"
              c:identifier="inf_cert_util_write_certificate_mem"
              throws="1">
      <doc xml:space="preserve">This function writes the certificates in the array @certs into memory, in
PEM format. If an error occurs the function returns %NULL and @error
is set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A string with PEM-encoded certificate data, or
%NULL on error. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="certs" transfer-ownership="none">
          <doc xml:space="preserve">An
array of #gnutls_x509_crt_t objects.</doc>
          <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t*"/>
        </parameter>
        <parameter name="n_certs" transfer-ownership="none">
          <doc xml:space="preserve">Number of certificates in the error.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_certificate_with_key"
              c:identifier="inf_cert_util_write_certificate_with_key"
              throws="1">
      <doc xml:space="preserve">This function writes both the private key @key as well as the
certificates in the array @certs to disk, in PEM format. If an error
occurs the function returns %FALSE and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_privkey_t
structure.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
        <parameter name="certs" transfer-ownership="none">
          <doc xml:space="preserve">An array of
#gnutls_x509_crt_t objects.</doc>
          <array length="2" zero-terminated="0" c:type="gnutls_x509_crt_t*">
            <type name="InfGnutls.X509Crt" c:type="gnutls_x509_crt_t"/>
          </array>
        </parameter>
        <parameter name="n_certs" transfer-ownership="none">
          <doc xml:space="preserve">Number of certificates in the error.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The path at which to store the certificates.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_dh_params"
              c:identifier="inf_cert_util_write_dh_params"
              throws="1">
      <doc xml:space="preserve">Writes the given Diffie-Hellman parameters to the given path on the
filesystem. If an error occurs, @error is set and %FALSE is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_dh_params_t
structure.</doc>
          <type name="InfGnutls.DHParams" c:type="gnutls_dh_params_t"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The path at which so store @params.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cert_util_write_private_key"
              c:identifier="inf_cert_util_write_private_key"
              throws="1">
      <doc xml:space="preserve">Writes @key to the location specified by @filename on the filesystem.
If an error occurs, the function returns %FALSE and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">An initialized #gnutls_x509_privkey_t
structure.</doc>
          <type name="InfGnutls.X509PrivKey" c:type="gnutls_x509_privkey_t"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">The path at which so store the key.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="deinit" c:identifier="inf_deinit">
      <doc xml:space="preserve">This functions deinitializes the libinfinity library. Make sure that all
objects the library provides have been freed before calling this function.
If inf_init() has been called multiple times, then inf_deinit() needs to be
called the same number of times to actually deinitialize the library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="directory_error_quark"
              c:identifier="inf_directory_error_quark">
      <doc xml:space="preserve">Error domain for directory errors. Errors in this domain will be from the
#InfDirectoryError enumeration. See #GError for information on error
domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="directory_strerror" c:identifier="inf_directory_strerror">
      <doc xml:space="preserve">Returns a human-readable string for the given error code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A static string that must not be freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">An error code from the #InfDirectoryError enumeration.</doc>
          <type name="DirectoryError" c:type="InfDirectoryError"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_create_directory"
              c:identifier="inf_file_util_create_directory"
              throws="1">
      <doc xml:space="preserve">Attempts to create a directory at @path, creating intermediate directories
as necessary. The @mode parameter is only used on Unix in which case it
specifies the permissions to use for all newly created directories in the
same way as g_mkdir() would.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">The directory to create.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">Permissions to use for the newly created directory.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_create_single_directory"
              c:identifier="inf_file_util_create_single_directory"
              throws="1">
      <doc xml:space="preserve">Attempts to create a directory at @path. The @mode parameter is only used
on Unix in which case it specifies the permissions to use for all newly
created directories in the same way as g_mkdir() would.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">The directory to create.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">Permissions to use for the newly created directory.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_delete"
              c:identifier="inf_file_util_delete"
              throws="1">
      <doc xml:space="preserve">Removes the file or directory at @path. If it is a directory the directory
is deleted recursively. If the function fails %FALSE is returned
and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Path to the object to delete.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_delete_directory"
              c:identifier="inf_file_util_delete_directory"
              throws="1">
      <doc xml:space="preserve">Removes the directory at @path recursively. Fails if @path points to a
regular file and not a directory. If the function fails %FALSE is returned
and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Path to the directory to delete.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_delete_file"
              c:identifier="inf_file_util_delete_file"
              throws="1">
      <doc xml:space="preserve">Removes the file at @path if it is empty. Fails if @path points to a
directory and not a regular file. If the function fails %FALSE is returned
and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Path to the file to delete.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_delete_single_directory"
              c:identifier="inf_file_util_delete_single_directory"
              throws="1">
      <doc xml:space="preserve">Removes the directory at @path if it is empty, or fails otherwise. Fails
if @path points to a regular file and not a directory. If the function
fails %FALSE is returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Path to the directory to delete.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_list_directory"
              c:identifier="inf_file_util_list_directory"
              throws="1">
      <doc xml:space="preserve">Calls @func for each file within the given directory. It also passes the
type of the found file to the callback function. The callback function can
return %FALSE to stop the iteration. If it does this, then this function
still returns %TRUE. This can for example be used to find a file in a
directory. If, in addition, the callback function sets @error, then this
function returns %FALSE and propagates the error.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">The directory to explore.</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="2">
          <doc xml:space="preserve">Callback function to be called for each child of the
directory at @path.</doc>
          <type name="FileListFunc" c:type="InfFileListFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">Additional data to pass to @func.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_write_private_data"
              c:identifier="inf_file_util_write_private_data"
              throws="1">
      <doc xml:space="preserve">Writes @data to the file pointed to by @filename. On Unix-like systems,
@filename is created with 0600 permission. If the function fails, %FALSE is
returned and @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">Filename of the file to be written to.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">Data that should be written to file.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">Length of data in bytes.</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="gnutls_certificate_verification_error_quark"
              c:identifier="inf_gnutls_certificate_verification_error_quark">
      <doc xml:space="preserve">Error domain for GnuTLS certificate verification errors. Errors in this
domain will be GnuTLS certificate verification results as returned by
gnutls_certificate_verify_peers2(). See #GError for information on
error domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="gnutls_certificate_verification_set_error"
              c:identifier="inf_gnutls_certificate_verification_set_error">
      <doc xml:space="preserve">Sets a #GError from a certificate verification result.
If @error is %NULL, does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Location to store the error, or %NULL.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="verify" transfer-ownership="none">
          <doc xml:space="preserve">A GnuTLS certificate verification code.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="gnutls_error_quark" c:identifier="inf_gnutls_error_quark">
      <doc xml:space="preserve">Error domain for GnuTLS errors. Errors in this domain will be GnuTLS error
codes. See #GError for information on error domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="gnutls_set_error" c:identifier="inf_gnutls_set_error">
      <doc xml:space="preserve">Sets a #GError from a GnuTLS error code. If @error is %NULL, does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Location to store the error, or %NULL.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:space="preserve">A GnuTLS error code.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="gsasl_error_quark" c:identifier="inf_gsasl_error_quark">
      <doc xml:space="preserve">Error domain for GNU SASL errors. Errors in this domain will be GNU SASL
error codes. See #GError for information on error domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="gsasl_set_error" c:identifier="inf_gsasl_set_error">
      <doc xml:space="preserve">Sets a #GError from a GNU SASL error code. If @error is %NULL, does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">Location to store the error, or %NULL.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:space="preserve">A GNU SASL error code.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="inf_init" throws="1">
      <doc xml:space="preserve">This function initializes the libinfinity library and should be called
before any other functions of the library. The function does nothing if
it has already been called before.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the initialization was successful or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="native_socket_error_quark"
              c:identifier="inf_native_socket_error_quark">
      <doc xml:space="preserve">Returns a #GQuark representing the INF_NATIVE_SOCKET_ERROR domain.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A #GQuark representing the INF_NATIVE_SOCKET_ERROR domain.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="native_socket_make_error"
              c:identifier="inf_native_socket_make_error"
              throws="1">
      <doc xml:space="preserve">Converts the platform-dependent error code @code into a #GError. The
#GError will contain the same numerical value and a platform-dependent
human-readable error message.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">An error code obtained with #INF_NATIVE_SOCKET_LAST_ERROR</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="protocol_get_default_port"
              c:identifier="inf_protocol_get_default_port">
      <doc xml:space="preserve">Returns the default port on which the infinote daemon listens for new
connections.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The default port.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="protocol_get_version"
              c:identifier="inf_protocol_get_version">
      <doc xml:space="preserve">Returns the version of the Infinote protocol implemented by this
version of libinfinity.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The supported infinote version.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="protocol_parse_version"
              c:identifier="inf_protocol_parse_version"
              throws="1">
      <doc xml:space="preserve">Splits the given version string into it's major and minor version number.
If the string is badly formatted then the function returns %FALSE, @error
is set and @major and @minor are left untouched.

It is guaranteed that, if @version is inf_protocol_get_version(), the
function does not fail.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, or %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="version" transfer-ownership="none">
          <doc xml:space="preserve">A version string, such as "1.0"</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="major" transfer-ownership="none">
          <doc xml:space="preserve">A location to store the major version number to.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="minor" transfer-ownership="none">
          <doc xml:space="preserve">A location to store the minor version number to</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_error_quark"
              c:identifier="inf_request_error_quark"
              moved-to="Request.error_quark">
      <doc xml:space="preserve">Error domain for request errors. Errors in this domain will be from the
#InfRequestError enumeration. See #GError for information on error domains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="request_result_make_add_node"
              c:identifier="inf_request_result_make_add_node"
              moved-to="RequestResult.make_add_node">
      <doc xml:space="preserve">Creates a new #InfRequestResult for an "add-node" request, see
inf_browser_add_note() or inf_browser_add_subdirectory(). The
#InfRequestResult object is only valid as long as the caller maintains
a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node to which a node has been added.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
        <parameter name="new_node" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the new node.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_create_acl_account"
              c:identifier="inf_request_result_make_create_acl_account"
              moved-to="RequestResult.make_create_acl_account">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "create-acl-account" request, see
inf_browser_create_acl_account(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">The created #InfAclAccount.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </parameter>
        <parameter name="certificate" transfer-ownership="none">
          <doc xml:space="preserve">The certificate which can be used to log into @account.</doc>
          <type name="CertificateChain" c:type="InfCertificateChain*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_explore_node"
              c:identifier="inf_request_result_make_explore_node"
              moved-to="RequestResult.make_explore_node">
      <doc xml:space="preserve">Creates a new #InfRequestResult for an "explore-node" request, see
inf_browser_explore(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node to which was explored.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_join_user"
              c:identifier="inf_request_result_make_join_user"
              moved-to="RequestResult.make_join_user">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "join-user" request, see
inf_session_proxy_join_user(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @proxy.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:space="preserve">A #InfSessionProxy.</doc>
          <type name="SessionProxy" c:type="InfSessionProxy*"/>
        </parameter>
        <parameter name="user" transfer-ownership="none">
          <doc xml:space="preserve">The joined user.</doc>
          <type name="User" c:type="InfUser*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_lookup_acl_accounts"
              c:identifier="inf_request_result_make_lookup_acl_accounts"
              moved-to="RequestResult.make_lookup_acl_accounts">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "lookup-acl-accounts" request, see
inf_browser_lookup_acl_accounts(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="accounts" transfer-ownership="none">
          <doc xml:space="preserve">The list of accounts.</doc>
          <array length="2" zero-terminated="0" c:type="InfAclAccount*">
            <type name="AclAccount" c:type="InfAclAccount"/>
          </array>
        </parameter>
        <parameter name="n_accounts" transfer-ownership="none">
          <doc xml:space="preserve">The number of entries in the account list.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_query_acl"
              c:identifier="inf_request_result_make_query_acl"
              moved-to="RequestResult.make_query_acl">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "query-acl" request, see
inf_browser_query_acl(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node whose ACL was queried.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
        <parameter name="sheet_set" transfer-ownership="none">
          <doc xml:space="preserve">The sheet set for the queried node.</doc>
          <type name="AclSheetSet" c:type="const InfAclSheetSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_query_acl_account_list"
              c:identifier="inf_request_result_make_query_acl_account_list"
              moved-to="RequestResult.make_query_acl_account_list">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "query-acl-account-list" request, see
inf_browser_query_acl_account_list(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="accounts" transfer-ownership="none">
          <doc xml:space="preserve">The list of accounts.</doc>
          <array length="2" zero-terminated="0" c:type="InfAclAccount*">
            <type name="AclAccount" c:type="InfAclAccount"/>
          </array>
        </parameter>
        <parameter name="n_accounts" transfer-ownership="none">
          <doc xml:space="preserve">The number of items in the account list.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="does_notifications" transfer-ownership="none">
          <doc xml:space="preserve">Whether the server notifies the clients about added
or removed accounts.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_remove_acl_account"
              c:identifier="inf_request_result_make_remove_acl_account"
              moved-to="RequestResult.make_remove_acl_account">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "remove-acl-account" request, see
inf_browser_remove_acl_account(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:space="preserve">The removed #InfAclAccount.</doc>
          <type name="AclAccount" c:type="const InfAclAccount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_remove_node"
              c:identifier="inf_request_result_make_remove_node"
              moved-to="RequestResult.make_remove_node">
      <doc xml:space="preserve">Creates a new #InfRequestResult for an "remove-node" request, see
inf_browser_remove_node(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node to which was removed.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_save_session"
              c:identifier="inf_request_result_make_save_session"
              moved-to="RequestResult.make_save_session">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "save-session" request, see
infc_browser_iter_save_session(). The #InfRequestResult object is only
valid as long as the caller maintains a reference to @browser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node to which was saved.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_set_acl"
              c:identifier="inf_request_result_make_set_acl"
              moved-to="RequestResult.make_set_acl">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "set-acl" request, see
inf_browser_set_acl(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node whose ACL was set.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_subscribe_chat"
              c:identifier="inf_request_result_make_subscribe_chat"
              moved-to="RequestResult.make_subscribe_chat">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "subscribe-chat" request, see
infc_browser_subscribe_chat(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:space="preserve">The #InfSessionProxy for the subscribed session.</doc>
          <type name="SessionProxy" c:type="InfSessionProxy*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_result_make_subscribe_session"
              c:identifier="inf_request_result_make_subscribe_session"
              moved-to="RequestResult.make_subscribe_session">
      <doc xml:space="preserve">Creates a new #InfRequestResult for a "subscribe-session" request, see
inf_browser_subscribe(). The #InfRequestResult object is only valid
as long as the caller maintains a reference to @browser and @proxy.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #InfRequestResult. Free with
inf_request_result_free().</doc>
        <type name="RequestResult" c:type="InfRequestResult*"/>
      </return-value>
      <parameters>
        <parameter name="browser" transfer-ownership="none">
          <doc xml:space="preserve">A #InfBrowser.</doc>
          <type name="Browser" c:type="InfBrowser*"/>
        </parameter>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">An iterator pointing to the node to which a subscription was made.</doc>
          <type name="BrowserIter" c:type="const InfBrowserIter*"/>
        </parameter>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:space="preserve">The #InfSessionProxy for the subscription.</doc>
          <type name="SessionProxy" c:type="InfSessionProxy*"/>
        </parameter>
      </parameters>
    </function>
    <function name="request_strerror"
              c:identifier="inf_request_strerror"
              moved-to="Request.strerror">
      <doc xml:space="preserve">Returns a human-readable string for the given error code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A static string that must not be freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">An error code from the #InfRequestError enumeration.</doc>
          <type name="RequestError" c:type="InfRequestError"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_status_from_string"
              c:identifier="inf_user_status_from_string"
              moved-to="UserStatus.from_string"
              throws="1">
      <doc xml:space="preserve">This function does the opposite of inf_user_status_to_string(). It turns
the given string back to a #InfUserStatus, storing the result in @status
if @status is non-%NULL. If @string is invalid, then @status is left
untouched, @error is set and %FALSE is returned. Otherwise, the function
returns %TRUE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">When an error occured during the conversion, %FALSE is returned,
and %TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">A string representation of a #InfUserStatus.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="status"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to a #InfUserStatus value, or %NULL.</doc>
          <type name="UserStatus" c:type="InfUserStatus*"/>
        </parameter>
      </parameters>
    </function>
    <function name="user_status_to_string"
              c:identifier="inf_user_status_to_string"
              moved-to="UserStatus.to_string">
      <doc xml:space="preserve">Returns a non-localized string identifying the given status. This is not
meant to be shown to a user, but rather to serialize a user status, for
example to store it in XML.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A static string representation of @status.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="status" transfer-ownership="none">
          <doc xml:space="preserve">A value from the #InfUserStatus enumeration.</doc>
          <type name="UserStatus" c:type="InfUserStatus"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_add_child_text"
              c:identifier="inf_xml_util_add_child_text">
      <doc xml:space="preserve">Adds the given text as child text to @xml in the same way
xmlNodeAddContentLen() would do. The difference is that @text is allowed
to contain characters that are not valid in
&lt;ulink url="http://www.w3.org/TR/REC-xml/#dt-text"&gt;XML text&lt;/ulink&gt;, such
as formfeed characters \f. In case one occurs in @text, the function adds
an &amp;lt;uchar /&amp;gt; element node instead to @xml as specified in the
infinote protocol.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">The child text to add.</doc>
          <array length="2" zero-terminated="0" c:type="gchar*">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes of @text.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute"
              c:identifier="inf_xml_util_get_attribute"
              introspectable="0">
      <doc xml:space="preserve">Returns the value of the attribute called @attribute in the XML element
@xml. This function is a thin wrapper around xmlGetProp() which exists
mostly for consistency, and for not having to cast the @attribute argument
from char* to xmlChar*. The return value is a xmlChar*, though.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The value of the attribute, or %NULL. Free with
xmlFree() when no longer needed.</doc>
        <type name="libxml2.Char" c:type="xmlChar*"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_double"
              c:identifier="inf_xml_util_get_attribute_double"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int(). The only difference
is that the function reads a double-precision floating point number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_double_required"
              c:identifier="inf_xml_util_get_attribute_double_required"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int_required(). The only
difference is that the function reads a double-precision floating point
number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_int"
              c:identifier="inf_xml_util_get_attribute_int"
              throws="1">
      <doc xml:space="preserve">Reads the attribute named @attribute from the XML element @xml. The
attribute value is expected to be a signed integral number. If it is the
function converts the text to an integer and stores the result into
@result. In this case, %TRUE is returned and @error is left untouched.

If the value is not a signed integral number, then the function returns
%FALSE, @error is set and @result is left untouched.

If the attribute does not exist the function returns %FALSE but @error is
not set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_int_required"
              c:identifier="inf_xml_util_get_attribute_int_required"
              throws="1">
      <doc xml:space="preserve">Reads the attribute named @attribute from the XML element @xml. The
attribute value is expected to be a signed integral number. If it is the
function converts the text to an integere and stores the result into
@result. In this case, %TRUE is returned and @error is left untouched.

If the value is not a signed integral number or the attribute does not
exist, then the function returns %FALSE, @error is set and @result is
left untouched.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_long"
              c:identifier="inf_xml_util_get_attribute_long"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int(). The only difference
is that the function reads a signed long integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_long_required"
              c:identifier="inf_xml_util_get_attribute_long_required"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int_required(). The only
difference is that the function reads a signed long integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_required"
              c:identifier="inf_xml_util_get_attribute_required"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Returns the value of the attribute called @attribute in the XML element
@xml. If there is no such attribute then the function returns %NULL and
@error is set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The attribute's value, or %NULL on error.
Free with xmlFree() when no longer needed.</doc>
        <type name="libxml2.Char" c:type="xmlChar*"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_uint"
              c:identifier="inf_xml_util_get_attribute_uint"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int(). The only difference
is that the function reads an unsigned integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_uint_required"
              c:identifier="inf_xml_util_get_attribute_uint_required"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int_required(). The only
difference is that the function reads an unsigned integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_ulong"
              c:identifier="inf_xml_util_get_attribute_ulong"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int(). The only difference
is that the function reads an unsigned long integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gulong" c:type="gulong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_attribute_ulong_required"
              c:identifier="inf_xml_util_get_attribute_ulong_required"
              throws="1">
      <doc xml:space="preserve">Behaves exactly like inf_xml_util_get_attribute_int_required(). The only
difference is that the function reads an unsigned long integral number.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether @result was set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="result"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Location to store the read value.</doc>
          <type name="gulong" c:type="gulong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_get_child_text"
              c:identifier="inf_xml_util_get_child_text"
              throws="1">
      <doc xml:space="preserve">Reads a node's child text. If there are &amp;lt;uchar /&amp;gt; child elements, as
added by inf_xml_util_add_child_text() this function will convert them
back to character codes. There should not be any other child elements in
@xml.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The node's child text, or %NULL on
error. Free with g_free() when no longer needed.</doc>
        <array length="1" zero-terminated="0" c:type="gchar*">
          <type name="utf8" c:type="gchar"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="bytes"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">Location to store number of bytes of child
text, or %NULL.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="chars"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">Location to store number of characters of child
text, or %NULL.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_new_error_from_node"
              c:identifier="inf_xml_util_new_error_from_node">
      <doc xml:space="preserve">Creates a new #GError with the domain and erro code given in @xml's
attributes. The message is parsed from the child text as with
inf_xml_util_get_child_text(). The element name and namespace are ignored.
If @xml does not have the attributes as expected, %NULL is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A pointer to a new #GError, or %NULL on
failure. It is the caller's responsibility to dispose the #GError
object using g_error_free().</doc>
        <type name="GLib.Error" c:type="GError*"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr as returned by inf_xml_util_new_node_from_error().</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_new_node_from_error"
              c:identifier="inf_xml_util_new_node_from_error"
              introspectable="0">
      <doc xml:space="preserve">Creates a new #xmlNode that encodes @error. The element's name is
optionally specified by @name, or "error" by default, @error's domain
and code are set as attributes and its message is set as child text using
inf_xml_util_add_child_text(). @name_space is set as the element's
namespace, if not %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #xmlNodePtr. It is the caller's
responsibility to dispose it using xmlFreeNode().</doc>
        <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">The error object to represent in xml.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="name_space" transfer-ownership="none">
          <doc xml:space="preserve">The element's namespace, or %NULL.</doc>
          <type name="libxml2.NsPtr" c:type="xmlNsPtr"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">An element name, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute"
              c:identifier="inf_xml_util_set_attribute">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given value of the XML element
@xml. This is a thin wrapper around xmlSetProp(), mainly provided for
consistency and for not having to cast the arguments to xmlChar*.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute_double"
              c:identifier="inf_xml_util_set_attribute_double">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given double-precision
floating point number converted to text.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute_int"
              c:identifier="inf_xml_util_set_attribute_int">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given signed integral value
converted to text.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute_long"
              c:identifier="inf_xml_util_set_attribute_long">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given signed long integral value
converted to text.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute_uint"
              c:identifier="inf_xml_util_set_attribute_uint">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given unsigned integral value
converted to text.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="xml_util_set_attribute_ulong"
              c:identifier="inf_xml_util_set_attribute_ulong">
      <doc xml:space="preserve">Sets the attribute named @attribute to the given unsigned long integral
value converted to text.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="xml" transfer-ownership="none">
          <doc xml:space="preserve">A #xmlNodePtr.</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute to set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to set.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
