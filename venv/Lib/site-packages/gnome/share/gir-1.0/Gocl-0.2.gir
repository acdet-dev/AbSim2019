<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="gocl-0.2"/>
  <c:include name="gocl.h"/>
  <namespace name="Gocl"
             version="0.2"
             shared-library="libgocl-0.2-0.dll"
             c:identifier-prefixes="Gocl"
             c:symbol-prefixes="gocl">
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="GoclBuffer"
           parent="GObject.Object"
           glib:type-name="GoclBuffer"
           glib:get-type="gocl_buffer_get_type"
           glib:type-struct="BufferClass">
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="gocl_buffer_new">
        <doc xml:space="preserve">Creates a new buffer on context's memory. Depending on flags, the @host_ptr pointer can be
used to initialize the contents of the buffer from a block of memory in the host.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclBuffer, or %NULL on error</doc>
          <type name="Buffer" c:type="GoclBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclContext to attach the buffer to</doc>
            <type name="Context" c:type="GoclContext*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">An OR'ed combination of values from #GoclBufferFlags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of the buffer, in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="host_ptr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to memory in the host system, or %NULL</doc>
            <type name="guint64" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_to_array"
                c:identifier="gocl_buffer_list_to_array"
                introspectable="0">
        <doc xml:space="preserve">A convenient method to retrieve a #GList of #GoclBuffer's as an array of
#cl_mem's corresponding to the internal objects of each #GoclBuffer in
the #GList. This is a rather low-level method and should not normally be
called by applications.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">An array of #cl_mem
  objects. Free with g_free().</doc>
          <array length="1" zero-terminated="0" c:type="cl_mem*">
            <type c:type="cl_mem"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList containing
#GoclBuffer objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to a value to retrieve list length</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="create_cl_mem" introspectable="0">
        <return-value>
          <type c:type="cl_int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <type c:type="cl_context"/>
          </parameter>
          <parameter name="obj" transfer-ownership="none">
            <type c:type="cl_mem*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="host_ptr" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_all" introspectable="0">
        <return-value>
          <type c:type="cl_int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type c:type="cl_mem"/>
          </parameter>
          <parameter name="queue" transfer-ownership="none">
            <type c:type="cl_command_queue"/>
          </parameter>
          <parameter name="target_ptr" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="blocking" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="event_wait_list" transfer-ownership="none">
            <type c:type="cl_event*"/>
          </parameter>
          <parameter name="event_wait_list_len" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_event" transfer-ownership="none">
            <type c:type="cl_event*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_context" c:identifier="gocl_buffer_get_context">
        <doc xml:space="preserve">Retrieves the #GoclContext the buffer belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclContext object</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gocl_buffer_read">
        <doc xml:space="preserve">Asynchronously reads a block of data of @size bytes from remote context
into host memory, starting at @offset. The operation is enqueued in
@queue, and the program execution continues without blocking. For a
synchronous version of this methid, see gocl_buffer_read_sync().

A #GoclEvent is returned so that the application can get notified when the
operation finishes, by calling gocl_event_then(). Also, the returned event
can be added to the @event_wait_list argument of other operations, to
synchronize their execution with the completion of this operation.

If @event_wait_list is provided, the read operation will start only when
all the #GoclEvent in the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclEvent to get notified when the read
operation finishes</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclQueue where the operation will be enqueued</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </parameter>
          <parameter name="target_ptr" transfer-ownership="none">
            <doc xml:space="preserve">The pointer to copy
the data to</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of the data to be read</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset to start reading from</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
object to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="read_all_sync" c:identifier="gocl_buffer_read_all_sync">
        <doc xml:space="preserve">Reads all the data in buffer from remote context into the host memory
referenced by @target_ptr. The operation is enqueued in @queue, and the
program execution blocks until the read finishes.

If @size is not %NULL, it will store the total size read.

If @event_wait_list is provided, the read operation will
start only when all the #GoclEvent in the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclQueue where the operation will be enqueued</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </parameter>
          <parameter name="target_ptr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The
pointer to copy the data to</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to retrieve the size of the buffer,
or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
object to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="read_sync" c:identifier="gocl_buffer_read_sync">
        <doc xml:space="preserve">Reads a block of data of @size bytes from remote context into host memory,
starting at @offset. The operation is actually enqueued in @queue, and
the program execution blocks until the read finishes. If @event_wait_list
is provided, the read operation will start only when all the #GoclEvent in
the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclQueue where the operation will be enqueued</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </parameter>
          <parameter name="target_ptr" transfer-ownership="none">
            <doc xml:space="preserve">The pointer to copy
the data to</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of the data to be read</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset to start reading from</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
object to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="gocl_buffer_write">
        <doc xml:space="preserve">Asynchronously writes a block of data of @size bytes from host memory into
remote context, starting at @offset. The operation is enqueued in
@queue, and the program execution continues without blocking. For a
synchronous version of this methid, see gocl_buffer_write_sync().

A #GoclEvent is returned so that the application can get notified when the
operation finishes, by calling gocl_event_then(). Also, the returned event
can be added to the @event_wait_list argument of other operations, to
synchronize their execution with the completion of this operation.

If @event_wait_list is provided, the write operation will start only when
all the #GoclEvent in the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclEvent to get notified when the write
operation finishes</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclQueue where the operation will be enqueued</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to write data from</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of the data to be written</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset to start writing data to</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
object to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="write_sync" c:identifier="gocl_buffer_write_sync">
        <doc xml:space="preserve">Writes a block of data of @size bytes from host memory into remote context
memory, starting at @offset. The operation is actually enqueued in @queue, and
the program execution blocks until the read finishes. If @event_wait_list
is provided, the read operation will start only when all the #GoclEvent in
the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclQueue where the operation will be enqueued</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to write data from</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of the data to be written</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset to start writing data to</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
object to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Context"/>
      </property>
      <property name="flags"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="host-ptr"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="size"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="BufferPrivate" c:type="GoclBufferPrivate*"/>
      </field>
    </class>
    <record name="BufferClass"
            c:type="GoclBufferClass"
            glib:is-gtype-struct-for="Buffer">
      <doc xml:space="preserve">The class for #GoclBuffer objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="create_cl_mem" introspectable="0">
        <callback name="create_cl_mem" introspectable="0">
          <return-value>
            <type c:type="cl_int"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Buffer" c:type="GoclBuffer*"/>
            </parameter>
            <parameter name="context" transfer-ownership="none">
              <type c:type="cl_context"/>
            </parameter>
            <parameter name="obj" transfer-ownership="none">
              <type c:type="cl_mem*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="host_ptr" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_all" introspectable="0">
        <callback name="read_all" introspectable="0">
          <return-value>
            <type c:type="cl_int"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Buffer" c:type="GoclBuffer*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type c:type="cl_mem"/>
            </parameter>
            <parameter name="queue" transfer-ownership="none">
              <type c:type="cl_command_queue"/>
            </parameter>
            <parameter name="target_ptr" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
            <parameter name="blocking" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="event_wait_list" transfer-ownership="none">
              <type c:type="cl_event*"/>
            </parameter>
            <parameter name="event_wait_list_len" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="out_event" transfer-ownership="none">
              <type c:type="cl_event*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <bitfield name="BufferFlags" c:type="GoclBufferFlags">
      <member name="read_write"
              value="1"
              c:identifier="GOCL_BUFFER_FLAGS_READ_WRITE">
        <doc xml:space="preserve">The buffer can be read and written by a
                                   kernel. This is the default.</doc>
      </member>
      <member name="write_only"
              value="2"
              c:identifier="GOCL_BUFFER_FLAGS_WRITE_ONLY">
        <doc xml:space="preserve">The buffer can be written but not read
                                   by a kernel. Reading from the buffer
                                   inside a kernel is undefined.</doc>
      </member>
      <member name="read_only"
              value="4"
              c:identifier="GOCL_BUFFER_FLAGS_READ_ONLY">
        <doc xml:space="preserve">The buffer can be read but not written
                                   by a kernel. Writing to the buffer
                                   inside a kernel is undefined.</doc>
      </member>
      <member name="use_host_ptr"
              value="8"
              c:identifier="GOCL_BUFFER_FLAGS_USE_HOST_PTR">
        <doc xml:space="preserve">The buffer is initialized with the data
                                   referenced by the provided host memory
                                   pointer.</doc>
      </member>
      <member name="alloc_host_ptr"
              value="16"
              c:identifier="GOCL_BUFFER_FLAGS_ALLOC_HOST_PTR">
        <doc xml:space="preserve">The buffer is allocated from host
                                   accessible memory.</doc>
      </member>
      <member name="copy_host_ptr"
              value="32"
              c:identifier="GOCL_BUFFER_FLAGS_COPY_HOST_PTR">
        <doc xml:space="preserve">The buffer is allocated from host
                                   accessible memory, and initialized with
                                   the data referenced by the provided host
                                   memory pointer.</doc>
      </member>
    </bitfield>
    <record name="BufferPrivate" c:type="GoclBufferPrivate" disguised="1">
    </record>
    <class name="Context"
           c:symbol-prefix="context"
           c:type="GoclContext"
           parent="GObject.Object"
           glib:type-name="GoclContext"
           glib:get-type="gocl_context_get_type"
           glib:type-struct="ContextClass">
      <implements name="Gio.Initable"/>
      <constructor name="gpu_new_sync"
                   c:identifier="gocl_context_gpu_new_sync">
        <doc xml:space="preserve">Attemps to create a new GPU context. If @gl_context and @gl_display
are provided (not %NULL), then the context will be setup to share
objects with an existing OpenGL context. For this to work, the
&lt;i&gt;cl_khr_gl_sharing&lt;/i&gt; extension should be supported by the OpenCL
GPU implementation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GoclContext object, or %NULL on error</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
        <parameters>
          <parameter name="gl_context"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A GL context, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="gl_display"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A GL display, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync" c:identifier="gocl_context_new_sync">
        <doc xml:space="preserve">Attempts to create a #GoclContext of the type specified in @device_type.
Upon error, %NULL is returned. On success, a new #GoclContext object is
returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclContext</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
        <parameters>
          <parameter name="device_type" transfer-ownership="none">
            <doc xml:space="preserve">A value from #GoclDeviceType</doc>
            <type name="DeviceType" c:type="GoclDeviceType"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_default_cpu_sync"
                c:identifier="gocl_context_get_default_cpu_sync">
        <doc xml:space="preserve">Returns platform's default CPU context. The first call to this method will
attempt to create a new #GoclContext using a device type of
%GOCL_DEVICE_TYPE_CPU. Upon success, the context is cached and subsequent calls
will return the same object, increasing its reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GoclContext object, or %NULL on error</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
      </function>
      <function name="get_default_gpu_sync"
                c:identifier="gocl_context_get_default_gpu_sync">
        <doc xml:space="preserve">Returns platform's default GPU context. The first call to this method will
attempt to create a new #GoclContext using a device type of
%GOCL_DEVICE_TYPE_GPU. Upon success, the context is cached and subsequent
calls will return the same object, increasing its reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GoclContext object, or %NULL on error</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
      </function>
      <method name="get_device_by_index"
              c:identifier="gocl_context_get_device_by_index">
        <doc xml:space="preserve">Retrieves the @device_index-th device from the list of context devices.
Use gocl_context_get_num_devices() to get the number of devices in the
context.

Notice that method creates a new #GoclDevice instance every time is called.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclDevice</doc>
          <type name="Device" c:type="GoclDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext</doc>
            <type name="Context" c:type="GoclContext*"/>
          </instance-parameter>
          <parameter name="device_index" transfer-ownership="none">
            <doc xml:space="preserve">The index of the device to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_devices"
              c:identifier="gocl_context_get_num_devices">
        <doc xml:space="preserve">Obtains the number of devices in this context. Calls to
gocl_context_get_device_by_index() must provide a device index between
0 and the number of devices returned by this method, minus one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of devices</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext</doc>
            <type name="Context" c:type="GoclContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="device-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="gl-context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="gl-display"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ContextPrivate" c:type="GoclContextPrivate*"/>
      </field>
    </class>
    <record name="ContextClass"
            c:type="GoclContextClass"
            glib:is-gtype-struct-for="Context">
      <doc xml:space="preserve">The class for #GoclContext objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ContextPrivate" c:type="GoclContextPrivate" disguised="1">
    </record>
    <class name="Device"
           c:symbol-prefix="device"
           c:type="GoclDevice"
           parent="GObject.Object"
           glib:type-name="GoclDevice"
           glib:get-type="gocl_device_get_type"
           glib:type-struct="DeviceClass">
      <method name="acquire_gl_objects"
              c:identifier="gocl_device_acquire_gl_objects">
        <doc xml:space="preserve">Enqueues an asynchronous request for acquiring the #GoclBuffer (or deriving)
objects contained in @object_list, which were created from OpenGL objects.
For a blocking version of this method, see
gocl_device_acquire_gl_objects_sync().

This method works only if the &lt;i&gt;cl_khr_gl_sharing&lt;/i&gt; OpenCL extension is
supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclEvent to get notified when the operation
finishes</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
          <parameter name="object_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList of
#GoclBuffer objects, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
objects to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="acquire_gl_objects_sync"
              c:identifier="gocl_device_acquire_gl_objects_sync">
        <doc xml:space="preserve">Enqueues a request for acquiring the #GoclBuffer (or deriving) objects
contained in @object_list, which were created from OpenGL objects, blocking
the program execution until the operation finishes.

This method works only if the &lt;i&gt;cl_khr_gl_sharing&lt;/i&gt; OpenCL extension is
supported.

Upon success, %TRUE is returned, otherwise %FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
          <parameter name="object_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList of
#GoclBuffer objects, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
objects to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="gocl_device_get_context">
        <doc xml:space="preserve">Obtains the #GoclContext the device belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclContext. The returned object is owned by
  the device, do not free.</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default_queue"
              c:identifier="gocl_device_get_default_queue">
        <doc xml:space="preserve">Returns a #GoclQueue command queue associated with this device, or %NULL upon
error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclQueue object, which is owned by the device
  and should not be freed.</doc>
          <type name="Queue" c:type="GoclQueue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="gocl_device_get_id">
        <doc xml:space="preserve">Returns the internal #cl_device_id.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The device id</doc>
          <type name="guint64" c:type="cl_device_id"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_compute_units"
              c:identifier="gocl_device_get_max_compute_units">
        <doc xml:space="preserve">Retrieves the number of compute units in an OpenCL device, by querying
CL_DEVICE_MAX_COMPUTE_UNITS in device info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of compute units in the device</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_work_group_size"
              c:identifier="gocl_device_get_max_work_group_size">
        <doc xml:space="preserve">Retrieves the maximum work group size for the device,
by querying the @CL_DEVICE_MAX_WORK_GROUP_SIZE info key through
clGetDeviceInfo().
Upon success a value greater than zero is returned, otherwise zero
is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The maximum size of the work group for this device.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_extension" c:identifier="gocl_device_has_extension">
        <doc xml:space="preserve">Tells whether the device supports a given OpenCL extension, described by
@extension_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device supports the extension, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
          <parameter name="extension_name" transfer-ownership="none">
            <doc xml:space="preserve">The OpenCL extension name, as string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_gl_objects"
              c:identifier="gocl_device_release_gl_objects">
        <doc xml:space="preserve">Enqueues an asynchronous request for releasing the #GoclBuffer (or deriving)
objects contained in @object_list, which were created from OpenGL objects.
For a blocking version of this method, see
gocl_device_release_gl_objects_sync().

This method works only if the &lt;i&gt;cl_khr_gl_sharing&lt;/i&gt; OpenCL extension is
supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclEvent to get notified when the operation
finishes</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
          <parameter name="object_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList of
#GoclBuffer objects, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
objects to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="release_gl_objects_sync"
              c:identifier="gocl_device_release_gl_objects_sync">
        <doc xml:space="preserve">Enqueues a request for releasing the #GoclBuffer (or deriving) objects
contained in @object_list, which were previously acquired by a call to
gocl_device_acquire_gl_objects_sync().

Upon success, %TRUE is returned, otherwise %FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclDevice</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </instance-parameter>
          <parameter name="object_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList of
#GoclBuffer objects, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List or #GoclEvent
objects to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Context"/>
      </property>
      <property name="id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="DevicePrivate" c:type="GoclDevicePrivate*"/>
      </field>
    </class>
    <record name="DeviceClass"
            c:type="GoclDeviceClass"
            glib:is-gtype-struct-for="Device">
      <doc xml:space="preserve">The class for #GoclDevice objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="DevicePrivate" c:type="GoclDevicePrivate" disguised="1">
    </record>
    <bitfield name="DeviceType" c:type="GoclDeviceType">
      <member name="default" value="1" c:identifier="GOCL_DEVICE_TYPE_DEFAULT">
        <doc xml:space="preserve">Default device</doc>
      </member>
      <member name="cpu" value="2" c:identifier="GOCL_DEVICE_TYPE_CPU">
        <doc xml:space="preserve">CPU device</doc>
      </member>
      <member name="gpu" value="4" c:identifier="GOCL_DEVICE_TYPE_GPU">
        <doc xml:space="preserve">GPU device</doc>
      </member>
      <member name="accelerator"
              value="8"
              c:identifier="GOCL_DEVICE_TYPE_ACCELERATOR">
        <doc xml:space="preserve">Accelerator device</doc>
      </member>
      <member name="all"
              value="4294967295"
              c:identifier="GOCL_DEVICE_TYPE_ALL">
        <doc xml:space="preserve">Any device</doc>
      </member>
    </bitfield>
    <class name="Event"
           c:symbol-prefix="event"
           c:type="GoclEvent"
           parent="GObject.Object"
           glib:type-name="GoclEvent"
           glib:get-type="gocl_event_get_type"
           glib:type-struct="EventClass">
      <function name="list_to_array"
                c:identifier="gocl_event_list_to_array"
                introspectable="0">
        <doc xml:space="preserve">A convenient method to retrieve a #GList of #GoclEvent's as an array of
#cl_event's corresponding to the internal objects of each #GoclEvent in
the #GList. This is a rather low-level method and should not normally be
called by applications.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">An array of #cl_event
  objects. Free with g_free().</doc>
          <array length="1" zero-terminated="0" c:type="cl_event*">
            <type c:type="cl_event"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="event_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GList containing
#GoclEvent objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to a value to retrieve list length</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_queue" c:identifier="gocl_event_get_queue">
        <doc xml:space="preserve">Retrieves the #GoclQueue object where the operation that created this
event was queued.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GoclQueue associated with the event</doc>
          <type name="Queue" c:type="GoclQueue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclEvent</doc>
            <type name="Event" c:type="GoclEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="idle_unref" c:identifier="gocl_event_idle_unref">
        <doc xml:space="preserve">Schedules an object de-reference in an idle call.
This is a rather low-level method and should not normally be called by
applications.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclEvent</doc>
            <type name="Event" c:type="GoclEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_event_wait_list"
              c:identifier="gocl_event_set_event_wait_list">
        <doc xml:space="preserve">Stores a copy of the given #GList of #GoclEvent's to take ownership over the
list and guarantee that the events will remain alive until this event is
destroyed.

This is a rather low-level method and should not normally be called by
applications.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclEvent</doc>
            <type name="Event" c:type="GoclEvent*"/>
          </instance-parameter>
          <parameter name="event_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List of #GoclEvent
events that this event should wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="steal_resolver_func"
              c:identifier="gocl_event_steal_resolver_func"
              introspectable="0">
        <doc xml:space="preserve">Steals the internal resolver function from this event and sets it to %NULL,
so that only the first caller is able to resolve this event. This is a rather
low-level method that should not normally be called by applications.

This method is intended to secure the #GoclEvent, to guarantee that the
creator of the event has exclusive control over the triggering of the
event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The internal resolver function</doc>
          <type name="EventResolverFunc" c:type="GoclEventResolverFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclEvent</doc>
            <type name="Event" c:type="GoclEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="then" c:identifier="gocl_event_then">
        <doc xml:space="preserve">Requests for a notification when the operation represented by this event
has finished. When this event triggers, @callback will be called
passing @user_data as argument, if provided.

If the event already triggered when this method is called, the notification
is immediately scheduled as an idle call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclEvent</doc>
            <type name="Event" c:type="GoclEvent*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">A callback with a #GoclEventCallback signature</doc>
            <type name="EventCallback" c:type="GoclEventCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Arbitrary data to pass in @callback, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="event"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="queue"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Queue"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="EventPrivate" c:type="GoclEventPrivate*"/>
      </field>
    </class>
    <callback name="EventCallback" c:type="GoclEventCallback">
      <doc xml:space="preserve">Prototype of the @callback argument of gocl_event_then().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The #GoclEvent</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">A #GError if an error ocurred, %NULL otherwise</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">The arbitrary pointer passed in gocl_event_then(),
or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="EventClass"
            c:type="GoclEventClass"
            glib:is-gtype-struct-for="Event">
      <doc xml:space="preserve">The class for #GoclEvent objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="EventPrivate" c:type="GoclEventPrivate" disguised="1">
    </record>
    <callback name="EventResolverFunc" c:type="GoclEventResolverFunc">
      <doc xml:space="preserve">Prototype of the function that notifies the completion of an event.
This function is not normally called directly by applications. The object
that creates the event is responsible for stealing the resolver function
with gocl_event_steal_resolver_func(), and then resolve the event with
success or error by calling this method, when the related operation
completes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">The #GoclEvent</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">A #GError if an error ocurred, %NULL otherwise</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Image"
           c:symbol-prefix="image"
           c:type="GoclImage"
           parent="Buffer"
           glib:type-name="GoclImage"
           glib:get-type="gocl_image_get_type"
           glib:type-struct="ImageClass">
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="gocl_image_new">
        <doc xml:space="preserve">Creates a new image buffer. Currently only 8-bits unsigned integer format is
supported, with RGBA channels.
Other image properties like row pitch, slice pitch, etc. are assumed to be
zero by now.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclImage, or %NULL on error</doc>
          <type name="Image" c:type="GoclImage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext to create the image in</doc>
            <type name="Context" c:type="GoclContext*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">An OR'ed combination of values from #GoclBufferFlags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="host_ptr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Pointer to host memory, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">Image type value from #GoclImageType</doc>
            <type name="ImageType" c:type="GoclImageType"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">Image width in pixels</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">Image height in pixels, zero if image type is 1D</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">Image depth in pixels, or zero if image is not 3D</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_gl_texture"
                   c:identifier="gocl_image_new_from_gl_texture">
        <doc xml:space="preserve">Creates a new image buffer from a GL texture handle. This only works if the
OpenCL platform supports the &lt;i&gt;cl_khr_gl_sharing&lt;/i&gt; extension, and the
@context has been created for sharing with OpenGL, using
gocl_context_gpu_new_sync().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclImage, or %NULL on error</doc>
          <type name="Image" c:type="GoclImage*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext to create the image in</doc>
            <type name="Context" c:type="GoclContext*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">An OR'ed combination of values from #GoclBufferFlags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">The GL texture handle</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="depth"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="gl-texture"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="height"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="width"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <field name="parent_instance">
        <type name="Buffer" c:type="GoclBuffer"/>
      </field>
      <field name="priv">
        <type name="ImagePrivate" c:type="GoclImagePrivate*"/>
      </field>
    </class>
    <record name="ImageClass"
            c:type="GoclImageClass"
            glib:is-gtype-struct-for="Image">
      <doc xml:space="preserve">The class for #GoclImage objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="BufferClass" c:type="GoclBufferClass"/>
      </field>
    </record>
    <record name="ImagePrivate" c:type="GoclImagePrivate" disguised="1">
    </record>
    <enumeration name="ImageType" c:type="GoclImageType">
      <member name="1d" value="4340" c:identifier="GOCL_IMAGE_TYPE_1D">
        <doc xml:space="preserve">Unidimensional image</doc>
      </member>
      <member name="1d_buffer"
              value="4342"
              c:identifier="GOCL_IMAGE_TYPE_1D_BUFFER">
        <doc xml:space="preserve">Unidimensional buffer image</doc>
      </member>
      <member name="1d_array"
              value="4341"
              c:identifier="GOCL_IMAGE_TYPE_1D_ARRAY">
        <doc xml:space="preserve">Array of unidimensional images</doc>
      </member>
      <member name="2d" value="4337" c:identifier="GOCL_IMAGE_TYPE_2D">
        <doc xml:space="preserve">Bidimensional image</doc>
      </member>
      <member name="2d_array"
              value="4339"
              c:identifier="GOCL_IMAGE_TYPE_2D_ARRAY">
        <doc xml:space="preserve">Array of bidimensional images</doc>
      </member>
      <member name="3d" value="4338" c:identifier="GOCL_IMAGE_TYPE_3D">
        <doc xml:space="preserve">Tridimensional image</doc>
      </member>
    </enumeration>
    <class name="Kernel"
           c:symbol-prefix="kernel"
           c:type="GoclKernel"
           parent="GObject.Object"
           glib:type-name="GoclKernel"
           glib:get-type="gocl_kernel_get_type"
           glib:type-struct="KernelClass">
      <implements name="Gio.Initable"/>
      <method name="run_in_device" c:identifier="gocl_kernel_run_in_device">
        <doc xml:space="preserve">Runs the kernel on the specified device, asynchronously. A #GoclEvent
is returned, and can be used to get notified when the execution finishes,
or as wait event input to other operations on the device.

If @event_wait_list is provided, the kernel execution will start
only when all the events in the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclEvent to get notified when execution
finishes</doc>
          <type name="Event" c:type="GoclEvent*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclDevice to run the kernel on</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List of #GoclEvent
events to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="run_in_device_sync"
              c:identifier="gocl_kernel_run_in_device_sync">
        <doc xml:space="preserve">Runs the kernel on the specified device, blocking the program
until the kernel execution finishes. For non-blocking version,
gocl_kernel_run_in_device() is provided.

If @event_wait_list is provided, the kernel execution will start
only when all the events in the list have triggered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclDevice to run the kernel on</doc>
            <type name="Device" c:type="GoclDevice*"/>
          </parameter>
          <parameter name="event_wait_list"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">List of #GoclEvent
events to wait for, or %NULL</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Event"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument" c:identifier="gocl_kernel_set_argument">
        <doc xml:space="preserve">Sets the value of the kernel argument at @index, as an arbitrary block of
memory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index of this argument in the kernel function</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The size of @buffer, in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to an arbitrary block of memory</doc>
            <type name="gpointer" c:type="const gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_buffer"
              c:identifier="gocl_kernel_set_argument_buffer">
        <doc xml:space="preserve">Sets the value of the kernel argument at @index, as a buffer object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index of this argument in the kernel function</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">A #GoclBuffer</doc>
            <type name="Buffer" c:type="GoclBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_float"
              c:identifier="gocl_kernel_set_argument_float">
        <doc xml:space="preserve">Sets the value of the kernel argument at @index, as an array of floats.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index of this argument in the kernel function</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="num_elements" transfer-ownership="none">
            <doc xml:space="preserve">The number of float elements in @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">Array of float
values</doc>
            <array length="1" zero-terminated="0" c:type="gfloat*">
              <type name="gfloat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_int32"
              c:identifier="gocl_kernel_set_argument_int32">
        <doc xml:space="preserve">Sets the value of the kernel argument at @index, as an array of int32.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The index of this argument in the kernel function</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="num_elements" transfer-ownership="none">
            <doc xml:space="preserve">The number of int32 elements in @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">Array of int32
values</doc>
            <array length="1" zero-terminated="0" c:type="gint32*">
              <type name="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_global_work_size"
              c:identifier="gocl_kernel_set_global_work_size">
        <doc xml:space="preserve">Sets the global work sizes to use when executing the kernel, corresponding
to the first, second, and third dimensions, respectively. By default, the
sizes are all zeros.

If the @size1 value is zero, it means no global work size is specified and
%NULL will be used when enqueuing the kernel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="size1" transfer-ownership="none">
            <doc xml:space="preserve">global work size for the first dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size2" transfer-ownership="none">
            <doc xml:space="preserve">global work size for the second dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size3" transfer-ownership="none">
            <doc xml:space="preserve">global work size for the third dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_work_size"
              c:identifier="gocl_kernel_set_local_work_size">
        <doc xml:space="preserve">Sets the local work sizes to use when executing the kernel, corresponding
to the first, second, and third dimensions, respectively. By default, the
sizes are all zeros.

If the @size1 value is zero, it means no local work size is specified and
%NULL will be used when enqueuing the kernel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="size1" transfer-ownership="none">
            <doc xml:space="preserve">local work size for the first dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size2" transfer-ownership="none">
            <doc xml:space="preserve">local work size for the second dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size3" transfer-ownership="none">
            <doc xml:space="preserve">local work size for the third dimension</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_work_dimension"
              c:identifier="gocl_kernel_set_work_dimension">
        <doc xml:space="preserve">Sets the work dimension (1, 2, 3) to use when executing the kernel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclKernel</doc>
            <type name="Kernel" c:type="GoclKernel*"/>
          </instance-parameter>
          <parameter name="work_dim" transfer-ownership="none">
            <doc xml:space="preserve">The work dimension</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <property name="name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="program"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Program"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="KernelPrivate" c:type="GoclKernelPrivate*"/>
      </field>
    </class>
    <record name="KernelClass"
            c:type="GoclKernelClass"
            glib:is-gtype-struct-for="Kernel">
      <doc xml:space="preserve">The class for #GoclKernel objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="KernelPrivate" c:type="GoclKernelPrivate" disguised="1">
    </record>
    <constant name="OPENCL_ERROR_DOMAIN_STR"
              value="org.gnome.lib.gocl.OpenCL.ErrorDomain"
              c:type="GOCL_OPENCL_ERROR_DOMAIN_STR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Program"
           c:symbol-prefix="program"
           c:type="GoclProgram"
           parent="GObject.Object"
           glib:type-name="GoclProgram"
           glib:get-type="gocl_program_get_type"
           glib:type-struct="ProgramClass">
      <constructor name="new" c:identifier="gocl_program_new">
        <doc xml:space="preserve">Creates and returns a new #GoclProgram. Upon error, %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclProgram</doc>
          <type name="Program" c:type="GoclProgram*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext</doc>
            <type name="Context" c:type="GoclContext*"/>
          </parameter>
          <parameter name="sources" transfer-ownership="none">
            <doc xml:space="preserve">Array of source code
null-terminated strings</doc>
            <array length="2" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="num_sources" transfer-ownership="none">
            <doc xml:space="preserve">The number of elements in @sources</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_sync"
                   c:identifier="gocl_program_new_from_file_sync">
        <doc xml:space="preserve">Creates and returns a new #GoclProgram. This is a convenient constructor for
cases when there is only one file containing the source code. Upon error,
%NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclProgram, or %NULL on error</doc>
          <type name="Program" c:type="GoclProgram*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclContext</doc>
            <type name="Context" c:type="GoclContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">The source code file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="build" c:identifier="gocl_program_build">
        <doc xml:space="preserve">Builds the program using the build options specified in
@options. This method is non-blocking. If @callback is provided, it will
be called when the operation completes, and gocl_program_build_finish()
can be used within the callback to retrieve the result of the operation.

A #GCancellable object can be passed in @cancellable to allow cancelling
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclProgram</doc>
            <type name="Program" c:type="GoclProgram*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">A string specifying OpenCL program build options</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">Callback to be called upon completion, or %NULL</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Arbitrary data to pass in @callback, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_finish"
              c:identifier="gocl_program_build_finish"
              throws="1">
        <doc xml:space="preserve">Retrieves the result of a gocl_program_build() asynchronous operation.
On error, %FALSE is returned and @error is filled accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclProgram</doc>
            <type name="Program" c:type="GoclProgram*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The #GAsyncResult object from callback's arguments</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_sync" c:identifier="gocl_program_build_sync">
        <doc xml:space="preserve">Builds the program using the build options specified in
@options. This method is blocking. For an asynchronous version,
gocl_program_build() is provided. On error, %FALSE is returned.

A detailed description of the build options is available at Kronos
documentation website:
http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclProgram</doc>
            <type name="Program" c:type="GoclProgram*"/>
          </instance-parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">A string specifying OpenCL program build options</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="gocl_program_get_context">
        <doc xml:space="preserve">Obtain the #GoclContext the program belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GoclContext. The returned object is owned by
  the program, do not free.</doc>
          <type name="Context" c:type="GoclContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclProgram</doc>
            <type name="Program" c:type="GoclProgram*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_kernel" c:identifier="gocl_program_get_kernel">
        <doc xml:space="preserve">Creates and retrieves a new #GoclKernel object from a kernel function
in the source code, specified by @kernel_name string. Upon success,
a new #GoclKernel is returned, otherwise %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly created #GoclKernel object</doc>
          <type name="Kernel" c:type="GoclKernel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclProgram</doc>
            <type name="Program" c:type="GoclProgram*"/>
          </instance-parameter>
          <parameter name="kernel_name" transfer-ownership="none">
            <doc xml:space="preserve">A string representing the name of a kernel function</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Context"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ProgramPrivate" c:type="GoclProgramPrivate*"/>
      </field>
    </class>
    <record name="ProgramClass"
            c:type="GoclProgramClass"
            glib:is-gtype-struct-for="Program">
      <doc xml:space="preserve">The class for #GoclProgram objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ProgramPrivate" c:type="GoclProgramPrivate" disguised="1">
    </record>
    <class name="Queue"
           c:symbol-prefix="queue"
           c:type="GoclQueue"
           parent="GObject.Object"
           glib:type-name="GoclQueue"
           glib:get-type="gocl_queue_get_type"
           glib:type-struct="QueueClass">
      <implements name="Gio.Initable"/>
      <method name="get_device" c:identifier="gocl_queue_get_device">
        <doc xml:space="preserve">Retrieves the device associated with this command queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GoclDevice this queue refers to</doc>
          <type name="Device" c:type="GoclDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclQueue</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="gocl_queue_get_flags">
        <doc xml:space="preserve">Retrieves the properties of this command queue, as an OR'ed set of values
from #GoclQueueFlags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The flags (properties) of the command queue</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GoclQueue</doc>
            <type name="Queue" c:type="GoclQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="device"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Device"/>
      </property>
      <property name="flags"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="QueuePrivate" c:type="GoclQueuePrivate*"/>
      </field>
    </class>
    <record name="QueueClass"
            c:type="GoclQueueClass"
            glib:is-gtype-struct-for="Queue">
      <doc xml:space="preserve">The class for #GoclQueue objects.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="QueueFlags" c:type="GoclQueueFlags">
      <member name="out_of_order"
              value="1"
              c:identifier="GOCL_QUEUE_FLAGS_OUT_OF_ORDER">
        <doc xml:space="preserve">Enables out-of-order execution of commands.</doc>
      </member>
      <member name="profiling"
              value="2"
              c:identifier="GOCL_QUEUE_FLAGS_PROFILING">
        <doc xml:space="preserve">Enables profiling of commands.</doc>
      </member>
    </bitfield>
    <record name="QueuePrivate" c:type="GoclQueuePrivate" disguised="1">
    </record>
    <function name="error_get_last" c:identifier="gocl_error_get_last">
      <doc xml:space="preserve">Retrieves the error that ocurred in the last Gocl operation, if any, or
%NULL if the last operation was successful.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A pointer to a newly created error, or %NULL</doc>
        <type name="GLib.Error" c:type="GError*"/>
      </return-value>
    </function>
  </namespace>
</repository>
