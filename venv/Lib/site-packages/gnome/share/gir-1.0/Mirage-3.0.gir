<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <namespace name="Mirage"
             version="3.0"
             shared-library="libmirage.dll"
             c:identifier-prefixes="Mirage"
             c:symbol-prefixes="mirage">
    <class name="CdTextCoder"
           c:symbol-prefix="cdtext_coder"
           c:type="MirageCdTextCoder"
           parent="Object"
           glib:type-name="MirageCdTextCoder"
           glib:get-type="mirage_cdtext_coder_get_type"
           glib:type-struct="CdTextCoderClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageCdTextCoder&lt;/structname&gt;
structure are private to the #MirageCdTextCoder implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CdTextCoderPrivate" c:type="MirageCdTextCoderPrivate*"/>
      </field>
    </class>
    <record name="CdTextCoderClass"
            c:type="MirageCdTextCoderClass"
            glib:is-gtype-struct-for="CdTextCoder">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageCdTextCoder&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="CdTextCoderPrivate"
            c:type="MirageCdTextCoderPrivate"
            disguised="1">
    </record>
    <callback name="CdTextDataCallback" c:type="MirageCdTextDataCallback">
      <doc xml:space="preserve">Specifies the type of callback functions that can be passed to
mirage_cdtext_decoder_get_data().

@code is the language code assigned to the block which data belongs to.
@track is the number of track to which data belongs to, or 0 if data is global
(belongs to session/disc). @data is buffer containing data and @data_len
is the length of data in the buffer.

@data points to buffer that belongs to decoder and therefore should not be freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">language code</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">pack type</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="track" transfer-ownership="none">
          <doc xml:space="preserve">track number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">data</doc>
          <array length="4" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="data_len" transfer-ownership="none">
          <doc xml:space="preserve">data length</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Context"
           c:symbol-prefix="context"
           c:type="MirageContext"
           parent="GObject.Object"
           glib:type-name="MirageContext"
           glib:get-type="mirage_context_get_type"
           glib:type-struct="ContextClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageContext&lt;/structname&gt;
structure are private to the #MirageContext implementation and
should never be accessed directly.</doc>
      <method name="clear_options" c:identifier="mirage_context_clear_options">
        <doc xml:space="preserve">Clears all the options from the context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_input_stream"
              c:identifier="mirage_context_create_input_stream"
              throws="1">
        <doc xml:space="preserve">Opens a file pointed to by @filename and creates a chain of filter
streams on top of it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">on success, an object implementing #MirageStream
interface is returned, which can be used to access data stored in file.
On failure, %NULL is returned. The reference to the object should be
released using g_object_unref() when no longer needed.</doc>
          <type name="Stream" c:type="MirageStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to create input stream on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_output_stream"
              c:identifier="mirage_context_create_output_stream"
              throws="1">
        <doc xml:space="preserve">Opens a file pointed to by @filename and optionally creates a chain
of filter streams on top of it.

The chain of filters is described by @filter-chain, which is a
NULL-terminated array of strings corresponding to type names of
filters, with the last filter being the one on the top. Filters are
passed by their name types because their actual type values are
determined when the plugins are loaded. If invalid filter is specified
in the chain, this function will fail. It is the caller's responsibility
to construct a valid filter chain.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">on success, an object implementing #MirageStream
interface is returned, which can be used to write data to file.
On failure, %NULL is returned. The reference to the object should be
released using g_object_unref() when no longer needed.</doc>
          <type name="Stream" c:type="MirageStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to create output stream on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="filter_chain"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">NULL-terminated array of strings describing types of filters to include in the filter chain, or %NULL</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_debug_domain"
              c:identifier="mirage_context_get_debug_domain">
        <doc xml:space="preserve">Retrieves debug context's domain name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to buffer containing the domain name, or %NULL. The buffer belongs to the object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_debug_mask"
              c:identifier="mirage_context_get_debug_mask">
        <doc xml:space="preserve">Retrieves debug context's debug mask.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">debug context's debug mask</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_debug_name"
              c:identifier="mirage_context_get_debug_name">
        <doc xml:space="preserve">Retrieves debug context's name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to buffer containing the name, or %NULL. The buffer belongs to the object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_option" c:identifier="mirage_context_get_option">
        <doc xml:space="preserve">Retrieves option named @name from the context.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">pointer to a #GVariant containing the option
value on success, %NULL on failure.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">option name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_image"
              c:identifier="mirage_context_load_image"
              throws="1">
        <doc xml:space="preserve">Creates a #MirageDisc object representing image stored in @filenames. @filenames
is a NULL-terminated list of filenames containing image data. The function tries
to find a parser that can handle give filename(s) and uses it to load the data
into disc object.

If multiple filenames are provided and parser supports only single-file images,
only the first filename is used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageDisc object on success, %NULL on failure. The reference to
the object should be released using g_object_unref() when no longer needed.</doc>
          <type name="Disc" c:type="MirageDisc*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="filenames" transfer-ownership="none">
            <doc xml:space="preserve">filename(s)</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="obtain_password"
              c:identifier="mirage_context_obtain_password"
              throws="1">
        <doc xml:space="preserve">Obtains password string, using the #MiragePasswordFunction callback
that was provided via mirage_context_set_password_function().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">password string on success, %NULL on failure. The string should be
freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_debug_domain"
              c:identifier="mirage_context_set_debug_domain">
        <doc xml:space="preserve">Sets debug context's domain name to @domain.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">domain name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_debug_mask"
              c:identifier="mirage_context_set_debug_mask">
        <doc xml:space="preserve">Sets debug context's debug mask.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="debug_mask" transfer-ownership="none">
            <doc xml:space="preserve">debug mask</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_debug_name"
              c:identifier="mirage_context_set_debug_name">
        <doc xml:space="preserve">Sets debug context's name to @name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_option" c:identifier="mirage_context_set_option">
        <doc xml:space="preserve">Sets an option to the context. If option with the specified name already
exists, it is replaced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">option name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:space="preserve">option value</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password_function"
              c:identifier="mirage_context_set_password_function">
        <doc xml:space="preserve">Sets the password function to context. The function is used by parsers
that support encrypted images to obtain password for unlocking such images.

Both @func and @user_data can be %NULL; in that case the appropriate setting
will be reset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContext</doc>
            <type name="Context" c:type="MirageContext*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">a password function pointer</doc>
            <type name="PasswordFunction" c:type="MiragePasswordFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">pointer to user data to be passed to the password function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">destroy notify for @user_data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContextPrivate" c:type="MirageContextPrivate*"/>
      </field>
    </class>
    <record name="ContextClass"
            c:type="MirageContextClass"
            glib:is-gtype-struct-for="Context">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageContext&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ContextPrivate" c:type="MirageContextPrivate" disguised="1">
    </record>
    <interface name="Contextual"
               c:symbol-prefix="contextual"
               c:type="MirageContextual"
               glib:type-name="MirageContextual"
               glib:get-type="mirage_contextual_get_type"
               glib:type-struct="ContextualInterface">
      <doc xml:space="preserve">An object that can be attached a #MirageContext.</doc>
      <virtual-method name="get_context" invoker="get_context">
        <doc xml:space="preserve">Retrieves the attached context.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">attached context (a #MirageContext), or %NULL.
The reference to context is incremented, and should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Context" c:type="MirageContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_context" invoker="set_context">
        <doc xml:space="preserve">Sets/attaches a context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="full">
            <doc xml:space="preserve">debug context (a #MirageContext)</doc>
            <type name="Context" c:type="MirageContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_input_stream"
              c:identifier="mirage_contextual_create_input_stream"
              throws="1">
        <doc xml:space="preserve">Opens a file pointed to by @filename and creates a chain of filter
streams on top of it.

&lt;note&gt;
This is a convenience function that retrieves a #MirageContext from
@self and calls mirage_context_create_input_stream().
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">on success, an object implementing #MirageStream
interface is returned, which can be used to access data stored in file.
On failure, %NULL is returned. The reference to the object should be
released using g_object_unref() when no longer needed.</doc>
          <type name="Stream" c:type="MirageStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to create input stream on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_output_stream"
              c:identifier="mirage_contextual_create_output_stream"
              throws="1">
        <doc xml:space="preserve">Opens a file pointed to by @filename and creates a chain of filter
streams on top of it.

&lt;note&gt;
This is a convenience function that retrieves a #MirageContext from
@self and calls mirage_context_create_output_stream().
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">on success, an object implementing #MirageStream
interface is returned, which can be used to write data to file.
On failure, %NULL is returned. The reference to the object should be
released using g_object_unref() when no longer needed.</doc>
          <type name="Stream" c:type="MirageStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename to create output stream on</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="filter_chain"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">NULL-terminated array of strings describing types of filters to include in the filter chain, or %NULL</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="debug_is_active"
              c:identifier="mirage_contextual_debug_is_active">
        <doc xml:space="preserve">Checks whether debug messages at debug level @level are currently
active or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a boolean indicating whether debug messages at debug level
@level are currently active or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">debug level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="debug_message"
              c:identifier="mirage_contextual_debug_message"
              introspectable="0">
        <doc xml:space="preserve">Outputs debug message with verbosity level @level, format string @format and
format arguments @Varargs. The message is displayed if debug context has mask
that covers @level, or if @level is either %MIRAGE_DEBUG_WARNING or
%MIRAGE_DEBUG_ERROR.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">debug level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">message format. See the printf() documentation.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">parameters to insert into the format string.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="debug_messagev"
              c:identifier="mirage_contextual_debug_messagev"
              introspectable="0">
        <doc xml:space="preserve">Outputs debug message with verbosity level @level, format string @format and
format arguments @args. The message is displayed if debug context has mask
that covers @level, or if @level is either %MIRAGE_DEBUG_WARNING or
%MIRAGE_DEBUG_ERROR.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">debug level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">message format. See the printf() documentation.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">parameters to insert into the format string.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="debug_print_buffer"
              c:identifier="mirage_contextual_debug_print_buffer">
        <doc xml:space="preserve">Prints contents of @buffer as a sequence of @buffer_length two-digit
hexadecimal numbers, arranged in lines of @width numbers. Each line
is optionally prefixed by @prefix. If specified debug @level is not
active (masked by context), this function does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">debug level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="prefix"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">prefix, or none</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">output width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to print</doc>
            <array length="4" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="buffer_length" transfer-ownership="none">
            <doc xml:space="preserve">buffer length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="mirage_contextual_get_context">
        <doc xml:space="preserve">Retrieves the attached context.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">attached context (a #MirageContext), or %NULL.
The reference to context is incremented, and should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Context" c:type="MirageContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_option" c:identifier="mirage_contextual_get_option">
        <doc xml:space="preserve">Retrieves option named @name from the context.

&lt;note&gt;
This is a convenience function that retrieves a #MirageContext from
@self and calls mirage_context_get_option().
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariant containing the option value on
success, %NULL on failure.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">option name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="obtain_password"
              c:identifier="mirage_contextual_obtain_password"
              throws="1">
        <doc xml:space="preserve">Obtains password string, using the #MiragePasswordFunction callback
that was provided via mirage_context_set_password_function().

&lt;note&gt;
This is a convenience function that retrieves a #MirageContext from
@self and calls mirage_context_obtain_password().
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">password string on success, %NULL on failure. The string should be
freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_context" c:identifier="mirage_contextual_set_context">
        <doc xml:space="preserve">Sets/attaches a context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageContextual</doc>
            <type name="Contextual" c:type="MirageContextual*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="full">
            <doc xml:space="preserve">debug context (a #MirageContext)</doc>
            <type name="Context" c:type="MirageContext*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ContextualInterface"
            c:type="MirageContextualInterface"
            glib:is-gtype-struct-for="Contextual">
      <doc xml:space="preserve">Provides an interface for implementing objects that can be attached a
#MirageContext.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="set_context">
        <callback name="set_context">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageContextual</doc>
              <type name="Contextual" c:type="MirageContextual*"/>
            </parameter>
            <parameter name="context" transfer-ownership="full">
              <doc xml:space="preserve">debug context (a #MirageContext)</doc>
              <type name="Context" c:type="MirageContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_context">
        <callback name="get_context">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">attached context (a #MirageContext), or %NULL.
The reference to context is incremented, and should be released using g_object_unref()
when no longer needed.</doc>
            <type name="Context" c:type="MirageContext*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageContextual</doc>
              <type name="Contextual" c:type="MirageContextual*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="DebugMask" c:type="MirageDebugMask">
      <doc xml:space="preserve">Debug message types and debug masks used to control verbosity of various
parts of libMirage.

All masks except %MIRAGE_DEBUG_ERROR and %MIRAGE_DEBUG_WARNING can be combined
together to control verbosity of libMirage.</doc>
      <member name="error" value="-1" c:identifier="MIRAGE_DEBUG_ERROR">
        <doc xml:space="preserve">error message</doc>
      </member>
      <member name="warning" value="-2" c:identifier="MIRAGE_DEBUG_WARNING">
        <doc xml:space="preserve">warning message</doc>
      </member>
      <member name="parser" value="1" c:identifier="MIRAGE_DEBUG_PARSER">
        <doc xml:space="preserve">message belonging to image parser and file stream parser</doc>
      </member>
      <member name="disc" value="2" c:identifier="MIRAGE_DEBUG_DISC">
        <doc xml:space="preserve">message belonging to disc</doc>
      </member>
      <member name="session" value="4" c:identifier="MIRAGE_DEBUG_SESSION">
        <doc xml:space="preserve">message belonging to session</doc>
      </member>
      <member name="track" value="8" c:identifier="MIRAGE_DEBUG_TRACK">
        <doc xml:space="preserve">message belonging to track</doc>
      </member>
      <member name="sector" value="16" c:identifier="MIRAGE_DEBUG_SECTOR">
        <doc xml:space="preserve">message belonging to sector</doc>
      </member>
      <member name="fragment" value="32" c:identifier="MIRAGE_DEBUG_FRAGMENT">
        <doc xml:space="preserve">message belonging to fragment</doc>
      </member>
      <member name="cdtext" value="64" c:identifier="MIRAGE_DEBUG_CDTEXT">
        <doc xml:space="preserve">message belonging to CD-TEXT encoder/decoder</doc>
      </member>
      <member name="stream" value="128" c:identifier="MIRAGE_DEBUG_STREAM">
        <doc xml:space="preserve">messages belonging to file and filter stream I/O operations</doc>
      </member>
      <member name="image_id" value="256" c:identifier="MIRAGE_DEBUG_IMAGE_ID">
        <doc xml:space="preserve">messages belonging to image identification part of image parsers</doc>
      </member>
      <member name="writer" value="512" c:identifier="MIRAGE_DEBUG_WRITER">
        <doc xml:space="preserve">messages belonging to image writer</doc>
      </member>
    </enumeration>
    <record name="DebugMaskInfo" c:type="MirageDebugMaskInfo">
      <doc xml:space="preserve">Structure containing debug mask information.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">name</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">value</doc>
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <class name="Disc"
           c:symbol-prefix="disc"
           c:type="MirageDisc"
           parent="Object"
           glib:type-name="MirageDisc"
           glib:get-type="mirage_disc_get_type"
           glib:type-struct="DiscClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageDisc&lt;/structname&gt;
structure are private to the #MirageDisc implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="add_session_by_index"
              c:identifier="mirage_disc_add_session_by_index">
        <doc xml:space="preserve">Adds session to disc layout.

@index is the index at which session is added. Negative index denotes
index going backwards (i.e. -1 adds session at the end, -2 adds session
second-to-last, etc.). If index, either negative or positive, is too big,
session is added at the beginning or at the end of the layout, respectively.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index at which session should be added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="session" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageSession to be added</doc>
            <type name="Session" c:type="MirageSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_session_by_number"
              c:identifier="mirage_disc_add_session_by_number"
              throws="1">
        <doc xml:space="preserve">Adds session to disc layout.

@number is session number that should be assigned to added session. It determines
session's position in the layout. If session with that number already exists in
the layout, the function fails.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">session number for the added session</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="session" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageSession to be added</doc>
            <type name="Session" c:type="MirageSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_track_by_index"
              c:identifier="mirage_disc_add_track_by_index"
              throws="1">
        <doc xml:space="preserve">Adds track to disc layout.

@index is the index at which track is added. The function attempts to find
appropriate session by iterating over sessions list and verifying index ranges,
then adds the track using mirage_session_add_track_by_index(). Negative
@index denotes index going backwards (i.e. -1 adds track at the end of last
session, etc.). If @index, either negative or positive, is too big, track is
respectively added  at the beginning of the first or at the end of the last
session in the layout.

If disc layout is empty (i.e. contains no sessions), then session is created.

The rest of behavior is same as of mirage_session_add_track_by_index().

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index at which track should be added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="track" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageTrack to be added</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_track_by_number"
              c:identifier="mirage_disc_add_track_by_number"
              throws="1">
        <doc xml:space="preserve">Adds track to disc layout.

@number is track number that should be assigned to added track. It determines
track's position in the layout. The function attempts to find appropriate session
using mirage_disc_get_session_by_track(), then adds the track using
mirage_session_add_track_by_number().

If disc layout is empty (i.e. contains no sessions), then session is created.
If @number is greater than last track's number, the track is added at the end
of last session.

The rest of behavior is same as of mirage_session_add_track_by_number().

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">track number for the added track</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="track" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageTrack to be added</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_sessions"
              c:identifier="mirage_disc_enumerate_sessions">
        <doc xml:space="preserve">Iterates over sessions list, calling @func for each session in the layout.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumSessionCallback"
                  c:type="MirageEnumSessionCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_disc_structure"
              c:identifier="mirage_disc_get_disc_structure"
              throws="1">
        <doc xml:space="preserve">Retrieves disc structure of type @type from layer @layer. The pointer to buffer
containing the disc structure is stored in @data; the buffer belongs to the
object and therefore should not be modified.

&lt;note&gt;
Disc structures are valid only for DVD and BD discs; therefore, if disc type
is not set to %MIRAGE_MEDIUM_DVD or %MIRAGE_MEDIUM_BD prior to calling this
function, the function will fail.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">disc layer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">disc structure type</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store buffer containing disc structure data, or %NULL</doc>
            <array length="3" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store data length, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dpm_data" c:identifier="mirage_disc_get_dpm_data">
        <doc xml:space="preserve">Retrieves DPM data for disc. The pointer to buffer containing DPM data entries
is stored in @data; the buffer belongs to object and therefore should not be
modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store DPM start sector, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="resolution"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store DPM data resolution, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="num_entries"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store number of DPM entries, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing DPM data, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint32**">
              <type name="guint32" c:type="guint32*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_dpm_data_for_sector"
              c:identifier="mirage_disc_get_dpm_data_for_sector"
              throws="1">
        <doc xml:space="preserve">Retrieves DPM data for sector at address @address. Two pieces of data can be
retrieved; first one is sector angle, expressed in rotations (i.e. 0.25 would
mean 1/4 of rotation or 90˚ and 1.0 means one full rotation or 360˚), and the
other one is sector density at given address, expressed in degrees per sector).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address of sector to retrieve DPM data for</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="angle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store sector angle, or %NULL</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="density"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store sector density, or %NULL</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filenames" c:identifier="mirage_disc_get_filenames">
        <doc xml:space="preserve">Retrieves image filename(s).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to %NULL-terminated
array of filenames. The array belongs to the object and should not be modified.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_medium_type"
              c:identifier="mirage_disc_get_medium_type">
        <doc xml:space="preserve">Retrieves medium type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">medium type</doc>
          <type name="MediumType" c:type="MirageMediumType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_sessions"
              c:identifier="mirage_disc_get_number_of_sessions">
        <doc xml:space="preserve">Retrieves number of sessions in the disc layout.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of sessions</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_tracks"
              c:identifier="mirage_disc_get_number_of_tracks">
        <doc xml:space="preserve">Retrieves number of tracks in the disc layout.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of tracks</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sector"
              c:identifier="mirage_disc_get_sector"
              throws="1">
        <doc xml:space="preserve">Retrieves sector object representing sector at sector address @address.

This function attempts to retrieve appropriate track using
mirage_disc_get_track_by_address(),
then retrieves sector object using mirage_track_get_sector().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">sector object on success, %NULL on failure</doc>
          <type name="Sector" c:type="MirageSector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">sector address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_after"
              c:identifier="mirage_disc_get_session_after"
              throws="1">
        <doc xml:space="preserve">Retrieves session that comes after @session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a session</doc>
            <type name="Session" c:type="MirageSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_before"
              c:identifier="mirage_disc_get_session_before"
              throws="1">
        <doc xml:space="preserve">Retrieves session that comes before @session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a session</doc>
            <type name="Session" c:type="MirageSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_by_address"
              c:identifier="mirage_disc_get_session_by_address"
              throws="1">
        <doc xml:space="preserve">Retrieves session by address. @address must be valid (disc-relative) sector
address that is part of the session to be retrieved (i.e. lying between session's
start and end sector).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address belonging to session to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_by_index"
              c:identifier="mirage_disc_get_session_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves session by index. If @index is negative, sessions from the end of
layout are retrieved (e.g. -1 is for last session, -2 for second-to-last
session, etc.). If @index is out of range, regardless of the sign, the
function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of session to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_by_number"
              c:identifier="mirage_disc_get_session_by_number"
              throws="1">
        <doc xml:space="preserve">Retrieves session by session number.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">number of session to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_by_track"
              c:identifier="mirage_disc_get_session_by_track"
              throws="1">
        <doc xml:space="preserve">Retrieves session by track number. @track must be valid track number of track
that is part of the session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">number of track belonging to session to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_address"
              c:identifier="mirage_disc_get_track_by_address"
              throws="1">
        <doc xml:space="preserve">Retrieves track by address. @address must be valid (disc-relative) sector
address that is part of the track to be retrieved (i.e. lying between track's
start and end sector).

The function attempts to find appropriate session using
mirage_disc_get_session_by_address(), then retrieves the track using
mirage_session_get_track_by_address().

The rest of behavior is same as of mirage_session_get_track_by_address().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address belonging to track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_index"
              c:identifier="mirage_disc_get_track_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves track by index. The function attempts to find appropriate session
by iterating over sessions list and verifying index ranges, then retrieves
the track using mirage_session_get_track_by_index(). If @index is negative,
tracks from the end of layout are retrieved (e.g. -1 is for last track, -2
for second-to-last track, etc.). If @index is out of range, regardless of
the sign, the function fails.

The rest of behavior is same as of mirage_session_get_track_by_index().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_number"
              c:identifier="mirage_disc_get_track_by_number"
              throws="1">
        <doc xml:space="preserve">Retrieves track by track number. The function attempts to find appropriate session
using mirage_disc_get_session_by_track(), then retrieves the track using
mirage_session_get_track_by_number().

The rest of behavior is same as of mirage_session_get_track_by_number().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">track number of track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_contains_address"
              c:identifier="mirage_disc_layout_contains_address">
        <doc xml:space="preserve">Checks whether the disc contains the given address or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address falls inside disc, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address to be checked</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_get_first_session"
              c:identifier="mirage_disc_layout_get_first_session">
        <doc xml:space="preserve">Retrieves session number of the first session in the disc layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">first session number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_first_track"
              c:identifier="mirage_disc_layout_get_first_track">
        <doc xml:space="preserve">Retrieves track number of the first track in the disc layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">first track number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_length"
              c:identifier="mirage_disc_layout_get_length">
        <doc xml:space="preserve">Retrieves length of the disc layout. The returned length is given in sectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">disc layout length</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_start_sector"
              c:identifier="mirage_disc_layout_get_start_sector">
        <doc xml:space="preserve">Retrieves start sector of the disc layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">start sector</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_set_first_session"
              c:identifier="mirage_disc_layout_set_first_session">
        <doc xml:space="preserve">Sets first session number to @first_session. This is a number that is
assigned to the first session in the disc layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="first_session" transfer-ownership="none">
            <doc xml:space="preserve">first session number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_set_first_track"
              c:identifier="mirage_disc_layout_set_first_track">
        <doc xml:space="preserve">Sets first track number to @first_track. This is a number that is
assigned to the first track in the disc layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="first_track" transfer-ownership="none">
            <doc xml:space="preserve">first track number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_set_start_sector"
              c:identifier="mirage_disc_layout_set_start_sector">
        <doc xml:space="preserve">Sets start sector of the disc layout to @start_sector. This is a sector at which
the first session (and consequently first track) in the disc layout will start.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="start_sector" transfer-ownership="none">
            <doc xml:space="preserve">start sector</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_sector"
              c:identifier="mirage_disc_put_sector"
              throws="1">
        <doc xml:space="preserve">Writes the @sector to disc.

This function attempts to retrieve appropriate track using
mirage_disc_get_track_by_address(),
then writes sector object using mirage_track_put_sector(); therefore,
same restrictions regarding sector address apply as when putting sector
directly to track.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="sector" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector representing sector to be written</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_session_by_index"
              c:identifier="mirage_disc_remove_session_by_index"
              throws="1">
        <doc xml:space="preserve">Removes session from disc layout.

@index is the index of the session to be removed. This function calls
mirage_disc_get_session_by_index() so @index behavior is determined by that
function.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of session to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_session_by_number"
              c:identifier="mirage_disc_remove_session_by_number"
              throws="1">
        <doc xml:space="preserve">Removes session from disc layout.

@number is session number of the session to be removed.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">session number of session to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_session_by_object"
              c:identifier="mirage_disc_remove_session_by_object">
        <doc xml:space="preserve">Removes session from disc layout.

@session is a #MirageSession object to be removed.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">session object to be removed</doc>
            <type name="Session" c:type="MirageSession*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_track_by_index"
              c:identifier="mirage_disc_remove_track_by_index"
              throws="1">
        <doc xml:space="preserve">Removes track from disc layout.

@index is the index of the track to be removed. This function calls
mirage_disc_get_track_by_index() so @index behavior is determined by that
function.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of track to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_track_by_number"
              c:identifier="mirage_disc_remove_track_by_number"
              throws="1">
        <doc xml:space="preserve">Removes track from disc layout.

@number is track number of the track to be removed. This function calls
mirage_disc_get_track_by_number() so @number behavior is determined by that
function.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">track number of track to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_disc_structure"
              c:identifier="mirage_disc_set_disc_structure">
        <doc xml:space="preserve">Sets disc structure of type @type to layer @layer to disc. @data is buffer
containing disc structure data and @len is data length.

&lt;note&gt;
Disc structures are valid only for DVD and BD discs. This function
silently fails on invalid disc types.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">disc layer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">disc structure type</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">disc structure data to be set</doc>
            <array length="3" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of disc structure data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dpm_data" c:identifier="mirage_disc_set_dpm_data">
        <doc xml:space="preserve">Sets the DPM data for disc. If @num_entries is not positive, DPM data is reset.
@start is the address at which DPM data begins, @resolution is resolution of
DPM data and @num_entries is the number of DPM entries in buffer pointed to by
@data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">DPM start sector</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="resolution" transfer-ownership="none">
            <doc xml:space="preserve">DPM data resolution</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="num_entries" transfer-ownership="none">
            <doc xml:space="preserve">number of DPM entries</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing DPM data</doc>
            <array length="2" zero-terminated="0" c:type="guint32*">
              <type name="guint32" c:type="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_filename" c:identifier="mirage_disc_set_filename">
        <doc xml:space="preserve">Sets image filename. The functionality is similar to mirage_disc_set_filenames(),
except that only one filename is set. It is intended to be used in parsers which
support only single-file images.

&lt;note&gt;
Intended for internal use only, in image parser implementations.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filenames" c:identifier="mirage_disc_set_filenames">
        <doc xml:space="preserve">Sets image filename(s).

&lt;note&gt;
Intended for internal use only, in image parser implementations.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="filenames" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of filenames</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_medium_type"
              c:identifier="mirage_disc_set_medium_type">
        <doc xml:space="preserve">Sets medium type. @medium_type must be one of #MirageMediumType.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageDisc</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </instance-parameter>
          <parameter name="medium_type" transfer-ownership="none">
            <doc xml:space="preserve">medium type</doc>
            <type name="MediumType" c:type="MirageMediumType"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DiscPrivate" c:type="MirageDiscPrivate*"/>
      </field>
      <glib:signal name="layout-changed" when="last">
        <doc xml:space="preserve">Emitted when a layout of #MirageDisc changed in a way that causes a bottom-up change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="DiscClass"
            c:type="MirageDiscClass"
            glib:is-gtype-struct-for="Disc">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageDisc&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="DiscPrivate" c:type="MirageDiscPrivate" disguised="1">
    </record>
    <record name="DiscStructureCopyright"
            c:type="MirageDiscStructureCopyright">
      <field name="copy_protection" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="region_info" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="__dummy1__" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="__dummy2__" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <record name="DiscStructureManufacturingData"
            c:type="MirageDiscStructureManufacturingData">
      <field name="disc_manufacturing_data" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="2048">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
    </record>
    <record name="DiscStructurePhysicalInfo"
            c:type="MirageDiscStructurePhysicalInfo">
      <field name="part_ver" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="book_type" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="max_rate" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="disc_size" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="layer_type" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="track_path" writable="1" bits="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="num_layers" writable="1" bits="2">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="__dummy1__" writable="1" bits="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="track_density" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="linear_density" writable="1" bits="4">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="data_start" writable="1" bits="24">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="__dummy2__" writable="1" bits="8">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="data_end" writable="1" bits="24">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="__dummy3__" writable="1" bits="8">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="layer0_end" writable="1" bits="24">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="__dummy4__" writable="1" bits="8">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="__dummy5__" writable="1" bits="7">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="bca" writable="1" bits="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="media_specific" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="2031">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
    </record>
    <callback name="EnumFilterStreamInfoCallback"
              c:type="MirageEnumFilterStreamInfoCallback">
      <doc xml:space="preserve">Callback function type used with mirage_enumerate_filter_streams().
A pointer to filter stream information structure is stored in @info; the
structure belongs to the filter stream object and should not be modified.
@user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">filter stream info</doc>
          <type name="FilterStreamInfo"
                c:type="const MirageFilterStreamInfo*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumFragmentCallback" c:type="MirageEnumFragmentCallback">
      <doc xml:space="preserve">Callback function type used with mirage_track_enumerate_fragments().
A pointer to a fragment object is stored in @fragment, without incrementing
its reference counter. @user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fragment" transfer-ownership="none">
          <doc xml:space="preserve">fragment</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumIndexCallback" c:type="MirageEnumIndexCallback">
      <doc xml:space="preserve">Callback function type used with mirage_track_enumerate_indices().
A pointer to an index object is stored in @index, without incrementing
its reference counter. @user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="index" transfer-ownership="none">
          <doc xml:space="preserve">index</doc>
          <type name="Index" c:type="MirageIndex*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumLanguageCallback" c:type="MirageEnumLanguageCallback">
      <doc xml:space="preserve">Callback function type used with mirage_session_enumerate_languages() and
mirage_track_enumerate_languages(). A pointer to a language object is
stored in @language, without incrementing its reference counter.
@user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="language" transfer-ownership="none">
          <doc xml:space="preserve">language</doc>
          <type name="Language" c:type="MirageLanguage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumParserInfoCallback"
              c:type="MirageEnumParserInfoCallback">
      <doc xml:space="preserve">Callback function type used with mirage_enumerate_parsers().
A pointer to parser information structure is stored in @info; the
structure belongs to the parser object and should not be modified.
@user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">parser info</doc>
          <type name="ParserInfo" c:type="const MirageParserInfo*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumSessionCallback" c:type="MirageEnumSessionCallback">
      <doc xml:space="preserve">Callback function type used with mirage_disc_enumerate_sessions().
A pointer to a session object is stored in @session, without incrementing
its reference counter. @user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">session</doc>
          <type name="Session" c:type="MirageSession*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumTrackCallback" c:type="MirageEnumTrackCallback">
      <doc xml:space="preserve">Callback function type used with mirage_session_enumerate_tracks().
A pointer to a track object is stored in @track, without incrementing
its reference counter. @user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="track" transfer-ownership="none">
          <doc xml:space="preserve">track</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EnumWriterInfoCallback"
              c:type="MirageEnumWriterInfoCallback">
      <doc xml:space="preserve">Callback function type used with mirage_enumerate_writers().
A pointer to writer information structure is stored in @info; the
structure belongs to the writer object and should not be modified.
@user_data is user data passed to enumeration function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">writer info</doc>
          <type name="WriterInfo" c:type="const MirageWriterInfo*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to enumeration function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Error"
                 glib:type-name="MirageError"
                 glib:get-type="mirage_error_get_type"
                 c:type="MirageError"
                 glib:error-domain="mirage-error">
      <member name="LibraryError"
              value="0"
              c:identifier="MIRAGE_ERROR_LIBRARY_ERROR"
              glib:nick="LibraryError">
      </member>
      <member name="ParserError"
              value="1"
              c:identifier="MIRAGE_ERROR_PARSER_ERROR"
              glib:nick="ParserError">
      </member>
      <member name="FragmentError"
              value="2"
              c:identifier="MIRAGE_ERROR_FRAGMENT_ERROR"
              glib:nick="FragmentError">
      </member>
      <member name="DiscError"
              value="3"
              c:identifier="MIRAGE_ERROR_DISC_ERROR"
              glib:nick="DiscError">
      </member>
      <member name="LanguageError"
              value="4"
              c:identifier="MIRAGE_ERROR_LANGUAGE_ERROR"
              glib:nick="LanguageError">
      </member>
      <member name="SectorError"
              value="5"
              c:identifier="MIRAGE_ERROR_SECTOR_ERROR"
              glib:nick="SectorError">
      </member>
      <member name="SessionError"
              value="6"
              c:identifier="MIRAGE_ERROR_SESSION_ERROR"
              glib:nick="SessionError">
      </member>
      <member name="TrackError"
              value="7"
              c:identifier="MIRAGE_ERROR_TRACK_ERROR"
              glib:nick="TrackError">
      </member>
      <member name="StreamError"
              value="8"
              c:identifier="MIRAGE_ERROR_STREAM_ERROR"
              glib:nick="StreamError">
      </member>
      <member name="ImageFileError"
              value="9"
              c:identifier="MIRAGE_ERROR_IMAGE_FILE_ERROR"
              glib:nick="ImageFileError">
      </member>
      <member name="DataFileError"
              value="10"
              c:identifier="MIRAGE_ERROR_DATA_FILE_ERROR"
              glib:nick="DataFileError">
      </member>
      <member name="CannotHandle"
              value="11"
              c:identifier="MIRAGE_ERROR_CANNOT_HANDLE"
              glib:nick="CannotHandle">
      </member>
      <member name="EncryptedImage"
              value="12"
              c:identifier="MIRAGE_ERROR_ENCRYPTED_IMAGE"
              glib:nick="EncryptedImage">
      </member>
      <member name="WriterError"
              value="13"
              c:identifier="MIRAGE_ERROR_WRITER_ERROR"
              glib:nick="WriterError">
      </member>
      <function name="quark" c:identifier="mirage_error_quark">
        <doc xml:space="preserve">Registers an error quark for libMirage if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The error quark used for libMirage errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="ErrorCode" c:type="MirageErrorCode">
      <doc xml:space="preserve">Error codes for libMirage library.</doc>
      <member name="library_error"
              value="0"
              c:identifier="MIRAGE_ERROR_LIBRARY_ERROR">
        <doc xml:space="preserve">error in core libMirage code</doc>
      </member>
      <member name="parser_error"
              value="1"
              c:identifier="MIRAGE_ERROR_PARSER_ERROR">
        <doc xml:space="preserve">error in parser code</doc>
      </member>
      <member name="fragment_error"
              value="2"
              c:identifier="MIRAGE_ERROR_FRAGMENT_ERROR">
        <doc xml:space="preserve">error in fragment code</doc>
      </member>
      <member name="disc_error"
              value="3"
              c:identifier="MIRAGE_ERROR_DISC_ERROR">
        <doc xml:space="preserve">error in disc code</doc>
      </member>
      <member name="language_error"
              value="4"
              c:identifier="MIRAGE_ERROR_LANGUAGE_ERROR">
        <doc xml:space="preserve">error in language/CD-TEXT code</doc>
      </member>
      <member name="sector_error"
              value="5"
              c:identifier="MIRAGE_ERROR_SECTOR_ERROR">
        <doc xml:space="preserve">error in sector code</doc>
      </member>
      <member name="session_error"
              value="6"
              c:identifier="MIRAGE_ERROR_SESSION_ERROR">
        <doc xml:space="preserve">error in session code</doc>
      </member>
      <member name="track_error"
              value="7"
              c:identifier="MIRAGE_ERROR_TRACK_ERROR">
        <doc xml:space="preserve">error in track code</doc>
      </member>
      <member name="stream_error"
              value="8"
              c:identifier="MIRAGE_ERROR_STREAM_ERROR">
        <doc xml:space="preserve">error in stream code</doc>
      </member>
      <member name="image_file_error"
              value="9"
              c:identifier="MIRAGE_ERROR_IMAGE_FILE_ERROR">
        <doc xml:space="preserve">error related to image file</doc>
      </member>
      <member name="data_file_error"
              value="10"
              c:identifier="MIRAGE_ERROR_DATA_FILE_ERROR">
        <doc xml:space="preserve">error related to data file</doc>
      </member>
      <member name="cannot_handle"
              value="11"
              c:identifier="MIRAGE_ERROR_CANNOT_HANDLE">
        <doc xml:space="preserve">parser/writer/filter stream cannot handle given file</doc>
      </member>
      <member name="encrypted_image"
              value="12"
              c:identifier="MIRAGE_ERROR_ENCRYPTED_IMAGE">
        <doc xml:space="preserve">image is encrypted and password needs to be provided</doc>
      </member>
      <member name="writer_error"
              value="13"
              c:identifier="MIRAGE_ERROR_WRITER_ERROR">
        <doc xml:space="preserve">error in image writer code</doc>
      </member>
    </enumeration>
    <class name="FileStream"
           c:symbol-prefix="file_stream"
           c:type="MirageFileStream"
           parent="Object"
           glib:type-name="MirageFileStream"
           glib:get-type="mirage_file_stream_get_type"
           glib:type-struct="FileStreamClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageFileStream&lt;/structname&gt;
structure are private to the #MirageFileStream implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <implements name="Stream"/>
      <method name="open" c:identifier="mirage_file_stream_open" throws="1">
        <doc xml:space="preserve">Opens the stream on the file pointed to by @filename. If @writable
is %FALSE, the stream is opened in read-only mode; if @writable is
%TRUE, the stream is opened in read-write mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="FileStream" c:type="MirageFileStream*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">name of file on which the stream is to be opened</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">a boolean indicating whether stream should be opened for read/write access</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileStreamPrivate" c:type="MirageFileStreamPrivate*"/>
      </field>
    </class>
    <record name="FileStreamClass"
            c:type="MirageFileStreamClass"
            glib:is-gtype-struct-for="FileStream">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageFileStream&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="FileStreamPrivate"
            c:type="MirageFileStreamPrivate"
            disguised="1">
    </record>
    <class name="FilterStream"
           c:symbol-prefix="filter_stream"
           c:type="MirageFilterStream"
           parent="Object"
           abstract="1"
           glib:type-name="MirageFilterStream"
           glib:get-type="mirage_filter_stream_get_type"
           glib:type-struct="FilterStreamClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageFilterStream&lt;/structname&gt;
structure are private to the #MirageFilterStream implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <implements name="Stream"/>
      <virtual-method name="open" invoker="open" throws="1">
        <doc xml:space="preserve">Opens stream on top of provided underlying stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an underlying stream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">a flag indicating whether the stream should be opened in read/write mode or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read" throws="1">
        <return-value transfer-ownership="none">
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="simplified_partial_read">
        <return-value transfer-ownership="none">
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="simplified_partial_write">
        <return-value transfer-ownership="none">
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write" throws="1">
        <return-value transfer-ownership="none">
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="generate_info"
              c:identifier="mirage_filter_stream_generate_info"
              introspectable="0">
        <doc xml:space="preserve">Generates filter stream information from the input fields. It is intended as a function
for creating filter stream information in filter stream implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">filter stream ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">filter stream name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">flag indicating whether filter stream supports write operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="num_types" transfer-ownership="none">
            <doc xml:space="preserve">number of MIME types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">description and MIME type string pairs, one for each defined type</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="mirage_filter_stream_get_info">
        <doc xml:space="preserve">Retrieves filter stream information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to filter stream information structure. The
structure belongs to object and therefore should not be modified.</doc>
          <type name="FilterStreamInfo"
                c:type="const MirageFilterStreamInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_underlying_stream"
              c:identifier="mirage_filter_stream_get_underlying_stream">
        <doc xml:space="preserve">Retrieves filter stream's underlying stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to filter stream's underlying stream.
The reference belongs to filter stream and should not be released.</doc>
          <type name="Stream" c:type="MirageStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="mirage_filter_stream_open" throws="1">
        <doc xml:space="preserve">Opens stream on top of provided underlying stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an underlying stream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">a flag indicating whether the stream should be opened in read/write mode or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="simplified_get_position"
              c:identifier="mirage_filter_stream_simplified_get_position">
        <doc xml:space="preserve">Retrieves position in the stream.

This function is intented for use in filter stream implementations that
are based on the simplified interface. It should be used by the
implementation's simplified_partial_read function to determine position to
read from without having to worry about position management and update.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">position in the stream</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="simplified_set_stream_length"
              c:identifier="mirage_filter_stream_simplified_set_stream_length">
        <doc xml:space="preserve">Sets size of the stream.

This function is intented for use in filter stream implementations that
are based on the simplified interface. It should be used by the
implementation to set the stream size during stream parsing; the set
stream size is then used by the read function that is implemented by
the simplified interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStream</doc>
            <type name="FilterStream" c:type="MirageFilterStream*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of the stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FilterStreamPrivate" c:type="MirageFilterStreamPrivate*"/>
      </field>
    </class>
    <record name="FilterStreamClass"
            c:type="MirageFilterStreamClass"
            glib:is-gtype-struct-for="FilterStream">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageFilterStream&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
      <field name="open">
        <callback name="open" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFilterStream</doc>
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">an underlying stream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
            <parameter name="writable" transfer-ownership="none">
              <doc xml:space="preserve">a flag indicating whether the stream should be opened in read/write mode or not</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read" throws="1">
          <return-value transfer-ownership="none">
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write" throws="1">
          <return-value transfer-ownership="none">
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="simplified_partial_read">
        <callback name="simplified_partial_read">
          <return-value transfer-ownership="none">
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="simplified_partial_write">
        <callback name="simplified_partial_write">
          <return-value transfer-ownership="none">
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="FilterStream" c:type="MirageFilterStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="FilterStreamInfo" c:type="MirageFilterStreamInfo">
      <doc xml:space="preserve">A structure containing filter stream information. It can be obtained
with call to mirage_filter_stream_get_info().</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">filter stream ID</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">filter stream name</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="writable" writable="1">
        <doc xml:space="preserve">whether filter stream supports write operation</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">zero-terminated array of file type description strings</doc>
        <array c:type="gchar**">
          <type name="utf8" c:type="gchar*"/>
        </array>
      </field>
      <field name="mime_type" writable="1">
        <doc xml:space="preserve">zero-terminated array of file type MIME strings</doc>
        <array c:type="gchar**">
          <type name="utf8" c:type="gchar*"/>
        </array>
      </field>
      <method name="copy" c:identifier="mirage_filter_stream_info_copy">
        <doc xml:space="preserve">Copies parser information from @info to @dest.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStreamInfo to copy data from</doc>
            <type name="FilterStreamInfo"
                  c:type="const MirageFilterStreamInfo*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStreamInfo to copy data to</doc>
            <type name="FilterStreamInfo" c:type="MirageFilterStreamInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="mirage_filter_stream_info_free">
        <doc xml:space="preserve">Frees the allocated fields in @info (but not the structure itself!).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFilterStreamInfo to free</doc>
            <type name="FilterStreamInfo" c:type="MirageFilterStreamInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="FilterStreamPrivate"
            c:type="MirageFilterStreamPrivate"
            disguised="1">
    </record>
    <class name="Fragment"
           c:symbol-prefix="fragment"
           c:type="MirageFragment"
           parent="Object"
           glib:type-name="MirageFragment"
           glib:get-type="mirage_fragment_get_type"
           glib:type-struct="FragmentClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageFragment&lt;/structname&gt;
structure are private to the #MirageFragment implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="contains_address"
              c:identifier="mirage_fragment_contains_address">
        <doc xml:space="preserve">Checks whether the fragment contains the given address or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address falls inside fragment, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address to be checked</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="mirage_fragment_get_address">
        <doc xml:space="preserve">Retrieves fragment's start address. The @address is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">start address</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="mirage_fragment_get_length">
        <doc xml:space="preserve">Retrieves fragment's length. The returned @length is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">length</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_writable" c:identifier="mirage_fragment_is_writable">
        <doc xml:space="preserve">Checks if fragment is writable, i.e., whether it has main channel data
stream set and this stream is writable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if fragment is writable, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="main_data_get_filename"
              c:identifier="mirage_fragment_main_data_get_filename">
        <doc xml:space="preserve">Retrieves filename of main channel data stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to main channel data file name string.
The string belongs to object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="main_data_get_format"
              c:identifier="mirage_fragment_main_data_get_format">
        <doc xml:space="preserve">Retrieves main data file format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">main data file format</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="main_data_get_offset"
              c:identifier="mirage_fragment_main_data_get_offset">
        <doc xml:space="preserve">Retrieves main data file offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">main data file offset</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="main_data_get_size"
              c:identifier="mirage_fragment_main_data_get_size">
        <doc xml:space="preserve">Retrieves main data file sector size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">main data file sector size</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="main_data_set_format"
              c:identifier="mirage_fragment_main_data_set_format">
        <doc xml:space="preserve">Sets main data file format. @format must be one of #MirageMainDataFormat.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">main data file format</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="main_data_set_offset"
              c:identifier="mirage_fragment_main_data_set_offset">
        <doc xml:space="preserve">Sets main data file offset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">main data file offset</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="main_data_set_size"
              c:identifier="mirage_fragment_main_data_set_size">
        <doc xml:space="preserve">Sets main data file sector size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">main data file sector size</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="main_data_set_stream"
              c:identifier="mirage_fragment_main_data_set_stream">
        <doc xml:space="preserve">Sets main channel data stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageStream on main channel data file</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_main_data"
              c:identifier="mirage_fragment_read_main_data"
              throws="1">
        <doc xml:space="preserve">Reads main channel data for sector at fragment-relative @address (given
in sectors). The buffer for reading data into is allocated by function
and should be freed using g_free() when no longer needed. The pointer
to buffer is stored into @buffer and the length of read data is stored into
@length.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer with read data, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store read data length</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_subchannel_data"
              c:identifier="mirage_fragment_read_subchannel_data"
              throws="1">
        <doc xml:space="preserve">Writes subchannel data for sector at fragment-relative @address (given
in sectors).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">buffer with data to write, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to store read data length</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_address" c:identifier="mirage_fragment_set_address">
        <doc xml:space="preserve">Sets fragment's start address. The @address is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">start address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_length" c:identifier="mirage_fragment_set_length">
        <doc xml:space="preserve">Sets fragment's length. The @length is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subchannel_data_get_filename"
              c:identifier="mirage_fragment_subchannel_data_get_filename">
        <doc xml:space="preserve">Retrieves filename of subchannel data input stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to subchannel data file name string.
The string belongs to object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subchannel_data_get_format"
              c:identifier="mirage_fragment_subchannel_data_get_format">
        <doc xml:space="preserve">Retrieves subchannel data file format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">subchannel data file format</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subchannel_data_get_offset"
              c:identifier="mirage_fragment_subchannel_data_get_offset">
        <doc xml:space="preserve">Retrieves subchannel data file offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">subchannel data file offset</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subchannel_data_get_size"
              c:identifier="mirage_fragment_subchannel_data_get_size">
        <doc xml:space="preserve">Retrieves subchannel data file sector size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">subchannel data file sector size</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="subchannel_data_set_format"
              c:identifier="mirage_fragment_subchannel_data_set_format">
        <doc xml:space="preserve">Sets subchannel data file format. @format must be a combination of
#MirageSubchannelDataFormat.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">subchannel data file format</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subchannel_data_set_offset"
              c:identifier="mirage_fragment_subchannel_data_set_offset">
        <doc xml:space="preserve">Sets subchannel data file offset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">subchannel data file offset</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="subchannel_data_set_size"
              c:identifier="mirage_fragment_subchannel_data_set_size">
        <doc xml:space="preserve">Sets subchannel data file sector size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">subchannel data file sector size</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subchannel_data_set_stream"
              c:identifier="mirage_fragment_subchannel_data_set_stream">
        <doc xml:space="preserve">Sets subchannel data stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageStream on subchannel data file</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="use_the_rest_of_file"
              c:identifier="mirage_fragment_use_the_rest_of_file"
              throws="1">
        <doc xml:space="preserve">Uses the rest of data file. It automatically calculates and sets fragment's
length.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_main_data"
              c:identifier="mirage_fragment_write_main_data"
              throws="1">
        <doc xml:space="preserve">Writes main channel data for sector at fragment-relative @address (given
in sectors).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">buffer with data to write, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of data to write</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_subchannel_data"
              c:identifier="mirage_fragment_write_subchannel_data"
              throws="1">
        <doc xml:space="preserve">Reads subchannel data for sector at fragment-relative @address (given
in sectors). The buffer for reading data into is allocated by function
and should be freed using g_free() when no longer needed. The pointer
to buffer is stored into @buffer and the length of read data is stored into
@length.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">buffer with read data, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of data to write</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FragmentPrivate" c:type="MirageFragmentPrivate*"/>
      </field>
      <glib:signal name="layout-changed" when="last">
        <doc xml:space="preserve">Emitted when a layout of #MirageFragment changed in a way that causes a bottom-up change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="FragmentClass"
            c:type="MirageFragmentClass"
            glib:is-gtype-struct-for="Fragment">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageFragment&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="FragmentPrivate"
            c:type="MirageFragmentPrivate"
            disguised="1">
    </record>
    <enumeration name="FragmentRole" c:type="MirageFragmentRole">
      <doc xml:space="preserve">Fragment roles.</doc>
      <member name="pregap" value="0" c:identifier="MIRAGE_FRAGMENT_PREGAP">
        <doc xml:space="preserve">pregap fragment</doc>
      </member>
      <member name="data" value="1" c:identifier="MIRAGE_FRAGMENT_DATA">
        <doc xml:space="preserve">data fragment</doc>
      </member>
    </enumeration>
    <constant name="ISRC_SIZE" value="12" c:type="MIRAGE_ISRC_SIZE">
      <doc xml:space="preserve">Length of ISRC string.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Index"
           c:symbol-prefix="index"
           c:type="MirageIndex"
           parent="Object"
           glib:type-name="MirageIndex"
           glib:get-type="mirage_index_get_type"
           glib:type-struct="IndexClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageIndex&lt;/structname&gt;
structure are private to the #MirageIndex implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="get_address" c:identifier="mirage_index_get_address">
        <doc xml:space="preserve">Retrieves index' start adddress. The @address is given in sectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">address</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageIndex</doc>
            <type name="Index" c:type="MirageIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number" c:identifier="mirage_index_get_number">
        <doc xml:space="preserve">Retrieves index' index number.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">index number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageIndex</doc>
            <type name="Index" c:type="MirageIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_address" c:identifier="mirage_index_set_address">
        <doc xml:space="preserve">Sets index' start address. The @address is given in sectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageIndex</doc>
            <type name="Index" c:type="MirageIndex*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_number" c:identifier="mirage_index_set_number">
        <doc xml:space="preserve">Sets index' index number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageIndex</doc>
            <type name="Index" c:type="MirageIndex*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">index number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="IndexPrivate" c:type="MirageIndexPrivate*"/>
      </field>
    </class>
    <record name="IndexClass"
            c:type="MirageIndexClass"
            glib:is-gtype-struct-for="Index">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageIndex&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="IndexPrivate" c:type="MirageIndexPrivate" disguised="1">
    </record>
    <class name="Language"
           c:symbol-prefix="language"
           c:type="MirageLanguage"
           parent="Object"
           glib:type-name="MirageLanguage"
           glib:get-type="mirage_language_get_type"
           glib:type-struct="LanguageClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageLanguage&lt;/structname&gt;
structure are private to the #MirageLanguage implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="get_code" c:identifier="mirage_language_get_code">
        <doc xml:space="preserve">Retrieves language's language code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">language code</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageLanguage</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pack_data"
              c:identifier="mirage_language_get_pack_data"
              throws="1">
        <doc xml:space="preserve">Retrieves pack data of type @pack_type. A pointer to buffer containing pack
data is stored in @pack data; the buffer belongs to the object and therefore
should not be modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageLanguage</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </instance-parameter>
          <parameter name="pack_type" transfer-ownership="none">
            <doc xml:space="preserve">pack type</doc>
            <type name="LanguagePackType" c:type="MirageLanguagePackType"/>
          </parameter>
          <parameter name="pack_data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store buffer containing pack data, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of pack data, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_code" c:identifier="mirage_language_set_code">
        <doc xml:space="preserve">Sets language's language code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageLanguage</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pack_data"
              c:identifier="mirage_language_set_pack_data"
              throws="1">
        <doc xml:space="preserve">Sets pack data of type @pack_type to data in @pack_data. @length is length of
data in @pack_data. @pack_type must be one of #MirageLanguagePackType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageLanguage</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </instance-parameter>
          <parameter name="pack_type" transfer-ownership="none">
            <doc xml:space="preserve">pack type</doc>
            <type name="LanguagePackType" c:type="MirageLanguagePackType"/>
          </parameter>
          <parameter name="pack_data" transfer-ownership="none">
            <doc xml:space="preserve">pack data</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of pack data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="LanguagePrivate" c:type="MirageLanguagePrivate*"/>
      </field>
    </class>
    <record name="LanguageClass"
            c:type="MirageLanguageClass"
            glib:is-gtype-struct-for="Language">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageLanguage&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <enumeration name="LanguagePackType" c:type="MirageLanguagePackType">
      <doc xml:space="preserve">CD-TEXT pack types.</doc>
      <member name="title"
              value="128"
              c:identifier="MIRAGE_LANGUAGE_PACK_TITLE">
        <doc xml:space="preserve">Album name and Track titles</doc>
      </member>
      <member name="performer"
              value="129"
              c:identifier="MIRAGE_LANGUAGE_PACK_PERFORMER">
        <doc xml:space="preserve">Singer/player/conductor/orchestra</doc>
      </member>
      <member name="songwriter"
              value="130"
              c:identifier="MIRAGE_LANGUAGE_PACK_SONGWRITER">
        <doc xml:space="preserve">Name of the songwriter</doc>
      </member>
      <member name="composer"
              value="131"
              c:identifier="MIRAGE_LANGUAGE_PACK_COMPOSER">
        <doc xml:space="preserve">Name of the composer</doc>
      </member>
      <member name="arranger"
              value="132"
              c:identifier="MIRAGE_LANGUAGE_PACK_ARRANGER">
        <doc xml:space="preserve">Name of the arranger</doc>
      </member>
      <member name="message"
              value="133"
              c:identifier="MIRAGE_LANGUAGE_PACK_MESSAGE">
        <doc xml:space="preserve">Message from content provider or artist</doc>
      </member>
      <member name="disc_id"
              value="134"
              c:identifier="MIRAGE_LANGUAGE_PACK_DISC_ID">
        <doc xml:space="preserve">Disc identification information</doc>
      </member>
      <member name="genre"
              value="135"
              c:identifier="MIRAGE_LANGUAGE_PACK_GENRE">
        <doc xml:space="preserve">Genre identification / information</doc>
      </member>
      <member name="toc" value="136" c:identifier="MIRAGE_LANGUAGE_PACK_TOC">
        <doc xml:space="preserve">TOC information</doc>
      </member>
      <member name="toc2" value="137" c:identifier="MIRAGE_LANGUAGE_PACK_TOC2">
        <doc xml:space="preserve">Second TOC</doc>
      </member>
      <member name="res_8a"
              value="138"
              c:identifier="MIRAGE_LANGUAGE_PACK_RES_8A">
        <doc xml:space="preserve">Reserved 8A</doc>
      </member>
      <member name="res_8b"
              value="139"
              c:identifier="MIRAGE_LANGUAGE_PACK_RES_8B">
        <doc xml:space="preserve">Reserved 8B</doc>
      </member>
      <member name="res_8c"
              value="140"
              c:identifier="MIRAGE_LANGUAGE_PACK_RES_8C">
        <doc xml:space="preserve">Reserved 8C</doc>
      </member>
      <member name="closed_info"
              value="141"
              c:identifier="MIRAGE_LANGUAGE_PACK_CLOSED_INFO">
        <doc xml:space="preserve">For internal use by content provider</doc>
      </member>
      <member name="upc_isrc"
              value="142"
              c:identifier="MIRAGE_LANGUAGE_PACK_UPC_ISRC">
        <doc xml:space="preserve">UPC/EAN code of album and ISRC for tracks</doc>
      </member>
      <member name="size" value="143" c:identifier="MIRAGE_LANGUAGE_PACK_SIZE">
        <doc xml:space="preserve">Size information of the block</doc>
      </member>
    </enumeration>
    <record name="LanguagePrivate"
            c:type="MirageLanguagePrivate"
            disguised="1">
    </record>
    <constant name="MCN_SIZE" value="13" c:type="MIRAGE_MCN_SIZE">
      <doc xml:space="preserve">Length of MCN string.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="MainDataFormat" c:type="MirageMainDataFormat">
      <doc xml:space="preserve">Track file data formats.</doc>
      <member name="data"
              value="1"
              c:identifier="MIRAGE_MAIN_DATA_FORMAT_DATA">
        <doc xml:space="preserve">binary data</doc>
      </member>
      <member name="audio"
              value="2"
              c:identifier="MIRAGE_MAIN_DATA_FORMAT_AUDIO">
        <doc xml:space="preserve">audio data</doc>
      </member>
      <member name="audio_swap"
              value="4"
              c:identifier="MIRAGE_MAIN_DATA_FORMAT_AUDIO_SWAP">
        <doc xml:space="preserve">audio data that needs to be swapped</doc>
      </member>
    </enumeration>
    <enumeration name="MediumType" c:type="MirageMediumType">
      <doc xml:space="preserve">Medium types.</doc>
      <member name="cd" value="1" c:identifier="MIRAGE_MEDIUM_CD">
        <doc xml:space="preserve">CD disc</doc>
      </member>
      <member name="dvd" value="2" c:identifier="MIRAGE_MEDIUM_DVD">
        <doc xml:space="preserve">DVD disc</doc>
      </member>
      <member name="bd" value="3" c:identifier="MIRAGE_MEDIUM_BD">
        <doc xml:space="preserve">BD (Blue-Ray) disc</doc>
      </member>
      <member name="hd" value="4" c:identifier="MIRAGE_MEDIUM_HD">
        <doc xml:space="preserve">HD-DVD disc</doc>
      </member>
      <member name="hdd" value="5" c:identifier="MIRAGE_MEDIUM_HDD">
        <doc xml:space="preserve">Hard-disk</doc>
      </member>
    </enumeration>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="MirageObject"
           parent="GObject.Object"
           glib:type-name="MirageObject"
           glib:get-type="mirage_object_get_type"
           glib:type-struct="ObjectClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageObject&lt;/structname&gt;
structure are private to the #MirageObject implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="get_parent" c:identifier="mirage_object_get_parent">
        <doc xml:space="preserve">Returns pointer to object's parent object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">parent object, or %NULL.</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageObject</doc>
            <type name="Object" c:type="MirageObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_parent" c:identifier="mirage_object_set_parent">
        <doc xml:space="preserve">Sets object's parent. If @parent is %NULL, the object's parent is
reset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageObject</doc>
            <type name="Object" c:type="MirageObject*"/>
          </instance-parameter>
          <parameter name="parent"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parent</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ObjectPrivate" c:type="MirageObjectPrivate*"/>
      </field>
      <glib:signal name="context-changed" when="last">
        <doc xml:space="preserve">Emitted when a new #MirageContext is set to a #MirageObject.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="MirageObjectClass"
            glib:is-gtype-struct-for="Object">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageObject&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ObjectPrivate" c:type="MirageObjectPrivate" disguised="1">
    </record>
    <class name="Parser"
           c:symbol-prefix="parser"
           c:type="MirageParser"
           parent="Object"
           abstract="1"
           glib:type-name="MirageParser"
           glib:get-type="mirage_parser_get_type"
           glib:type-struct="ParserClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageParser&lt;/structname&gt;
structure are private to the #MirageParser implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <virtual-method name="load_image" invoker="load_image" throws="1">
        <doc xml:space="preserve">Loads the image stored in @streams.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageDisc object representing image on success, %NULL on failure</doc>
          <type name="Disc" c:type="MirageDisc*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of data streams</doc>
            <array c:type="MirageStream**">
              <type name="Stream" c:type="MirageStream*"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_redbook_pregap"
              c:identifier="mirage_parser_add_redbook_pregap">
        <doc xml:space="preserve">A helper function, intended to be used in simpler parsers that don't get proper
pregap information from the image file.

First, it sets disc layout start to -150. Then, it adds 150-sector pregap to
first track of each session found on the layout; for this, a NULL fragment is
used. If track already has a pregap, then the pregaps are stacked.

Note that the function works only on discs which have medium type set to
CD-ROM. On other discs, it does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <doc xml:space="preserve">disc object</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_text_stream"
              c:identifier="mirage_parser_create_text_stream"
              throws="1">
        <doc xml:space="preserve">Constructs a filter chain for reading text files on top of provided
@stream. First, if encoding is provided via parser parameters, or if
a multi-byte encoding is detected, a #GConverterInputStream with a
#GCharsetConverter is applied. Then on top of it, a #GDataInputStream
is created, which can be used to read text file line-by-line.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GDataInputStream object on success,
or %NULL on failure.</doc>
          <type name="Gio.DataInputStream" c:type="GDataInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_info"
              c:identifier="mirage_parser_generate_info"
              introspectable="0">
        <doc xml:space="preserve">Generates parser information from the input fields. It is intended as a function
for creating parser information in parser implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parser ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">parser name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="num_types" transfer-ownership="none">
            <doc xml:space="preserve">number of MIME types</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">description and MIME type string pairs, one for each defined type</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="mirage_parser_get_info">
        <doc xml:space="preserve">Retrieves parser information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to parser information structure.  The
structure belongs to object and should not be modified.</doc>
          <type name="ParserInfo" c:type="const MirageParserInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="guess_medium_type"
              c:identifier="mirage_parser_guess_medium_type">
        <doc xml:space="preserve">Attempts to guess medium type by looking at the length of the disc layout.
Currently, it supports identification of CD-ROM media, which are assumed to
have layout length of 90 minutes or less.

Note that this function does not set the medium type to disc object; you still
need to do it via mirage_disc_set_medium_type(). It is meant to be used in
simple parsers whose image files don't provide medium type information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a value from #MirageMediumTypes, according to the guessed medium type.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <doc xml:space="preserve">disc object</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_image"
              c:identifier="mirage_parser_load_image"
              throws="1">
        <doc xml:space="preserve">Loads the image stored in @streams.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageDisc object representing image on success, %NULL on failure</doc>
          <type name="Disc" c:type="MirageDisc*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParser</doc>
            <type name="Parser" c:type="MirageParser*"/>
          </instance-parameter>
          <parameter name="streams" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of data streams</doc>
            <array c:type="MirageStream**">
              <type name="Stream" c:type="MirageStream*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ParserPrivate" c:type="MirageParserPrivate*"/>
      </field>
    </class>
    <record name="ParserClass"
            c:type="MirageParserClass"
            glib:is-gtype-struct-for="Parser">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageParser&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
      <field name="load_image">
        <callback name="load_image" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #MirageDisc object representing image on success, %NULL on failure</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageParser</doc>
              <type name="Parser" c:type="MirageParser*"/>
            </parameter>
            <parameter name="streams" transfer-ownership="none">
              <doc xml:space="preserve">%NULL-terminated array of data streams</doc>
              <array c:type="MirageStream**">
                <type name="Stream" c:type="MirageStream*"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ParserInfo" c:type="MirageParserInfo">
      <doc xml:space="preserve">A structure containing parser information. It can be obtained with call to
mirage_parser_get_info().</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">parser ID</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">parser name</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">zero-terminated array of file type description strings</doc>
        <array c:type="gchar**">
          <type name="utf8" c:type="gchar*"/>
        </array>
      </field>
      <field name="mime_type" writable="1">
        <doc xml:space="preserve">zero-terminated array of file type MIME strings</doc>
        <array c:type="gchar**">
          <type name="utf8" c:type="gchar*"/>
        </array>
      </field>
      <method name="copy" c:identifier="mirage_parser_info_copy">
        <doc xml:space="preserve">Copies parser information from @info to @dest.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParserInfo to copy data from</doc>
            <type name="ParserInfo" c:type="const MirageParserInfo*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParserInfo to copy data to</doc>
            <type name="ParserInfo" c:type="MirageParserInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="mirage_parser_info_free">
        <doc xml:space="preserve">Frees the allocated fields in @info (but not the structure itself!).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageParserInfo to free</doc>
            <type name="ParserInfo" c:type="MirageParserInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="ParserPrivate" c:type="MirageParserPrivate" disguised="1">
    </record>
    <callback name="PasswordFunction" c:type="MiragePasswordFunction">
      <doc xml:space="preserve">Password function type used to obtain password for encrypted
images. A password function needs to be set to #MirageContext via
mirage_context_set_password_function(), along with @user_data that
the password function should be called with.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">password string on success, otherwise %NULL. Password string should
be a copy, allocated via function such as g_strdup(), and will be freed after
it is used.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:space="preserve">user data passed to password function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Plugin"
           c:symbol-prefix="plugin"
           c:type="MiragePlugin"
           parent="GObject.TypeModule"
           glib:type-name="MiragePlugin"
           glib:get-type="mirage_plugin_get_type"
           glib:type-struct="PluginClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MiragePlugin&lt;/structname&gt;
structure are private to the #MiragePlugin implementation and
should never be accessed directly.</doc>
      <implements name="GObject.TypePlugin"/>
      <constructor name="new" c:identifier="mirage_plugin_new">
        <doc xml:space="preserve">Creates new plugin.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #MiragePlugin object that represents plugin. It should be
released with g_object_unref() when no longer needed.</doc>
          <type name="Plugin" c:type="MiragePlugin*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">plugin's filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="filename"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.TypeModule" c:type="GTypeModule"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PluginPrivate" c:type="MiragePluginPrivate*"/>
      </field>
    </class>
    <record name="PluginClass"
            c:type="MiragePluginClass"
            glib:is-gtype-struct-for="Plugin">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MiragePlugin&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.TypeModuleClass" c:type="GTypeModuleClass"/>
      </field>
    </record>
    <record name="PluginPrivate" c:type="MiragePluginPrivate" disguised="1">
    </record>
    <constant name="SOVERSION_MAJOR"
              value="10"
              c:type="MIRAGE_SOVERSION_MAJOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SOVERSION_MINOR" value="0" c:type="MIRAGE_SOVERSION_MINOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SOVERSION_PATCH" value="0" c:type="MIRAGE_SOVERSION_PATCH">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Sector"
           c:symbol-prefix="sector"
           c:type="MirageSector"
           parent="Object"
           glib:type-name="MirageSector"
           glib:get-type="mirage_sector_get_type"
           glib:type-struct="SectorClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageSector&lt;/structname&gt;
structure are private to the #MirageSector implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="extract_data"
              c:identifier="mirage_sector_extract_data"
              throws="1">
        <doc xml:space="preserve">Extracts data from sector. Which parts of main channel data are extracted
depends on provided @main_data_length.

&lt;note&gt;
Intended for internal use.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="main_data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">location to store pointer to main data buffer</doc>
            <type name="guint8" c:type="const guint8**"/>
          </parameter>
          <parameter name="main_data_length" transfer-ownership="none">
            <doc xml:space="preserve">requested length of data in main data buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="subchannel_format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">requested subchannel data format</doc>
            <type name="SectorSubchannelFormat"
                  c:type="MirageSectorSubchannelFormat"/>
          </parameter>
          <parameter name="subchannel_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to subchannel data buffer, or %NULL</doc>
            <type name="guint8" c:type="const guint8**"/>
          </parameter>
          <parameter name="subchannel_data_length" transfer-ownership="none">
            <doc xml:space="preserve">requested length of data in subchannel data buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="feed_data"
              c:identifier="mirage_sector_feed_data"
              throws="1">
        <doc xml:space="preserve">Feeds data to sector. If @type is %MIRAGE_SECTOR_RAW or %MIRAGE_SECTOR_RAW_SCRAMBLED,
the real sector type is determined during feeding.

&lt;note&gt;
Intended for internal use.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">absolute disc address the sector represents. Given in sectors.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">track type (one of #MirageSectorType)</doc>
            <type name="SectorType" c:type="MirageSectorType"/>
          </parameter>
          <parameter name="main_data" transfer-ownership="none">
            <doc xml:space="preserve">main data buffer</doc>
            <type name="guint8" c:type="const guint8*"/>
          </parameter>
          <parameter name="main_data_length" transfer-ownership="none">
            <doc xml:space="preserve">length of data in main data buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="subchannel_format" transfer-ownership="none">
            <doc xml:space="preserve">subchannel data format</doc>
            <type name="SectorSubchannelFormat"
                  c:type="MirageSectorSubchannelFormat"/>
          </parameter>
          <parameter name="subchannel_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">subchannel data buffer</doc>
            <type name="guint8" c:type="const guint8*"/>
          </parameter>
          <parameter name="subchannel_data_length" transfer-ownership="none">
            <doc xml:space="preserve">length of data in subchannel data buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ignore_data_mask" transfer-ownership="none">
            <doc xml:space="preserve">a mask of #MirageSectorValidData values, indicating which parts of main channel sector data, if any, should be ignored and regerated even though they are provided by the data feed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="mirage_sector_get_address">
        <doc xml:space="preserve">Retrieves absolute disc address of the sector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">sector address</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="mirage_sector_get_data" throws="1">
        <doc xml:space="preserve">Retrieves sector's user data. The pointer to appropriate location in
sector's data buffer is stored into @ret_buf;  therefore, the buffer should not
be modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing user data, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of user data, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_edc_ecc"
              c:identifier="mirage_sector_get_edc_ecc"
              throws="1">
        <doc xml:space="preserve">Retrieves sector's EDC/ECC data. The pointer to appropriate location in
sector's data buffer is stored into @ret_buf;  therefore, the buffer should not
be modified.

If EDC/ECC data is not provided by image file(s), it is generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing EDC/ECC data, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of EDC/ECC data, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_header"
              c:identifier="mirage_sector_get_header"
              throws="1">
        <doc xml:space="preserve">Retrieves sector's header. The pointer to appropriate location in
sector's data buffer is stored into @ret_buf; therefore, the buffer should not
be modified.

If header is not provided by image file(s), it is generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing header, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of header, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sector_type"
              c:identifier="mirage_sector_get_sector_type">
        <doc xml:space="preserve">Retrieves sector type (track mode); one of #MirageSectorType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">sector type (track mode)</doc>
          <type name="SectorType" c:type="MirageSectorType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subchannel"
              c:identifier="mirage_sector_get_subchannel"
              throws="1">
        <doc xml:space="preserve">Retrieves sector's subchannel. @format must be one of #MirageSectorSubchannelFormat.
The pointer to appropriate location in sector's data buffer is stored into
@ret_buf;  therefore, the buffer should not be modified.

If subchannel is not provided by image file(s), it is generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">subchannel format</doc>
            <type name="SectorSubchannelFormat"
                  c:type="MirageSectorSubchannelFormat"/>
          </parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing subchannel, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of subchannel data, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_subheader"
              c:identifier="mirage_sector_get_subheader"
              throws="1">
        <doc xml:space="preserve">Retrieves sector's subheader. The pointer to appropriate location in
sector's data buffer is stored into @ret_buf;  therefore, the buffer should not
be modified.

If subheader is not provided by image file(s), it is generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing subheader, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of subheader, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sync" c:identifier="mirage_sector_get_sync" throws="1">
        <doc xml:space="preserve">Retrieves sector's sync pattern. The pointer to appropriate location in
sector's data buffer is stored into @ret_buf; therefore, the buffer should not
be modified.

If sync pattern is not provided by image file(s), it is generated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="ret_buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store pointer to buffer containing sync pattern, or %NULL</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="ret_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store length of sync pattern, or %NULL. Length is given in bytes.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scramble" c:identifier="mirage_sector_scramble">
        <doc xml:space="preserve">Scrambles 2340 bytes of sector data after sync pattern, using scrambler
from ECMA-130 Annex B. Running this function on already-scrambled
sector results in unscrambling.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="mirage_sector_set_data" throws="1">
        <doc xml:space="preserve">Sets sector's user data to that stored in @buf.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing user data</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of user data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_edc_ecc"
              c:identifier="mirage_sector_set_edc_ecc"
              throws="1">
        <doc xml:space="preserve">Sets sector's EDC/ECC data to that stored in @buf.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing EDC/ECC data</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of EDC/ECC data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_header"
              c:identifier="mirage_sector_set_header"
              throws="1">
        <doc xml:space="preserve">Sets sector's header to that stored in @buf.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing header</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of header</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subchannel"
              c:identifier="mirage_sector_set_subchannel"
              throws="1">
        <doc xml:space="preserve">Sets sector's subchannel data to that stored in @buf. @format must be
one of #MirageSectorSubchannelFormat.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">subchannel format</doc>
            <type name="SectorSubchannelFormat"
                  c:type="MirageSectorSubchannelFormat"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing subchannel data</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of subchannel data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subheader"
              c:identifier="mirage_sector_set_subheader"
              throws="1">
        <doc xml:space="preserve">Sets sector's subheader to that stored in @buf.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing subheader</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of subheader</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync" c:identifier="mirage_sector_set_sync" throws="1">
        <doc xml:space="preserve">Sets sector's sync pattern to that stored in @buf.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing sync pattern</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of sync pattern</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_lec" c:identifier="mirage_sector_verify_lec">
        <doc xml:space="preserve">Verifies the sector data in terms of L-EC error detection/correction.
Data sectors (Mode 1, Mode 2 Form 1 and Mode 2 Form 2) contain error
detection/error correction codes which is part of so called layered
error correction. This function calculates the EDC for sector data and
compares it with EDC provided by the image file.

As a result of comparison, the sectors with intentionally faulty EDC
(and possibly ECC, though ECC is not verified) can be discovered.

This function requires EDC/ECC data to be provided by the image. If it
is not provided, it would be generated by #MirageSector on first access
via mirage_sector_get_edc_ecc() using the same algorithm as the one used
by this function. Therefore, in case of EDC/ECC data missing, the verification
automatically succeeds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sector passes verification (i.e. no L-EC errors are detected) otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="verify_subchannel_crc"
              c:identifier="mirage_sector_verify_subchannel_crc">
        <doc xml:space="preserve">Verifies the Q subchannel's CRC for the sector.

As a result of comparison, the sectors with intentionally faulty Q subchannel
can be discovered.

This function requires subchannel data to be provided by the image. If it
is not provided, it would be generated by #MirageSector on first access
via mirage_sector_get_subchannel() using the same algorithm as the one used
by this function. Therefore, in case of subchannel data missing, the verification
automatically succeeds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sector's Q subchannel CRC passes verification otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SectorPrivate" c:type="MirageSectorPrivate*"/>
      </field>
    </class>
    <record name="SectorClass"
            c:type="MirageSectorClass"
            glib:is-gtype-struct-for="Sector">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageSector&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="SectorPrivate" c:type="MirageSectorPrivate" disguised="1">
    </record>
    <enumeration name="SectorSubchannelFormat"
                 c:type="MirageSectorSubchannelFormat">
      <doc xml:space="preserve">Subchannel selection flags.</doc>
      <member name="none" value="0" c:identifier="MIRAGE_SUBCHANNEL_NONE">
        <doc xml:space="preserve">no subchannel</doc>
      </member>
      <member name="pw" value="1" c:identifier="MIRAGE_SUBCHANNEL_PW">
        <doc xml:space="preserve">PW subchannel; 96 bytes, interleaved P-W</doc>
      </member>
      <member name="q" value="2" c:identifier="MIRAGE_SUBCHANNEL_Q">
        <doc xml:space="preserve">Q subchannel; 16 bytes, Q subchannel</doc>
      </member>
      <member name="rw" value="3" c:identifier="MIRAGE_SUBCHANNEL_RW">
        <doc xml:space="preserve">RW subchannel; 96 bytes, cooked R-W</doc>
      </member>
    </enumeration>
    <enumeration name="SectorType" c:type="MirageSectorType">
      <doc xml:space="preserve">Sector type. Also implies track mode.</doc>
      <member name="mode0" value="0" c:identifier="MIRAGE_SECTOR_MODE0">
        <doc xml:space="preserve">Mode 0 sector</doc>
      </member>
      <member name="audio" value="1" c:identifier="MIRAGE_SECTOR_AUDIO">
        <doc xml:space="preserve">Audio sector</doc>
      </member>
      <member name="mode1" value="2" c:identifier="MIRAGE_SECTOR_MODE1">
        <doc xml:space="preserve">Mode 1 sector</doc>
      </member>
      <member name="mode2" value="3" c:identifier="MIRAGE_SECTOR_MODE2">
        <doc xml:space="preserve">Mode 2 Formless sector</doc>
      </member>
      <member name="mode2_form1"
              value="4"
              c:identifier="MIRAGE_SECTOR_MODE2_FORM1">
        <doc xml:space="preserve">Mode 2 Form 1 sector</doc>
      </member>
      <member name="mode2_form2"
              value="5"
              c:identifier="MIRAGE_SECTOR_MODE2_FORM2">
        <doc xml:space="preserve">Mode 2 Form 2 sector</doc>
      </member>
      <member name="mode2_mixed"
              value="6"
              c:identifier="MIRAGE_SECTOR_MODE2_MIXED">
        <doc xml:space="preserve">Mode 2 Mixed sector</doc>
      </member>
      <member name="raw" value="7" c:identifier="MIRAGE_SECTOR_RAW">
        <doc xml:space="preserve">raw sector (automatic sector type detection)</doc>
      </member>
      <member name="raw_scrambled"
              value="8"
              c:identifier="MIRAGE_SECTOR_RAW_SCRAMBLED">
        <doc xml:space="preserve">scrambled raw sector (automatic sector type detection)</doc>
      </member>
    </enumeration>
    <enumeration name="SectorValidData" c:type="MirageSectorValidData">
      <doc xml:space="preserve">Sector data validity flags.</doc>
      <member name="sync" value="1" c:identifier="MIRAGE_VALID_SYNC">
        <doc xml:space="preserve">sync pattern valid</doc>
      </member>
      <member name="header" value="2" c:identifier="MIRAGE_VALID_HEADER">
        <doc xml:space="preserve">header valid</doc>
      </member>
      <member name="subheader" value="4" c:identifier="MIRAGE_VALID_SUBHEADER">
        <doc xml:space="preserve">subheader valid</doc>
      </member>
      <member name="data" value="8" c:identifier="MIRAGE_VALID_DATA">
        <doc xml:space="preserve">user data valid</doc>
      </member>
      <member name="edc_ecc" value="16" c:identifier="MIRAGE_VALID_EDC_ECC">
        <doc xml:space="preserve">EDC/ECC data valid</doc>
      </member>
      <member name="subchan" value="32" c:identifier="MIRAGE_VALID_SUBCHAN">
        <doc xml:space="preserve">subchannel valid</doc>
      </member>
    </enumeration>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="MirageSession"
           parent="Object"
           glib:type-name="MirageSession"
           glib:get-type="mirage_session_get_type"
           glib:type-struct="SessionClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageSession&lt;/structname&gt;
structure are private to the #MirageSession implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="add_language"
              c:identifier="mirage_session_add_language"
              throws="1">
        <doc xml:space="preserve">Adds language to session.

@code is language code that should be assigned to added language. If
language with that code is already present in the session, the function fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code for the added language</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="language" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageLanguage to be added</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_track_by_index"
              c:identifier="mirage_session_add_track_by_index">
        <doc xml:space="preserve">Adds track to session layout.

@index is the index at which track is added. Negative index denotes
index going backwards (i.e. -1 adds track at the end, -2 adds track
second-to-last, etc.). If index, either negative or positive, is too big,
track is respectively added at the beginning or at the end of the layout.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index at which track should be added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="track" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageTrack to be added</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_track_by_number"
              c:identifier="mirage_session_add_track_by_number"
              throws="1">
        <doc xml:space="preserve">Adds track to session layout.

@number is track number that should be assigned to added track. It determines
track's position in the layout. If track with that number already exists in
the layout, the function fails.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">track number for the added track</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="track" transfer-ownership="full">
            <doc xml:space="preserve">a #MirageTrack to be added</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_languages"
              c:identifier="mirage_session_enumerate_languages">
        <doc xml:space="preserve">Iterates over languages list, calling @func for each language.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumLanguageCallback"
                  c:type="MirageEnumLanguageCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_tracks"
              c:identifier="mirage_session_enumerate_tracks">
        <doc xml:space="preserve">Iterates over tracks list, calling @func for each track in the layout.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumTrackCallback" c:type="MirageEnumTrackCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cdtext_data"
              c:identifier="mirage_session_get_cdtext_data"
              throws="1">
        <doc xml:space="preserve">Returns CD-TEXT data for session. It internally creates and uses #MirageCdTextCoder
object as an encoder to encode data from #MirageLanguage objects from both session and
its tracks. Buffer with encoded data is stored in @data; it should be freed with
g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="data"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to return buffer with encoded CD-TEXT data</doc>
            <array length="1" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">location to return length of data in buffer</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_language_by_code"
              c:identifier="mirage_session_get_language_by_code"
              throws="1">
        <doc xml:space="preserve">Retrieves language by language code.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageLanguage on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Language" c:type="MirageLanguage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code of language to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_language_by_index"
              c:identifier="mirage_session_get_language_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves language by index. If @index is negative, languages from the end of
session are retrieved (e.g. -1 is for last language, -2 for second-to-last
language, etc.). If @index is out of range, regardless of the sign, the
function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageLanguage on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Language" c:type="MirageLanguage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of language to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_leadout_length"
              c:identifier="mirage_session_get_leadout_length">
        <doc xml:space="preserve">Retrieves session's leadout length. The returned length is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">leadout length</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mcn" c:identifier="mirage_session_get_mcn">
        <doc xml:space="preserve">Retrieves MCN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to MCN string, or %NULL. The string
belongs to the object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next"
              c:identifier="mirage_session_get_next"
              throws="1">
        <doc xml:space="preserve">Retrieves session that is placed after @self in disc layout.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_languages"
              c:identifier="mirage_session_get_number_of_languages">
        <doc xml:space="preserve">Retrieves number of languages the session contains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of languages</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_tracks"
              c:identifier="mirage_session_get_number_of_tracks">
        <doc xml:space="preserve">Retrieves number of tracks in the session layout.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of tracks</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prev"
              c:identifier="mirage_session_get_prev"
              throws="1">
        <doc xml:space="preserve">Retrieves session that is placed before @self in disc layout.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageSession on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Session" c:type="MirageSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_session_type"
              c:identifier="mirage_session_get_session_type">
        <doc xml:space="preserve">Retrieves session type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">session type</doc>
          <type name="SessionType" c:type="MirageSessionType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_track_after"
              c:identifier="mirage_session_get_track_after"
              throws="1">
        <doc xml:space="preserve">Retrieves track that comes after @track.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">a track</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_before"
              c:identifier="mirage_session_get_track_before"
              throws="1">
        <doc xml:space="preserve">Retrieves track that comes before @track.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">a track</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_address"
              c:identifier="mirage_session_get_track_by_address"
              throws="1">
        <doc xml:space="preserve">Retrieves track by address. @address must be valid (disc-relative) sector
address that is part of the track to be retrieved (i.e. lying between tracks's
start and end sector).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address belonging to track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_index"
              c:identifier="mirage_session_get_track_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves track by index. If @index is negative, tracks from the end of
layout are retrieved (e.g. -1 is for last track, -2 for second-to-last
track, etc.). If @index is out of range, regardless of the sign, the
function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_track_by_number"
              c:identifier="mirage_session_get_track_by_number"
              throws="1">
        <doc xml:space="preserve">Retrieves track by track number.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">number of track to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_contains_address"
              c:identifier="mirage_session_layout_contains_address">
        <doc xml:space="preserve">Checks whether the session contains the given address or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address falls inside session, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address to be checked</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_get_first_track"
              c:identifier="mirage_session_layout_get_first_track">
        <doc xml:space="preserve">Retrieves track number of the first track in the session layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">first track number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_length"
              c:identifier="mirage_session_layout_get_length">
        <doc xml:space="preserve">Retrieves length of the session layout. This means the length of
all tracks combined, including lead-in and lead-out tracks. The returned
length is given in sectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">session layout length</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_session_number"
              c:identifier="mirage_session_layout_get_session_number">
        <doc xml:space="preserve">Retrieves sessions's session number.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">session number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_start_sector"
              c:identifier="mirage_session_layout_get_start_sector">
        <doc xml:space="preserve">Retrieves start sector of the session layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">start sector</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_set_first_track"
              c:identifier="mirage_session_layout_set_first_track">
        <doc xml:space="preserve">Sets first track number to @first_track. This is a number that is
assigned to the first track in the session layout.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="first_track" transfer-ownership="none">
            <doc xml:space="preserve">first track number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_set_session_number"
              c:identifier="mirage_session_layout_set_session_number">
        <doc xml:space="preserve">Sets sessions's session number.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">session number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_set_start_sector"
              c:identifier="mirage_session_layout_set_start_sector">
        <doc xml:space="preserve">Sets start sector of the session layout to @start_sector. This is a sector at which
the first track in the session layout will start.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="start_sector" transfer-ownership="none">
            <doc xml:space="preserve">start sector</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_code"
              c:identifier="mirage_session_remove_language_by_code"
              throws="1">
        <doc xml:space="preserve">Removes language from session.

@code is language code the language to be removed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code of language to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_index"
              c:identifier="mirage_session_remove_language_by_index"
              throws="1">
        <doc xml:space="preserve">Removes language from session.

@index is the index of the language to be removed. This function calls
mirage_session_get_language_by_index() so @index behavior is determined by that
function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of language to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_object"
              c:identifier="mirage_session_remove_language_by_object">
        <doc xml:space="preserve">Removes language from session.

@language is a #MirageLanguage object to be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="language" transfer-ownership="none">
            <doc xml:space="preserve">language object to be removed</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_track_by_index"
              c:identifier="mirage_session_remove_track_by_index"
              throws="1">
        <doc xml:space="preserve">Removes track from session layout.

@index is the index of the track to be removed. This function calls
mirage_session_get_track_by_index() so @index behavior is determined by that
function.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of track to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_track_by_number"
              c:identifier="mirage_session_remove_track_by_number"
              throws="1">
        <doc xml:space="preserve">Removes track from session layout.

@number is track number of the track to be removed.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">track number of track to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_track_by_object"
              c:identifier="mirage_session_remove_track_by_object">
        <doc xml:space="preserve">Removes track from session layout.

@track is a #MirageTrack object to be removed.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">track object to be removed</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cdtext_data"
              c:identifier="mirage_session_set_cdtext_data"
              throws="1">
        <doc xml:space="preserve">Sets CD-TEXT data for session. It internally creates and uses #MirageCdTextCoder
object as a decoder to decode data in @data. Decoded data is stored in #MirageLanguage
objects in both session and its tracks. Therefore session must have same number of tracks
as the encoded CD-TEXT data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">buffer containing encoded CD-TEXT data</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of data in buffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_leadout_length"
              c:identifier="mirage_session_set_leadout_length">
        <doc xml:space="preserve">Sets session's leadout length to @length. It does so by creating NULL fragment
and adding it to leadout. This function is internally used to properly handle
multi-session disc layouts. The length is given in sectors.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">leadout length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mcn" c:identifier="mirage_session_set_mcn">
        <doc xml:space="preserve">Sets MCN (Media Catalogue Number).

Because MCN is stored in subchannel data, this function silently
fails if any of session's tracks contains fragments with subchannel
data provided.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="mcn" transfer-ownership="none">
            <doc xml:space="preserve">MCN</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_session_type"
              c:identifier="mirage_session_set_session_type">
        <doc xml:space="preserve">Sets session type. @type must be one of #MirageSessionTypes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSession</doc>
            <type name="Session" c:type="MirageSession*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">session type</doc>
            <type name="SessionType" c:type="MirageSessionType"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SessionPrivate" c:type="MirageSessionPrivate*"/>
      </field>
      <glib:signal name="layout-changed" when="last">
        <doc xml:space="preserve">Emitted when a layout of #MirageSession changed in a way that causes a bottom-up change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="SessionClass"
            c:type="MirageSessionClass"
            glib:is-gtype-struct-for="Session">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageSession&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <record name="SessionPrivate" c:type="MirageSessionPrivate" disguised="1">
    </record>
    <enumeration name="SessionType" c:type="MirageSessionType">
      <doc xml:space="preserve">Session type.</doc>
      <member name="cdda" value="0" c:identifier="MIRAGE_SESSION_CDDA">
        <doc xml:space="preserve">CD AUDIO</doc>
      </member>
      <member name="cdrom" value="1" c:identifier="MIRAGE_SESSION_CDROM">
        <doc xml:space="preserve">CD-ROM</doc>
      </member>
      <member name="cdi" value="2" c:identifier="MIRAGE_SESSION_CDI">
        <doc xml:space="preserve">CD-I</doc>
      </member>
      <member name="cdrom_xa" value="3" c:identifier="MIRAGE_SESSION_CDROM_XA">
        <doc xml:space="preserve">CD-ROM XA</doc>
      </member>
    </enumeration>
    <interface name="Stream"
               c:symbol-prefix="stream"
               c:type="MirageStream"
               glib:type-name="MirageStream"
               glib:get-type="mirage_stream_get_type"
               glib:type-struct="StreamInterface">
      <doc xml:space="preserve">A stream object.</doc>
      <virtual-method name="get_filename" invoker="get_filename">
        <doc xml:space="preserve">Retrieves the name to file on which the stream is opened. If @self is
a filter stream in the filter stream chain, the filename is obtained from
the stream at the bottom of the chain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the filename.
The buffer belongs to the stream object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_writable" invoker="is_writable">
        <doc xml:space="preserve">Queries the stream (chain) for write support. For the stream to be
writable, the stream object implementation itself must support write
operations, and any stream objects below it in the stream chain must
also be writable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream (chain) is writable, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="move_file" invoker="move_file" throws="1">
        <doc xml:space="preserve">Attempts to move the file on top of which the stream (chain) is opened
to @new_filename. If supported, native move operations are used,
otherwise a copy + delete fallback is used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="new_filename" transfer-ownership="none">
            <doc xml:space="preserve">the new filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read" invoker="read" throws="1">
        <doc xml:space="preserve">Attempts to read @count bytes from stream into the buffer starting at
@buffer. Will block during the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes read, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to read data into</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to read from stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" invoker="seek" throws="1">
        <doc xml:space="preserve">Seeks in the stream by the given @offset, modified by @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset to seek</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">seek type</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell" invoker="tell">
        <doc xml:space="preserve">Retrieves the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset from the beginning of the stream.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write" invoker="write" throws="1">
        <doc xml:space="preserve">Attempts to write @count bytes to stream from the buffer starting at
@buffer. Will block during the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes written, or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to write data from</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to write to stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_filename" c:identifier="mirage_stream_get_filename">
        <doc xml:space="preserve">Retrieves the name to file on which the stream is opened. If @self is
a filter stream in the filter stream chain, the filename is obtained from
the stream at the bottom of the chain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the filename.
The buffer belongs to the stream object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_g_input_stream"
              c:identifier="mirage_stream_get_g_input_stream">
        <doc xml:space="preserve">Constructs and returns a compatibility object inheriting a #GInputStream.
This is to allow regular GIO stream objects (for example, a
#GDataInputStream) to be chained on top of our filter stream chain.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream. The reference should be
released using g_object_unref() when no longer needed.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_writable" c:identifier="mirage_stream_is_writable">
        <doc xml:space="preserve">Queries the stream (chain) for write support. For the stream to be
writable, the stream object implementation itself must support write
operations, and any stream objects below it in the stream chain must
also be writable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the stream (chain) is writable, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move_file"
              c:identifier="mirage_stream_move_file"
              throws="1">
        <doc xml:space="preserve">Attempts to move the file on top of which the stream (chain) is opened
to @new_filename. If supported, native move operations are used,
otherwise a copy + delete fallback is used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="new_filename" transfer-ownership="none">
            <doc xml:space="preserve">the new filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="mirage_stream_read" throws="1">
        <doc xml:space="preserve">Attempts to read @count bytes from stream into the buffer starting at
@buffer. Will block during the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes read, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to read data into</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to read from stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="mirage_stream_seek" throws="1">
        <doc xml:space="preserve">Seeks in the stream by the given @offset, modified by @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset to seek</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">seek type</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="mirage_stream_tell">
        <doc xml:space="preserve">Retrieves the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset from the beginning of the stream.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="mirage_stream_write" throws="1">
        <doc xml:space="preserve">Attempts to write @count bytes to stream from the buffer starting at
@buffer. Will block during the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of bytes written, or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFileStream</doc>
            <type name="Stream" c:type="MirageStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to write data from</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to write to stream</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="StreamInterface"
            c:type="MirageStreamInterface"
            glib:is-gtype-struct-for="Stream">
      <doc xml:space="preserve">Provides an interface for implementing I/O streams.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_filename">
        <callback name="get_filename">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">pointer to a buffer containing the filename.
The buffer belongs to the stream object and should not be modified.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_writable">
        <callback name="is_writable">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the stream (chain) is writable, %FALSE if it is not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="move_file">
        <callback name="move_file" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
            <parameter name="new_filename" transfer-ownership="none">
              <doc xml:space="preserve">the new filename</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">number of bytes read, or -1 on error, or 0 on end of file.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">a buffer to read data into</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">number of bytes to read from stream</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">number of bytes written, or -1 on error.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">a buffer to write data from</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:space="preserve">number of bytes to write to stream</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:space="preserve">offset to seek</doc>
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">seek type</doc>
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the offset from the beginning of the stream.</doc>
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageFileStream</doc>
              <type name="Stream" c:type="MirageStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="SubChannel" c:type="MirageSubChannel">
      <doc xml:space="preserve">Subchannel type for interleaving/deinterleaving.</doc>
      <member name="w" value="0" c:identifier="SUBCHANNEL_W">
        <doc xml:space="preserve">W subchannel data</doc>
      </member>
      <member name="v" value="1" c:identifier="SUBCHANNEL_V">
        <doc xml:space="preserve">V subchannel data</doc>
      </member>
      <member name="u" value="2" c:identifier="SUBCHANNEL_U">
        <doc xml:space="preserve">U subchannel data</doc>
      </member>
      <member name="t" value="3" c:identifier="SUBCHANNEL_T">
        <doc xml:space="preserve">T subchannel data</doc>
      </member>
      <member name="s" value="4" c:identifier="SUBCHANNEL_S">
        <doc xml:space="preserve">S subchannel data</doc>
      </member>
      <member name="r" value="5" c:identifier="SUBCHANNEL_R">
        <doc xml:space="preserve">R subchannel data</doc>
      </member>
      <member name="q" value="6" c:identifier="SUBCHANNEL_Q">
        <doc xml:space="preserve">Q subchannel data</doc>
      </member>
      <member name="p" value="7" c:identifier="SUBCHANNEL_P">
        <doc xml:space="preserve">P subchannel data</doc>
      </member>
    </enumeration>
    <enumeration name="SubchannelDataFormat"
                 c:type="MirageSubchannelDataFormat">
      <doc xml:space="preserve">Subchannel file data formats.</doc>
      <member name="internal"
              value="1"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_INTERNAL">
        <doc xml:space="preserve">internal subchannel (i.e. included in track file)</doc>
      </member>
      <member name="external"
              value="2"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_EXTERNAL">
        <doc xml:space="preserve">external subchannel (i.e. provided by separate file)</doc>
      </member>
      <member name="pw96_interleaved"
              value="16"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_PW96_INTERLEAVED">
        <doc xml:space="preserve">P-W subchannel, 96 bytes, interleaved</doc>
      </member>
      <member name="pw96_linear"
              value="32"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_PW96_LINEAR">
        <doc xml:space="preserve">P-W subchannel, 96 bytes, linear</doc>
      </member>
      <member name="rw96"
              value="64"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_RW96">
        <doc xml:space="preserve">R-W subchannel, 96 bytes, cooked</doc>
      </member>
      <member name="q16"
              value="128"
              c:identifier="MIRAGE_SUBCHANNEL_DATA_FORMAT_Q16">
        <doc xml:space="preserve">Q subchannel, 16 bytes</doc>
      </member>
    </enumeration>
    <class name="Track"
           c:symbol-prefix="track"
           c:type="MirageTrack"
           parent="Object"
           glib:type-name="MirageTrack"
           glib:get-type="mirage_track_get_type"
           glib:type-struct="TrackClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageTrack&lt;/structname&gt;
structure are private to the #MirageTrack implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <method name="add_fragment" c:identifier="mirage_track_add_fragment">
        <doc xml:space="preserve">Adds a fragment implementation to track. @index is index at which fragment
should be added. Negative index denotes index going backwards (i.e. -1 adds
fragment at the end, -2 adds fragment second-to-last, etc.). If index, either
negative or positive, is too big, fragment is respectively added at the
beginning or at the end of the track.

&lt;note&gt;
Currently, unlike in most libMirage's *_add_* functions, @fragment argument cannot be %NULL.
This is because specific fragment implementation is required and therefore must be
provided by the caller.
&lt;/note&gt;

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index at which fragment should be added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fragment" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageFragment to be added</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_index"
              c:identifier="mirage_track_add_index"
              throws="1">
        <doc xml:space="preserve">Adds index to track.

@address is track-relative address at which index should be added. As it determines
position of the index, it also determines the number index will be assigned.

If address falls before index 01 (i.e. if it's less than address that was set
using mirage_track_set_track_start()), the function fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address at which the index is to be added</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_language"
              c:identifier="mirage_track_add_language"
              throws="1">
        <doc xml:space="preserve">Adds language to track.

@code is language code that should be assigned to added language. If
language with that code is already present in the track, the function fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code for the added language</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="language"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #MirageLanguage to be added</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_fragments"
              c:identifier="mirage_track_enumerate_fragments">
        <doc xml:space="preserve">Iterates over fragments list, calling @func for each fragment in the layout.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumFragmentCallback"
                  c:type="MirageEnumFragmentCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_indices"
              c:identifier="mirage_track_enumerate_indices">
        <doc xml:space="preserve">Iterates over indices list, calling @func for each index.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumIndexCallback" c:type="MirageEnumIndexCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_languages"
              c:identifier="mirage_track_enumerate_languages">
        <doc xml:space="preserve">Iterates over languages list, calling @func for each language.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">callback function</doc>
            <type name="EnumLanguageCallback"
                  c:type="MirageEnumLanguageCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_fragment_with_subchannel"
              c:identifier="mirage_track_find_fragment_with_subchannel"
              throws="1">
        <doc xml:space="preserve">Retrieves first fragment that contains subchannel data. A reference to fragment
is stored in @fragment; it should be released with g_object_unref() when no
longer needed.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageFragment on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_adr" c:identifier="mirage_track_get_adr">
        <doc xml:space="preserve">Retrieves track's ADR.

&lt;note&gt;
At the moment, ADR is always returned as 1.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">ADR value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ctl" c:identifier="mirage_track_get_ctl">
        <doc xml:space="preserve">Retrieves track's CTL. CTL is calculated on basis of track mode and track
flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">CTL value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="mirage_track_get_flags">
        <doc xml:space="preserve">Retrieves track flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">track flags</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fragment_by_address"
              c:identifier="mirage_track_get_fragment_by_address"
              throws="1">
        <doc xml:space="preserve">Retrieves fragment by address. @address must be valid (track-relative) sector
address that is part of the fragment to be retrieved (i.e. lying between fragment's
start and end address).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageFragment on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address belonging to fragment to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fragment_by_index"
              c:identifier="mirage_track_get_fragment_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves fragment by index. If @index is negative, fragments from the end of
track are retrieved (e.g. -1 is for last track, -2 for second-to-last
track, etc.). If @index is out of range, regardless of the sign, the
function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageFragment on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of fragment to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_index_by_address"
              c:identifier="mirage_track_get_index_by_address"
              throws="1">
        <doc xml:space="preserve">Retrieves index by address. @address must be valid (track-relative) sector
address that is part of the index to be retrieved (i.e. lying between index's
start and end sector).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageIndex on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Index" c:type="MirageIndex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address belonging to index to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_index_by_number"
              c:identifier="mirage_track_get_index_by_number"
              throws="1">
        <doc xml:space="preserve">Retrieves index by index number. If @number is negative, indices from the end of
track are retrieved (e.g. -1 is for index, -2 for second-to-last index, etc.).
If @number is out of range, regardless of the sign, the function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageIndex on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Index" c:type="MirageIndex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">index number of index to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_isrc" c:identifier="mirage_track_get_isrc">
        <doc xml:space="preserve">Retrieves ISRC.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to ISRC string, or %NULL. The string
belongs to the object and should not be modified.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_language_by_code"
              c:identifier="mirage_track_get_language_by_code"
              throws="1">
        <doc xml:space="preserve">Retrieves language by language code.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageLanguage on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Language" c:type="MirageLanguage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code of language to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_language_by_index"
              c:identifier="mirage_track_get_language_by_index"
              throws="1">
        <doc xml:space="preserve">Retrieves language by index. If @index is negative, languages from the end of
track are retrieved (e.g. -1 is for last language, -2 for second-to-last
language, etc.). If @index is out of range, regardless of the sign, the
function fails.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageLanguage on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Language" c:type="MirageLanguage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of language to be retrieved</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_next" c:identifier="mirage_track_get_next" throws="1">
        <doc xml:space="preserve">Retrieves track that is placed after @self in session layout</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_fragments"
              c:identifier="mirage_track_get_number_of_fragments">
        <doc xml:space="preserve">Retrieves number of fragments making up the track.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of fragments</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_indices"
              c:identifier="mirage_track_get_number_of_indices">
        <doc xml:space="preserve">Retrieves number of indices the track contains. Note that this includes
only indices greater than 01.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of indices</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number_of_languages"
              c:identifier="mirage_track_get_number_of_languages">
        <doc xml:space="preserve">Retrieves number of languages the track contains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of languages</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prev" c:identifier="mirage_track_get_prev" throws="1">
        <doc xml:space="preserve">Retrieves track that is placed before @self in session layout.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #MirageTrack on success, %NULL on failure.
The reference to the object should be released using g_object_unref()
when no longer needed.</doc>
          <type name="Track" c:type="MirageTrack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sector"
              c:identifier="mirage_track_get_sector"
              throws="1">
        <doc xml:space="preserve">Retrieves a sector. @address is sector address for which a #MirageSector
object representing sector should be returned. @abs specifies whether @address
is absolute or relative; if %TRUE, @address is absolute (i.e. relative to start
of the disc), if %FALSE, it is relative (i.e. relative to start of the track).

A reference to sector is stored in @sector; it should be released with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">sector object on success, %NULL on failure. The sector object
should be released with g_object_unref() when no longer needed.</doc>
          <type name="Sector" c:type="MirageSector*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">sector address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="abs" transfer-ownership="none">
            <doc xml:space="preserve">absolute address</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sector_type"
              c:identifier="mirage_track_get_sector_type">
        <doc xml:space="preserve">Retrieves type of sectors comprising the track.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">sector type</doc>
          <type name="SectorType" c:type="MirageSectorType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_track_start"
              c:identifier="mirage_track_get_track_start">
        <doc xml:space="preserve">Retrieves track start address. This is track-relative address at which pregap
ends and track "logically" starts (i.e. where index changes from 00 to 01).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">track start address</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_contains_address"
              c:identifier="mirage_track_layout_contains_address">
        <doc xml:space="preserve">Checks whether the track contains the given address or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @address falls inside track, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address to be checked</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_get_length"
              c:identifier="mirage_track_layout_get_length">
        <doc xml:space="preserve">Retrieves track's length. The returned length is given in sectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">track length</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_session_number"
              c:identifier="mirage_track_layout_get_session_number">
        <doc xml:space="preserve">Retrieves track's session number. If track is not part of disc layout, 0
is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">session number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_start_sector"
              c:identifier="mirage_track_layout_get_start_sector">
        <doc xml:space="preserve">Retrieves track's start sector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">start sector</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_get_track_number"
              c:identifier="mirage_track_layout_get_track_number">
        <doc xml:space="preserve">Retrieves track's track number.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">track number</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="layout_set_start_sector"
              c:identifier="mirage_track_layout_set_start_sector">
        <doc xml:space="preserve">Sets track's start sector.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;

&lt;note&gt;
Causes top-down change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="start_sector" transfer-ownership="none">
            <doc xml:space="preserve">start sector</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="layout_set_track_number"
              c:identifier="mirage_track_layout_set_track_number">
        <doc xml:space="preserve">Set track's track number.

&lt;note&gt;
Intended for internal use only.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="track_number" transfer-ownership="none">
            <doc xml:space="preserve">track number</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_sector"
              c:identifier="mirage_track_put_sector"
              throws="1">
        <doc xml:space="preserve">Writes the @sector to track. The address at which sector is written
is retrieved from sector's property; for this function to succeed,
the address must either fall within track's layout (i.e., the track's
fragment(s) must have sufficient length "reserved" to accept sector),
or, alternatively, the sector address is allowed to equal track's
current lenght plus one. In the latter case, the track's length is
incremented when the sector is written (i.e., the corresponding track's
fragment is extended before data is written to it).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="sector" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageSector representing sector to be written</doc>
            <type name="Sector" c:type="MirageSector*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fragment_by_index"
              c:identifier="mirage_track_remove_fragment_by_index"
              throws="1">
        <doc xml:space="preserve">Removes fragment from track.

@index is the index of the fragment to be removed. This function calls
mirage_track_get_fragment_by_index() so @index behavior is determined by that
function.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of fragment to be removed.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fragment_by_object"
              c:identifier="mirage_track_remove_fragment_by_object">
        <doc xml:space="preserve">Removes fragment from track.

@fragment is a #MirageFragment object to be removed.

&lt;note&gt;
Causes bottom-up change.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="fragment" transfer-ownership="none">
            <doc xml:space="preserve">fragment object to be removed</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_index_by_number"
              c:identifier="mirage_track_remove_index_by_number"
              throws="1">
        <doc xml:space="preserve">Removes index from track. This causes index numbers of remaining indices to be readjusted.

@number is index number of index to be removed. It must be greater or equal than 2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="number" transfer-ownership="none">
            <doc xml:space="preserve">index number of index to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_index_by_object"
              c:identifier="mirage_track_remove_index_by_object">
        <doc xml:space="preserve">Removes index from track.This causes index numbers of remaining indices to be readjusted.

@index is a #MirageIndex object to be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index object to be removed</doc>
            <type name="Index" c:type="MirageIndex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_code"
              c:identifier="mirage_track_remove_language_by_code"
              throws="1">
        <doc xml:space="preserve">Removes language from track.

@code is language code the language to be removed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">language code of language to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_index"
              c:identifier="mirage_track_remove_language_by_index"
              throws="1">
        <doc xml:space="preserve">Removes language from track.

@index is the index of the language to be removed. This function calls
mirage_track_get_language_by_index() so @index behavior is determined by that
function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of language to be removed</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_language_by_object"
              c:identifier="mirage_track_remove_language_by_object">
        <doc xml:space="preserve">Removes language from track.

@language is a #MirageLanguage object to be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="language" transfer-ownership="none">
            <doc xml:space="preserve">language object to be removed</doc>
            <type name="Language" c:type="MirageLanguage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ctl" c:identifier="mirage_track_set_ctl">
        <doc xml:space="preserve">Sets track's CTL; the function translates CTL into track flags and sets them
using mirage_track_set_flags(). Track mode set with CTL is ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="ctl" transfer-ownership="none">
            <doc xml:space="preserve">track's CTL</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="mirage_track_set_flags">
        <doc xml:space="preserve">Sets track flags. @flags must be a combination of #MirageTrackFlags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">track flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_isrc" c:identifier="mirage_track_set_isrc">
        <doc xml:space="preserve">Sets MCN.

Because ISRC is stored in subchannel data, this function silently
fails if track contains fragments with subchannel data provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="isrc" transfer-ownership="none">
            <doc xml:space="preserve">ISRC</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sector_type"
              c:identifier="mirage_track_set_sector_type">
        <doc xml:space="preserve">Sets sector type. @mode must be one of #MirageSectorType.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="sector_type" transfer-ownership="none">
            <doc xml:space="preserve">type of sectors comprising the track</doc>
            <type name="SectorType" c:type="MirageSectorType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_track_start"
              c:identifier="mirage_track_set_track_start">
        <doc xml:space="preserve">Sets track start address. @track_start is a track-relative address at which track's
pregap ends and track "logically" starts (i.e. where index changes from 00 to 01). Note that
this is not the same as start address that is set by mirage_track_layout_set_start_sector();
that one sets the address at which track "physically" starts (i.e. where index 00 starts).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageTrack</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </instance-parameter>
          <parameter name="track_start" transfer-ownership="none">
            <doc xml:space="preserve">track start address</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TrackPrivate" c:type="MirageTrackPrivate*"/>
      </field>
      <glib:signal name="layout-changed" when="last">
        <doc xml:space="preserve">Emitted when a layout of #MirageTrack changed in a way that causes a bottom-up change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="TrackClass"
            c:type="MirageTrackClass"
            glib:is-gtype-struct-for="Track">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageTrack&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
    </record>
    <enumeration name="TrackConstant" c:type="MirageTrackConstant">
      <doc xml:space="preserve">Track constants.</doc>
      <member name="leadin" value="0" c:identifier="MIRAGE_TRACK_LEADIN">
        <doc xml:space="preserve">Lead-in track</doc>
      </member>
      <member name="leadout" value="170" c:identifier="MIRAGE_TRACK_LEADOUT">
        <doc xml:space="preserve">Lead-out track</doc>
      </member>
    </enumeration>
    <enumeration name="TrackFlag" c:type="MirageTrackFlag">
      <doc xml:space="preserve">Track flags.</doc>
      <member name="fourchannel"
              value="1"
              c:identifier="MIRAGE_TRACK_FLAG_FOURCHANNEL">
        <doc xml:space="preserve">four channel audio</doc>
      </member>
      <member name="copypermitted"
              value="2"
              c:identifier="MIRAGE_TRACK_FLAG_COPYPERMITTED">
        <doc xml:space="preserve">copy permitted</doc>
      </member>
      <member name="preemphasis"
              value="4"
              c:identifier="MIRAGE_TRACK_FLAG_PREEMPHASIS">
        <doc xml:space="preserve">pre-emphasis</doc>
      </member>
    </enumeration>
    <record name="TrackPrivate" c:type="MirageTrackPrivate" disguised="1">
    </record>
    <constant name="VERSION_LONG" value="3.0.5" c:type="MIRAGE_VERSION_LONG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VERSION_MAJOR" value="3" c:type="MIRAGE_VERSION_MAJOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VERSION_MICRO" value="5" c:type="MIRAGE_VERSION_MICRO">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VERSION_MINOR" value="0" c:type="MIRAGE_VERSION_MINOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VERSION_SHORT" value="3.0" c:type="MIRAGE_VERSION_SHORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Writer"
           c:symbol-prefix="writer"
           c:type="MirageWriter"
           parent="Object"
           abstract="1"
           glib:type-name="MirageWriter"
           glib:get-type="mirage_writer_get_type"
           glib:type-struct="WriterClass">
      <doc xml:space="preserve">All the fields in the &lt;structname&gt;MirageWriter&lt;/structname&gt;
structure are private to the #MirageWriter implementation and
should never be accessed directly.</doc>
      <implements name="Contextual"/>
      <virtual-method name="create_fragment"
                      invoker="create_fragment"
                      throws="1">
        <doc xml:space="preserve">Creates a fragment with specified @role for given @track. The latter
needs to already be part of disc's layout.

The role helps writer implementation determine what kind of fragment
to create; for example, some writer implementations create dummy
fragments for pregaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">pointer to created fragment object on success, %NULL on failure</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">track for which the fragment is to be created</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
          <parameter name="role" transfer-ownership="none">
            <doc xml:space="preserve">fragment role</doc>
            <type name="FragmentRole" c:type="MirageFragmentRole"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finalize_image"
                      invoker="finalize_image"
                      throws="1">
        <doc xml:space="preserve">Finalizes the image, possibly creating the image descriptor file if
necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <doc xml:space="preserve">disc object for which the image is being written</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_image" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_parameter_boolean"
              c:identifier="mirage_writer_add_parameter_boolean">
        <doc xml:space="preserve">Adds a boolean parameter to writer's parameter sheet.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">parameter description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">default value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_parameter_enum"
              c:identifier="mirage_writer_add_parameter_enum"
              introspectable="0">
        <doc xml:space="preserve">Adds an enum parameter to writer's parameter sheet. The enum parameters
are treated as string parameters, except they have a pre-defined set
of valid values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">parameter description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">default value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated list of valid string values</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_parameter_int"
              c:identifier="mirage_writer_add_parameter_int">
        <doc xml:space="preserve">Adds an integer parameter to writer's parameter sheet.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">parameter description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">default value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_parameter_string"
              c:identifier="mirage_writer_add_parameter_string">
        <doc xml:space="preserve">Adds a string parameter to writer's parameter sheet.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">parameter name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">parameter description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <doc xml:space="preserve">default value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert_image"
              c:identifier="mirage_writer_convert_image"
              throws="1">
        <doc xml:space="preserve">Convenience function that converts an already-opened image stored in
@original_disc and writes it to @filename. If conversion progress
reporting is enabled via mirage_writer_set_conversion_progress_step(),
the #MirageWriter::conversion-progress signal is emitted at specified
time intervals during conversion.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename of output image</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="original_disc" transfer-ownership="none">
            <doc xml:space="preserve">disc layout obtained from original image</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">writer parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional %GCancellable object, NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_fragment"
              c:identifier="mirage_writer_create_fragment"
              throws="1">
        <doc xml:space="preserve">Creates a fragment with specified @role for given @track. The latter
needs to already be part of disc's layout.

The role helps writer implementation determine what kind of fragment
to create; for example, some writer implementations create dummy
fragments for pregaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">pointer to created fragment object on success, %NULL on failure</doc>
          <type name="Fragment" c:type="MirageFragment*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">track for which the fragment is to be created</doc>
            <type name="Track" c:type="MirageTrack*"/>
          </parameter>
          <parameter name="role" transfer-ownership="none">
            <doc xml:space="preserve">fragment role</doc>
            <type name="FragmentRole" c:type="MirageFragmentRole"/>
          </parameter>
        </parameters>
      </method>
      <method name="finalize_image"
              c:identifier="mirage_writer_finalize_image"
              throws="1">
        <doc xml:space="preserve">Finalizes the image, possibly creating the image descriptor file if
necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <doc xml:space="preserve">disc object for which the image is being written</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_info" c:identifier="mirage_writer_generate_info">
        <doc xml:space="preserve">Generates writer information from the input fields. It is intended as a function
for creating writer information in writer implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">writer ID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">writer name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_conversion_progress_step"
              c:identifier="mirage_writer_get_conversion_progress_step">
        <doc xml:space="preserve">Retrieves conversion progress step setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of conversion progress step.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="mirage_writer_get_info">
        <doc xml:space="preserve">Retrieves writer information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to writer information structure.  The
structure belongs to object and should not be modified.</doc>
          <type name="WriterInfo" c:type="const MirageWriterInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parameter_boolean"
              c:identifier="mirage_writer_get_parameter_boolean">
        <doc xml:space="preserve">Looks up the boolean parameter with specified @id from user-supplied
writer parameters and returns its value. If user did not supply the
parameter, its default value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">user-supplied parameter value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameter_enum"
              c:identifier="mirage_writer_get_parameter_enum">
        <doc xml:space="preserve">Looks up the enum parameter with specified @id from user-supplied
writer parameters and returns its value. If user did not supply the
parameter, its default value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">user-supplied parameter value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameter_int"
              c:identifier="mirage_writer_get_parameter_int">
        <doc xml:space="preserve">Looks up the string parameter with specified @id from user-supplied
writer parameters and returns its value. If user did not supply the
parameter, its default value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">user-supplied parameter value.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameter_string"
              c:identifier="mirage_writer_get_parameter_string">
        <doc xml:space="preserve">Looks up the string parameter with specified @id from user-supplied
writer parameters and returns its value. If user did not supply the
parameter, its default value is returned instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">user-supplied parameter value.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_parameter_ids"
              c:identifier="mirage_writer_lookup_parameter_ids">
        <doc xml:space="preserve">Retrieves the list of parameter ID strings from writer's parameter
sheet. The IDs are ordered in the same way as they were inserted into
the parameter sheet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the list of parameter
IDs. The list and its elements belong to the writer and should not be
modified.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_parameter_info"
              c:identifier="mirage_writer_lookup_parameter_info">
        <doc xml:space="preserve">Looks up the parameter with specified @id in writer's parameter sheet
and retrieves the parameter's information structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pointer to parameter's information structure on success,
%NULL on failure. The information structure belong to the writer and
should not be modified.</doc>
          <type name="WriterParameter" c:type="const MirageWriterParameter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">parameter ID string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_image"
              c:identifier="mirage_writer_open_image"
              throws="1">
        <doc xml:space="preserve">Initializes the image writer to start the writing process for @disc.
The latter should have set the image filename(s) and medium type, but
does not have to have disc layout (sessions, tracks) built yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="disc" transfer-ownership="none">
            <doc xml:space="preserve">disc object for which the image will be created</doc>
            <type name="Disc" c:type="MirageDisc*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">writer parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_conversion_progress_step"
              c:identifier="mirage_writer_set_conversion_progress_step">
        <doc xml:space="preserve">Sets conversion progress step. Setting @step to 0 disables conversion
progress reporting.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriter</doc>
            <type name="Writer" c:type="MirageWriter*"/>
          </instance-parameter>
          <parameter name="step" transfer-ownership="none">
            <doc xml:space="preserve">new conversion progress step value</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="MirageObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="WriterPrivate" c:type="MirageWriterPrivate*"/>
      </field>
      <glib:signal name="conversion-progress" when="last">
        <doc xml:space="preserve">Emitted when the image conversion progress reaches a new progress mark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">percentual image conversion progress</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="WriterClass"
            c:type="MirageWriterClass"
            glib:is-gtype-struct-for="Writer">
      <doc xml:space="preserve">The class structure for the &lt;structname&gt;MirageWriter&lt;/structname&gt; type.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="MirageObjectClass"/>
      </field>
      <field name="open_image">
        <callback name="open_image" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Writer" c:type="MirageWriter*"/>
            </parameter>
            <parameter name="disc" transfer-ownership="none">
              <type name="Disc" c:type="MirageDisc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_fragment">
        <callback name="create_fragment" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">pointer to created fragment object on success, %NULL on failure</doc>
            <type name="Fragment" c:type="MirageFragment*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageWriter</doc>
              <type name="Writer" c:type="MirageWriter*"/>
            </parameter>
            <parameter name="track" transfer-ownership="none">
              <doc xml:space="preserve">track for which the fragment is to be created</doc>
              <type name="Track" c:type="MirageTrack*"/>
            </parameter>
            <parameter name="role" transfer-ownership="none">
              <doc xml:space="preserve">fragment role</doc>
              <type name="FragmentRole" c:type="MirageFragmentRole"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finalize_image">
        <callback name="finalize_image" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #MirageWriter</doc>
              <type name="Writer" c:type="MirageWriter*"/>
            </parameter>
            <parameter name="disc" transfer-ownership="none">
              <doc xml:space="preserve">disc object for which the image is being written</doc>
              <type name="Disc" c:type="MirageDisc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="WriterInfo" c:type="MirageWriterInfo">
      <doc xml:space="preserve">A structure containing writer information. It can be obtained with call to
mirage_writer_get_info().</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">writer ID</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">writer name</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <method name="copy" c:identifier="mirage_writer_info_copy">
        <doc xml:space="preserve">Copies parser information from @info to @dest.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriterInfo to copy data from</doc>
            <type name="WriterInfo" c:type="const MirageWriterInfo*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriterInfo to copy data to</doc>
            <type name="WriterInfo" c:type="MirageWriterInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="mirage_writer_info_free">
        <doc xml:space="preserve">Frees the allocated fields in @info (but not the structure itself!).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #MirageWriterInfo to free</doc>
            <type name="WriterInfo" c:type="MirageWriterInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="WriterParameter" c:type="MirageWriterParameter">
      <doc xml:space="preserve">A structure encapsulating information about image writer parameters,
using in writer's parameter sheet.</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">parameter name</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">description of parameter</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" writable="1">
        <doc xml:space="preserve">default value for parameter. Also determines parameter type.</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </field>
      <field name="enum_values" writable="1">
        <doc xml:space="preserve">if parameter is an enum, this field contains all possible values. The variant has a signature "as".</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </field>
    </record>
    <record name="WriterPrivate" c:type="MirageWriterPrivate" disguised="1">
    </record>
    <function name="cdtext_decoder_get_block_info"
              c:identifier="mirage_cdtext_decoder_get_block_info"
              throws="1">
      <doc xml:space="preserve">Retrieves block information for CD-TEXT block specified by @block. @block
must be a valid block number (0-7). Language code assigned to the block is
stored in @code, code of character set used within block is stored in
@charset and block's copyright flag is stored in @copyright.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="block" transfer-ownership="none">
          <doc xml:space="preserve">block number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="code"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store language code, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="charset"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store character set, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="copyright"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store copyright flag, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_decoder_get_data"
              c:identifier="mirage_cdtext_decoder_get_data">
      <doc xml:space="preserve">Retrieves data for CD-TEXT block specified by @block. @block must be a valid
block number (0-7). It calls @callback_func for every data pack that has been
encoded in the block.

If @callback_func returns %FALSE, the function immediately returns %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="block" transfer-ownership="none">
          <doc xml:space="preserve">block number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="callback_func"
                   transfer-ownership="none"
                   scope="call"
                   closure="3">
          <doc xml:space="preserve">callback function</doc>
          <type name="CdTextDataCallback" c:type="MirageCdTextDataCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_decoder_init"
              c:identifier="mirage_cdtext_decoder_init">
      <doc xml:space="preserve">Initializes CD-TEXT decoder. @buffer is the buffer containing encoded CD-TEXT
data and @buflen is length of data in the buffer.

This function decodes CD-TEXT data and stores it in decoder's internal representation.
Information about decoded CD-TEXT blocks and their data can be obtained via
subsequent calls to mirage_cdtext_decoder_get_block_info() and
mirage_cdtext_decoder_get_data().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing encoded data</doc>
          <array length="2" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="buflen" transfer-ownership="none">
          <doc xml:space="preserve">length of data in buffer</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_encoder_add_data"
              c:identifier="mirage_cdtext_encoder_add_data">
      <doc xml:space="preserve">Adds data to the encoder. @code is language code of the block the data
should be added to. @type denotes pack type and should be one of #MirageLanguagePackTypes.
@track is track number the data belongs to, or 0 if data is global (belongs to disc/session).
@data is buffer containing data to be added, and @data_len is length of data in the buffer.

This function does not perform any encoding yet; it merely adds the data into
encoder's internal representation of CD-TEXT block.

&lt;note&gt;
Block needs to have its information set with mirage_cdtext_encoder_set_block_info()
before data can be added to it.
&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">language code</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">data type</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="track" transfer-ownership="none">
          <doc xml:space="preserve">track number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">data</doc>
          <array length="5" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="data_len" transfer-ownership="none">
          <doc xml:space="preserve">data length</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_encoder_encode"
              c:identifier="mirage_cdtext_encoder_encode">
      <doc xml:space="preserve">Encodes the CD-TEXT data. Pointer to buffer containing the encoded data is
stored in @buffer, and length of data in buffer is stored in @buflen.

Note that @buffer is the same as the argument passed to mirage_cdtext_encoder_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="buffer"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">location to store buffer</doc>
          <array length="2" zero-terminated="0" c:type="guint8**">
            <type name="guint8" c:type="guint8*"/>
          </array>
        </parameter>
        <parameter name="buflen"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">location to store buffer length</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_encoder_init"
              c:identifier="mirage_cdtext_encoder_init">
      <doc xml:space="preserve">Initializes CD-TEXT encoder.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">buffer into which data will be encoded</doc>
          <array length="2" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="buflen" transfer-ownership="none">
          <doc xml:space="preserve">buffer length</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cdtext_encoder_set_block_info"
              c:identifier="mirage_cdtext_encoder_set_block_info"
              throws="1">
      <doc xml:space="preserve">Sets block information for CD-TEXT block specified by @block. @block must be
a valid block number (0-7). @code is the language code that is to be assigned
to the block (e.g. 9 for English), @charset denotes character set that is used within
the block, and @copyright is the copyright flag for the block.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #MirageCdTextCoder</doc>
          <type name="CdTextCoder" c:type="MirageCdTextCoder*"/>
        </parameter>
        <parameter name="block" transfer-ownership="none">
          <doc xml:space="preserve">block number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">language code</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="charset" transfer-ownership="none">
          <doc xml:space="preserve">character set</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="copyright" transfer-ownership="none">
          <doc xml:space="preserve">copyright flag</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_writer"
              c:identifier="mirage_create_writer"
              throws="1">
      <doc xml:space="preserve">Attempts to create an instance of image writer whose ID is @writer_id.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">newly-created writer object on success, %NULL
on failure. The reference to the object should be released using
g_object_unref() when no longer needed.</doc>
        <type name="Writer" c:type="MirageWriter*"/>
      </return-value>
      <parameters>
        <parameter name="writer_id" transfer-ownership="none">
          <doc xml:space="preserve">ID of writer to create</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enumerate_filter_streams"
              c:identifier="mirage_enumerate_filter_streams"
              throws="1">
      <doc xml:space="preserve">Iterates over list of supported filter streams, calling @func for each filter stream.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve">callback function</doc>
          <type name="EnumFilterStreamInfoCallback"
                c:type="MirageEnumFilterStreamInfoCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="enumerate_parsers"
              c:identifier="mirage_enumerate_parsers"
              throws="1">
      <doc xml:space="preserve">Iterates over list of supported parsers, calling @func for each parser.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve">callback function</doc>
          <type name="EnumParserInfoCallback"
                c:type="MirageEnumParserInfoCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="enumerate_writers"
              c:identifier="mirage_enumerate_writers"
              throws="1">
      <doc xml:space="preserve">Iterates over list of supported writers, calling @func for each writers.

If @func returns %FALSE, the function immediately returns %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve">callback function</doc>
          <type name="EnumWriterInfoCallback"
                c:type="MirageEnumWriterInfoCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark"
              c:identifier="mirage_error_quark"
              moved-to="Error.quark">
      <doc xml:space="preserve">Registers an error quark for libMirage if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The error quark used for libMirage errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="get_filter_streams_info"
              c:identifier="mirage_get_filter_streams_info"
              throws="1">
      <doc xml:space="preserve">Retrieves information structures for supported filter streams.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of filter streams' information structures</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="MirageFilterStreamInfo**">
            <type name="FilterStreamInfo" c:type="MirageFilterStreamInfo*"/>
          </array>
        </parameter>
        <parameter name="num_filter_streams"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported filter streams</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_filter_streams_type"
              c:identifier="mirage_get_filter_streams_type"
              throws="1">
      <doc xml:space="preserve">Retrieves #GType values for supported filter streams.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="types"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of filter streams' #GType values</doc>
          <array length="1" zero-terminated="0" c:type="GType**">
            <type name="GType" c:type="GType*"/>
          </array>
        </parameter>
        <parameter name="num_filter_streams"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported filter streams</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_parsers_info"
              c:identifier="mirage_get_parsers_info"
              throws="1">
      <doc xml:space="preserve">Retrieves information structures for supported parsers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of parsers' information structures</doc>
          <array length="1" zero-terminated="0" c:type="MirageParserInfo**">
            <type name="ParserInfo" c:type="MirageParserInfo*"/>
          </array>
        </parameter>
        <parameter name="num_parsers"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported parsers</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_parsers_type"
              c:identifier="mirage_get_parsers_type"
              throws="1">
      <doc xml:space="preserve">Retrieves #GType values for supported parsers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="types"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of parsers' #GType values</doc>
          <array length="1" zero-terminated="0" c:type="GType**">
            <type name="GType" c:type="GType*"/>
          </array>
        </parameter>
        <parameter name="num_parsers"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported parsers</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_supported_debug_masks"
              c:identifier="mirage_get_supported_debug_masks"
              throws="1">
      <doc xml:space="preserve">Retrieves the pointer to array of supported debug masks and stores it in @masks.
The array consists of one or more structures of type #MirageDebugMaskInfo. The
number of elements in the array is stored in @num_masks. The array belongs to
libMirage and should not be altered or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="masks"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">location to store pointer to masks array</doc>
          <array length="1" zero-terminated="0" c:type="MirageDebugMaskInfo**">
            <type name="DebugMaskInfo" c:type="MirageDebugMaskInfo*"/>
          </array>
        </parameter>
        <parameter name="num_masks"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">location to store number of elements in masks array</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_writers_info"
              c:identifier="mirage_get_writers_info"
              throws="1">
      <doc xml:space="preserve">Retrieves information structures for supported parsers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of writers' information structures</doc>
          <array length="1" zero-terminated="0" c:type="MirageWriterInfo**">
            <type name="WriterInfo" c:type="MirageWriterInfo*"/>
          </array>
        </parameter>
        <parameter name="num_writers"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported writers</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_writers_type"
              c:identifier="mirage_get_writers_type"
              throws="1">
      <doc xml:space="preserve">Retrieves #GType values for supported writers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="types"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">array of writers' #GType values</doc>
          <array length="1" zero-terminated="0" c:type="GType**">
            <type name="GType" c:type="GType*"/>
          </array>
        </parameter>
        <parameter name="num_writers"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">number of supported writers</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_ascii2isrc" c:identifier="mirage_helper_ascii2isrc">
      <doc xml:space="preserve">Converts ASCII character @c into ISRC character.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">ISRC character</doc>
        <type name="guint8" c:type="guint8"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">ASCII character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_bcd2hex" c:identifier="mirage_helper_bcd2hex">
      <doc xml:space="preserve">Converts bcd-encoded integer into hex-encoded integer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">hex-encoded integer</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="bcd" transfer-ownership="none">
          <doc xml:space="preserve">bcd-encoded integer</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_calculate_crc16"
              c:identifier="mirage_helper_calculate_crc16">
      <doc xml:space="preserve">Calculates the CRC-16 checksum of the data stored in @data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">CRC-16 checksum of data</doc>
        <type name="guint16" c:type="guint16"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="crctab" transfer-ownership="none">
          <doc xml:space="preserve">pointer to CRC polynomial table</doc>
          <array zero-terminated="0" c:type="guint16*" fixed-size="256">
            <type name="guint16" c:type="guint16"/>
          </array>
        </parameter>
        <parameter name="reflected" transfer-ownership="none">
          <doc xml:space="preserve">whether to use the reflected algorithm</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="invert" transfer-ownership="none">
          <doc xml:space="preserve">whether the result should be inverted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_calculate_crc32_fast"
              c:identifier="mirage_helper_calculate_crc32_fast">
      <doc xml:space="preserve">Calculates the CRC-32 checksum of the data stored in @data. This is
fast slice-by-8 implementation that processes 8 bytes at a time, and
requires @crctab to be allocating using mirage_helper_init_crc32_lut()
with slice parameter set to 8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">CRC-32 checksum of data</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="crctab" transfer-ownership="none">
          <doc xml:space="preserve">pointer to CRC polynomial table</doc>
          <array zero-terminated="0" c:type="guint32*" fixed-size="2048">
            <type name="guint32" c:type="guint32"/>
          </array>
        </parameter>
        <parameter name="reflected" transfer-ownership="none">
          <doc xml:space="preserve">whether to use the reflected algorithm</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="invert" transfer-ownership="none">
          <doc xml:space="preserve">whether the initial value and result should be inverted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_calculate_crc32_standard"
              c:identifier="mirage_helper_calculate_crc32_standard">
      <doc xml:space="preserve">Calculates the CRC-32 checksum of the data stored in @data. This is
standard inplementation that processes 1 byte at a time, and requires
@crctab to be allocated using mirage_helper_init_crc32_lut() with slice
parameter set to 1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">CRC-32 checksum of data</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="crctab" transfer-ownership="none">
          <doc xml:space="preserve">pointer to CRC polynomial table</doc>
          <array zero-terminated="0" c:type="guint32*" fixed-size="256">
            <type name="guint32" c:type="guint32"/>
          </array>
        </parameter>
        <parameter name="reflected" transfer-ownership="none">
          <doc xml:space="preserve">whether to use the reflected algorithm</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="invert" transfer-ownership="none">
          <doc xml:space="preserve">whether the initial value and result should be inverted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_determine_sector_type"
              c:identifier="mirage_helper_determine_sector_type">
      <doc xml:space="preserve">Determines sector type from its data, based on first 16 bytes, which
correspond to sync pattern and header.

This function is intened to be used in image parsers, for determining
track mode in cases when full (2352-byte) sector data is available.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">sector type (one of %MirageSectorType)</doc>
        <type name="SectorType" c:type="MirageSectorType"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing at least first 16 bytes of sector's data</doc>
          <type name="guint8" c:type="const guint8*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_encoding_from_bom"
              c:identifier="mirage_helper_encoding_from_bom">
      <doc xml:space="preserve">Tries to decode BOM provided in @buffer, and based on the result
returns the following encodings: UTF-32BE, UTF32-LE, UTF-16LE, UTF-16BE
or UTF-8 (if BOM is not valid).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the name of encoding, or %NULL if UTF-8 is
assumed. The string is statically stored and should not be modified.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a 4-byte buffer containing BOM</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="4">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_find_data_file"
              c:identifier="mirage_helper_find_data_file">
      <doc xml:space="preserve">Attempts to find a file with filename @filename and path @path. @filename can
be file's basename or an absolute path. @path can be either directory path (in
this case, it must end with '/') or a filename (i.e. of file descriptor).

If @filename is an absolute path, its existence is first checked. If it
does not exist, search (see below) is performed in @filename's dirname. If
still no match is found and @path is not %NULL, @path's dirname is combined
with @filename's basename, and the combination's existence is checked. If
that fails as well, search (see below) is performed in @path's dirname.
Searching in the directory is performed as follows. Directory is opened
and its content is case-insensitively compared to @filename's basename.
All filenames whose beginning match @filename are considered, and the
shortest one is returned. This way, all possible case variations
(i.e. file.iso, FILE.ISO, FiLe.IsO, etc.) are taken into account.
This function can return a filename with additional suffices, but only if
a file without those extra suffices does not exist. E.g., if search is
done for 'data.img', and only 'data.img.gz' exists, it will be returned.
However, if both 'data.img' and 'data.img.gz' exist, the former will be
returned.
The returned string should be freed when no longer needed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the fullpath of file, or %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">declared filename</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="path"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">path where to look for file (can be a filename), or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_format_string"
              c:identifier="mirage_helper_format_string"
              introspectable="0">
      <doc xml:space="preserve">General-purpose string formatter with token replacement. Similarly to
sprintf, the tokens begin with percent character, but instead of denoting
format type, the tokens denote placeholders for user-defined replacements.
Sprintf-like field width and precision modifiers are supported for formatting
the replacements. If replacement is not specified for a replacement token
found in format, then the token is removed in the output string.

If replacement does not exist and the token to be replaced is preceded
by other word-caracters (see #GRegex documentation for details), in
addition to the replacement token, all those word characters are removed
together with the leading non-word character.

&lt;informalexample&gt;
&lt;programlisting&gt;
// Example: formatting a filename
output = mirage_helper_format_string("%b-%02s-track%t.%e",
    "b", g_variant_new_string("some_image"),
    "s", g_variant_new_int16(1),
    "t", g_variant_new_int16(3),
    "e", g_variant_new_string("iso"), NULL);
// output = "some_image-01-track3.iso"

// Example: removal of preceding characters when replacement does not exist
output = mirage_helper_format_string("%b-%02s-track%t.%e",
    "b", g_variant_new_string("some_image"),
    "s", g_variant_new_int16(1),
    "e", g_variant_new_string("iso"), NULL);
// output = "some_image-01.iso"
&lt;/programlisting&gt;
&lt;/informalexample&gt;

@Varargs is a %NULL-terminated list of replacement token/value pairs,
where a replacement token/value pair is a pair of string and a #GVariant.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">string with all replacement tokens either
replaced or removed. The string should be freed using g_free() when
no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of replacement token/value pairs</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_format_stringd"
              c:identifier="mirage_helper_format_stringd">
      <doc xml:space="preserve">Dictionary-version of mirage_helper_format_string().

@dictionary is a #GHashTable where keys are replacement token strings
and each value is a #GVariant containing corresponding token replacement
value.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">string with all replacement tokens either
replaced or removed. The string should be freed using g_free() when
no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dictionary" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable containing replacement token/value pairs</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="helper_format_stringv"
              c:identifier="mirage_helper_format_stringv"
              introspectable="0">
      <doc xml:space="preserve">Variable-argument-list-version of mirage_helper_format_string().

@args is a %NULL-terminated list of replacement token/value pairs,
where a replacement token/value pair is a pair of string and a #GVariant.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">string with all replacement tokens either
replaced or removed. The string should be freed using g_free() when
no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated list of replacement token/value pairs</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_get_suffix" c:identifier="mirage_helper_get_suffix">
      <doc xml:space="preserve">Retrieves suffix from @filename.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">pointer to character in @filename at which the suffix starts.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">filename</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_has_suffix" c:identifier="mirage_helper_has_suffix">
      <doc xml:space="preserve">Checks whether file name @filename ends with suffix @suffix.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @filename contains suffix @suffix, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">filename</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="suffix" transfer-ownership="none">
          <doc xml:space="preserve">suffix</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_hex2bcd" c:identifier="mirage_helper_hex2bcd">
      <doc xml:space="preserve">Converts hex-encoded integer into bcd-encoded integer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">bcd-encoded integer</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="hex" transfer-ownership="none">
          <doc xml:space="preserve">hex-encoded integer</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_init_crc16_lut"
              c:identifier="mirage_helper_init_crc16_lut">
      <doc xml:space="preserve">Calculates a look-up table for CRC16 based on the generator polynomial.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Pointer to the CRC16 look-up table or NULL on failure.</doc>
        <type name="guint16" c:type="guint16*"/>
      </return-value>
      <parameters>
        <parameter name="genpoly" transfer-ownership="none">
          <doc xml:space="preserve">generator polynomial</doc>
          <type name="guint16" c:type="guint16"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_init_crc32_lut"
              c:identifier="mirage_helper_init_crc32_lut">
      <doc xml:space="preserve">Calculates a look-up table for CRC32 based on the generator polynomial.
The size of the lookup table depends on @slices. The standard algorithm
processes 1 byte at a time and has a look-up table size of 1KiB, whereas
The slice-by-4 and slice-by-8 algorithms use 4 and 8 KiB look-up tables that
are derived from the initial look-up table.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Pointer to the CRC32 look-up table or NULL on failure.</doc>
        <type name="guint32" c:type="guint32*"/>
      </return-value>
      <parameters>
        <parameter name="genpoly" transfer-ownership="none">
          <doc xml:space="preserve">generator polynomial</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="slices" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to process at once</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_init_ecma_130b_scrambler_lut"
              c:identifier="mirage_helper_init_ecma_130b_scrambler_lut">
      <doc xml:space="preserve">Calculates a look-up table for sector data scrambler from ECMA-130,
Annex B. The look-up table consists of 2340 entries, each being a
scramble byte for corresponding byte in sector data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Pointer to the generated scrambler look-up table or NULL on failure.</doc>
        <type name="guint8" c:type="guint8*"/>
      </return-value>
    </function>
    <function name="helper_isrc2ascii" c:identifier="mirage_helper_isrc2ascii">
      <doc xml:space="preserve">Converts ISRC character @c into ASCII character.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">ACSII character</doc>
        <type name="gchar" c:type="gchar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">ISRC character</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_lba2msf" c:identifier="mirage_helper_lba2msf">
      <doc xml:space="preserve">Converts LBA sector address stored in @lba into MSF address, storing each field
into @m, @s and @f, respectively.

If @diff is %TRUE, 150 frames difference is accounted for; this should be
used when converting absolute addresses. When converting relative addresses
(or lengths), @diff should be set to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="lba" transfer-ownership="none">
          <doc xml:space="preserve">LBA address</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="diff" transfer-ownership="none">
          <doc xml:space="preserve">account for the difference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="m"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store minutes, or %NULL</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="s"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store seconds, or %NULL</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="f"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">location to store frames, or %NULL</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_lba2msf_str"
              c:identifier="mirage_helper_lba2msf_str">
      <doc xml:space="preserve">Converts LBA sector address stored in @lba into MSF address.

If @diff is %TRUE, 150 frames difference is accounted for; this should be
used when converting absolute addresses. When converting relative addresses
(or lengths), @diff should be set to %FALSE.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string containing MSF address; it should be freed
with g_free() when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="lba" transfer-ownership="none">
          <doc xml:space="preserve">LBA address</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="diff" transfer-ownership="none">
          <doc xml:space="preserve">account for the difference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_msf2lba" c:identifier="mirage_helper_msf2lba">
      <doc xml:space="preserve">Converts MSF sector address stored in @m, @s and @f into LBA address.

If @diff is %TRUE, 150 frames difference is accounted for; this should be
used when converting absolute addresses. When converting relative addresses
(or lengths), @diff should be set to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">integer representing LBA address</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="m" transfer-ownership="none">
          <doc xml:space="preserve">minutes</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="s" transfer-ownership="none">
          <doc xml:space="preserve">seconds</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="f" transfer-ownership="none">
          <doc xml:space="preserve">frames</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="diff" transfer-ownership="none">
          <doc xml:space="preserve">difference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_msf2lba_str"
              c:identifier="mirage_helper_msf2lba_str">
      <doc xml:space="preserve">Converts MSF sector address stored in @msf string into LBA address.

If @diff is %TRUE, 150 frames difference is accounted for; this should be
used when converting absolute addresses. When converting relative addresses
(or lengths), @diff should be set to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">integer representing LBA address or -1 on failure.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="msf" transfer-ownership="none">
          <doc xml:space="preserve">MSF string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="diff" transfer-ownership="none">
          <doc xml:space="preserve">difference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_sector_edc_ecc_compute_ecc_block"
              c:identifier="mirage_helper_sector_edc_ecc_compute_ecc_block">
      <doc xml:space="preserve">Calculates ECC (error correction code) for data in @src and writes the result
into @dest. The code assumes 2352 byte sectors. It can calculate both P and Q
layer of ECC data, depending on @major_count, @minor_count, @major_mult and
minor_inc.

To calculate ECC (first P, then Q layer) for different types of sectors and store it into sector data, use:
&lt;itemizedlist&gt;
&lt;listitem&gt;
Mode 1 sector:
&lt;programlisting&gt;
mirage_helper_sector_edc_ecc_compute_ecc_block(sector_buffer+0xC, 86, 24, 2, 86, sector_buffer+0x81C);
mirage_helper_sector_edc_ecc_compute_ecc_block(sector_buffer+0xC, 52, 43, 86, 88, sector_buffer+0x8C8);
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
Mode 2 Form 1 sector:
&lt;programlisting&gt;
mirage_helper_sector_edc_ecc_compute_ecc_block(sector_buffer+0xC, 86, 24, 2, 86, sector_buffer+0x81C); \n
mirage_helper_sector_edc_ecc_compute_ecc_block(sector_buffer+0xC, 52, 43, 86, 88, sector_buffer+0x8C8);
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
(This is assuming all other sector data, including EDC, is already stored in sector_buffer and that sector_buffer is 2532 bytes long)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">data to calculate ECC data for</doc>
          <type name="guint8" c:type="const guint8*"/>
        </parameter>
        <parameter name="major_count" transfer-ownership="none">
          <doc xml:space="preserve">major count</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="minor_count" transfer-ownership="none">
          <doc xml:space="preserve">minor count</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="major_mult" transfer-ownership="none">
          <doc xml:space="preserve">major multiplicator</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="minor_inc" transfer-ownership="none">
          <doc xml:space="preserve">minor increment</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to write calculated ECC data into</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_sector_edc_ecc_compute_edc_block"
              c:identifier="mirage_helper_sector_edc_ecc_compute_edc_block">
      <doc xml:space="preserve">Calculates EDC (error detection code) for data in @src of length @size and
writes the result into @dest.

To calculate EDC for different types of sectors and store it into sector data, use:
&lt;itemizedlist&gt;
&lt;listitem&gt;
Mode 1 sector:
&lt;programlisting&gt;
mirage_helper_sector_edc_ecc_compute_edc_block(sector_buffer+0x00, 0x810, sector_buffer+0x810);
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
Mode 2 Form 1 sector:
&lt;programlisting&gt;
mirage_helper_sector_edc_ecc_compute_edc_block(sector_buffer+0x10, 0x808, sector_buffer+0x818);
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
Mode 2 Form 2 sector:
&lt;programlisting&gt;
mirage_helper_sector_edc_ecc_compute_edc_block(sector_buffer+0x10, 0x91C, sector_buffer+0x92C);
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
(This is assuming all other sector data is already stored in sector_buffer and that sector_buffer is 2532 bytes long)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">data to calculate EDC data for</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of data in @src</doc>
          <type name="guint16" c:type="guint16"/>
        </parameter>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to write calculated EDC data into (4 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="4">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_strcasecmp" c:identifier="mirage_helper_strcasecmp">
      <doc xml:space="preserve">Replacement function for g_strcasecmp/strcasecmp, which can properly handle UTF-8.
Glib docs state this is only an approximation, albeit it should be a fairly good one.

It compares the two strings @str1 and @str2, ignoring the case of the characters.
It returns an integer less than, equal to, or greater than zero if @str1 is found,
respectively, to be less than, to match, or be greater than @str2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an integer less than, equal to, or greater than zero  if  @str1
is  found, respectively, to  be less than, to match, or be greater than @str2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="str1" transfer-ownership="none">
          <doc xml:space="preserve">first string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="str2" transfer-ownership="none">
          <doc xml:space="preserve">second string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_strncasecmp"
              c:identifier="mirage_helper_strncasecmp">
      <doc xml:space="preserve">Replacement function for g_strncasecmp/strncasecmp, which can properly handle UTF-8.
Glib docs state this is only an approximation, albeit it should be a fairly good one.

It compares first @len characters of string @str1 and @str2, ignoring the case of
the characters. It returns an integer less than, equal to, or greater than zero if
first @len characters of @str1 is found, respectively, to be less than, to match,
or be greater than first @len characters of @str2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an integer less than, equal to, or greater than zero  if  first @len
characters of @str1 is found, respectively, to  be less than, to match, or
be greater than first @len characters of @str2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="str1" transfer-ownership="none">
          <doc xml:space="preserve">first string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="str2" transfer-ownership="none">
          <doc xml:space="preserve">second string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of string to compare</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_deinterleave"
              c:identifier="mirage_helper_subchannel_deinterleave">
      <doc xml:space="preserve">Deinterleaves subchannel data of type @subchan from subchannel data stored in
@channel96 and writes the resulting subhcannel data into @subchannel12.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="subchan" transfer-ownership="none">
          <doc xml:space="preserve">subchannel type</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="channel96" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing subchannel data to deinterleave (96 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="96">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="channel12"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to deinterleave subchannel data into (12 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="12">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_interleave"
              c:identifier="mirage_helper_subchannel_interleave">
      <doc xml:space="preserve">Interleaves subchannel data of type @subchan stored in @channel12 into
subchannel data stored in @subchannel96.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="subchan" transfer-ownership="none">
          <doc xml:space="preserve">subchannel type</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="channel12" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing subchannel data to interleave (12 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="12">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="channel96"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to interleave subchannel data into (96 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="96">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_q_calculate_crc"
              c:identifier="mirage_helper_subchannel_q_calculate_crc">
      <doc xml:space="preserve">Calculates the CRC-16 checksum of the Q subchannel data stored in @data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">CRC-16 checksum of Q subchannel data</doc>
        <type name="guint16" c:type="guint16"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing Q subchannel data (10 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="10">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_q_decode_isrc"
              c:identifier="mirage_helper_subchannel_q_decode_isrc">
      <doc xml:space="preserve">Decodes ISRC stored in @buf into string @isrc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing encoded ISRC (8 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="8">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="isrc"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">string to decode ISRC into (12 bytes)</doc>
          <array zero-terminated="0" c:type="gchar*" fixed-size="12">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_q_decode_mcn"
              c:identifier="mirage_helper_subchannel_q_decode_mcn">
      <doc xml:space="preserve">Decodes MCN stored in @buf into string @mcn.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">buffer containing encoded MCN (7 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="7">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="mcn"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">string to decode MCN into (13 bytes)</doc>
          <array zero-terminated="0" c:type="gchar*" fixed-size="13">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_q_encode_isrc"
              c:identifier="mirage_helper_subchannel_q_encode_isrc">
      <doc xml:space="preserve">Encodes ISRC string @isrc into buffer @buf.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to encode ISRC into (8 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="8">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="isrc" transfer-ownership="none">
          <doc xml:space="preserve">ISRC string (12 bytes)</doc>
          <array zero-terminated="0" c:type="gchar*" fixed-size="12">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_subchannel_q_encode_mcn"
              c:identifier="mirage_helper_subchannel_q_encode_mcn">
      <doc xml:space="preserve">Encodes MCN string @mcn into buffer @buf.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">buffer to encode MCN into (7 bytes)</doc>
          <array zero-terminated="0" c:type="guint8*" fixed-size="7">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="mcn" transfer-ownership="none">
          <doc xml:space="preserve">MCN string (13 bytes)</doc>
          <array zero-terminated="0" c:type="gchar*" fixed-size="13">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="helper_validate_isrc"
              c:identifier="mirage_helper_validate_isrc">
      <doc xml:space="preserve">Performs a limited validation of an ISRC string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TRUE or FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="isrc" transfer-ownership="none">
          <doc xml:space="preserve">An ASCII encoded ISRC string.</doc>
          <array zero-terminated="0" c:type="gchar*" fixed-size="12">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="initialize" c:identifier="mirage_initialize" throws="1">
      <doc xml:space="preserve">Initializes libMirage library. It should be called before any other of
libMirage functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="shutdown" c:identifier="mirage_shutdown" throws="1">
      <doc xml:space="preserve">Shuts down libMirage library. It should be called when libMirage is no longer
needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
  </namespace>
</repository>
