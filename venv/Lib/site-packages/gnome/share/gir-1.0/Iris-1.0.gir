<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gio" version="2.0"/>
  <package name="gio-2.0"/>
  <package name="gobject-2.0"/>
  <namespace name="Iris"
             version="1.0"
             shared-library="libiris-1.0-0.dll"
             c:identifier-prefixes="Iris"
             c:symbol-prefixes="iris">
    <class name="Arbiter"
           c:symbol-prefix="arbiter"
           c:type="IrisArbiter"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="IrisArbiter"
           glib:get-type="iris_arbiter_get_type">
      <function name="coordinate"
                c:identifier="iris_arbiter_coordinate"
                introspectable="0">
        <doc xml:space="preserve">Coordinates messages incoming to the receivers.  This is used to guarantee
semantics for the receivers.

Any message received on the @exclusive receiver is guaranteed to be the
only message received at a time.  No other exclusive, concurrent, or
teardown messages will be running.

Messages received on the @concurrent receiver can be received concurrently
meaning more than one message is allowed to be received at a time.

Only one message can be recieved on @teardown ever.  After a message has
been received on @teardown, no further messages will ever be received
on any receivers.</doc>
        <return-value>
          <doc xml:space="preserve">An new #IrisArbiter that will arbitrate messages incoming
  to the passed receivers.</doc>
          <type name="Arbiter" c:type="IrisArbiter*"/>
        </return-value>
        <parameters>
          <parameter name="exclusive" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </parameter>
          <parameter name="concurrent" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </parameter>
          <parameter name="teardown" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </parameter>
        </parameters>
      </function>
      <function name="receive"
                c:identifier="iris_arbiter_receive"
                introspectable="0">
        <doc xml:space="preserve">Creates a new #IrisReceiver instance that executes @callback when a message
is received on the receiver.  Note that if you attach this to an arbiter,
a message posted to @port may not result in @callback being executed right
away.

If not %NULL, @notify will be called when the receiver is destroyed.</doc>
        <return-value>
          <doc xml:space="preserve">the newly created #IrisReceiver instance</doc>
          <type name="Receiver" c:type="IrisReceiver*"/>
        </return-value>
        <parameters>
          <parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler or %NULL</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     scope="notified"
                     closure="3"
                     destroy="4">
            <type name="MessageHandler" c:type="IrisMessageHandler"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <callback name="Callback" c:type="IrisCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="GMainScheduler"
           c:symbol-prefix="gmainscheduler"
           c:type="IrisGMainScheduler"
           parent="Scheduler"
           glib:type-name="IrisGMainScheduler"
           glib:get-type="iris_gmainscheduler_get_type"
           glib:type-struct="GMainSchedulerClass">
      <constructor name="new" c:identifier="iris_gmainscheduler_new">
        <doc xml:space="preserve">Creates a new instance of #IrisGMainScheduler.  If @context is %NULL, then
the default #GMainContext will be used.

See g_main_context_default().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created instance of #IrisGMainScheduler</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">An optional #GMainContext or %NULL</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_context"
              c:identifier="iris_gmainscheduler_get_context">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #GMainContext instance for this scheduler</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="gmain_scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisGMainScheduler</doc>
            <type name="GMainScheduler" c:type="IrisGMainScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Scheduler" c:type="IrisScheduler"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GMainSchedulerPrivate"
              c:type="IrisGMainSchedulerPrivate*"/>
      </field>
    </class>
    <record name="GMainSchedulerClass"
            c:type="IrisGMainSchedulerClass"
            glib:is-gtype-struct-for="GMainScheduler">
      <field name="parent_class">
        <type name="SchedulerClass" c:type="IrisSchedulerClass"/>
      </field>
    </record>
    <record name="GMainSchedulerPrivate"
            c:type="IrisGMainSchedulerPrivate"
            disguised="1">
    </record>
    <class name="LFQueue"
           c:symbol-prefix="lfqueue"
           c:type="IrisLFQueue"
           parent="Queue"
           glib:type-name="IrisLFQueue"
           glib:get-type="iris_lfqueue_get_type"
           glib:type-struct="LFQueueClass">
      <constructor name="new" c:identifier="iris_lfqueue_new">
        <doc xml:space="preserve">Creates a new instance of #IrisLFQueue, a lock-free queue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisLFQueue instance</doc>
          <type name="Queue" c:type="IrisQueue*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="Queue" c:type="IrisQueue"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="LFQueuePrivate" c:type="IrisLFQueuePrivate*"/>
      </field>
    </class>
    <record name="LFQueueClass"
            c:type="IrisLFQueueClass"
            glib:is-gtype-struct-for="LFQueue">
      <field name="parent_class">
        <type name="QueueClass" c:type="IrisQueueClass"/>
      </field>
    </record>
    <record name="LFQueuePrivate" c:type="IrisLFQueuePrivate" disguised="1">
    </record>
    <class name="LFScheduler"
           c:symbol-prefix="lfscheduler"
           c:type="IrisLFScheduler"
           parent="Scheduler"
           glib:type-name="IrisLFScheduler"
           glib:get-type="iris_lfscheduler_get_type"
           glib:type-struct="LFSchedulerClass">
      <constructor name="new" c:identifier="iris_lfscheduler_new">
        <doc xml:space="preserve">Creates a new instance of #IrisLFScheduler.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisLFScheduler instance.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
      </constructor>
      <constructor name="new_full" c:identifier="iris_lfscheduler_new_full">
        <doc xml:space="preserve">Creates a new instance of #IrisLFScheduler.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisLFScheduler instance.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
        <parameters>
          <parameter name="min_threads" transfer-ownership="none">
            <doc xml:space="preserve">A #guint containing the minimum number of threads</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">A #guint containing the maximum number of threads</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="Scheduler" c:type="IrisScheduler"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="LFSchedulerPrivate" c:type="IrisLFSchedulerPrivate*"/>
      </field>
    </class>
    <record name="LFSchedulerClass"
            c:type="IrisLFSchedulerClass"
            glib:is-gtype-struct-for="LFScheduler">
      <field name="parent_class">
        <type name="SchedulerClass" c:type="IrisSchedulerClass"/>
      </field>
    </record>
    <record name="LFSchedulerPrivate"
            c:type="IrisLFSchedulerPrivate"
            disguised="1">
    </record>
    <record name="Message"
            c:type="IrisMessage"
            glib:type-name="IrisMessage"
            glib:get-type="iris_message_get_type"
            c:symbol-prefix="message">
      <field name="what" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="items" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <constructor name="new" c:identifier="iris_message_new">
        <doc xml:space="preserve">Creates a new #IrisMessage.  @what can be any constant used within
your application that the local or remote application knows how to
handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisMessage.</doc>
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none">
            <doc xml:space="preserve">the message type</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_data"
                   c:identifier="iris_message_new_data"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #IrisMessage instance with the data value initialized.
The ellipsis parameter is used so you may pass any type of value or
pointer into the constructor, however only one is allowed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly created #IrisMessage instance</doc>
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none">
            <doc xml:space="preserve">The message type</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the data element</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="iris_message_new_full"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new instance of a #IrisMessage and sets its fields.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #IrisMessage.</doc>
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none">
            <doc xml:space="preserve">the message type</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="first_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first field in the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the GType and value for the first property, followed optionally
  by more name/type/value triplets, follwed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="contains" c:identifier="iris_message_contains">
        <doc xml:space="preserve">Checks to see if @message contains a field named @name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the message contains @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="iris_message_copy">
        <doc xml:space="preserve">Copies @message.  If the node contains complex data types then the
reference count of the objects are increased.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copied #IrisMessage.</doc>
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="count_names" c:identifier="iris_message_count_names">
        <doc xml:space="preserve">Retrieves the number of key/value pairs that are currently stored within
the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of key/value pairs</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="iris_message_get_boolean">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_char" c:identifier="iris_message_get_char">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key</doc>
          <type name="gchar" c:type="gchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="iris_message_get_data">
        <doc xml:space="preserve">Retrieves the data value for the #IrisMessage.  A message may have one
data value within it that is not associated with a key.  This is that
value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a GValue that should not be modified.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="iris_message_get_double">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key as a #gdouble.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float" c:identifier="iris_message_get_float">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key as a #gfloat.</doc>
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="iris_message_get_int">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key as a #gint.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="iris_message_get_int64">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key as a #gint64.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_long" c:identifier="iris_message_get_long">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key</doc>
          <type name="glong" c:type="glong"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_object"
              c:identifier="iris_message_get_object"
              introspectable="0">
        <doc xml:space="preserve">Retrieves the object value for @key.</doc>
        <return-value>
          <doc xml:space="preserve">the value for @key or %NULL</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pointer"
              c:identifier="iris_message_get_pointer"
              introspectable="0">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value>
          <doc xml:space="preserve">the value for @key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="iris_message_get_string">
        <doc xml:space="preserve">Retrieves the value for @key which must be a string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the value for @key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The key of the item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uchar" c:identifier="iris_message_get_uchar">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ulong" c:identifier="iris_message_get_ulong">
        <doc xml:space="preserve">Retrieves the value for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value for @key</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="iris_message_get_value">
        <doc xml:space="preserve">Copies the value found using @name as the key into the #GValue
pointed to by @value.  Remember to unset your value using
g_value_unset() when you are done.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the value to retrieve</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GValue to store the result in</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="iris_message_is_empty">
        <doc xml:space="preserve">Checks to see if the message is currently empty, meaning it has no
key/value pairs associated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if there are no key/value pairs associated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="iris_message_ref">
        <doc xml:space="preserve">Atomically Increases the reference count of @message by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed #IrisMessage, with the reference count
  increased by one.</doc>
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="iris_message_set_boolean">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_char" c:identifier="iris_message_set_char">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="iris_message_set_data">
        <doc xml:space="preserve">Updates the data field for the message. A message may have only one
data value within it that is not associated with a key. This is that
value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="iris_message_set_double">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_float" c:identifier="iris_message_set_float">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="iris_message_set_int">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="iris_message_set_int64">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_long" c:identifier="iris_message_set_long">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object" c:identifier="iris_message_set_object">
        <doc xml:space="preserve">Updates @message to use @object as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pointer" c:identifier="iris_message_set_pointer">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="iris_message_set_string">
        <doc xml:space="preserve">Updates the @key for @message to the string pointed to by @value.  The
contents of the string is duplicated and stored within the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uchar" c:identifier="iris_message_set_uchar">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="guint8" c:type="guchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ulong" c:identifier="iris_message_set_ulong">
        <doc xml:space="preserve">Updates @message to use @value as the value for @key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="iris_message_set_value">
        <doc xml:space="preserve">Updates the value for @key to use the value pointed to by @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue containing the new value</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="iris_message_unref">
        <doc xml:space="preserve">Atomically decrease the reference count of an #IrisMessage.  If the
reference count reaches zero, the object is destroyed and all its
allocated resources are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="MessageHandler" c:type="IrisMessageHandler">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="message" transfer-ownership="none">
          <type name="Message" c:type="IrisMessage*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Port"
           c:symbol-prefix="port"
           c:type="IrisPort"
           parent="GObject.Object"
           glib:type-name="IrisPort"
           glib:get-type="iris_port_get_type"
           glib:type-struct="PortClass">
      <constructor name="new" c:identifier="iris_port_new">
        <doc xml:space="preserve">Creates a new instance of an #IrisPort.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly created #IrisPort</doc>
          <type name="Port" c:type="IrisPort*"/>
        </return-value>
      </constructor>
      <virtual-method name="get_receiver"
                      invoker="get_receiver"
                      introspectable="0">
        <doc xml:space="preserve">Retreives the currently attached receiver for the port.</doc>
        <return-value>
          <doc xml:space="preserve">An #IrisReceiver instance or %NULL.</doc>
          <type name="Receiver" c:type="IrisReceiver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="post" invoker="post">
        <doc xml:space="preserve">Posts @message to the port.  Any receivers listening to the port will
receive the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #IrisMessage to post</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="repost" invoker="repost">
        <doc xml:space="preserve">Re-posts a message to the queue.  This should only ever be used by
receiver implementations that need to push their single-held message
back to the beginning of a port.  The receiver should also call
iris_port_flush() after calling this.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_receiver" invoker="set_receiver">
        <doc xml:space="preserve">Sets the current receiver for the port.  If a receiver already
exists, it will be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="receiver" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="flush" c:identifier="iris_port_flush">
        <doc xml:space="preserve">Flushes the port by trying to redeliver messages to a listening
#IrisReceiver.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_queue_count" c:identifier="iris_port_get_queue_count">
        <doc xml:space="preserve">Retreives the count of queued items still waiting to be delivered to
a receiver.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint of the number of queued messages.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_receiver"
              c:identifier="iris_port_get_receiver"
              introspectable="0">
        <doc xml:space="preserve">Retreives the currently attached receiver for the port.</doc>
        <return-value>
          <doc xml:space="preserve">An #IrisReceiver instance or %NULL.</doc>
          <type name="Receiver" c:type="IrisReceiver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_receiver" c:identifier="iris_port_has_receiver">
        <doc xml:space="preserve">Determines if the port is currently connected to a receiver.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if there is a receiver hooked up.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_paused" c:identifier="iris_port_is_paused">
        <doc xml:space="preserve">Checks if the port is currently paused.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the port is paused.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="post" c:identifier="iris_port_post">
        <doc xml:space="preserve">Posts @message to the port.  Any receivers listening to the port will
receive the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">The #IrisMessage to post</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="repost" c:identifier="iris_port_repost">
        <doc xml:space="preserve">Re-posts a message to the queue.  This should only ever be used by
receiver implementations that need to push their single-held message
back to the beginning of a port.  The receiver should also call
iris_port_flush() after calling this.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_receiver" c:identifier="iris_port_set_receiver">
        <doc xml:space="preserve">Sets the current receiver for the port.  If a receiver already
exists, it will be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisPort</doc>
            <type name="Port" c:type="IrisPort*"/>
          </instance-parameter>
          <parameter name="receiver" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PortPrivate" c:type="IrisPortPrivate*"/>
      </field>
    </class>
    <record name="PortClass"
            c:type="IrisPortClass"
            glib:is-gtype-struct-for="Port">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="post">
        <callback name="post">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="port" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisPort</doc>
              <type name="Port" c:type="IrisPort*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">The #IrisMessage to post</doc>
              <type name="Message" c:type="IrisMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="repost">
        <callback name="repost">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="port" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisPort</doc>
              <type name="Port" c:type="IrisPort*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisMessage</doc>
              <type name="Message" c:type="IrisMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_receiver" introspectable="0">
        <callback name="get_receiver" introspectable="0">
          <return-value>
            <doc xml:space="preserve">An #IrisReceiver instance or %NULL.</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </return-value>
          <parameters>
            <parameter name="port" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisPort</doc>
              <type name="Port" c:type="IrisPort*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_receiver">
        <callback name="set_receiver">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="port" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisPort</doc>
              <type name="Port" c:type="IrisPort*"/>
            </parameter>
            <parameter name="receiver" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisReceiver</doc>
              <type name="Receiver" c:type="IrisReceiver*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="PortPrivate" c:type="IrisPortPrivate" disguised="1">
    </record>
    <class name="Queue"
           c:symbol-prefix="queue"
           c:type="IrisQueue"
           parent="GObject.Object"
           glib:type-name="IrisQueue"
           glib:get-type="iris_queue_get_type"
           glib:type-struct="QueueClass">
      <constructor name="new" c:identifier="iris_queue_new">
        <doc xml:space="preserve">Creates a new instance of #IrisQueue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisQueue.</doc>
          <type name="Queue" c:type="IrisQueue*"/>
        </return-value>
      </constructor>
      <virtual-method name="length" invoker="length">
        <doc xml:space="preserve">Retrieves the current length of the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the queue</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pop" invoker="pop" introspectable="0">
        <doc xml:space="preserve">Pops an item off the queue.  It is up to the queue implementation to
determine if this method should block.  The default implementation of
#IrisQueue blocks until an item is available.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if there was an error</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="push" invoker="push">
        <doc xml:space="preserve">Pushes a non-%NULL pointer onto the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to store that is not %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="timed_pop" invoker="timed_pop" introspectable="0">
        <doc xml:space="preserve">Pops an item off the queue or returns %NULL when @timeout has passed.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if @timeout has passed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the absolute timeout for pop</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="try_pop" invoker="try_pop" introspectable="0">
        <doc xml:space="preserve">Tries to pop an item off the queue.  If no item is available %NULL
is returned.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if none was available.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="length" c:identifier="iris_queue_length">
        <doc xml:space="preserve">Retrieves the current length of the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the queue</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="iris_queue_pop" introspectable="0">
        <doc xml:space="preserve">Pops an item off the queue.  It is up to the queue implementation to
determine if this method should block.  The default implementation of
#IrisQueue blocks until an item is available.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if there was an error</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="iris_queue_push">
        <doc xml:space="preserve">Pushes a non-%NULL pointer onto the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to store that is not %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop"
              c:identifier="iris_queue_timed_pop"
              introspectable="0">
        <doc xml:space="preserve">Pops an item off the queue or returns %NULL when @timeout has passed.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if @timeout has passed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the absolute timeout for pop</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_pop"
              c:identifier="iris_queue_try_pop"
              introspectable="0">
        <doc xml:space="preserve">Tries to pop an item off the queue.  If no item is available %NULL
is returned.</doc>
        <return-value>
          <doc xml:space="preserve">the next item off the queue or %NULL if none was available.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="QueuePrivate" c:type="IrisQueuePrivate*"/>
      </field>
    </class>
    <record name="QueueClass"
            c:type="IrisQueueClass"
            glib:is-gtype-struct-for="Queue">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="push">
        <callback name="push">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisQueue</doc>
              <type name="Queue" c:type="IrisQueue*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">a pointer to store that is not %NULL</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pop" introspectable="0">
        <callback name="pop" introspectable="0">
          <return-value>
            <doc xml:space="preserve">the next item off the queue or %NULL if there was an error</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisQueue</doc>
              <type name="Queue" c:type="IrisQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="try_pop" introspectable="0">
        <callback name="try_pop" introspectable="0">
          <return-value>
            <doc xml:space="preserve">the next item off the queue or %NULL if none was available.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisQueue</doc>
              <type name="Queue" c:type="IrisQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="timed_pop" introspectable="0">
        <callback name="timed_pop" introspectable="0">
          <return-value>
            <doc xml:space="preserve">the next item off the queue or %NULL if @timeout has passed.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisQueue</doc>
              <type name="Queue" c:type="IrisQueue*"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:space="preserve">the absolute timeout for pop</doc>
              <type name="GLib.TimeVal" c:type="GTimeVal*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="length">
        <callback name="length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the length of the queue</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisQueue</doc>
              <type name="Queue" c:type="IrisQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="QueuePrivate" c:type="IrisQueuePrivate" disguised="1">
    </record>
    <record name="RRobin"
            c:type="IrisRRobin"
            glib:type-name="IrisRRobin"
            glib:get-type="iris_rrobin_get_type"
            c:symbol-prefix="rrobin">
      <field name="size" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="count" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="active" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="data" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="iris_rrobin_new">
        <doc xml:space="preserve">Creates a new instance of the lock-free, round-robin data structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #IrisRRobin instance</doc>
          <type name="RRobin" c:type="IrisRRobin*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">The maximum number of entries</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="iris_rrobin_append">
        <doc xml:space="preserve">Appends a new data item to the round-robin structure. The data supplied
will be added to the arguments of the callback used in iris_rrobin_apply().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there was enough free-space to append the item.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a gpointer to callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="apply" c:identifier="iris_rrobin_apply" introspectable="0">
        <doc xml:space="preserve">Executes @callback using the data from the next item in the round-robin
data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if no items where in the #IrisRRobin, else %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">An #IrisRRobinFunc to execute</doc>
            <type name="RRobinFunc" c:type="IrisRRobinFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data supplied to callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach"
              c:identifier="iris_rrobin_foreach"
              introspectable="0">
        <doc xml:space="preserve">Executes @callback for each item in the #IrisRRobin structure. If
@callback returns %FALSE, then iteration is stopped and the method
will return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">An #IrisRRobinForeachFunc</doc>
            <type name="RRobinForeachFunc" c:type="IrisRRobinForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data supplied to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="iris_rrobin_ref">
        <doc xml:space="preserve">Increments the reference count of @rrobin atomically by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The @rrobin instance with its reference count incremented.</doc>
          <type name="RRobin" c:type="IrisRRobin*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="iris_rrobin_remove">
        <doc xml:space="preserve">Removes the first instance of @data within the @rrobin structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a gpointer to callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="iris_rrobin_unref">
        <doc xml:space="preserve">Atomically decreates the reference count of @rrobin. If the reference
count reaches zero, teh object is destroyed and all its allocated
resources are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rrobin" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisRRobin</doc>
            <type name="RRobin" c:type="IrisRRobin*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="RRobinForeachFunc" c:type="IrisRRobinForeachFunc">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="rrobin" transfer-ownership="none">
          <type name="RRobin" c:type="IrisRRobin*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RRobinFunc" c:type="IrisRRobinFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Receiver"
           c:symbol-prefix="receiver"
           c:type="IrisReceiver"
           parent="GObject.Object"
           glib:type-name="IrisReceiver"
           glib:get-type="iris_receiver_get_type"
           glib:type-struct="ReceiverClass">
      <method name="get_scheduler"
              c:identifier="iris_receiver_get_scheduler"
              introspectable="0">
        <doc xml:space="preserve">Retrieves the scheduler instance for the receiver.</doc>
        <return-value>
          <doc xml:space="preserve">An #IrisScheduler instance</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="receiver" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_scheduler" c:identifier="iris_receiver_set_scheduler">
        <doc xml:space="preserve">Sets the scheduler instance used by this receiver to execute work items.
Note that it is probably not a good idea to switch schedulers while
executing work items.  However, we do make an attempt to support it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="receiver" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisReceiver</doc>
            <type name="Receiver" c:type="IrisReceiver*"/>
          </instance-parameter>
          <parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ReceiverPrivate" c:type="IrisReceiverPrivate*"/>
      </field>
    </class>
    <record name="ReceiverClass"
            c:type="IrisReceiverClass"
            disguised="1"
            glib:is-gtype-struct-for="Receiver">
    </record>
    <record name="ReceiverPrivate" c:type="IrisReceiverPrivate" disguised="1">
    </record>
    <class name="Scheduler"
           c:symbol-prefix="scheduler"
           c:type="IrisScheduler"
           parent="GObject.Object"
           glib:type-name="IrisScheduler"
           glib:get-type="iris_scheduler_get_type"
           glib:type-struct="SchedulerClass">
      <constructor name="new" c:identifier="iris_scheduler_new">
        <doc xml:space="preserve">Creates a new instance of #IrisScheduler with the defaults.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisScheduler instance.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
      </constructor>
      <constructor name="new_full" c:identifier="iris_scheduler_new_full">
        <doc xml:space="preserve">Creates a new scheduler with a defined set of thread ratios.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created scheduler instance.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
        <parameters>
          <parameter name="min_threads" transfer-ownership="none">
            <doc xml:space="preserve">The minimum number of threads to allocate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">The maximum number of threads to allocate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="default"
                c:identifier="iris_scheduler_default"
                introspectable="0">
        <doc xml:space="preserve">Retrieves the default scheduler which can be shared.</doc>
        <return-value>
          <doc xml:space="preserve">a #IrisScheduler instance</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
      </function>
      <function name="manager_print_stat"
                c:identifier="iris_scheduler_manager_print_stat">
        <doc xml:space="preserve">Prints out information on the threads within iris to standard error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <virtual-method name="add_thread" invoker="add_thread">
        <doc xml:space="preserve">Requests that the scheduler add the thread to its set of executing
threads. It is the responsibility of the scheduler to tell the thread
to start managing a work queue with iris_thread_manage().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_max_threads" invoker="get_max_threads">
        <doc xml:space="preserve">Retrieves the maximum number of threads the scheduler should be allocated.
The default is equal to the number of cpus unless there is only a single
cpu, in which case the default is 2.

Currently, only Linux is supported for the number of cpus.  If you
would like another OS supported, please send an email with the method
to retreive the number of cpus (get_nprocs() on Linux).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of threads to allocate.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_min_threads" invoker="get_min_threads">
        <doc xml:space="preserve">Requests the minimum number of threads that the scheduler needs to
execute efficiently. This value should never change, and should always
be greater or equal to 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minimum number of threads to allocate to the scheduler.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue" invoker="queue">
        <doc xml:space="preserve">NOTE: notify will probably disappear soon

Queues a new work item to be executed by one of the schedulers work
threads.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisCallback</doc>
            <type name="Callback" c:type="IrisCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">an optional callback after execution</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_thread" invoker="remove_thread">
        <doc xml:space="preserve">Requests that a scheduler remove the thread from current activity. If the
scheduler has a dedicated queue for the thread, it should flush the items
into another threads or set of threads queues.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_thread" c:identifier="iris_scheduler_add_thread">
        <doc xml:space="preserve">Requests that the scheduler add the thread to its set of executing
threads. It is the responsibility of the scheduler to tell the thread
to start managing a work queue with iris_thread_manage().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_threads"
              c:identifier="iris_scheduler_get_max_threads">
        <doc xml:space="preserve">Retrieves the maximum number of threads the scheduler should be allocated.
The default is equal to the number of cpus unless there is only a single
cpu, in which case the default is 2.

Currently, only Linux is supported for the number of cpus.  If you
would like another OS supported, please send an email with the method
to retreive the number of cpus (get_nprocs() on Linux).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of threads to allocate.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_threads"
              c:identifier="iris_scheduler_get_min_threads">
        <doc xml:space="preserve">Requests the minimum number of threads that the scheduler needs to
execute efficiently. This value should never change, and should always
be greater or equal to 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minimum number of threads to allocate to the scheduler.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="manager_prepare"
              c:identifier="iris_scheduler_manager_prepare">
        <doc xml:space="preserve">Prepares a scheduler for execution.  Any required threads for
processing are attached to the scheduler for future use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="manager_request"
              c:identifier="iris_scheduler_manager_request">
        <doc xml:space="preserve">Request that more workers be added to a scheduler. If @per_quantum
is &gt; 0, then it will be used to try to maximize the number of threads
that can be added to minimize the time to process the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="per_quantum" transfer-ownership="none">
            <doc xml:space="preserve">The number of items processed in last quantum</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="total" transfer-ownership="none">
            <doc xml:space="preserve">the total number of work items left</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="manager_unprepare"
              c:identifier="iris_scheduler_manager_unprepare">
        <doc xml:space="preserve">Unprepares a scheduler by removing all of its active threads
and resources.  The unused threads can then be repurposed to
other schedulers within the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="queue" c:identifier="iris_scheduler_queue">
        <doc xml:space="preserve">NOTE: notify will probably disappear soon

Queues a new work item to be executed by one of the schedulers work
threads.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisCallback</doc>
            <type name="Callback" c:type="IrisCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">an optional callback after execution</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_thread" c:identifier="iris_scheduler_remove_thread">
        <doc xml:space="preserve">Requests that a scheduler remove the thread from current activity. If the
scheduler has a dedicated queue for the thread, it should flush the items
into another threads or set of threads queues.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
          <parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default" c:identifier="iris_scheduler_set_default">
        <doc xml:space="preserve">Allows the caller to set the default scheduler for the process.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SchedulerPrivate" c:type="IrisSchedulerPrivate*"/>
      </field>
      <field name="maxed" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <record name="SchedulerClass"
            c:type="IrisSchedulerClass"
            glib:is-gtype-struct-for="Scheduler">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_max_threads">
        <callback name="get_max_threads">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the maximum number of threads to allocate.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="scheduler" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisScheduler</doc>
              <type name="Scheduler" c:type="IrisScheduler*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_min_threads">
        <callback name="get_min_threads">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the minimum number of threads to allocate to the scheduler.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="scheduler" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisScheduler</doc>
              <type name="Scheduler" c:type="IrisScheduler*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue">
        <callback name="queue">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="scheduler" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisScheduler</doc>
              <type name="Scheduler" c:type="IrisScheduler*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="notified"
                       closure="2"
                       destroy="3">
              <doc xml:space="preserve">An #IrisCallback</doc>
              <type name="Callback" c:type="IrisCallback"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">data for @func</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="notify" transfer-ownership="none" scope="async">
              <doc xml:space="preserve">an optional callback after execution</doc>
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_thread">
        <callback name="add_thread">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="scheduler" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisScheduler</doc>
              <type name="Scheduler" c:type="IrisScheduler*"/>
            </parameter>
            <parameter name="thread" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisThread</doc>
              <type name="Thread" c:type="IrisThread*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_thread">
        <callback name="remove_thread">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="scheduler" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisScheduler</doc>
              <type name="Scheduler" c:type="IrisScheduler*"/>
            </parameter>
            <parameter name="thread" transfer-ownership="none">
              <doc xml:space="preserve">An #IrisThread</doc>
              <type name="Thread" c:type="IrisThread*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="SchedulerPrivate"
            c:type="IrisSchedulerPrivate"
            disguised="1">
    </record>
    <class name="Service"
           c:symbol-prefix="service"
           c:type="IrisService"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="IrisService"
           glib:get-type="iris_service_get_type"
           glib:type-struct="ServiceClass">
      <virtual-method name="handle_concurrent">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_exclusive">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_start">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_stat">
        <return-value transfer-ownership="full">
          <type name="Message" c:type="IrisMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_stop">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="is_started" c:identifier="iris_service_is_started">
        <doc xml:space="preserve">See iris_service_start().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the service has been started</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisService</doc>
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_concurrent"
              c:identifier="iris_service_send_concurrent">
        <doc xml:space="preserve">Sends a concurrent message to the service. The message can be handled
concurrently with other concurrent messages to the service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisService</doc>
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_exclusive" c:identifier="iris_service_send_exclusive">
        <doc xml:space="preserve">Sends an exclusive message to the service. The message is guaranteed
to be handled while no other handlers are executing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisService</doc>
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisMessage</doc>
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="iris_service_start">
        <doc xml:space="preserve">Starts the #IrisService.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisService</doc>
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="iris_service_stop">
        <doc xml:space="preserve">Stops a running #IrisService</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisService</doc>
            <type name="Service" c:type="IrisService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ServicePrivate" c:type="IrisServicePrivate*"/>
      </field>
    </class>
    <record name="ServiceClass"
            c:type="IrisServiceClass"
            glib:is-gtype-struct-for="Service">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="handle_start">
        <callback name="handle_start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="Service" c:type="IrisService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_stop">
        <callback name="handle_stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="Service" c:type="IrisService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_stat">
        <callback name="handle_stat">
          <return-value transfer-ownership="full">
            <type name="Message" c:type="IrisMessage*"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="Service" c:type="IrisService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_exclusive">
        <callback name="handle_exclusive">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="Service" c:type="IrisService*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="IrisMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_concurrent">
        <callback name="handle_concurrent">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="Service" c:type="IrisService*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="IrisMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ServicePrivate" c:type="IrisServicePrivate" disguised="1">
    </record>
    <record name="Stack"
            c:type="IrisStack"
            glib:type-name="IrisStack"
            glib:get-type="iris_stack_get_type"
            c:symbol-prefix="stack">
      <constructor name="new" c:identifier="iris_stack_new">
        <doc xml:space="preserve">Creates a new instance of an #IrisStack, which is a concurrent,
lock-free stack implementation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisStack instance.</doc>
          <type name="Stack" c:type="IrisStack*"/>
        </return-value>
      </constructor>
      <method name="pop" c:identifier="iris_stack_pop" introspectable="0">
        <doc xml:space="preserve">Pops an item off of the stack atomically. If no item is on the stack,
then %NULL is returned.</doc>
        <return-value>
          <doc xml:space="preserve">the most recent item on the stack, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisStack</doc>
            <type name="Stack" c:type="IrisStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="iris_stack_push">
        <doc xml:space="preserve">Pushes a new item onto the stack atomically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisStack</doc>
            <type name="Stack" c:type="IrisStack*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="iris_stack_ref">
        <doc xml:space="preserve">Atomically increases the reference count of @stack by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed #IrisStack, which the reference count
  increased by one.</doc>
          <type name="Stack" c:type="IrisStack*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisStack</doc>
            <type name="Stack" c:type="IrisStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="iris_stack_unref">
        <doc xml:space="preserve">Atomically decreases the reference count of @stack.  If the reference
count reaches zero, the object is destroyed and all its allocated
resources are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisStack</doc>
            <type name="Stack" c:type="IrisStack*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="Task"
           c:symbol-prefix="task"
           c:type="IrisTask"
           parent="GObject.Object"
           glib:type-name="IrisTask"
           glib:get-type="iris_task_get_type"
           glib:type-struct="TaskClass">
      <constructor name="new" c:identifier="iris_task_new">
        <doc xml:space="preserve">Creates a new instance of #IrisTask.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created instance of #IrisTask</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
      </constructor>
      <constructor name="new_full" c:identifier="iris_task_new_full">
        <doc xml:space="preserve">Creates a new instance of #IrisTask.  This method allows for setting
if the task is asynchronous with @async.  An asynchronous task has the
ability to not complete during the execution of the task's execution
method (in this case @func).  To mark the task's execution as completed,
g_task_complete() must be called for the task.

If you want errbacks and callbacks to complete within a #GMainContext,
you may specify @context or %NULL for the callbacks to happen within
the worker thread.

@scheduler allows you to set a specific #IrisScheduler to perform
execution of the task within.  Note that all message passing associated
with the tasks internal #IrisPort&lt;!-- --&gt;'s will also happen on this
scheduler.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly created #IrisTask instance.</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisTaskFunc</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A destroy notify after execution of the task</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="async" transfer-ownership="none">
            <doc xml:space="preserve">Will the task complete during the execution of @func</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler or %NULL</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #GMainContext or %NULL</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_closure"
                   c:identifier="iris_task_new_with_closure">
        <doc xml:space="preserve">Creates a new task using the closure for execution.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisTask</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_func" c:identifier="iris_task_new_with_func">
        <doc xml:space="preserve">Create a new #IrisTask instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisTask instance</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisTaskFunc to execute</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">An optional #GDestroyNotify or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="all_of"
                c:identifier="iris_task_all_of"
                introspectable="0">
        <doc xml:space="preserve">Creates a new task that will complete when each of the passed
#IrisTask&lt;!-- --&gt;'s complete.</doc>
        <return-value>
          <doc xml:space="preserve">the newly created #IrisTask instance.</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <parameter name="tasks" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="any_of"
                c:identifier="iris_task_any_of"
                introspectable="0">
        <doc xml:space="preserve">Creates a new task that will not complete until any one of the
#IrisTask&lt;!-- --&gt;'s completes.</doc>
        <return-value>
          <doc xml:space="preserve">the newly created #IrisTask instance.</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <parameter name="tasks" transfer-ownership="none">
            <doc xml:space="preserve">A #GList of #IrisTask&lt;!-- --&gt;'s</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="cancel">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dependency_canceled">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="dep" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dependency_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="dep" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="execute">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="IrisMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_both"
              c:identifier="iris_task_add_both"
              introspectable="0">
        <doc xml:space="preserve">Adds a new task handler to the callbacks phase of the task.  If the task
is in an errored state when the handler is reached, @errback will be
invoked.  Otherwise, @callback will be invoked.  One, and only one, of
these functions is guaranteed to be invoked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTaskFunc</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="errback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">An #IrisTaskFunc</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data for @callback or @errback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">A #GDestroyNotify</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_both_closure"
              c:identifier="iris_task_add_both_closure">
        <doc xml:space="preserve">Adds a task handler to the end of the callbacks chain.  If the task is
in an errored state when the task handler is reached, @errback will be
invoked.  Otherwise, @callback will be invoked.  One, and only one, of
the closures is guaranteed to be invoked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="errback" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_callback" c:identifier="iris_task_add_callback">
        <doc xml:space="preserve">Adds a callback to the callbacks phase.  The callback will be executed
in the order it was added.  If the task has an error when the callback
is reached, it will not be executed at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisTaskFunc</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">notify when the closure has executed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_callback_closure"
              c:identifier="iris_task_add_callback_closure">
        <doc xml:space="preserve">Adds a callback closure to be executed in the callbacks phase.

See iris_task_add_callback().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dependency" c:identifier="iris_task_add_dependency">
        <doc xml:space="preserve">Prevents further execution of the task or callbacks phase until
the @dependency task has completed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="dependency" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_errback" c:identifier="iris_task_add_errback">
        <doc xml:space="preserve">Adds an errback to the callbacks phase.  The errback will be executed
in the order it was added.  If errback will only execute if the task
has an error when the errback is reached.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="errback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">An #IrisTaskFunc</doc>
            <type name="TaskFunc" c:type="IrisTaskFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">notify when the closure has executed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_errback_closure"
              c:identifier="iris_task_add_errback_closure">
        <doc xml:space="preserve">Adds an errback closure to be executed in the callbacks phase.

See iris_task_add_errback().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure</doc>
            <type name="GObject.Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" c:identifier="iris_task_cancel">
        <doc xml:space="preserve">Cancels a task.  If the task is already executing, it is up to the executing
task to periodically check the canceled state with iris_task_is_canceled()
and quit execution.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="complete" c:identifier="iris_task_complete">
        <doc xml:space="preserve">Marks the task as completing the execution phase.  This can be used by
asynchronous tasks to denote that they have completed.

Completion of the task will result in the callbacks phase being performed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error" c:identifier="iris_task_get_error" throws="1">
        <doc xml:space="preserve">Stores a copy of the current error for the task into the location
@error.  If no error currently exists, the value stored will be %NULL.
The error must be freed by the caller using g_error_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task had an error and was copied.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_main_context"
              c:identifier="iris_task_get_main_context">
        <doc xml:space="preserve">Retrieves the #GMainContext associated with the task or %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #GMainContext or %NULL</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_result" c:identifier="iris_task_get_result">
        <doc xml:space="preserve">Retreives the current value for the task and stores it to the
#GValue @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the current result</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_error" c:identifier="iris_task_has_error">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task is currently in an errored state.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_async" c:identifier="iris_task_is_async">
        <doc xml:space="preserve">Checks if the task is an asynchronous task, meaning it will not complete
when the tasks execute method returns.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task is asynchronous</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_canceled" c:identifier="iris_task_is_canceled">
        <doc xml:space="preserve">Checks if a task has been canceled.  Note that if the task handles
the cancel and chooses to ignore it, %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task was canceled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_executing" c:identifier="iris_task_is_executing">
        <doc xml:space="preserve">Checks if the task is currently executing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task is executing</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_finished" c:identifier="iris_task_is_finished">
        <doc xml:space="preserve">Checks to see if the task has executed and the callbacks phase has
completed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the task has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_dependency"
              c:identifier="iris_task_remove_dependency">
        <doc xml:space="preserve">Removes @dependency from preventing the tasks execution.  If the task is
ready to execute it will be scheduled for execution.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="dependency" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dependency_sync"
              c:identifier="iris_task_remove_dependency_sync">
        <doc xml:space="preserve">Synchronously removes @dep from @task&lt;!-- --&gt;'s list of dependencies.
See iris_task_remove_dependency().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="dependency" transfer-ownership="none">
            <type name="Task" c:type="IrisTask*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="iris_task_run">
        <doc xml:space="preserve">Asynchronously schedules the task for execution.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run_async" c:identifier="iris_task_run_async">
        <doc xml:space="preserve">Asynchronously schedules the task for execution. Upon completion of
execution and callbacks/errbacks phase, @callback will be executed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">A #GAsyncReadyCallback</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error" c:identifier="iris_task_set_error">
        <doc xml:space="preserve">Sets the error for the task.  If in the callback phase, the next iteration
will execute the errback instead of the callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_main_context"
              c:identifier="iris_task_set_main_context">
        <doc xml:space="preserve">Sets a #GMainContext to use to perform the errbacks and callbacks
from.  All future callbacks and errbacks will be executed from within
the context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">A #GMainContext</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_result" c:identifier="iris_task_set_result">
        <doc xml:space="preserve">Sets the current result for the task.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_result_gtype"
              c:identifier="iris_task_set_result_gtype"
              introspectable="0">
        <doc xml:space="preserve">Sets the current value for the task without needing to use a #GValue
container.  You can pass a single value after @type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">A #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scheduler" c:identifier="iris_task_set_scheduler">
        <doc xml:space="preserve">Sets the scheduler used to execute future work items.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="scheduler" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisScheduler</doc>
            <type name="Scheduler" c:type="IrisScheduler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_error" c:identifier="iris_task_take_error">
        <doc xml:space="preserve">Steals the ownership of @error and attaches it to the task.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">A #GError</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="vall_of"
              c:identifier="iris_task_vall_of"
              introspectable="0">
        <doc xml:space="preserve">Creates a new task that will complete when each of the passed
#IrisTask&lt;!-- --&gt;'s complete.</doc>
        <return-value>
          <doc xml:space="preserve">the newly created #IrisTask instance.</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="first_task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="vany_of"
              c:identifier="iris_task_vany_of"
              introspectable="0">
        <doc xml:space="preserve">Creates a new task that will complete when one of the passed #IrisTask
instances completes.</doc>
        <return-value>
          <doc xml:space="preserve">An #IrisTask</doc>
          <type name="Task" c:type="IrisTask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="first_task" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisTask</doc>
            <type name="Task" c:type="IrisTask*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TaskPrivate" c:type="IrisTaskPrivate*"/>
      </field>
    </class>
    <record name="TaskClass"
            c:type="IrisTaskClass"
            glib:is-gtype-struct-for="Task">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="handle_message">
        <callback name="handle_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="IrisMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="execute">
        <callback name="execute">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel">
        <callback name="cancel">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dependency_canceled">
        <callback name="dependency_canceled">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
            <parameter name="dep" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dependency_finished">
        <callback name="dependency_finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
            <parameter name="dep" transfer-ownership="none">
              <type name="Task" c:type="IrisTask*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved1">
        <callback name="reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved2">
        <callback name="reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved3">
        <callback name="reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved4">
        <callback name="reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="TaskFunc" c:type="IrisTaskFunc">
      <doc xml:space="preserve">Callback for tasks, callbacks, and errbacks.
See iris_task_add_callback(), iris_task_add_errback().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="task" transfer-ownership="none">
          <doc xml:space="preserve">An #IrisTask</doc>
          <type name="Task" c:type="IrisTask*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user specified data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TaskPrivate" c:type="IrisTaskPrivate" disguised="1">
    </record>
    <record name="Thread" c:type="IrisThread">
      <field name="user_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="user_data2" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="user_data3" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="scheduler" readable="0" private="1">
        <type name="Scheduler" c:type="IrisScheduler*"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="queue" readable="0" private="1">
        <type name="GLib.AsyncQueue" c:type="GAsyncQueue*"/>
      </field>
      <field name="exclusive" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="mutex" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="active" readable="0" private="1">
        <type name="Queue" c:type="IrisQueue*"/>
      </field>
      <method name="is_working" c:identifier="iris_thread_is_working">
        <doc xml:space="preserve">Checks to see if a thread is currently processing work items from a queue.
Keep in mind this is always a race condition.  It is primarily useful for
schedulers to know if a thread they are running in is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the thread is currently working on a queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="manage" c:identifier="iris_thread_manage">
        <doc xml:space="preserve">Sends a message to the thread asking it to retreive work items from
the queue.

If @leader is %TRUE, then the thread will periodically ask the scheduler
manager to ask for more threads.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </instance-parameter>
          <parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">A #GAsyncQueue</doc>
            <type name="Queue" c:type="IrisQueue*"/>
          </parameter>
          <parameter name="leader" transfer-ownership="none">
            <doc xml:space="preserve">If the thread is responsible for asking for more threads</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_stat" c:identifier="iris_thread_print_stat">
        <doc xml:space="preserve">Prints the stats of an #IrisThread to standard output for analysis.
See iris_thread_stat() for programmatically access the statistics.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="shutdown" c:identifier="iris_thread_shutdown">
        <doc xml:space="preserve">Sends a message to the thread asking it to shutdown.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThread</doc>
            <type name="Thread" c:type="IrisThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="get" c:identifier="iris_thread_get" introspectable="0">
        <doc xml:space="preserve">Retrieves the pointer to the current threads structure.</doc>
        <return-value>
          <doc xml:space="preserve">the threads structure or NULL if not an #IrisThread.</doc>
          <type name="Thread" c:type="IrisThread*"/>
        </return-value>
      </function>
      <function name="new" c:identifier="iris_thread_new" introspectable="0">
        <doc xml:space="preserve">Createa a new #IrisThread instance that can be used to queue work items
to be processed on the thread.

If @exclusive, then the thread will not yield to the scheduler and
therefore will not participate in scheduler thread balancing.</doc>
        <return-value>
          <doc xml:space="preserve">the newly created #IrisThread instance</doc>
          <type name="Thread" c:type="IrisThread*"/>
        </return-value>
        <parameters>
          <parameter name="exclusive" transfer-ownership="none">
            <doc xml:space="preserve">the thread is exclusive</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ThreadWork" c:type="IrisThreadWork">
      <field name="callback" writable="1">
        <type name="Callback" c:type="IrisCallback"/>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="taken" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="free" c:identifier="iris_thread_work_free">
        <doc xml:space="preserve">Frees the resources associated with an #IrisThreadWork.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread_work" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThreadWork</doc>
            <type name="ThreadWork" c:type="IrisThreadWork*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="iris_thread_work_run">
        <doc xml:space="preserve">Executes the thread work. This method is called from within the worker
thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread_work" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisThreadWork</doc>
            <type name="ThreadWork" c:type="IrisThreadWork*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="iris_thread_work_new"
                introspectable="0">
        <doc xml:space="preserve">Creates a new instance of #IrisThreadWork, which is the negotiated contract
between schedulers and the thread workers themselves.</doc>
        <return-value>
          <doc xml:space="preserve">The newly created #IrisThreadWork instance.</doc>
          <type name="ThreadWork" c:type="IrisThreadWork*"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">An #IrisCallback</doc>
            <type name="Callback" c:type="IrisCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">user supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="WSQueue"
           c:symbol-prefix="wsqueue"
           c:type="IrisWSQueue"
           parent="Queue"
           glib:type-name="IrisWSQueue"
           glib:get-type="iris_wsqueue_get_type"
           glib:type-struct="WSQueueClass">
      <constructor name="new" c:identifier="iris_wsqueue_new">
        <return-value transfer-ownership="full">
          <type name="Queue" c:type="IrisQueue*"/>
        </return-value>
        <parameters>
          <parameter name="global" transfer-ownership="none">
            <type name="Queue" c:type="IrisQueue*"/>
          </parameter>
          <parameter name="peers" transfer-ownership="none">
            <type name="RRobin" c:type="IrisRRobin*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="local_pop"
              c:identifier="iris_wsqueue_local_pop"
              introspectable="0">
        <doc xml:space="preserve">Performs a local pop on the queue.  This should only be called by the
thread that owns the #IrisWSQueue.</doc>
        <return-value>
          <doc xml:space="preserve">A pointer or %NULL if the queue is empty.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisWSQueue</doc>
            <type name="WSQueue" c:type="IrisWSQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="local_push" c:identifier="iris_wsqueue_local_push">
        <doc xml:space="preserve">Pushes an item onto the queue.  This should only be called from the thread
that owns the #IrisWSQueue as it is not safe to call from other threads.
Research shows that only work items yielded from the owning thread should
land directly into this queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisWSQueue</doc>
            <type name="WSQueue" c:type="IrisWSQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_steal"
              c:identifier="iris_wsqueue_try_steal"
              introspectable="0">
        <doc xml:space="preserve">Tries to steal an item from the #IrisWSQueue within the timeout
specified.</doc>
        <return-value>
          <doc xml:space="preserve">A gpointer or %NULL if no items were available.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">An #IrisWSQueue</doc>
            <type name="WSQueue" c:type="IrisWSQueue*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">timeout in millseconds</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Queue" c:type="IrisQueue"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="WSQueuePrivate" c:type="IrisWSQueuePrivate*"/>
      </field>
    </class>
    <record name="WSQueueClass"
            c:type="IrisWSQueueClass"
            glib:is-gtype-struct-for="WSQueue">
      <field name="parent_class">
        <type name="QueueClass" c:type="IrisQueueClass"/>
      </field>
    </record>
    <record name="WSQueuePrivate" c:type="IrisWSQueuePrivate" disguised="1">
    </record>
    <class name="WSScheduler"
           c:symbol-prefix="wsscheduler"
           c:type="IrisWSScheduler"
           parent="Scheduler"
           glib:type-name="IrisWSScheduler"
           glib:get-type="iris_wsscheduler_get_type"
           glib:type-struct="WSSchedulerClass">
      <constructor name="new" c:identifier="iris_wsscheduler_new">
        <doc xml:space="preserve">Creates a new instance of the work-stealing scheduler.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisWSScheduler.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
      </constructor>
      <constructor name="new_full" c:identifier="iris_wsscheduler_new_full">
        <doc xml:space="preserve">Creates a new instance of the work-stealing scheduler with a specified
range of active threads.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #IrisWSScheduler.</doc>
          <type name="Scheduler" c:type="IrisScheduler*"/>
        </return-value>
        <parameters>
          <parameter name="min_threads" transfer-ownership="none">
            <doc xml:space="preserve">a #guint containing the minimum number of threads</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">a #guint containing the maximum number of threads</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="Scheduler" c:type="IrisScheduler"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="WSSchedulerPrivate" c:type="IrisWSSchedulerPrivate*"/>
      </field>
    </class>
    <record name="WSSchedulerClass"
            c:type="IrisWSSchedulerClass"
            glib:is-gtype-struct-for="WSScheduler">
      <field name="parent_class">
        <type name="SchedulerClass" c:type="IrisSchedulerClass"/>
      </field>
    </record>
    <record name="WSSchedulerPrivate"
            c:type="IrisWSSchedulerPrivate"
            disguised="1">
    </record>
    <function name="init" c:identifier="iris_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="thread_get_type" c:identifier="iris_thread_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
  </namespace>
</repository>
